<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇编语言（一）</title>
      <link href="/2023/09/13/hui-bian-yu-yan-yi/"/>
      <url>/2023/09/13/hui-bian-yu-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="汇编语言启蒙"><a href="#汇编语言启蒙" class="headerlink" title="汇编语言启蒙"></a>汇编语言启蒙</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><p><strong>1.1机器语言</strong>：机器指令的集合，机器指令是一系列<strong>二进制数字</strong>，计算机将机器指令转化为一系列的<strong>高低电平</strong>，使电子器件受到驱动</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这个工作由微处理器（如CPU）完成，每一种微处理器都有其机器指令集</div><p><strong>1.2汇编语言</strong>：由以下三类指令组成</p><blockquote><p><strong>汇编指令</strong>：机器指令便于记忆的格式，由对应的<strong>机器码</strong><br><strong>伪指令</strong>：没有对应的机器码，由<strong>编译器执行</strong>，计算机并不执行<br><strong>符号</strong>：由编译器识别，没有对应的机器码</p></blockquote><p><strong>1.3指令与数据</strong>：两者本质上都是<strong>一串二进制数据</strong>，也并没有特殊的格式区别它们，取决于CPU如何解释它们</p><h3 id="2-存储器"><a href="#2-存储器" class="headerlink" title="2.存储器"></a>2.存储器</h3><p><strong>2.1存储单元</strong>：每个存储器被划分为<strong>若干个存储单元</strong>，每个存储单元存储<strong>一个字节</strong><br><strong>2.2总线</strong>：CPU和<strong>其他部件</strong>交流的通道，物理上是一根根<strong>导线的集合</strong></p><blockquote><p><strong>地址总线</strong>：指定存储单元</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 地址总线的宽度（根数）为N，则其能对2^N个单元寻址</div><p><strong>数据总线</strong>：传输数据</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据总线的宽度（根数）为N，则一次能传输N位的数据</div><p><strong>控制总线</strong>：传输控制指令</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据总线的宽度（根数）为N，则有N种控制指令（激活则为高电平）</div><p><strong>2.3主板与接口卡</strong></p><blockquote><p><strong>主板</strong>：主板上一些主要器件通过<strong>总线</strong>相连，如CPU、存储器、外围芯片组和<strong>扩展插槽</strong>等<br><strong>接口卡</strong>：插在<strong>扩展插槽</strong>上，CPU通过控制接口卡控制<strong>外部设备</strong>，如鼠标、屏幕和键盘等</p></blockquote><p><strong>2.4存储芯片</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 依据读写属性分类</div><blockquote><p><strong>随机存储器</strong>：<strong>可读可写</strong>，但是必须<strong>带电存储</strong>，关机后存储内容消失<br><strong>只读存储器</strong>：只能读取，存储内容不会丢失</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 依据功能分类</div><blockquote><p><strong>随机存储器</strong>：存放CPU使用的<strong>大部分数据和程序</strong><br><strong>装有BIOS的ROM</strong>：BIOS是主板和各类接口卡中的软件，可通过它对该硬件进行<strong>最基本的输入和输出</strong><br><strong>接口卡上的RAM</strong>：某些接口卡需要<strong>对大量输入输出数据进行暂时存储</strong>，则会装有RAM，如显示卡的显存</p></blockquote><p><strong>2.5内存地址空间</strong>：CPU在操作<strong>物理存储器</strong>时，将他们<strong>总的</strong>看作为一个由若干存储单元组成的<strong>逻辑存储器</strong>，每个存储器占<strong>一段地址空间</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内存地址空间的大小受到地址总线宽度的影响</div><h3 id="3-寄存器"><a href="#3-寄存器" class="headerlink" title="3.寄存器"></a>3.寄存器</h3><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 以8086CPU为例，该CPU是16位结构，注意这个大前提</div><p><strong>3.1CPU简介</strong></p><blockquote><p><strong>运算器</strong>：信息处理<br><strong>寄存器</strong>：信息存储，一般能存储的<strong>位数不高</strong><br><strong>控制器</strong>：控制各种器件工作</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPU内部总线连接各个器件，并传输数据信息</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过改变寄存器内容实现对CPU的控制</div><p><strong>3.2通用寄存器</strong>：通常用来存放一般性的数据</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 出于兼容性的考虑，一个寄存器可分多个寄存器，通常最小单位8位（因为一个内存单元是8位），如一个16位寄存器ax可以看成两个8位寄存器al和ah</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当指令操作al导致溢出时，溢出的位不会存储到ah中，因为它将al当作一个独立的寄存器</div><p><strong>3.3物理地址</strong>：一个单元<strong>真实唯一</strong>的地址，也是CPU通过地址总线发出的地址<br><strong>①十六位结构</strong></p><blockquote><p><strong>运算器一次处理</strong>最多16位的数据<br><strong>寄存器最大长度</strong>为16位<br><strong>寄存器和运算器的通路</strong>为16位</p></blockquote><p><strong>②地址加法器</strong>：计算物理地址，<code>物理地址 = 段地址*16+偏移地址</code>，也可以表示为<code>段地址:偏移地址</code></p><blockquote><p>易知每一段的起始地址为16的倍数，每一段的长度为64KB</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 8086CPU地址总线宽度为20，但是它本身一次性只能传输16位数据，如果直接从CPU内部发出地址信号，则只能达到64KB的寻址能力，故需要使用地址加法器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 地址加法器的本质就是扩大CPU的寻址能力，通过段地址粗略定位，再通过偏移地址精确定位</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 同一个物理地址可以使用不同的段地址和偏移地址表示</div><p><strong>3.4指令的执行</strong><br><strong>①段寄存器</strong>：提供<strong>段地址</strong></p><blockquote><p>8086CPU有四个段寄存器，<code>CS</code>、<code>DS</code>、<code>ES</code>和<code>SS</code></p></blockquote><p><strong>②指令指针寄存器</strong>：提供指令的<strong>初始偏移地址</strong></p><blockquote><p>8086CPU将<code>CS:IP</code>作为当前要实施的指令的物理地址</p></blockquote><p><strong>③过程概述</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_1.png" alt="初始状态"></p><blockquote><p><code>CS</code>和<code>IP</code>寄存器的值送入<strong>地址加法器</strong>中，获得指令的<strong>物理地址</strong><br><strong>地址加法器</strong>将物理地址送入<strong>控制输入输出电路</strong><br><strong>控制输入输出电路</strong>将物理地址送入<strong>地址总线</strong><br><strong>数据总线</strong>将对应物理地址<strong>对应的指令</strong>送入CPU</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如图，一条指令占据多个内存单元，数据总线输入的是整条指令，而不仅仅是对应物理地址对应的内存单元的数据</div><blockquote><p><strong>控制输入输出电路</strong>将对应指令送入<strong>指令缓冲器</strong><br><code>IP</code>的值自动增加，指向<strong>下一条指令</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若刚刚读入的指令长度为N个字节，则IP增加3</div><blockquote><p><strong>执行</strong>指令缓冲器中的指令，并重复上述过程执行<strong>下一条指令</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> CS:IP对应内存位置的数据即为指令，CPU根据这个区分指令和数据</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以修改CS和IP寄存器的值，指向我们的代码段，用于执行该段代码</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> mov指令可以修改大部分寄存器的地址，但是不能修改CS和IP的地址，需要用jmp修改</div><p><strong>3.5内存的访问</strong><br><strong>①内存中字的存储</strong>：一个字需要两个内存单位，字的<strong>低位字节</strong>存放在<strong>低地址单元</strong>中，<strong>高位字节</strong>存放再<strong>高地址单元</strong>中</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
            <tag> 《汇编语言》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C4D学习笔记（一）</title>
      <link href="/2023/09/08/c4d-xue-xi-bi-ji-yi/"/>
      <url>/2023/09/08/c4d-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="C4D学习笔记（一）"><a href="#C4D学习笔记（一）" class="headerlink" title="C4D学习笔记（一）"></a>C4D学习笔记（一）</h1><h2 id="C4D基础"><a href="#C4D基础" class="headerlink" title="C4D基础"></a>C4D基础</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>切换坐标系，效果不同<br>R显示旋转物体的控点<br>移动物体E<br>缩放物体T<br>ctrl+x快速删除物体<br>插入灯光要素<br>渲染后点击屏幕即可退出渲染<br>鼠标滚轮键打开/选择其他视图<br>alt+鼠标左键旋转视图<br>alt+鼠标滚轮拖动平移视图<br>alt+鼠标滚轮滑动缩放视图<br>鼠标中键按住调整实施选择的大小<br>长按选择功能栏打开其扩展部分<br>alt+R局部渲染<br>圆形物体改变其旋转分段可以将其改为多边体</p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C4D </tag>
            
            <tag> 建模渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp学习笔记（二）</title>
      <link href="/2023/07/22/cpp-xue-xi-bi-ji-er/"/>
      <url>/2023/07/22/cpp-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp学习笔记（一）"><a href="#Cpp学习笔记（一）" class="headerlink" title="Cpp学习笔记（一）"></a>Cpp学习笔记（一）</h1><h2 id="泛型编程风格"><a href="#泛型编程风格" class="headerlink" title="泛型编程风格"></a>泛型编程风格</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 《Essential C++》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode刷题笔记（一）</title>
      <link href="/2023/07/21/leecode-shua-ti-bi-ji-yi/"/>
      <url>/2023/07/21/leecode-shua-ti-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="LeeCode刷题笔记（一）"><a href="#LeeCode刷题笔记（一）" class="headerlink" title="LeeCode刷题笔记（一）"></a>LeeCode刷题笔记（一）</h1><h2 id="一、二分法"><a href="#一、二分法" class="headerlink" title="一、二分法"></a>一、二分法</h2><h3 id="1-二分查找（704）"><a href="#1-二分查找（704）" class="headerlink" title="1.二分查找（704）"></a>1.二分查找（704）</h3><pre class="line-numbers language-none"><code class="language-none">int search(int* nums, int numsSize, int target){    int left = 0;    int right = numsSize-1;    int middle = 0;    //若left小于等于right，说明区间中元素不为0    while(left&lt;=right) {        //更新查找下标middle的值        middle = (left+right)/2;        //此时target可能会在[left,middle-1]区间中        if(nums[middle] &gt; target) {            right = middle-1;        }         //此时target可能会在[middle+1,right]区间中        else if(nums[middle] &lt; target) {            left = middle+1;        }         //当前下标元素等于target值时，返回middle        else if(nums[middle] == target){            return middle;        }    }    //若未找到target元素，返回-1    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当题目中出现<strong>排序好</strong>的数组且<strong>没有重复元素</strong>时，可以考虑使用二分法<br>使用二分法时，要注意<strong>边界条件</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeeCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程风格</title>
      <link href="/2023/07/14/bian-cheng-feng-ge/"/>
      <url>/2023/07/14/bian-cheng-feng-ge/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《GoogleC++编程规范》 </tag>
            
            <tag> 编程风格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（六）</title>
      <link href="/2023/07/11/shu-ju-jie-gou-yu-suan-fa-liu/"/>
      <url>/2023/07/11/shu-ju-jie-gou-yu-suan-fa-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法（六）"><a href="#数据结构与算法（六）" class="headerlink" title="数据结构与算法（六）"></a>数据结构与算法（六）</h1><h2 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h2><h3 id="1-散列"><a href="#1-散列" class="headerlink" title="1.散列"></a>1.散列</h3><p><strong>1.1思路</strong>：构造<strong>散列函数h</strong>，可以直接计算关键词存储位置<code>h(key)</code>，同时应用某种策略解决多个<strong>关键词位置相同</strong>的问题，这样就可以使得查找的时间复杂度为<code>O(1)</code></p><blockquote><p>散列函数是某种<strong>关于关键词</strong>自定义的规则，比如说求余等，因为零零散散放在数组中，所以也叫散列</p></blockquote><p><strong>1.2散列表（哈希表）的抽象</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_67.png" alt="散列表"><br>1.3结构代码</p><h3 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2.散列函数"></a>2.散列函数</h3><p><strong>2.1构造准则</strong>：计算简单（提高查找速度），使得地址空间分布均匀（减少冲突）<br><strong>2.2数字关键词的散列函数构造</strong><br>①直接定址：<code>h(key)=a*key+b</code>，a、b为常数<br>②除留余数：<code>h(key)=key%p</code>，p为容器大小<br>③数字分析法：分析数字关键字各位的变化情况，取<strong>比较随机的位</strong>作为地址，或者取比较随机的位结合上述构造方法</p><blockquote><p>比如手机的后四位<br>④数字折叠法：把数字分割为几个位数相同的部分，然后叠加，比如说123变为1、2、3<br>⑤平方取中法：将数字平方后取结果的中间某几位<br><strong>2.3字符关键字的散列函数构造</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_68.png" alt="字符关键字的散列函数构造"></p></blockquote><h3 id="3-处理冲突"><a href="#3-处理冲突" class="headerlink" title="3.处理冲突"></a>3.处理冲突</h3><p><strong>3.1开放定址法</strong>：若发生了第<code>i</code>次冲突，试探性地将其地址增加<code>di</code>，即<code>hi(key)=h(key)+di</code>，根据<code>di</code>的形式可为以下三种</p><blockquote><p>注意这里的冲突不是总计的冲突，而是当前元素发生冲突的次数（即对于每个元素，i都是从0开始计数）</p></blockquote><p><strong>①线性探测法</strong>：<code>di=i</code><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_69.png" alt="线性探测法"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_70.png" alt="线性探测法性能"></p><blockquote><p>线性探测会产生聚集现象，即数据<strong>集中在某一块</strong></p></blockquote><p><strong>②平方探测法</strong>：<code>di</code>序列为<code>1、-1、4、-4....i^2、-i^2</code><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_71.png" alt="平方探测法"></p><blockquote><p>只要散列表的长度是某个<code>4k+1</code>形式的<strong>素数</strong>时，平方探测法可以探查到整个散列表空间</p></blockquote><p><strong>③双散列探测法</strong>：<code>di=i*h2(key)</code>，其中h2为另一个非0散列函数<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_73.png" alt="双散列探测法"></p><p><strong>3.2分离链接法</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_72.png" alt="分离链接法"></p><p><strong>3.3再散列</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_74.png" alt="再散列"></p><h3 id="4-散列表的实现"><a href="#4-散列表的实现" class="headerlink" title="4.散列表的实现"></a>4.散列表的实现</h3><p><strong>4.1结构与初始化</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_75.png" alt="结构与初始化"></p><blockquote><p>哈希表中的<code>TheCells</code>是一个<strong>结构数组</strong>，结构中主要有记录数值的<code>Element</code>和记录<strong>状态</strong>的<code>Info</code><br><code>NextPrime</code>的功能是计算输入的下一个素数，哈希表的元素个数大小最好是<strong>素数</strong>，因为哈希表的一些性质需要用某个数除以哈希表的大小</p></blockquote><p><strong>4.2查找（以平方探测法为例子）</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_76.png" alt="查找"></p><blockquote><p>高亮语句的作用是防止<code>NewPos</code>超出表的范围</p></blockquote><p><strong>4.3删除和插入</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_77.png" alt="删除和插入"></p><blockquote><p>删除操作就是在查找的基础上将其状态改为<code>delete</code>即可，哈希表<strong>不能直接删除对应元素</strong>，因为根据哈希表解决冲突的条件，如果直接删掉该元素，则和该元素产生冲突的元素也会一起被“删除”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（五）</title>
      <link href="/2023/07/09/shu-ju-jie-gou-yu-suan-fa-wu/"/>
      <url>/2023/07/09/shu-ju-jie-gou-yu-suan-fa-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法（五）"><a href="#数据结构与算法（五）" class="headerlink" title="数据结构与算法（五）"></a>数据结构与算法（五）</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 默认按照从小到大排序</div><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p><strong>1.1思路</strong>：从头比较相邻的两个元素，如果两个元素满足设定的大小关系，则不变，反之则调换位置，这样可以把最小/大的元素放在末尾，随机再对n-1个元素再次使用冒泡排序，总共重复n-1次<br><strong>1.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_39.png" alt="冒泡排序"></p><blockquote><p>其中<code>flag</code>的作用就是判断是否已经排序好</p></blockquote><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><p><strong>2.1思路</strong>：类似于打扑克理牌的过程，一开始我们手里有一张牌，即<code>A[0]</code>，随后从A[1]开始往手里加牌，和<strong>手里的牌的最后一位</strong>（即<code>A[P-1]</code>）开始向前比较，如果比新牌大，则交换新牌和他的位置，直到找到新牌的位置（即前一张牌小于新牌）<br><strong>2.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_40.png" alt="插入排序"></p><blockquote><p>注意中间变量的作用</p></blockquote><h3 id="3-希尔排序（改进的插入排序）"><a href="#3-希尔排序（改进的插入排序）" class="headerlink" title="3.希尔排序（改进的插入排序）"></a>3.希尔排序（改进的插入排序）</h3><p><strong>3.1逆序对</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_41.png" alt="逆序对"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_42.png" alt="改进思路"><br><strong>3.2思路</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_43.png" alt="基本思路"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_44.png" alt="不足"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_45.png" alt="改进"></p><h3 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4.选择排序"></a>4.选择排序</h3><p><strong>4.1思路</strong>：首先找到全部元素中的最小元素，放在最前面，然后再找到剩余元素的最小元素，放在第二位，以此类推<br><strong>4.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_46.png" alt="选择排序"></p><h3 id="5-堆排序（改进的选择排序）"><a href="#5-堆排序（改进的选择排序）" class="headerlink" title="5.堆排序（改进的选择排序）"></a>5.堆排序（改进的选择排序）</h3><p><strong>5.1思路</strong>：选择排序的瓶颈主要是如何<strong>快速找到最小元</strong>，所以可以采用最小堆来找到最小元素<br><strong>5.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_47.png" alt="堆排序"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_48.png" alt="改进的堆排序"></p><blockquote><p>改进的堆排序将数组调整为最大堆，然后将根节点和最后元素交换，然后将最大元素排除在外，重复以上步骤</p></blockquote><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><p><strong>6.1思路</strong>：主要采用的是<strong>分而治之</strong>的思想，将整个序列一直二分，直到将其分为最小单元即只有两个单元，然后将其转化为有序子列并成为新的最小单元，以此类推，直到整个序列都被排序</p><blockquote><p>两个<strong>有序子列</strong>的合并：已知两个有序子列，以及一个足够容纳两个子列的空容器，首先比较两个子序列的第一个位置上的元素，选择较小的那个放进容器，然后被选择的子序列的位置向后挪一位，以此类推完成排序<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_49.png" alt="有序子列的归并"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_50.png" alt="有序子列的归并代码实现"><br><strong>6.2代码实现</strong><br><strong>①递归实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_51.png" alt="递归实现"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_52.png" alt="统一接口"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_53.png" alt="注意事项"><br><strong>②非递归实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_54.png" alt="非递归实现"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_55.png" alt="统一接口"></p></blockquote><h3 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 小规模数据采用简单排序（如插入排序），大规模数据采用快速排序</div><p><strong>7.1思路</strong>：挑选一个主元，将序列分为大于该主元和小于该主元的两部分，然后在对这两部分实施上述类似的操作</p><blockquote><p>快速排序可以保证在划分子集后，主元所在位置都是它<strong>最终的正确位置</strong></p></blockquote><p><strong>7.2代码实现</strong><br><strong>①主元的选取</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_56.png" alt="主元的选取"></p><blockquote><p>这样选取主元之后，<code>Right</code>和<code>Left</code>元素都不用考虑了</p></blockquote><p><strong>②子集划分</strong>：如下图，选取后的主元为6，考虑中间的元素（理由见上），最左端和最右端都有一个指针，当左端（右端）指针指向元素小于（大于）主元时，向右（左）移动指针，<strong>反之则停下，当两边指针都停下时交换对应元素</strong>，随后继续迭代，当左端指针大于右端时，交换主元和左端指针位置，完成子集划分<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_57.png" alt="子集划分——开始"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_58.png" alt="子集划分——结束"><br><strong>③算法主体</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_59.png" alt="快速排序"></p><h3 id="8-基于表排序的物理排序"><a href="#8-基于表排序的物理排序" class="headerlink" title="8.基于表排序的物理排序"></a>8.基于表排序的物理排序</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 之前的算法都需要频繁地交换元素，对于元素较大的序列效率较差，可以先进行表排序，减少交换元素的次数</div><p><strong>8.1表排序</strong>：不直接排序元素本身，而是排序其指针（位置），需要一个新的数组存储<strong>排序后的位置</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_60.png" alt="表排序"><br><strong>8.2物理排序</strong>：进行完表排序后，发现其排列组成了若干个独立的环，如下图所示，<code>table[0]</code>→<code>A[3]</code>→<code>table[3]</code>→<code>A[1]</code>→<code>table[1]</code>→<code>A[5]</code>→<code>table[5]</code>→<code>A[0]</code>→<code>table[0]</code>形成了一个独立的环，分别调整这些环，将环的一项拆除（将对应的数据存到临时变量中），并根据其<code>table[]</code>的值将对应数据放入其中，**并将其<code>table[i]</code>改为对应的<code>i</code>**，表示这个数据的位置是调整过的，直到空位<code>table[]</code>对应位置满足<code>table[i]==i</code>，表示环结束，将存在临时变量中的数据存到对应空位中。<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_61.png" alt="物理排序"></p><h3 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9.基数排序"></a>9.基数排序</h3><p><strong>9.1桶排序</strong>：建立一个<strong>指针数组</strong>，每个指针对应一个<strong>链表</strong>，每个链表代表一种情况，将符合该情况的数据插入该链表即可，排序完后依次从每个桶中提取数据即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_62.png" alt="桶排序"><br><strong>9.2基数排序</strong>：实际上就是多次的桶排序，如下例，一个三位数如果将每一个数都看作为一种情况，则需要1000个桶，不划算，可以每次只看三位数的某一位，假设从个位数看到百位数，则只需要十个桶，看三次即可，第一次将个位数符合情况的插入到各个桶中，<strong>根据第一次桶排序的顺序</strong>，观察其十位数，插入到对应的桶中，以此类推，观察完所有特征即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_63.png" alt="基数排序"><br><strong>9.3多关键字排序</strong><br><strong>①主位优先</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_64.png" alt="主位优先"><br><strong>②次位优先</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_65.png" alt="次位优先"></p><blockquote><p>注意题中需要的顺序，如果主位优先中第二步也采用桶排序，则获得的顺序是13组，而不是4组，要注意如果只使用桶排序，<strong>关键字的顺序</strong>是非常重要的</p></blockquote><h3 id="10-小结"><a href="#10-小结" class="headerlink" title="10.小结"></a>10.小结</h3><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_66.png" alt="小结"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MITS6.081（一）</title>
      <link href="/2023/07/05/mits6-081-huan-jing-pei-zhi/"/>
      <url>/2023/07/05/mits6-081-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="MITS6-081（一）"><a href="#MITS6-081（一）" class="headerlink" title="MITS6.081（一）"></a>MITS6.081（一）</h1>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MITS6.081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp学习笔记（一）</title>
      <link href="/2023/07/05/cpp-xue-xi-bi-ji-yi/"/>
      <url>/2023/07/05/cpp-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp学习笔记（一）"><a href="#Cpp学习笔记（一）" class="headerlink" title="Cpp学习笔记（一）"></a>Cpp学习笔记（一）</h1><h2 id="Cpp基础"><a href="#Cpp基础" class="headerlink" title="Cpp基础"></a>Cpp基础</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 由于C++在基础上有很多和C类似，所以主要介绍和C不同的部分</div><p><strong>1.1输入输出</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要包含iostream头文件</div><p><strong>①输出</strong>：<code>cout&lt;&lt;内容1&lt;&lt;内容2...&lt;&lt;endl;</code></p><blockquote><p><code>cout</code>：<code>iostream</code>类的一个实例，连接到<strong>标准输出设备</strong>，通常是显示屏<br><code>&lt;&lt;</code>：<strong>输出流运算符</strong>，作用是把运算符右边的数据输出到运算符左边的目标<br><code>endl</code>：<strong>换行符</strong></p></blockquote><p><strong>②输入</strong>：<code>cin&gt;&gt;容器（变量）;</code></p><blockquote><p><code>cin</code>：同<code>cout</code>，连接到<strong>标准输入设备</strong>，通常是键盘<br><code>&gt;&gt;</code>：<strong>输入流运算符</strong>，将<strong>标准输入设备的数据</strong>保存到右边的容器中</p></blockquote><p><strong>1.2命名空间</strong>：命名空间可以<strong>避免程序发生命名冲突</strong>，当命名冲突发生时，需要获得<strong>解析</strong>才能继续执行</p><blockquote><p>常见的语句是<code>using namespace std;</code><br><code>std</code>：<strong>标准库</strong>的命名空间<br><code>using</code>：让对应命名空间<strong>曝光</strong><br><strong>解析</strong>：<code>命名空间::变量名</code></p></blockquote><p><strong>1.3数组和向量</strong><br><strong>①</strong><code>array</code>：和C中的数组一样，<code>数据类型 数组名[元素个数]</code>,缺省元素会初始化为0</p><blockquote><p><strong>访问</strong>：<code>名称[]</code>，下标从0开始<br><strong>初始化</strong>：同C语言数组</p></blockquote><p><strong>②</strong><code>vector</code>：<code>vector&lt;数据类型&gt; 向量名(元素个数)</code></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要包含vector头文件</div><blockquote><p><strong>访问</strong>：同数组<br><strong>初始化</strong>：不同于数组，向量只能一个一个初始化，或者<strong>采用已初始化好的数组</strong>，即 <code>vector&lt;数据类型&gt; 向量名(数组名，数组名+数组元素个数)</code></p></blockquote><p><strong>1.4空指针</strong>：在C和C++中，<code>NULL</code>和0都可以使用，<strong>C通常使用<code>NULL</code>，C++通常使用0</strong></p><blockquote><p>其中<code>NULL</code>是一个宏，定义如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#if defined(__cplusplus)# define NULL 0              // C++中使用0作为NULL的值#else# define NULL ((void *)0)    // C中使用((void *)0)作为NULL的值#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.5引用</strong>：C++独有的<strong>传址方式</strong>，被称为变量的别名，本质上其指向对象的<strong>指针常量</strong></p><blockquote><p>如下所示，<code>b</code>为<code>a</code>的一个引用</p></blockquote><pre class="line-numbers language-none"><code class="language-none">int a = 1024;int *p = &amp;a;int &amp;b = a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 引用变量在定义时就必须初始化，一旦指定就不可改变</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对引用变量的操作就是对其指向对象的操作，包括寻址操作等</div><p><strong>1.6函数默认参数值</strong></p><blockquote><p>在C语言中，不能给函数设置默认参数值</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只能在函数定义或者函数声明默认值，但是不能在两个地方都声明，通常放在函数声明处</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果为某一参数设定默认值，则该参数右侧所有参数都需要有默认值</div><p><strong>1.7inline函数</strong>：对于<code>inline</code>函数，编译器<strong>在每个函数调用节点上将其展开</strong>为函数代码副本（类似与C语言宏函数）</p><blockquote><p>在函数定义之前添加<code>inline</code>关键词即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内联函数的定义通常放在头文件中（和普通的函数不同，inline函数可以定义多次），通常是一些简单的函数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> inline函数只是对编译器的一种的请求，编译器不一定会按照inline函数定义处理</div><p><strong>1.8函数重载</strong>：<strong>参数列表不相同</strong>但是名称相同的函数</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 编译器根据提供的参数判断哪个函数是最合适的</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不能仅仅依靠返回类型的不同实现函数重载，因为编译器无法根据返回类型判断你想调用那个函数</div><p><strong>1.9函数模板</strong>：将参数列表参数的<strong>类型信息</strong>抽离，等到<strong>使用时再定义</strong></p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void  display_message(const string &amp;msg,const vector&lt;T&gt; &amp;vec){  cout&lt;&lt;msg;  for(int i = 0;i&lt;vec.size();++i)  {    T t = vec[i];    cout&lt;&lt;t&lt;&lt;'';  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>typename</code>关键字表示<code>T</code>（自定义）是<code>display_message</code>函数中代表类型的<strong>占位符</strong>，需要在<strong>函数调用</strong>的时候决定，当函数调用时，传入的类型是什么，<code>T</code>就会<strong>被绑定为什么类型</strong>，编译器就会生成一份<strong>对应版本的函数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 模板函数也可以重载</div><p><strong>1.10动态内存分配</strong>：new/delete和malloc/free</p><h3 id="2-泛型编程"><a href="#2-泛型编程" class="headerlink" title="2.泛型编程"></a>2.泛型编程</h3><p><strong>2.1引言</strong>：如何编写一个可以处理<strong>任意相似容器（如array、vector和list）</strong>的函数（如<strong>查找元素</strong>）？</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 抽象查找的过程，查找的关键步骤即确定开始位置、比较元素、确定下一个元素位置和确定结束位置</div><p><strong>2.2泛型指针<code>iterator</code></strong><br><strong>①定义</strong>：本质上是一个<strong>类</strong>，性质类似于指针，但是其相关操作（如提领、递增、递减、相等等）用类中的<strong>相关函数重写</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其功能和使用方法和指针一样，只是底层实现不同</div><p><strong>②声明</strong>：<code>数据类型::iterator 变量名</code></p><blockquote><p><code>::</code>表示该<code>iterator</code>是属于该数据类型的</p></blockquote><p><strong>③赋值</strong>：每个<strong>标准容器</strong>都提供了对应函数返回其对象的<code>iterator</code></p><blockquote><p><code>begin()</code>：返回指向该容器对象<strong>第一个元素</strong>的<code>iterator</code><br><code>end()</code>：返回指向该容器对象<strong>最后一个元素</strong>的<code>iterator</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 还可以使用模板，使得函数既能接收指针，也能接收泛型指针</div><p><strong>2.3泛型操作符</strong>：将一些操作（如判断是否相等），替换为函数（传递函数指针）或者<code>function object</code><br><strong>①标准<code>function object</code></strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 标准库为以下三类运算符定义了function object，需要包含functional头文件</div><blockquote><p><strong>算数运算符</strong>：<code>plus&lt;type&gt;</code>（<code>+</code>）等<br><strong>关系运算符</strong>：<code>less&lt;type&gt;</code>（<code>&lt;</code>）等<br><strong>逻辑运算符</strong>：<code>logical_and</code>（<code>&amp;&amp;</code>）等<br>将其代替<strong>原本的操作符位置</strong>即可，<code>type</code>用于绑定操作数类型</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将function object传递给函数，形式为function object()，如plus<type>()</type></div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> function object的本质是inline函数，比使用函数指针调用函数更有效率</div><p><strong>②绑定适配器</strong>：将<code>function object</code>的参数绑定为某特殊值，将其转化为<strong>一元操作符</strong></p><blockquote><p><code>bind1st()</code>：其接收两个参数，第一个参数为一个<code>function object</code>，第二个参数为特殊值，该函数将该<code>function object</code>的<strong>第一个参数</strong>绑定为特殊值<br><code>bind2st()</code>：同上，绑定的是<strong>第二个参数</strong></p></blockquote><p><strong>2.4泛型算法</strong>：C++提供一个泛型算法的标准库<code>algorithm</code>，其中有一些实现的泛型算法，如搜索、查找等</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 《Essential C++》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（四）</title>
      <link href="/2023/07/03/shu-ju-jie-gou-yu-suan-fa-si/"/>
      <url>/2023/07/03/shu-ju-jie-gou-yu-suan-fa-si/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法（四）"><a href="#数据结构与算法（四）" class="headerlink" title="数据结构与算法（四）"></a>数据结构与算法（四）</h1><h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><h3 id="1-图"><a href="#1-图" class="headerlink" title="1.图"></a>1.图</h3><p><strong>1.1定义</strong>：由一个非空的有限<strong>顶点</strong>集合V和一个有限<strong>边</strong>集合E组成<br><strong>1.2表示</strong><br>①邻接矩阵：对角线为0的<strong>对称矩阵</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_15.png" alt="邻接矩阵"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_16.png" alt="邻接矩阵的数组表示"><br>②邻接表<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_17.png" alt="邻接表"></p><p><strong>1.3图的连通性</strong><br>①连通：如果两个顶点之间存在一条<strong>无向路径</strong>，则称这两点是连通的<br>②连通图：图中<strong>任意两点</strong>均连通<br>③连通分量<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_20.png" alt="连通分量"></p><h3 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2.图的遍历"></a>2.图的遍历</h3><p><strong>2.1深度优先搜索（DFS）</strong><br>①思想：选定一个入口，挑选一个没有被访问的与之相连的节点，来到这个节点之后同样挑选一个与之相连的没有被访问的节点，如果没有则原路返回，直到返回到出口<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_18.png" alt="DFS"><br><strong>2.2广度优先搜索（BFS）</strong><br>①思想：选择一个入口，将其压入队列中，弹出入口时，将与入口相连的节点压入队列中，然后弹出队列最前面的节点，并将与其相连的节点压入队列中，直到队列为空<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_19.png" alt="BFS"></p><p><strong>2.3两种遍历方法的特点</strong></p><h3 id="3-图的建立"><a href="#3-图的建立" class="headerlink" title="3.图的建立"></a>3.图的建立</h3><p><strong>3.1邻接矩阵表示</strong><br>①结构代码<br>顶点结构代码</p><pre class="line-numbers language-none"><code class="language-none">typedef struct GNode *PtrToNode;struct GNode{  int Nv; /*定点数  int Ne; /*边数  WeightType G[MaxVertexNum][MaxVertexNum];};typedef PtrToNode MGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>边结构代码</p><pre class="line-numbers language-none"><code class="language-none">typedef struct ENode *PtrToENode;struct ENode{  VerTex V1,V2; /*边连接的顶点  WeightType Weight; /*权重}typedef PtrToENode Edge;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②图的初始化（有一定顶点但是边为0）</p><pre class="line-numbers language-none"><code class="language-none">typedef int Vertex; /*用顶点下标表示顶点，为整型MGraph CreateGraph(int VertexNum){  Vertex V,W;  MGraph Graph;  Graph = (MGraph)malloc(sizeof(struct GNode));  Graph-&gt;Nv = VertexNum;  Graph-&gt;Ne = 0;  for(V = 0;V &lt; Graph-&gt;Nv;V++)    for(W = 0;W &lt; Graph-&gt;Nv;W++)      Graph-&gt;G[V][W] = 0;  return Graph;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②边的插入</p><pre class="line-numbers language-none"><code class="language-none">void InsertEdge(MGraph Graph,Edge E){  Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weigh;   Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weigh; /*如果是有向边，则这条可以省略}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③图的建立<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_21.png" alt="图的建立"><br><strong>3.2邻接表表示</strong><br>①结构代码<br>顶点结构</p><pre class="line-numbers language-none"><code class="language-none">typedef struct GNode *PtrToGNode;struct GNode{  int Nv; /*顶点数  int Ne; /*边数  AdjList G; /邻接表};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>邻接表结构</p><pre class="line-numbers language-none"><code class="language-none">typedef struct Vnode{  PtrToAdjVNode FirstEdge;  DataType Data; /*顶点数据}AdjList[MaxVertexNum];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该段代码将元素为<code>Vnode</code>结构的数组重命名为<code>AdjList</code></p></blockquote><p>边结构</p><pre class="line-numbers language-none"><code class="language-none">typedef struct AdjVNode *PtrToAdjVNode;struct AdjVNode{  Vertex AdjV; /*邻接点下标  WeightType Weight; /*边权重  PtrToAdjVNode Next;};②初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>typedef int Vertex; /*定义实质为整形的顶点下标变量<br>LGraph CreateGraph(int VertexNum)<br>{<br>  Vertex V;<br>  LGraph Graph;</p><p>  Graph = (LGraph)malloc(sizeof(struct GNode));<br>  Graph-&gt;Nv = VertexNum;<br>  Graph-&gt;Ne = 0;<br>  for(V = 0;V &lt; Graph-&gt;Nv;V++)<br>    Graph-&gt;G[V].FirstEdge = NULL;</p><p>  return Graph;<br>}<br>③插入边</p><pre class="line-numbers language-none"><code class="language-none">void Insert(LGraph Graph, Edge E){  /*建立新的邻接点  PtrToAdjVNode NewNode;  NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));  NewNode-&gt;AdjV = E-&gt;V2;  NewNode-&gt;Weight = E-&gt;Weight;  /*  NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;  Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-图的最短路径算法"><a href="#4-图的最短路径算法" class="headerlink" title="4.图的最短路径算法"></a>4.图的最短路径算法</h3><p><strong>4.1无权图的单源最短路径算法</strong><br>①思路：从起点出发，先找到和他距离为1的<strong>没有访问过</strong>的节点，然后在此基础上寻找距离为2的节点，以此类推，直到找到终点</p><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_22.png" alt="思路"><br>②伪码描述</p><blockquote><p>其中<code>dist</code>数组将没访问的节点与原点的距离设置为一个负数，可以同时起到<code>Visited</code>函数作用<br><code>path</code>记录的是最短路径中，当前节点的上一个节点信息</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_23.png" alt="伪码描述"><br><strong>4.2有权图的单源最短路径算法</strong><br>①思路：选定原点<code>s</code>，然后访问其<strong>邻接点</strong>，计算其路径长度并存储在<code>dist[]</code>中（<code>dist[]</code>记录的是原点<strong>经过已收录点</strong>到对应点的距离，初始值都为<strong>正无穷</strong>），选择一个<code>dist[]</code><strong>最小的未收录的点</strong>收录，随后访问收录点的<strong>未收录邻接点</strong>，更新<code>dist[]</code>，在更新的过程中，要注意新收录点可能会影响其邻接点的<code>dist[]</code>，即<strong>只经过旧收录点的路径不是最短的了</strong>，需要更新<code>dist[]</code>和<code>path[]</code>，以此类推，直到所有点都被收录。<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_24.png" alt="Dijkstra"><br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_25.png" alt="伪码描述"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_26.png" alt="时间复杂度"></p><p><strong>4.3多源最短路算法</strong><br>①思路<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_27.png" alt="Floyd"><br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_28.png" alt="伪码描述"></p><h3 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5.最小生成树"></a>5.最小生成树</h3><p><strong>5.1定义</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_29.png" alt="最小生成树"><br><strong>5.2贪心算法</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_30.png" alt="贪心算法"><br><strong>5.2prim算法</strong><br>①思路：先选择一个起点，选择其<strong>权重最小的邻接点</strong>并收录，随后选择<strong>已收录点</strong>的权重最小的邻接点，但是不能构成回路，以此类推，直到收录所有的点<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_31.png" alt="伪码描述"><br><strong>5.2Kruskal算法</strong><br>①思路：选择其中<strong>未被选择的权值最小的边</strong>（可以是多条）将顶点连接起来，以此类推，但是在过程中不能形成回路，直到收录了V-1条边<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_32.png" alt="伪码描述"></p><blockquote><p>回路的检查：一开始将所有顶点看作为独立集合，新加边就是合并集合，如果新加入的边的两边顶点已经是一个集合的了，则会形成回路</p></blockquote><h3 id="6-拓扑排序"><a href="#6-拓扑排序" class="headerlink" title="6.拓扑排序"></a>6.拓扑排序</h3><p><strong>6.1定义</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_33.png" alt="拓扑排序"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_34.png" alt="例子"><br><strong>6.2算法</strong><br>①思想：每次输出所有<strong>没有前驱节点</strong>的节点<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_35.png" alt="伪码描述"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_36.png" alt="算法改进"></p><h3 id="7-关键路径（项目管理问题）"><a href="#7-关键路径（项目管理问题）" class="headerlink" title="7.关键路径（项目管理问题）"></a>7.关键路径（项目管理问题）</h3><p><strong>7.1定义</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_37.png" alt="定义"><br><strong>7.2思路</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_38.png" alt="思路"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（三）</title>
      <link href="/2023/06/28/shu-ju-jie-gou-yu-suan-fa-san/"/>
      <url>/2023/06/28/shu-ju-jie-gou-yu-suan-fa-san/</url>
      
        <content type="html"><![CDATA[<h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h3><p><strong>1.1静态查找</strong>：没有插入和删除操作，只有查找<br><strong>①顺序查找</strong>：以数组为例，从数组尾端向首端（下标为0）查找</p><blockquote><p><strong>哨兵</strong>：在查找过程中，需要判断<strong>值是否找到</strong>以及是否<strong>到达边界</strong>，可以<strong>将边界元素设置为需要查找的值</strong>，查找返回结果要么是对应值的下标，要么是0（边界下标）</p></blockquote><p><strong>②二分查找</strong>：总共有三个位置（首端、中端和尾端），每次将中端元素和对应值比较，然后根据大小关系更新这三个位置（新首端or新尾端根据大小关系决定哪一个变化，变化的一端由旧中端决定），当<strong>首端大于尾端</strong>，查找结束<br><strong>1.2动态查找</strong>：除查找外，还有插入和删除操作</p><h3 id="2-树"><a href="#2-树" class="headerlink" title="2.树"></a>2.树</h3><p><strong>2.1定义</strong>：每个树都有一个<strong>根节点</strong>，其余节点可分为<strong>互不相交的子树</strong>，除了根节点外，每个节点只有<strong>一个父节点</strong>和若干个子节点，没有子节点的节点称为<strong>叶节点</strong></p><blockquote><p>树明显是基于<strong>递归</strong>定义的，所以有关树的很多算法都用到了递归思想<br><strong>2.2儿子-兄弟表示法</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_1.png" alt="儿子-兄弟表示法"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_2.png" alt="普通二叉树转化为二叉树"><br>由于所有的树都可以转化为二叉树，所以树的主要研究对象为二叉树</p></blockquote><p><strong>2.3二叉树</strong><br><strong>①定义</strong>： 由根节点和同为二叉树的<strong>左子树</strong>和<strong>右子树</strong>组成，即每个节点最多只能有两个子节点，称为<strong>左节点</strong>和<strong>右节点</strong><br><strong>②满二叉树</strong>：当树为n层时，有<strong>2^n-1个节点</strong>，叶子只能出现在最下面一层<br><strong>③完全二叉树</strong>：对二叉树中节点从上至下，从左往右进行编号，编号为i的节点与满二叉树中编号为i的节点位置相同，即完美二叉树，<strong>从某一叶节点缺失所有右边的兄弟节点，左边的兄弟节点不缺失</strong><br><strong>2.4二叉树的存储结构</strong><br><strong>①顺序存储结构</strong>：将二叉树转化为<strong>广义的完全二叉树</strong>（不存在的节点表示为空），从上至下，从左往右进行编号，节点的编号就是他在数组中的位置<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_3.png" alt="顺序存储"><br><strong>②链表存储</strong>：节点结构分别有指向左子节点的指针和指向右子节点的指针，整个二叉树只需要知道其<strong>根节点指针</strong>即可</p><h2 id="二、二叉树的遍历"><a href="#二、二叉树的遍历" class="headerlink" title="二、二叉树的遍历"></a>二、二叉树的遍历</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p><strong>1.1定义与递归表示</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_4.png" alt="先序遍历"><br><strong>1.2非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">void InOrderTraversal(BinTree BT){  BinTree T = BT;  Stack S = CreateStack(MaxSize); /*创建并初始化栈S  while(T|| !IsEmpty(S))  {    /*一直向左并将沿途节点压入栈    wihle(T)    {      printf("%5d",T-&gt;Data); /*第一次碰到该节点，打印节点      Push(S,T);      T = T-&gt;left    }    if(!IsEmpty(S))    {      T = Pop(S); /*将没有左节点的节点弹出      T = T-&gt;Right; /*遍历其右子树    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><p><strong>2.1定义与递归表示</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_5.png" alt="中序遍历"><br><strong>2.2非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">void InOrderTraversal(BinTree BT){  BinTree T = BT;  Stack S = CreateStack(MaxSize); /*创建并初始化栈S  while(T|| !IsEmpty(S))  {    /*一直向左并将沿途节点压入栈    wihle(T)    {      Push(S,T);      T = T-&gt;left    }    if(!IsEmpty(S))    {      T = Pop(S); /*将没有左节点的节点弹出      printf("%5d",T-&gt;Data); /*第二次碰到该节点，打印节点      T = T-&gt;Right; /*遍历其右子树    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><p><strong>3.1定义与递归表示</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_6.png" alt="后序遍历"></p><p><font color="red"><strong>3.2非递归实现</strong></font></p><h3 id="4-三种遍历的关系"><a href="#4-三种遍历的关系" class="headerlink" title="4.三种遍历的关系"></a>4.三种遍历的关系</h3><p><strong>4.1本质</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_7.png" alt="三种遍历的联系与区别"></p><blockquote><p>对于一个节点，有三次访问的时刻，即第一次访问（没有访问其子节点），从左子树返回访问和从右子树返回访问，三种遍历方式就是在第一、二、三次访问时输出</p></blockquote><p><strong>4.2根据两中遍历结果推断树的结构</strong>：先根据先序遍历/后续遍历判断出<strong>根节点</strong>，然后在根据根节点和中序遍历判断出<strong>左子树</strong>和<strong>右子树</strong>，再同上判断左右子树即可</p><blockquote><p>只有知道中序遍历和前/后序遍历才能推断出结果</p></blockquote><h3 id="5-层序遍历"><a href="#5-层序遍历" class="headerlink" title="5.层序遍历"></a>5.层序遍历</h3><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_8.png" alt="层序遍历"></p><h2 id="三、特殊二叉树"><a href="#三、特殊二叉树" class="headerlink" title="三、特殊二叉树"></a>三、特殊二叉树</h2><h3 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1.二叉搜索树"></a>1.二叉搜索树</h3><p><strong>1.1定义</strong></p><blockquote><p>非空左子树的<strong>所有键值</strong>小于其根节点<br>非空右子树的<strong>所有键值</strong>大于其根节点<br>左右子树都是二叉搜索树<br><strong>1.2二叉搜索树的查找</strong><br><strong>①递归实现</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType x,BinTree BST){  /*没找到，递归退出条件  if(!Bst)    return NULL;  /*递归查找  if(x&gt;Bst-&gt;Data)    return Find(x,BST-&gt;Right);  else if(x&lt;Bst-&gt;Data)    return Find(x,BST-&gt;Left);  /*成功找到，递归退出条件  else    return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType x,BinTree BST){  while(BST)  {    if(x &gt; BST-&gt;Data)      BST = BST-&gt;Right;    else if(x &lt; BST-&gt;Data)      BST = BST-&gt;Left;    else      return BST;  }  return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3二叉搜索树的插入</strong><br><strong>①递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Insert(ElementType x,BinTree BST){  /*递归退出条件，找到对应插入位置，即一个空位置  if(!BST)  {    BST = malloc(sizeof(struct TreeNode));    BST-&gt;Data = x;    BST-&gt;Left = BST-&gt;Right =NULL;  }  else  {    if(x &lt; BST-&gt;Data)      BST-&gt;Left = Insert(x,BST-&gt;Left);     else if(x &gt; BST-&gt;Data)      BST-&gt;Right = Insert(x,BST-&gt;Right);  }  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Insert(ElementType x,BinTree BST){  while(BST)  {    if(x &gt; BST-&gt;Data)    {      if(!BST-&gt;Right)      {      BST-&gt;Right = malloc(sizeof(struct TreeNode));      BST-&gt;Right-&gt;Data = x;      BST-&gt;Right-&gt;Right = BST-&gt;Right-&gt;Left = NULL;      return BST-&gt;Right      }      else      BST = BST-&gt;Right    }    else if(x &lt; BST-&gt;Data)    {      if(!BST-&gt;Left)      {      BST-&gt;Left = malloc(sizeof(struct TreeNode));      BST-&gt;Left-&gt;Data = x;      BST-&gt;Left-&gt;Right = BST-&gt;Left-&gt;Left = NULL;      return BST-&gt;Right      }      else      BST = BST-&gt;Left;    }    else     return BST;  }  BST = malloc(sizeof(struct TreeNode));  BST-&gt;Data = x;  BST-&gt;Left = Bst-&gt;Right = NULL;  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.4二叉搜索树的删除</strong><br><strong>①思路</strong>：节点分为三类，即叶节点、有一个孩子的节点和有两个孩子的节点</p><blockquote><p>叶节点：直接删除即可<br>有一个孩子的节点：将孩子节点接到其父节点即可<br>有两个孩子的节点：将其<strong>右子树最小元素</strong>或者<strong>左子树最大元素</strong>代替之，可以转化为上述两种情况</p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Delete(ElementType x,BinTree BST){  Position Tmp;  if(!BST)    print("未找到该元素")；  else if(x &lt; BST-&gt;Data)    BST-&gt;Left = Delete(x,BST-&gt;Left);  else if(x &gt; BST-&gt;Data)    BST-&gt;Right = Delete(x,BST-&gt;Right);  else    /*当有两个孩子    if(BST-&gt;Left &amp;&amp; BST-&gt;Right)    {      /*找到其右子树最小元素替代之      Tmp = FindMin(BST-&gt;Right);      BST-&gt;Data = Tmp-&gt;Data;      /*删除其右子树最小元素      BST-&gt;Right = Delete(BST-&gt;Data,BST-&gt;Right);    }    /*有一个或者没有孩子    else    {      Tmp = BST      if(!BST-&gt;Left)        BST = BST-&gt;Right      else if(!BST-&gt;Right)        BST = BST-&gt;Left;      free(Tmp)    }  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.5平衡二叉树</strong><br><strong>①定义</strong>：空树或者<strong>任意节点</strong>左右子树<strong>高度差</strong>绝对值不超过1</p><blockquote><p>平衡二叉树的优点：给定节点数n的最大高度为O(log2n)</p></blockquote><p><strong>②平衡二叉树的调整</strong>：当插入节点时可能会破坏搜索二叉树的平衡性<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_9.png" alt="RR旋转"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_10.png" alt="LL旋转"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_11.png" alt="LR旋转"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_12.png" alt="RL旋转"></p><blockquote><p>注意多余出来部分要根据二叉搜索树的定义调整</p></blockquote><h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h3><p><strong>2.1定义</strong>：特殊的<strong>队列</strong>，取出元素的顺序是按照元素的<strong>优先级</strong>（关键字）</p><blockquote><p>用<strong>数组</strong>表示的<strong>完全二叉树</strong><br>任意节点的优先级是<strong>其子树所有节点</strong>的最大/小值，即<strong>根节点到任意节点路径</strong>是<strong>有序</strong>的<br><strong>2.2结构代码</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">typedef struct HeapStruct *MaxHeapstruct HeapStruct{  ElementType *Elements; /*存储堆的数组  int Size; /*堆的当前元素个数  int Capacity; /*最大容量};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.3操作集（最大堆）</strong><br><strong>①创建堆</strong></p><pre class="line-numbers language-none"><code class="language-none">MaxHeap Create(int MaxSize){  MaxHeap H = malloc(sizeof(struct HeapStruct));  H-&gt;Elements = malloc((MaxSize+1)*sizeof(ElementType));  H-&gt;Size = 0;  H-&gt;Capacity = MaxSize;  /*定义哨兵，便于查找  H-&gt;Elements[0] = MaxData;  return H;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中定义了<strong>哨兵</strong><br><strong>②堆的插入</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">void Insert(MaxHeap H,ElementType item){  int i;  if(IsFull(H))  {    printf("最大堆已满")；    return;  }  i = ++H-&gt;Size;  /*保证最大堆特性的比较  for( ;H-&gt;Elements[i/2] &lt; item; i/=2)    H-&gt;Elements[i] = H-&gt;Elements[i/2];  H-&gt;Elements[i] = item;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>为了保证最大堆的特性，需要保证<strong>新插入节点要比父节点小</strong>，所以如果他比父节点要大，就<strong>交换</strong>其和父节点位置，直到其小于对应的父节点<br>在这个过程中，哨兵的存在可以防止其到0的位置（超出堆的范围，因为堆的下标不能是0）<br><strong>③堆的删除</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType DeleteMax(MaxHeap H){  /*从堆中取出最大元素，并删除一个节点  int Parent,Child;  ElementType MaxItem,temp;  if(IsEmpty(H))  {    printf("最大堆已为空")；    return;  }  /*取出根节点最大值  MaxItem = H-&gt;Elements[1];  /*用最大堆中最后一个元素从根节点开始向上过滤下层节点  temp = H-&gt;Elements[H-&gt;Size--]; /先取出末尾元素，然后Size减1  for(Parent = 1;Parent*2 &lt;= H-&gt;Size; Parent = Child)   {    Child = Parent * 2；    if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Elements[Child] &lt; H-&gt;ElementType[Child+1]))      Child++; /*找到其左儿子和右儿子的较大者并指向它    if(temp&gt;= H-&gt;Element[Child])    break; /*找到对应插入位置了，即比其儿子节点都大    else      H-&gt;Elements[Parent] = H-&gt;Elements[Child]; /*移动到下一层，将较大的儿子移上去  }  H-&gt;Elements[Parent] = H-&gt;Elements[Child];  return MaxItem;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总体思想：将最后一个位置的节点<strong>内存</strong>删除，将其值<strong>先插入到根节点</strong>中（因为根节点的值已经被取出），然后慢慢向下迭代，交换位置<br><code>Parent*2 &lt;= H-&gt;Size</code>的作用是判断该父节点有没有左儿子，如果没有左儿子就更加没有右儿子<br><code>Child!=H-&gt;Size</code>的作用是判断其有没有右儿子，因为如果左儿子刚好是堆的边界，则没有右儿子<br><strong>④堆的建立</strong><br>总体思想：先将各个元素按照<strong>输入顺序</strong>存入，形成<strong>完全二叉树</strong>，利用<strong>分而治之</strong>的思想，将整个堆分为<strong>根节点和左子堆和右子堆</strong>，以此类推，最后分到最后就是父节点和左右儿子节点的比较</p></blockquote><h3 id="3-哈夫曼树"><a href="#3-哈夫曼树" class="headerlink" title="3.哈夫曼树"></a>3.哈夫曼树</h3><p><strong>3.1定义</strong>：最优二叉树，即每个<strong>叶子结点</strong>到根节点的带权路径长度之和最小<br><strong>3.2构造</strong><br><strong>①总体思想</strong>：将所有节点按照大小排序（可以用堆的方法），每次把权值最小的两棵二叉树合并，比如说1、2、3、4、5，合并一次变为3（1、2）、3、4、5，然后变为6（3（1、2）、3）、4、5，以此类推<br><strong>②代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_14.png" alt="哈夫曼树的构造"><br><strong>3.3哈夫曼编码</strong>:为了使得出现频率高的字符编码短些，出现频率低的字符编码长些，可以将哈夫曼树的节点路径看作为1和0，左节点为0，右节点为1，<strong>编码长度就是路径长度</strong>，按照字符出现频率构造哈夫曼树即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_13.png" alt="哈夫曼编码"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）</title>
      <link href="/2023/06/27/cao-zuo-xi-tong-yi/"/>
      <url>/2023/06/27/cao-zuo-xi-tong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（一）"><a href="#操作系统（一）" class="headerlink" title="操作系统（一）"></a>操作系统（一）</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><p><strong>1.1操作系统</strong>：运行在<strong>内核态</strong>的软件，为应用程序提供<strong>硬件资源的抽象</strong>（接口），并<strong>管理并保护</strong>这些硬件资源以及<strong>用户态</strong>应用程序对其的使用（<strong>防止相互干扰并使其获得良好的性能</strong>），操作系统拥有<strong>所有硬件</strong>的<strong>完全访问权限</strong><br><strong>1.2虚拟cpu</strong>：通过<strong>时分共享</strong>，将一个cpu分成<strong>多个“cpu”</strong>，使得多个程序“同时运行”</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时分共享：通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间</div><p><strong>1.3虚拟内存</strong>：通过<strong>空分共享</strong>，每个进程都有自己的<strong>私有虚拟地址空间</strong>，操作系统以某种方式将其<strong>映射到机器的物理内存上</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 空分共享：将资源分成多份，并分配给不同的实体</div><h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h3><p><strong>2.1定义</strong>：操作系统为<strong>正在运行</strong>的程序提供的抽象，包含进程<strong>能影响到的系统部分</strong>的信息<br><strong>2.2程序如何变为进程</strong><br><strong>①</strong>将<strong>代码和静态数据</strong>加载到<strong>内存（进程的地址空间）</strong>中</p><blockquote><p>程序最初以<strong>某种可执行格式</strong>驻留在磁盘上，需要操作系统从磁盘读取这些字节并将其加载到内存中</p></blockquote><p><strong>②</strong>为程序的<strong>运行时堆和栈</strong>分配内存</p><blockquote><p>C程序使用栈存放<strong>局部变量、函数参数和返回地址</strong>，堆用于显式请求的<strong>动态分配数据</strong></p></blockquote><p><strong>③</strong>并执行一些<strong>初始化任务</strong>，特别是与<strong>输入/输出（I/O）相关</strong>的任务</p><p><strong>2.3进程状态</strong><br><strong>①运行</strong>：正在cpu上执行<br><strong>②就绪</strong>：进程已经准备好，但是还没有被<strong>调度</strong><br><strong>③阻塞</strong>：已经运行的程序，<strong>被某些操作打断（如中断）</strong>，直到某些操作完成，投入<strong>等待列表</strong>（就绪）</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 上下文切换：当一个进程停止时，它的寄存器将被保存到这个寄存器上下文中，通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程</div><p>2.4</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 《操作系统导论》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python（深度学习篇）</title>
      <link href="/2023/06/23/python-shen-du-xue-xi-pian/"/>
      <url>/2023/06/23/python-shen-du-xue-xi-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="python（深度学习篇）"><a href="#python（深度学习篇）" class="headerlink" title="python（深度学习篇）"></a>python（深度学习篇）</h1><h3 id="1-环境配置（Ubuntu22-04）"><a href="#1-环境配置（Ubuntu22-04）" class="headerlink" title="1.环境配置（Ubuntu22.04）"></a>1.环境配置（Ubuntu22.04）</h3><p><strong>1.1安装Anaconda</strong>：Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本；Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。<br>①到官网下载安装包：<code>wget https://repo.anaconda.com/archive/Anaconda3-2023.03-1-Linux-x86_64.sh</code><br>②到<strong>对应目录</strong>下安装：<code>bash Anaconda3-2023.03-1-Linux-x86_64.sh</code><br>③打开conda基础环境：<code>conda activate base</code><br>#<code>conda list</code>查看Anaconda环境情况<br><strong>1.2环境管理</strong></p><pre class="line-numbers language-none"><code class="language-none"># 1.查看conda的版本号conda --version# 2.查看虚拟环境列表conda info --envs# 3.创建虚拟环境并指定python的版本号为3.8conda create -n virtualname pip python=3.9# 4.激活虚拟环境conda activate virtualname# 5.退出虚拟环境conda deactivate# 6.删除虚拟环境conda remove --name virtualname --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3包管理</strong></p><pre class="line-numbers language-none"><code class="language-none"># 1.安装包conda install PackageName# 2.安装多个包conda install name1 name2 ...# 3.安装包并指定版本号conda install PackageName=版本号# 4.卸载包conda remove PackageName# 5.更新包conda update PackageName# 6.更新环境中的所有包conda update --all# 7.列出已安装的包conda list# 8.搜寻包conda search PackageName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.4在pycharm中使用Anaconda环境</strong><br>①创建新环境：<code>conda create --name env_name package_names</code><br>#env_name为环境名；package_names为环境下使用的包的名称，可以在后面加<code>=版本号</code>确定版本，也可以使用多个包（空格隔开）<br>#创建新环境后会进行安装<br>②激活虚拟环境：<code>conda activate pytorch</code><br>③设置pycharm：[Add new Interpreter]→[conda environment]→[Interpreter]→填写环境所在路径<br>#环境路径通常为：<code>/home/xxxx/anaconda3/env/bin/[环境名]</code></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程思想</title>
      <link href="/2023/06/23/mian-xiang-dui-xiang-bian-cheng-si-xiang/"/>
      <url>/2023/06/23/mian-xiang-dui-xiang-bian-cheng-si-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p><strong>1.1对象和类：</strong>类是对象的蓝图和模板，而对象是类的实例</p><blockquote><p>在面向对象编程的世界中，一切皆为对象，对象都有<strong>属性</strong>和<strong>行为</strong>，每个对象都是独一无二的，而且对象一定<strong>属于某个类</strong></p></blockquote><p><strong>1.2三大特性</strong><br>①封装：隐藏一切可以隐藏的实现细节，只向外界提供简单的编程接口，创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）<br>②继承：让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。<br>③多态：子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态<br>1.3类之间的关系<br>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。<br>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。<br>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 《面向对象分析与设计》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（三）</title>
      <link href="/2023/06/23/python-xue-xi-bi-ji-san/"/>
      <url>/2023/06/23/python-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（三）"><a href="#python学习笔记（三）" class="headerlink" title="python学习笔记（三）"></a>python学习笔记（三）</h1><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="1-文件路径"><a href="#1-文件路径" class="headerlink" title="1.文件路径"></a>1.文件路径</h3><p><strong>1.1定义：</strong>指明了文件在计算机上的<strong>位置</strong>，可分为<strong>绝对路径</strong>和<strong>相对路径</strong><br>①绝对路径：从<strong>根文件夹</strong>开始的完整路径<br>②相对路径：相对于程序的<strong>当前工作目录</strong>的路径</p><blockquote><p>windows上采用<code>\</code>作为文件夹之间的分隔符，Linux上和OS X上采用<code>/</code>作为文件夹之间的分隔符</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了程序的可移植性，采用python中os模块中的方法获取文件路径</div><p><strong>1.2获取</strong><br>①通过<code>os</code>模块获取</p><blockquote><p><code>os.path.join()</code>：将单个文件和路径上的文件夹名称的字符串传递给它，<code>os.path.join()</code>就会返回一个文件路径的字符串<br><code>os.getcwd()</code>：可以取得<strong>当前工作路径</strong>的<strong>字符串</strong>，并可以利用<code>os.chdir()</code>改变它<br><code>os.path.abspath(path)</code>：将返回参数（相对路径的<strong>字符串</strong>）的绝对路径的<strong>字符串</strong><br><code>os.path.dirname()</code>：获取文件绝对路径的目录部分</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果要获得路径的每一个文件夹的名称，可以使用'[路径]'.split(os.path.sep)</div><p>②使用<code>sys</code>模块</p><blockquote><p><code>sys.argv[0]</code>：获取当前脚本的路径（包括文件名）。<br><code>sys.path[0]</code>：获取当前脚本所在的目录路径。</p></blockquote><p>③使用<code>__file__</code>变量：包含了<strong>当前模块</strong>（脚本）的路径（包括文件名）</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该变量只在一个独立的模块（脚本）中才有定义</div><pre class="line-numbers language-none"><code class="language-none">import osimport sys# 获取当前工作目录current_directory = os.getcwd()print("当前工作目录:", current_directory)# 获取文件的绝对路径absolute_path = os.path.abspath('file.txt')print("文件的绝对路径:", absolute_path)# 拼接目录和文件名，返回完整路径full_path = os.path.join('dir', 'file.txt')print("完整路径:", full_path)# 获取当前脚本的路径script_path = sys.argv[0]print("当前脚本的路径:", script_path)# 获取当前脚本所在的目录路径script_directory = os.path.dirname(os.path.abspath(__file__))print("当前脚本所在的目录路径:", script_directory)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3有效性检查</strong></p><blockquote><p><code>os.path.exists(path)</code>：如果path参数所指的文件或文件夹存在，返回True<br><code>os.path.isfile(path)</code>：如果path参数存在，并且是一个文件，返回 True<br><code>os.path.isdir(path)</code>：如果path参数存在，并且是一个文件夹，返回Ture</p></blockquote><h3 id="2-文件处理"><a href="#2-文件处理" class="headerlink" title="2.文件处理"></a>2.文件处理</h3><p><strong>2.1打开文件</strong><br>①<code>open()</code>： 向它传递一个<strong>字符串</strong>路径，返回一个<code>File</code>对象，还可传入对应参数指定<strong>操作模式</strong>和<strong>编码方式</strong>，默认是<strong>读模式</strong>和<strong>操作系统默认的编码</strong><br>②操作模式：不同的操作模式有不同的规则</p><blockquote><p><code>'r'</code>：以只读模式打开文件（默认模式），文件指针位于文件的开头，如果文件不存在，则会引发FileNotFoundError。<br><code>'w'</code>：以写入模式打开文件，如果文件已存在，则会被清空。如果文件不存在，则会创建一个新文件。<br><code>'a'</code>：以追加模式打开文件，文件指针位于文件的末尾。如果文件不存在，则会创建一个新文件。<br><code>'x'</code>：以独占写入模式打开文件，如果文件已存在，则会引发FileExistsError。<br><code>'b'</code>：以二进制模式打开文件，可以与其他模式一起使用，例如’rb’或’wb’。<br><code>'t'</code>：以文本模式打开文件（默认模式），可以与其他模式一起使用，例如’rt’或’wt’。<br><code>'+'</code>：以读写模式打开文件，可以与其他模式一起使用，例如’r+’、’w+’或’a+’。</p></blockquote><p>③编码方式：通过<code>encoding</code>参数指定编码，常见的编码方式有<code>ASCII</code>、<code>UTF-8</code>等，选择编码方式时，应根据需求考虑文件中包含的<strong>字符范围、语言以及平台兼容性</strong>等因素</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果文件使用的编码方式与指定的编码方式不匹配，可能会导致读取或写入的数据出现错误</div><p>④如果<code>open</code>函数指定的文件并<strong>不存在或者无法打开</strong>，那么将引发异常状况导致程序崩溃，需要对其进行检查，此外，执行完业务逻辑后，需要<strong>及时对目标文件进行释放</strong>，可以使用python中的异常机制</p><blockquote><p>文件找不到会引发<code>FileNotFoundError</code>，指定了未知的编码会引发<code>LookupError</code>，而如果读取文件时无法按指定方式解码会引发<code>UnicodeDecodeError</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">def main():    f = None    try:        f = open('致橡树.txt', 'r', encoding='utf-8')        print(f.read())    except FileNotFoundError:        print('无法打开指定的文件!')    except LookupError:        print('指定了未知的编码!')    except UnicodeDecodeError:        print('读取文件时解码错误!')    finally:        if f:            f.close()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.2文件读写</strong><br>①文件读取</p><blockquote><p><code>read()</code>：将整个文件的内容读取为一个<strong>字符串值</strong><br><code>for-in</code>循环：还可以使用<code>for-in</code>循环逐行读取文件<br><code>readlines</code>：将文件按行读取到一个列表容器中</p></blockquote><pre class="line-numbers language-none"><code class="language-none">import timedef main():    # 一次性读取整个文件内容    with open('致橡树.txt', 'r', encoding='utf-8') as f:        print(f.read())    # 通过for-in循环逐行读取    with open('致橡树.txt', mode='r') as f:        for line in f:            print(line, end='')            time.sleep(0.5)    print()    # 读取文件按行读取到列表中    with open('致橡树.txt') as f:        lines = f.readlines()    print(lines)    if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②文件写入：采用<code>write()</code>方法，该方法接收<strong>字符串</strong>，并将其写入到文件对象中</p><pre class="line-numbers language-none"><code class="language-none">file = open("example.txt", "w")file.write("Hello, World!")file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.3文件信息查询</strong><br>①<code>os.path.getsize(path)</code>将返回path参数中文件的<strong>字节数</strong><br>②<code>os.listdir(path)</code>将返回<strong>文件名字符串的列表</strong>，包含path参数中的每个文件<br><strong>2.4文件管理器</strong><br>①定义</p><blockquote><p>上下文：任务本身会对其环境进行保存，做到哪里了，做了多少，各种状态都会标识记录，从而形成了上下文环境，在切换时根据每个任务的上下文环境，继续执行，从而达到多任务</p></blockquote><blockquote><p>上下文管理器对象：即任何实现了<code>__enter__()</code>和 <code>__exit__()</code> 方法的类的对象实例</p></blockquote><p>②使用：<code>with 上下文表达式 as 对象</code></p><blockquote><p>其中<strong>上下文表达式</strong>是一个返回上下文管理器对象的函数调用<br>在进入语句块之前，上下文管理器的<code>__enter__</code>方法会被调用，可以在这个方法中执行资源的获取操作<br>在离开语句块时，无论是正常的退出还是发生异常，上下文管理器的<code>__exit__</code>方法都会被调用，可以在这个方法中执行资源的释放操作</p></blockquote><pre class="line-numbers language-none"><code class="language-none">with open('example.txt', 'r') as file:    data = file.read()    print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③with关键字的实现原理</p><pre class="line-numbers language-none"><code class="language-none">class File(object):    def __init__(self, filename, mode):        self.filename = filename        self.mode = mode        self.file = None    def __enter__(self):        """        进入with as 语句的时候被with调用        返回值作为 as 后面的变量        """        print("__enter__ called")        self.file = open(self.filename, self.mode)        return self.file    def __exit__(self, exc_type, exc_value, exc_traceback):        """        离开with语句的时候被with调用        """        print("__exit__ called")        print("exc_type: ", exc_type)        print("exc_value: ", exc_value)        print("exc_traceback: ", exc_traceback)        self.file.close()        print("文件关闭操作")def main():    with File("test.txt", "w") as f:        print("with 代码块")        f.write("hello python1")        f.write("hello python2")        # a = 1 / 0        f.write("hello python3")    print("with 语句结束")if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>进入上下文管理器会自动调用<code>__enter__(self)</code>，该方法的返回值会被赋值给<code>as</code>子句后的对象，该方法可以返回多个值，因此在<code>as</code>子句后面也可以指定多个变量（括起来组成元组）<br>退出上下文管理器自动调用<code>__exit__(self, exc_type, exc_value, exc_traceback)</code>，前三个参数在调用<code>__exit__()</code>方法时由Python解释器自动传递，并提供与异常相关的信息</p></blockquote><p>④<code>with</code>关键字和<code>try-except</code>联合调用</p><pre class="line-numbers language-none"><code class="language-none">def main():    try:        with open('guido.jpg', 'rb') as fs1:            data = fs1.read()            print(type(data))  # &lt;class 'bytes'&gt;        with open('吉多.jpg', 'wb') as fs2:            fs2.write(data)    except FileNotFoundError as e:        print('指定的文件无法打开.')    except IOError as e:        print('读写文件时出现错误.')    print('程序执行结束.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>with</code>语句的主要目的是确保上下文管理器的资源<strong>被正确释放</strong>，即使在发生异常的情况下也能保证资源的释放，而<code>try-except</code>语句主要用于处理异常，提供错误处理和容错机制</p></blockquote><h3 id="3-变量保存"><a href="#3-变量保存" class="headerlink" title="3.变量保存"></a>3.变量保存</h3><p><strong>3.1json模块</strong><br>①简介：是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于<strong>跨平台跨语言</strong>的数据交换</p><blockquote><p>因为JSON是<strong>纯文本</strong>，任何系统任何编程语言处理纯文本都是没有问题的</p></blockquote><p>②JSON的数据类型和Python的数据类型对应关系</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>dict</td><td>object</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True/False</td><td>true/false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table><p>③实例</p><pre class="line-numbers language-none"><code class="language-none">import jsondef main():    mydict = {        'name': '骆昊',        'age': 38,        'qq': 957658,        'friends': ['王大锤', '白元芳'],        'cars': [            {'brand': 'BYD', 'max_speed': 180},            {'brand': 'Audi', 'max_speed': 280},            {'brand': 'Benz', 'max_speed': 320}        ]    }    try:        with open('data.json', 'w', encoding='utf-8') as fs:            json.dump(mydict, fs)    except IOError as e:        print(e)    print('保存数据完成!')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>json</code>模块常用方法<br><code>dump()</code>：将Python对象按照JSON格式序列化到文件中<br><code>dumps()</code>：将Python对象处理成JSON格式的字符串<br><code>load()</code>：将文件中的JSON数据反序列化成对象<br><code>loads()</code>：将字符串的内容反序列化成Python对象</p></blockquote><p><strong>3.2shelve模块：</strong>可以将Python程序中的变量保存到<strong>二进制的shelf文件</strong>中，这样，程序就可以从硬盘中恢复变量的数据</p><pre class="line-numbers language-none"><code class="language-none">#保存变量import shelveshelfFile = shelve.open('mydata') #初始化一个shelf变量，类似于file变量，其中mydata为保存变量的文件cats = ['Zophie', 'Pooka', 'Simon']shelfFile['cats'] = cats #变量以类似于字典的形式存储shelfFile.close() #结束#访问变量shelfFile = shelve.open('mydata')shelfFile['cats'] #访问cats变量shelfFile.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（二）</title>
      <link href="/2023/06/23/python-xue-xi-bi-ji-er/"/>
      <url>/2023/06/23/python-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（二）"><a href="#python学习笔记（二）" class="headerlink" title="python学习笔记（二）"></a>python学习笔记（二）</h1><h2 id="python进阶"><a href="#python进阶" class="headerlink" title="python进阶"></a>python进阶</h2><h3 id="1-正则表达式（Regex）"><a href="#1-正则表达式（Regex）" class="headerlink" title="1.正则表达式（Regex）"></a>1.正则表达式（Regex）</h3><p><strong>1.1定义</strong>：一种<strong>只描述文本特征</strong>文本描述方法</p><blockquote><p>与正则表达式有关的函数在<strong>re模块</strong>中</p></blockquote><p><strong>1.2字符分类</strong><br>①默认字符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_8.png" alt="默认字符"><br>②自定义:[ijk]</p><blockquote><p>可以使用<code>-</code>表示字母或数字的范围，如[0-57-8]表示[012345678]</p></blockquote><p><strong>一般的</strong>正则表达式符号不会被解释，不需要使用转义字符<br>在的左方括号后加上一个插入字符<code>^</code>，就可以得到<strong>非字符类</strong>，即匹配不在这个字符类中的所有字符<br><strong>1.3步骤</strong><br>①<code>import re</code>导入re模块<br>②用<code>re.compile()</code>函数创建一个<strong>Regex对象</strong>（记得使用<strong>原始字符串</strong>）<br>③向Regex对象的<code>search()</code>方法传入想查找的字符串，它返回一个<strong>Match对象</strong><br>④调用Match对象的<code>group()</code>方法，返回实际匹配文本的<strong>字符串</strong></p><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') #phoneNumRegex是一个Regex对象mo = phoneNumRegex.search('My number is 415-555-4242.') #mo是一个Match对象print('Phone number found: ' + mo.group())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>1.4修饰符号</strong>:在<strong>初始化Regex对象</strong>时使用，如果想要匹配这这些字符，需要使用对应的<strong>转义字符</strong><br>①<code>()</code>：对Regex对象进行<strong>分组</strong></p><blockquote><p>group()函数可以提取对象的<strong>某一组内容</strong>，默认是0，即不考虑分组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')mo = phoneNumRegex.search('My number is 415-555-4242.')mo.group(1) #得到的结果是'415'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果想要一次就获取<strong>所有的分组</strong>，使用<code>groups()</code>方法，返回多个组对应的<strong>字符串元组</strong></p></blockquote><p>②<code>|</code>：表示匹配许多表达式<strong>中的一个</strong>即可</p><pre class="line-numbers language-none"><code class="language-none">heroRegex = re.compile (r'Batman|Tina Fey')mo1 = heroRegex.search('Batman and Tina Fey.')mo1.group() #结果是'Batman'，即第一次匹配到的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>可以利用<code>()</code>和<code>|</code>实现某部分确定，某部分可选的正则表达式，如<code>batRegex = re.compile(r'Bat(man|mobile|copter|bat)')</code></p></blockquote><p>③<code>?</code>:表明它<strong>前面的分组</strong>在这个模式中是<strong>可选的</strong></p><blockquote><p><code>batRegex = re.compile(r'Bat(wo)?man')</code>既匹配’Batwoman’，又匹配’Batman’</p></blockquote><p>④<code>*</code>：意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现<strong>任意次</strong>，包括0次</p><blockquote><p><code>batRegex = re.compile(r'Bat(wo)*man')</code>可以匹配’Batwowowowoman’和’Batman’</p></blockquote><p>⑤<code>+</code>：类似于<code>*</code>，但是<strong>至少要一次</strong><br>⑥<code>{}</code>：类似于<code>*</code>，用于指定<strong>特定次数</strong>，<code>{n}</code>表示匹配n次，<code>{i，j}</code>代表i-j次</p><blockquote><p>贪心和非贪心匹配:Python 的正则表达式<strong>默认是“贪心”</strong>的，这表示在有二义的情况下，它们会<strong>尽可能匹配最长的字符串</strong>，花括号的“非贪心”版本匹配尽可能最短的字符串，即在<strong>结束的花括号后跟着一个问号</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">greedyHaRegex = re.compile(r'(Ha){3,5}')mo1 = greedyHaRegex.search('HaHaHaHaHa')mo1.group() #结果是'HaHaHaHaHa'nongreedyHaRegex = re.compile(r'(Ha){3,5}?')mo2 = nongreedyHaRegex.search('HaHaHaHaHa')mo2.group() #结果是'HaHaHa'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⑦<code>^</code>/<code>$</code>：被搜索字符串必须以正则表达式对应的字符串<strong>开始/结束</strong><br>⑧<code>.</code>：匹配一个<strong>除了换行之外</strong>的所有字符</p><blockquote><p>传入<code>re.DOTALL</code>作为<code>re.compile()</code>的第二个参数，可以让句点字符匹配<code>所有字符</code>，包括换行字符</p></blockquote><p><strong>1.5拓展方法</strong><br>①<code>findall()</code>：不同于<code>search()</code>返回的Match对象只包含<code>第一次出现的匹配文本</code>，<code>findall()</code>将返回一<strong>字符串列表</strong>，包含被查找字符串中的<strong>所有匹配</strong></p><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groupsphoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')['415-555-9999', '212-555-0000']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果在正则表达式中有分组，那么findall将返回<strong>元组的列表</strong>，每个元组表示一个找到的匹配，其中的项就是正则表达式中每个分组的匹配字符串</p></blockquote><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)') # has groupsphoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')[('415', '555', '1122'), ('212', '555', '0000')]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>②<code>sub()</code>：传入两个参数，第一个参数是一个字符串，用于取代发现和正则表达式匹配的部分，第二个参数是一个正则表达式，返回替换完成后的字符串</p><pre class="line-numbers language-none"><code class="language-none">namesRegex = re.compile(r'Agent \w+')namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')#返回'CENSORED gave the secret documents to CENSORED.'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果只想改变和对应正则表达式相匹配的<strong>一部分</strong>，可以给正则表达式参数<strong>分组</strong>，并在第一个参数开头加上<code>\n</code>，代表该字符串只替代第n组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">agentNamesRegex = re.compile(r'Agent (\w)\w*')agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.')#返回结果是'A**** told C**** that E**** knew B**** was a double agent.'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③复杂的正则表达式</p><blockquote><p>可以可以向<code>re.compile()</code>传入变量<code>re.VERBOSE</code>，作为第二个参数，忽略正则表达式字符串中的空白符和注释<br>使用三重引号，可以将正则表达式定义放在多行中</p></blockquote><p>详细可见<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">参考文章</a></p><h3 id="2-并发编程"><a href="#2-并发编程" class="headerlink" title="2.并发编程"></a>2.并发编程</h3><p><strong>2.1相关概念</strong><br>①并发编程：让程序同时执行多个任务<br>②进程：操作系统中<strong>正在执行</strong>的程序</p><blockquote><p>操作系统以进程为单位分配存储空间，每个进程都有自己的<strong>地址空间</strong>、<strong>数据栈</strong>以及其他用于跟踪进程执行的<strong>辅助数据</strong><br>不同进程通过<strong>进程间通信机制</strong>（IPC）来实现数据共享，具体的方式包括<strong>管道</strong>、<strong>信号</strong>、<strong>套接字</strong>、<strong>共享内存区</strong>等</p></blockquote><p>③线程：进程中可以获得CPU调度的执行单元</p><blockquote><p>某个时刻能够获得CPU的只有唯一的一个<strong>线程</strong></p></blockquote><p><strong>2.2多进程</strong><br><a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.md">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下基于VScode和CMake的C/C++开发</title>
      <link href="/2023/06/23/linux-xia-ji-yu-vscode-he-cmake-de-c-yu-yan-kai-fa/"/>
      <url>/2023/06/23/linux-xia-ji-yu-vscode-he-cmake-de-c-yu-yan-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="代码开发实战（一）"><a href="#代码开发实战（一）" class="headerlink" title="代码开发实战（一）"></a>代码开发实战（一）</h1><h2 id="Linux下基于VScode和CMake的C-x2F-C-开发"><a href="#Linux下基于VScode和CMake的C-x2F-C-开发" class="headerlink" title="Linux下基于VScode和CMake的C/C++开发"></a>Linux下基于VScode和CMake的C/C++开发</h2><h3 id="1-Linux系统概述"><a href="#1-Linux系统概述" class="headerlink" title="1.Linux系统概述"></a>1.Linux系统概述</h3><p><strong>1.1Linux系统简介：</strong>一个开源的<strong>多用户多任务</strong>的操作系统</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> Linux中一切皆文件</div><p><strong>1.2目录结构</strong></p><blockquote><p>/：根目录，最顶层的目录<br>bin：全称binary，含义是二进制。该目录中存储的都是一些<strong>二进制文件</strong>，文件都是可以被运行的。<br>dev：该目录中主要存放的是<strong>外接设备</strong>，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似window下的分配盘符）。<br>etc：该目录主要存储一些<strong>配置文件</strong>。<br>home：表示“家”，表示除了root用户以外<strong>其他用户的家目录</strong>，类似于windows下的User/用户目录。<br>proc：全称process，表示进程，该目录中存储的是Linux运行时候的<strong>进程</strong>。<br>root：该目录是<strong>root用户</strong>自己的家目录。<br>sbin：全称super binary，该目录也是存储一些可以被执行的<strong>二进制文件</strong>，但是必须得有<strong>super权限</strong>的用户才能执行。<br>tmp：表示“临时”的，当系统运行时候产生的<strong>临时文件</strong>会在这个目录存着。<br>usr：存放的是用户<strong>系统自带文件</strong>。类似于windows下的program files。<br>var：存放的程序/系统的<strong>日志文件</strong>的目录。<br>mnt：当外接设备需要<strong>挂载</strong>的时候，就需要挂载到mnt目录下。<br>boot：<strong>内核文件</strong>及引导加载程序（<strong>开机文件</strong>）<br>opt: 存放可选软件的安装目录，一些<strong>第三方应用程序</strong>可能会安装在这个目录下。</p></blockquote><p><strong>1.3指令与选项</strong><br>①指令格式：<code>指令 [选项] [对象]</code></p><blockquote><p>选项和操作对象都可以没有，也可以是<strong>多个</strong></p></blockquote><p>②路径相关指令</p><blockquote><p><code>pwd</code>：打印当前终端<strong>所在的目录</strong><br><code>ls [选项] [路径]</code>：列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示（不指定路径就是当前路径）<br><code>cd [路径]</code>：切换到对应路径下（不指定路径即为当前用户家目录）</p></blockquote><p>③文件相关指令</p><blockquote><p><code>mkdir</code>：创建目录<br><code>touch</code>：创建新文件/将指定文件的修改时间设置为当前时间<br><code>rm</code>：删除文件/目录<br><code>cp</code>：复制文件/文件夹到指定的位置<br><code>mv</code>：移动文件到新的位置，或者重命名文件<br><code>vi</code>：编辑文件</p></blockquote><p>③辅助指令</p><blockquote><p><code>man</code>：打开Linux下的命令手册<br><code>reboot</code>：重启系统<br><code>shutdown</code>：关机</p></blockquote><p><strong>1.4开发环境搭建</strong><br>①安装GCC，GDB</p><pre class="line-numbers language-none"><code class="language-none">sudo apt update# 通过以下命令安装编译器和调试器sudo apt install build-essential gdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>②安装Cmake和VSCode</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install cmakesudo apt install code<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-GCC-x2F-G-编译器"><a href="#2-GCC-x2F-G-编译器" class="headerlink" title="2.GCC/G++编译器"></a>2.GCC/G++编译器</h3><p><strong>2.1概述：</strong>gcc编译器用于编译C语言，g++用于编译C++语言</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 虽然g++可以编译C代码，但它会将源代码解析为C++代码进行编译，某些特定的C++功能和语法可能会被启用</div><p><strong>2.2编译过程及指令</strong><br>①预处理：<code>g++  -E test.cpp  -o test.i</code></p><blockquote><p>-E选项指示编译器仅对输入文件进行预处理</p></blockquote><p>②编译：<code>g++  -S test.i  -o   test.s</code></p><blockquote><p>-S编译选项告诉g++在为C++代码产生了汇编语言文件后停止编译<br>g++产生的汇编语言文件的缺省扩展名是.s</p></blockquote><p>③汇编：<code>g++  -c test.s  -o test.o</code></p><blockquote><p>-c选项告诉g++仅把源代码编译为机器语言的目标代码<br>缺省时g++建立的目标代码文件有一个.o的扩展名。</p></blockquote><p>④链接：<code>g++ test.o  -o test</code></p><blockquote><p>-o编译选项来为将产生的可执行文件用指定的文件名</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 以上四个过程可以合并为g++ test.cpp -o test</div><p><strong>2.3重要编译参数</strong><br>①<code>-g</code>：编译带调试信息的可执行文件<br>②<code>-O[n]</code>：优化源代码</p><blockquote><p><code>-O</code>选项告诉g++对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。<br><code>-O0</code>表示不做优化<br><code>-O1</code>为默认优化<br><code>-O2</code>除了完成<code>-O1</code>的优化之外，还进行一些额外的调整工作，如指令调整等。<br><code>-O3</code>则包括循环展开和其他一些与处理特性相关的优化工作。</p></blockquote><p>③<code>-l</code>：指定库文件</p><blockquote><p><code>-l</code>参数(小写)就是用来指定程序要链接的库，<code>-l</code>参数紧接着就是库名<br>在<code>/lib</code>和<code>/usr/lib</code>和<code>/usr/local/lib</code>里的库直接用<code>-l</code>参数就能链接</p></blockquote><p>④<code>-L</code>：指定库文件路径</p><blockquote><p>如果库文件没放在上面三个目录里，需要使用<code>-L</code>参数(大写)指定库文件所在目录<br><code>-L</code>参数跟着的是库文件所在的目录名</p></blockquote><p>⑤-I：指定头文件搜索目录</p><blockquote><p><code>/usr/include</code>目录一般是不用指定的，gcc知道去那里找，但是如果头文件<strong>不在</strong><code>/usr/icnclude</code>里我们就要用<code>-I</code>参数指定了，比如头文件放在<code>/myinclude</code>目录里，那编译命令行就要加上<code>I/myinclude</code> 参数了</p></blockquote><p>⑥<code>-Wall</code>：打印警告信息<br>⑦<code>-w</code>：关闭警告信息<br>⑧<code>-std=[语言版本]</code>:设置编译标准<br>⑨<code>-o</code>：指定输出文件名</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意-o参数和其他参数位置不同，其他参数在g++和编译文件之间，-o在编译文件之后，并接空格和文件名</div><p>⑩<code>-D</code>：定义宏</p><blockquote><p><code>g++ -DVERSION=2.0 main.cpp -o program</code>：将<code>main.cpp文</code>件中的<code>VERSION</code>宏定义为2</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> -DDEBUG定义DEBUG宏，可能文件中有DEBUG宏部分的相关信息，用个DDEBUG来选择开启或关闭DEBUG</div><p><strong>2.4编译过程</strong><br>①目录结构</p><pre class="line-numbers language-none"><code class="language-none"># 最初目录结构.├── include│   └── Swap.h├── main.cpp└── src   └── Swap.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②直接编译：g++ main.cpp src/Swap.cpp -Iinclude<br>③链接静态库编译</p><pre class="line-numbers language-none"><code class="language-none">## 进入src目录下$cd src# 汇编，生成Swap.o文件g++ Swap.cpp -c -I../include# 生成静态库libSwap.aar rs libSwap.a Swap.o## 回到上级目录$cd ..# 链接，生成可执行文件:staticmaing++ main.cpp -Iinclude -Lsrc -lSwap -o staticmain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>④链接动态库编译</p><pre class="line-numbers language-none"><code class="language-none">## 进入src目录下$cd src# 生成动态库libSwap.sog++ Swap.cpp -I../include -fPIC -shared -o libSwap.so## 上面命令等价于以下两条命令# gcc Swap.cpp -I../include -c -fPIC# gcc -shared -o libSwap.so Swap.o## 回到上级目录$cd ..# 链接，生成可执行文件:sharemaing++ main.cpp -Iinclude -Lsrc -lSwap -o sharemain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 运行动态库文件时，需要指定动态库所在位置：LD_LIBRARY_PATH=src ./sharemain</div><h3 id="3-GDB调试器"><a href="#3-GDB调试器" class="headerlink" title="3.GDB调试器"></a>3.GDB调试器</h3><p><strong>3.1概述：</strong><br>①简介：GDB是一个用来调试C/C++程序的功能强大的调试器，是Linux系统开发C/C++最常用的调试器<br>②主要功能</p><blockquote><p>设置<strong>断点</strong>：使程序在指定的代码行上暂停执行，便于观察<br><strong>单步执行</strong>程序，便于调试<br>查看程序中<strong>变量值的变化</strong><br>动态改变程序的<strong>执行环境</strong><br>分析崩溃程序产生的<strong>core文件</strong></p></blockquote><p>③使用：在命令行中输入<code>gdb [exefilename]</code>即可启动GDB调试器</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 编译程序时需要加上-g，之后才能用gdb进行调试：gcc -g main.c -o main</div><p><strong>3.2常用指令</strong></p><blockquote><p><code>help(h)</code>：查看命令帮助，具体命令查询在gdb中输入help + 命令<br><code>run(r)</code>：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）<br><code>start</code>：单步执行，运行程序，停在第一行执行语句<br><code>list(l)</code>：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）<br><code>set</code>：设置变量的值<br><code>next(n)</code>：单步调试（逐过程，函数直接执行）<br><code>step(s)</code>：单步调试（逐语句：跳入自定义函数内部执行）<br><code>backtrace(bt)</code>：查看函数的调用的栈帧和层级关系<br><code>frame(f)</code>：切换函数的栈帧<br><code>info(i)</code>：查看函数内部局部变量的数值<br><code>finish</code>：结束当前函数，返回到函数调用点<br><code>continue(c)</code>：继续运行<br><code>print(p)</code>：打印值及地址<br><code>quit(q)</code>：退出gdb<br><code>break+num(b)</code>：在第num行设置断点<br><code>info breakpoints</code>：查看当前设置的所有断点<br><code>delete breakpoints num(d)</code>：删除第num个断点<br><code>display</code>：追踪查看具体变量值<br><code>undisplay</code>：取消追踪观察变量<br><code>watch</code>：被设置观察点的变量发生修改时，打印显示<br><code>i watch</code>：显示观察点<br><code>enable breakpoint</code>：启用断点<br><code>disable breakpoints</code>：禁用断点<br><code>x</code>：查看内存x/20xw 显示20个单元，16进制，4字节每单元<br><code>run argv[1] argv[2]</code>：调试时命令行传参<br><code>set follow-fork-mode child</code>：Makefile项目管理：选择跟踪父子进程fork()</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 回车键：重复上一命令</div><h3 id="4-IDE-VSCode"><a href="#4-IDE-VSCode" class="headerlink" title="4.IDE(VSCode)"></a>4.IDE(VSCode)</h3><p><strong>4.1简介</strong><br>①界面可分为四部分</p><blockquote><p>侧边栏<br>菜单栏<br>编辑区<br>状态栏</p></blockquote><p>②插件安装</p><blockquote><p>C/C++<br>CMake<br>CMake Tools</p></blockquote><p>③项目文件夹结构：一般将头文件放在<code>include</code>文件夹中，将源文件（记得要包含对应头文件）放在<code>src</code>文件夹中，随后<code>main</code>函数独立于这两个文件夹，<strong>包含对应头文件</strong>即可</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在头文件中，可以添加#pragma once防止头文件重复编译</div><p><strong>4.2快捷键</strong><br>①常用快捷键</p><blockquote><p><code>Ctrl + P</code>：转到文件/其他常用操作<br><code>Ctrl + W</code>：关闭当前文件<br><code>Ctrl + Shift + P</code>：打开命令面板<br><code>Alt + Up/Down</code>当前行上移/下移<br><code>F2</code>：变量统一重命名<br><code>Ctrl + B</code>：关闭侧边栏<br><code>F12</code>：转到定义处<br><code>Ctrl+C</code>：复制文本<br><code>Ctrl+V</code>：粘贴文本<br><code>Ctrl+S</code>：保存文件<br><code>Ctrl+Z</code>：撤销操作 </p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> Ctrl +\`：打开终端</div><p>②<code>Ctrl + P</code>窗口相关操作</p><blockquote><p>直接输入文件名，跳转到文件<br><code>?</code>：列出当前可执行的动作<br><code>!</code>：显示<code>Errors</code>或<code>Warnings</code>，也可以<code>Ctrl+Shift+M</code><br><code>:</code>：跳转到行数，也可以<code>Ctrl+G</code>直接进入<br><code>@</code>：跳转到<code>symbol</code>（搜索变量或者函数），也可以<code>Ctrl+Shift+O</code>直接进入<br><code>@</code>：根据分类跳转<code>symbol</code>，查找属性或函数，也可以<code>Ctrl+Shift+O</code>后输入<code>:</code>进入<br><code>#</code>：根据名字查找<code>symbol</code>，也可以<code>Ctrl+T</code></p></blockquote><p>③编辑器与窗口管理</p><blockquote><p><code>Ctrl+Shift+N</code>：打开一个新窗口<br><code>Ctrl+Shift+W</code>：关闭窗口<br><code>Ctrl+N</code>：新建文件<br><code>Ctrl+Tab</code>：文件之间切换<br><code>Ctrl+\</code>：切出一个新的编辑器（最多 3 个）<br><code>Ctrl+1 Ctrl+2 Ctrl+3</code>：左中右3个编辑器的快捷键<br><code>Ctrl+k然后按Left或Right</code>：编辑器换位置</p></blockquote><p>④代码格式调整</p><blockquote><p>代码行缩进：<code>Ctrl+[</code>、<code>Ctrl+]</code><br>代码格式化：<code>Shift+Alt+F</code><br>上下移动一行：<code>Alt+Up</code>或<code>Alt+Down</code><br>向上向下复制一行：<code>Shift+Alt+Up</code>或<code>Shift+Alt+Down</code><br>在当前行下边插入一行：<code>Ctrl+Enter</code><br>在当前行上方插入一行：<code>Ctrl+Shift+Enter</code></p></blockquote><p>⑤光标相关</p><blockquote><p>移动到行首：<code>Home</code><br>移动到行尾：<code>End</code><br>移动到文件结尾：<code>Ctrl+End</code><br>移动到文件开头：<code>Ctrl+Home</code><br>移动到定义处：<code>F12</code><br>定义处缩略图（只看一眼而不跳转过去）：<code>Alt+F12</code><br>移动到后半个括号：<code>Ctrl+Shift+]</code><br>选择从光标到行尾：<code>Shift+End</code><br>选择从行首到光标处：<code>Shift+Home</code><br>删除光标右侧的所有字：<code>Ctrl+Delete</code><br>扩展/缩小选取范围：<code>Shift+Alt+Left</code>和<code>Shift+Alt+Right</code><br>同时选中所有匹配：<code>Ctrl+Shift+L</code>，<code>Ctrl+D</code>下一个匹配的也被选中</p></blockquote><p>⑥代码重构</p><blockquote><p>找到所有的引用：<code>Shift+F12</code><br>同时修改本文件中所有匹配的：<code>Ctrl+F12</code><br>重命名：比如要修改一个方法名，可以选中后按<code>F2</code>，输入新的名字，回车，会发现所有的文件都修改了<br>跳转到下一个Error或Warning：当有多个错误时可以按<code>F8</code>逐个跳转<br>查看diff：在<code>explorer</code>里选择文件右键<code>Set file to compare</code>，然后需要对比的文件上右键选择<code>Compare with file_name_you_chose</code></p></blockquote><p>⑦查找替换</p><blockquote><p>查找：<code>Ctrl+F</code><br>查找替换：<code>Ctrl+H</code><br>整个文件夹中查找：<code>Ctrl+Shift+F</code></p></blockquote><p>⑧显示相关</p><blockquote><p>全屏：<code>F11</code><br>zoomIn/zoomOut：<code>Ctrl +/-</code><br>侧边栏显/隐：<code>Ctrl+B</code><br>显示资源管理器：<code>Ctrl+Shift+E</code><br>显示搜索：<code>Ctrl+Shift+F</code><br>显示Git：<code>Ctrl+Shift+G</code><br>显示Debug：<code>Ctrl+Shift+D</code><br>显示Output：<code>Ctrl+Shift+U</code></p></blockquote><p><strong>4.3Jason文件配置</strong></p><h3 id="5-CMake"><a href="#5-CMake" class="headerlink" title="5.CMake"></a>5.CMake</h3><p><strong>5.1概述</strong><br>①简介：CMake是一个<strong>跨平台</strong>的安装编译工具，可以使用相同的<code>CMakeLists.txt</code>文件在多个操作系统（如Windows、Linux、macOS等）上生成适应不同编译器和构建工具的构建脚本</p><blockquote><p>如果不使用CMake的话，就要自己写针对不同平台的构建脚本，修改项目时，就十分麻烦</p></blockquote><p>②基本语法格式：<code>指令(参数1 参数n)</code></p><blockquote><p>参数之间使用<strong>空格</strong>或者<strong>分号</strong>隔开<br>指令时大小写无关的，参数是大小写相关的<br>变量使用<code>${变量}</code>方式取值，但是在<code>IF</code>控制语句中是<strong>直接使用变量名</strong></p></blockquote><p>③目录结构</p><blockquote><p>项目主目录存在一个<code>CMakeLists.txt</code>文件<br><strong>包含源文件的子文件夹</strong>包含<code>CMakeLists.txt</code>文件:主目录的<code>CMakeLists.txt</code>通过<code>add_subdirectory</code>添加子目录即可；<br><strong>包含源文件的子文件夹</strong>未包含<code>CMakeLists.txt</code>文件:子目录编译规则体现在主目录的<code>CMakeLists.txt</code>中；</p></blockquote><p>④编译流程</p><blockquote><p>手动编写<code>CMakeLists.txt</code><br>执行命令<code>cmake PATH</code>生成<code>Makefile</code>(<code>PATH</code>是<strong>顶层CMakeLists.txt</strong>所在的目录)。<br>执行命令<code>make</code>进行编译。</p></blockquote><p>⑤外部构建(out-of-source build)</p><pre class="line-numbers language-none"><code class="language-none">## 外部构建# 1. 在项目顶层目录下，创建build文件夹mkdir build# 2. 进入到build文件夹cd build# 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件cmake ..# 4. 执行make命令，生成targetmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章，不推荐使用</p></blockquote><p><strong>5.2常用语法</strong><br>①<code>cmake_minimum_required</code>：指定CMake的<strong>最小版本要求</strong></p><blockquote><p>语法：<code>cmake_minimum_required(VERSION versionNumber [FATAL_ERROR])</code><br>示例：<code>cmake_minimum_required(VERSION 2.8.3)</code><br>#CMake最小版本要求为2.8.3</p></blockquote><p>②<code>project</code>：定义<strong>工程名称</strong>，并可指定工程支持的语言</p><blockquote><p>语法：<code>project(projectname [CXX] [C] [Java])</code><br>示例：<code>project(HELLOWORLD) </code><br>#指定工程名为HELLOWORLD</p></blockquote><p>③<code>set</code>：显式的定义变量</p><blockquote><p>语法：<code>set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code><br>示例：<code>set(SRC sayhello.cpp hello.cpp)</code><br>#定义SRC变量，其值为sayhello.cpp hello.cpp，即两个文件</p></blockquote><p>④<code>include_directories</code>：向工程添加多个特定的<strong>头文件搜索路径</strong></p><blockquote><p>语法：<code>include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)</code><br>示例：<code>include_directories(/usr/include/myincludefolder ./include) </code><br>#将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径，绝对路径和相对路径均可</p></blockquote><p>⑤<code>link_directories</code>：向工程添加多个特定的<strong>库文件搜索路径</strong></p><blockquote><p>语法：<code>link_directories(dir1 dir2 ...)</code><br>示例：<code>link_directories(/usr/lib/mylibfolder ./lib)</code><br>#将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径</p></blockquote><p>⑥<code>add_library</code>：生成<strong>库文件</strong></p><blockquote><p>语法：<code>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</code><br>示例：<code>add_library(hello SHARED ${SRC})</code><br>#通过变量SRC生成libhello.so共享库</p></blockquote><p>⑦<code>add_compile_options</code>：添加<strong>编译参数</strong></p><blockquote><p>语法：<code>add_compile_options(&lt;options&gt;)</code><br>示例：<code>add_compile_options(-Wall -std=c++11 -O2)</code><br>#添加编译参数 -Wall -std=c++11 -O2</p></blockquote><p>⑧<code>add_executable</code>：生成<strong>可执行文件</strong></p><blockquote><p>语法：<code>add_executable(exename source1 source2 ... sourceN)</code><br>示例：<code>add_executable(main main.cpp)</code><br>#编译main.cpp生成可执行文件main</p></blockquote><p>⑨<code>target_link_libraries</code>：为target<strong>添加需要链接的共享库</strong></p><blockquote><p>语法：<code>target_link_libraries(target library1&lt;debug | optimized&gt; library2...)</code><br>示例：<code>target_link_libraries(main hello)</code><br>#将hello动态库文件链接到可执行文件main</p></blockquote><p>⑩<code>add_subdirectory</code>：向当前工程<strong>添加存放源文件的子目录</strong>，并可以指定中间二进制和目标二进制存放的位置</p><blockquote><p>语法：<code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code><br>示例：<code>add_subdirectory(src)</code><br>#添加src子目录，src中<strong>需有一个CMakeLists.txt</strong></p></blockquote><p>⑪<code>aux_source_directory</code>：发现<strong>一个目录下所有的源代码文件</strong>并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</p><blockquote><p>语法：<code>aux_source_directory(dir VARIABLE)</code><br>示例：<br><code>aux_source_directory(. SRC)</code> #定义SRC变量，其值为当前目录下所有的源代码文件<br><code>add_executable(main ${SRC})</code> #编译SRC变量所代表的源代码文件，生成main可执行文件</p></blockquote><p><strong>5.3常用变量</strong><br>①<code>CMAKE_C_FLAGS</code>：gcc编译选项<br>②<code>CMAKE_CXX_FLAGS</code>：g++编译选项</p><blockquote><p><code>set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")</code><br>#在CMAKE_CXX_FLAGS编译选项后追加-std=c++11<br>③<code>CMAKE_C_COMPILER</code>：指定C编译器<br>④<code>CMAKE_CXX_COMPILER</code>：指定C++编译器<br>⑤<code>EXECUTABLE_OUTPUT_PATH</code>：可执行文件输出的存放路径<br>⑥<code>LIBRARY_OUTPUT_PATH</code>：库文件输出的存放路径</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软技能 </tag>
            
            <tag> 代码开发实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统配置</title>
      <link href="/2023/06/23/linux-xi-tong-pei-zhi/"/>
      <url>/2023/06/23/linux-xi-tong-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统配置（Ubuntu22-04）"><a href="#Linux系统配置（Ubuntu22-04）" class="headerlink" title="Linux系统配置（Ubuntu22.04）"></a>Linux系统配置（Ubuntu22.04）</h1><h3 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h3><p><strong>1.1安装VMware-tools or open-vm-tools</strong>：<a href="https://blog.csdn.net/baidu_38797690/article/details/124191747">https://blog.csdn.net/baidu_38797690/article/details/124191747</a><br><strong>1.2更换软件源</strong>：在<strong>软件和更新</strong>中替换</p><h3 id="2-软件安装"><a href="#2-软件安装" class="headerlink" title="2.软件安装"></a>2.软件安装</h3><p><strong>2.1包管理器安装</strong>：大多数Linux发行版都提供了自己的包管理器，例如Ubuntu自带的apt、第三方包管理器sanp（需要自己下载）等。使用包管理器可以方便地从官方软件仓库中安装、更新和卸载软件</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update    # 更新软件源sudo apt-get install 软件包名   # 安装软件sudo apt-get remove 软件包名    #卸载软件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.2源码安装</strong>：有些软件可能不在官方软件仓库中，或者需要手动安装特定版本的软件。在这种情况下，你可以从软件官网上下载安装包，然后<strong>解压缩、编译和安装</strong><br>①安装底层依赖，比如python<br>①到对应网站上下载自己想要的版本的源码：<code>wget</code>+下载地址<br>③解压到任意目录<br>④在解压目录下配置（./configure）并编译（make）安装（make install）<br>⑤修改用户主目录下名为.bash_profile的文件，配置PATH环境变量并使其生效<br>⑥激活环境变量：source .bash_profile</p><h3 id="3-C-x2F-C-环境配置"><a href="#3-C-x2F-C-环境配置" class="headerlink" title="3.C/C++环境配置"></a>3.C/C++环境配置</h3><p><a href="https://blog.csdn.net/zcteo/article/details/117528089">https://blog.csdn.net/zcteo/article/details/117528089</a></p><h3 id="4-python环境配置"><a href="#4-python环境配置" class="headerlink" title="4.python环境配置"></a>4.python环境配置</h3><p><strong>4.1python解释器安装</strong>：使用源码编译安装时需要提前安装底层依赖<br><strong>4.2IDE安装</strong>：pycharm or visual studio code</p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（三）</title>
      <link href="/2023/06/23/c-yu-yan-xue-xi-bi-ji-san/"/>
      <url>/2023/06/23/c-yu-yan-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（三）"><a href="#C语言学习笔记（三）" class="headerlink" title="C语言学习笔记（三）"></a>C语言学习笔记（三）</h1><h2 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h2><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p><strong>1.1定义</strong>：在源代码<strong>编译前</strong>对其进行一些<strong>文本性质</strong>操作<br><strong>①</strong>删除注释<br><strong>②</strong>插入<code>#include</code>指令包含的文件的内容<br><strong>③</strong>定义和替换由<code>#define</code>指令定义的符号<br><strong>④</strong>确定代码部分内容是否根据一些<strong>条件编译</strong>指令进行编译<br><strong>1.2预定义符号</strong>：<strong>预处理器定义</strong>的符号，都有各自对应的含义<br><strong>①</strong><code>__FILE__</code>：进行编译的源文件名<br><strong>②</strong><code>__LINE__</code>：文件当前行的行号<br><strong>③</strong><code>__DATE__</code>：文件被编译的日期<br><strong>④</strong><code>__TIME__</code>：文件被编译的时间<br><strong>⑤</strong><code>__STDC__</code>：若编译器遵循ANSI C，返回1<br><strong>1.3#define</strong><br><strong>①普通替换</strong>：<code>#define name stuff</code></p><blockquote><p>每当<code>name</code>出现在这条命令之后，都会被替换为<code>stuff</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若stuff非常长，可以将其分为好几行，每行除了最后一行都要加上反斜杠\</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在使用该命令时，最好不要在末尾添加分号，而是在程序正文中添加，否则可能会多出一条空语句，在一些只能使用一条语句的地方会出错，如不使用代码块的if语句</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏的name全部大写，用于区分宏</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用宏定义类型，只需要修改宏的值就可改变类型</div><p><strong>②带参数的宏</strong>：<code>#define name(parameter-list) stuff</code></p><blockquote><p><code>parameter-list</code>为参数列表，参数之间用逗号<code>,</code>相隔，类似于函数的形参，<code>stuff</code>为包含<strong>参数列表中参数</strong>的表达式<br><strong>运用实例</strong>：如果定义了一个宏<code>#define SQUARE(x) ((x) * (x))</code>，在代码块中输入<code>SQUARE(a)</code>，在预处理阶段会被替换为<code>((5) * (5))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> #name会被预处理器处理为"name"，a##b会被预处理器处理为ab</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏本质上还是简单的替换操作，所以要避免其与正文中的其他操作符发生预料之外的作用，可以像上述一样采用()对每个参数和整体进行隔离</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 宏中可以出现其他宏定义的符号，但是不能出现递归</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 其中name和(parameter-list)之间不能有空格</div><p><strong>③带副作用的宏参数</strong></p><blockquote><p>当宏参数在宏定义中出现不止一次时，若宏参数具有副作用，可能会带来无法预料的后果，副作用指<strong>永久性的效果</strong>，如<code>x+1</code>和<code>x++</code>，后者会永久改变x的值<br>以下程序运行后结果<code>x = 6,y = 10,z = 9</code>，这是因为<code>z = MAX(x++,y++)</code>被替换为<code>z = ((x++)&gt;(y++)?(x++):(y++))</code>，其中<code>y++</code><strong>执行了两次</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#define MAX(a,b) ((a)&gt;(b)?(a):(b))x=5;y=8;z = MAX(x++,y++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了避免这种情况，可以将宏需要使用的数据存储到临时变量中</div><p><strong>④宏定义的移除</strong>：<code>#undef name</code><br><strong>⑤命令行控制宏</strong>：在命令行编译时<strong>添加编译选项</strong>对宏进行定义和修改</p><blockquote><p>如<code>cc -DARRAY_SIZE=100 prog.c</code>，则就是将<code>ARRAY_SIZE</code>修改为100<br>其他的选项还有<code>-Uname</code>（忽略宏<code>name</code>）以及<code>-Dname</code>（定义宏<code>name</code>）</p></blockquote><p><strong>⑥宏的利与弊</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏比较适用于频繁使用的小型简单代码，因为函数的调用和返回也需要开支</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏是与类型无关的，有些参数无法传递给函数，比如说传递参数的类型</div><blockquote><p>如<code>#define MALLOC(n,type) ((type*)malloc((n)*sizeof(type)))</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 宏会使得代码变得更长，因为宏的本质就是插入代码副本</div><p><strong>1.4条件编译</strong><br><strong>①定义</strong>：选择一部分代码在编译时是被<strong>正常编译</strong>还是被<strong>忽略</strong><br><strong>②格式</strong></p><pre class="line-numbers language-none"><code class="language-none">#if constant-expression  statement0#elif constant-expression  statement1#else  statement2#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>constant-expression</code>为常量表达式，常常为<strong>宏</strong>（和命令行控制宏一同使用），当其为<strong>非零值</strong>时，<code>statement</code>被<strong>正常编译</strong>，反之则被忽略<br><code>elif</code>、<code>else</code>子句出现的次数可以不限，只有当其前面<strong>所有常量表达式均为假</strong>时，且自身的常量表达式为真时，才被正常编译</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 记住要以#endif结束条件编译</div><p><strong>③定义判断</strong>：判断某个宏是否被定义</p><blockquote><p>若<code>symbol</code>被定义则为真<br><code>#if defined(symbol)</code><br><code>#ifdef symbol</code><br>若<code>symbol</code>没有被定义则为真<br><code>#if !defined(symbol)</code><br><code>#ifndef symbol</code></p></blockquote><p><strong>1.5#include</strong>：将对应文件内容写到该条指令<strong>对应位置</strong><br><strong>①格式</strong>：<code>#include &lt;filename&gt;</code>/<code>#include "filename"</code></p><blockquote><p>前者表示在<strong>编译器定义的标准位置</strong>寻找相关文件，后者表示在<strong>源文件所在目录</strong>寻找相关文件（如果没找到还是再去标准位置）</p></blockquote><p><strong>②嵌套包含</strong>：有些头文件中还会包含其他的头文件，可能会导致<strong>某些头文件被包含多次</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用条件编译避免这种情况</div><blockquote><p>如下，<code>_TOUWENJIAN_H</code>为这个头文件的代号，当头文件被第一次包含时，其被定义为1，第二次被包含时，通过条件编译，他的所有内容<strong>被忽略</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#ifndef _TOUWENJIAN_H#define _TOUWENJIAN_H 1    All the stuff that you want in the header file#endif <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 应该避免多重包含，因为上述做法只能忽略重复读入内容，该文件还是会被多次读取</div><p><strong>1.6命令行参数</strong>:C语言<code>main</code>函数有两个形参用于接收命令行参数<br><strong>①</strong><code>argc</code>：命令行参数的<strong>数目</strong><br><strong>②</strong><code>argv</code>：本质上是一个<strong>指向字符指针的指针</strong>，将命令行参数看作为一个<strong>字符指针数组(以空指针结尾)<strong>，该参数指向该数组的</strong>第一个参数</strong></p><blockquote><p><code>int main (int argc,char **argv)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 命令行第一个参数固定是程序的名称，不需要用户输入</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意命令行参数是字符数组，在C中，没有字符串</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_5.png" alt="命令行参数"></p><p><strong>1.7其他预处理指令</strong><br><strong>①</strong><code>#error</code>：允许生成<strong>错误信息</strong></p><blockquote><p><code>#error message</code>，其中<code>message</code>为错误提示信息</p></blockquote><p><strong>②</strong><code>#line</code>：定义下一行的<strong>行号</strong>，且可以修改<strong>文件名</strong></p><blockquote><p><code>#line number "strings"</code>，其中<code>number</code>为下一行行号，<code>"strings"</code>为文件名</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> "strings"为可选选项</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该命令会修改__LINE__和__FILE__</div><p><strong>③</strong><code>#progma</code>：用于支持<strong>因编译器而异</strong>的特性，如向一个函数插入<strong>内联的汇编代码</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 预处理器会忽略它不认识的#progma指令</div><h3 id="2-I-x2F-O函数"><a href="#2-I-x2F-O函数" class="headerlink" title="2.I/O函数"></a>2.I/O函数</h3><p><strong>2.1基本概念</strong><br><strong>①流</strong>：C语言的I/O操作就是从程序移进或移出字节，这个<strong>字节流</strong>称为流</p><blockquote><p><strong>文本流</strong>：零个或者多个字符，以<strong>换行符</strong>结束<br><strong>二进制流</strong>：完全根据<strong>程序编写它们的形式</strong>输入/出<br><strong>输出</strong>：由计算机<strong>向外部</strong>设备输出数据，如屏幕<br><strong>输入</strong>：由外部设备<strong>向计算机</strong>输入数据，如键盘<br>标准流：标准输入stdin，标准输出stdout和标准错误stderr<br>都是一个指向<code>FILE</code>结构的指针，通常标准输入设备为键盘，标准输出/错误设备为终端或者屏幕<br>FILE：一个数据结构，用于访问一个流</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 文本流的结束形式在不同的系统上可能不同，但是库函数会将标准形式（换行符）转化为对应的形式</div><p><strong>②缓冲区</strong>：字节流并不是直接从输入端到输出端，而是要经过一块称为缓冲区的<strong>内存区域</strong></p><blockquote><p><strong>输出缓冲区</strong>：在<strong>被写满</strong>的时候才会被<strong>写入（刷新）</strong>到设备或者文件中<br><strong>输入缓冲区</strong>：同理，输入缓冲区<strong>为空时</strong>才会从设备或文件中<strong>读取</strong>数据</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 上述的缓冲为完全缓冲，但是通常情况下，流的缓冲状态由编译器决定，通常是请求输入的同时刷新输出缓冲区</div><p>包含stdio.h头文件<br>2.2标准I/O常量<br>①EOF：提示到达了文件末尾，所选择的实际值比一个字符要多几位<br>②FOPEN_MAX：一个程序最多能打开文件的数量，至少是8（包括三个标准流）<br>③FILENAME_MAX：合法文件名的最大长度<br>2.3流的操控<br>①程序需要给每个处于活动状态的流分配一个FILE*指针变量<br>②调用fopen创建一个流，指定访问的文件/设备以及他们的访问方式，并初始化FILE结构</p><blockquote><p><code>FILE *fopen(char const *name,char const *mode);</code><br>两个参数都是字符串，name是希望打开的设备和文件的名字，mode提示流的操作模式以及它是文本流还是二进制流<br>文本：”r”只读”w”只写”a”添加<br>二进制：”rb”只读”wb”只写”ab”添加<br>读：访问文件必须已经存在<br>写：访问文件存在，则原来的内容就会被删除，若不存在，则会新创建一个<br>添加：类似于写，但是不会覆盖内容，而是在尾部写入新内容<br>时刻检查fopen的返回值<br>FILE *freopen(char const *filename,char const *mode,FILE *stream)<br>该函数试图关闭stream对应的流，并重新打开它<br>③调用fclose关闭对应流（防止与其关联的设备文件被访问），并释放FILE文件<br>int fclose(FILE *f);<br>关闭流之前刷新缓冲区，如果执行成功，则返回零值，否则返回EOF<br>检查任何可能失败的地方</p></blockquote><p>2.4I/O函数<br>依据处理数据的类型将其分为单个字符、文本行和二进制数据三种<br>①处理字符</p><blockquote><p>int getchar(void)：从标准输入读取，每次从流中读取下一个字符，如果不存在更多的字符，则返回EOF<br>int getc(FILE *stream)：<br>int fgetc(FILE *stream)：<br>这些函数的返回值都是int，因为EOF是一个整型<br>int putchar(int character)：输入到标准输出中，在打印前，将整型参数裁剪为一个无符号字符型<br>int putc(int character,FILE *stream)：<br>int fputc(int character,FILE *stream)：</p></blockquote><p>其中fgetc和fputc是函数，其余是宏</p><p>int ungetc(int character,FILE *stream)：将一个字符返回到流中，这样它可以被重新读入<br>注意退回到流和写入到流是不同的，前者类似于压栈，后者类似于队列的增长<br>如果流被改变，则退回的字符会被丢弃</p><p>②处理文本行</p><blockquote><p>char *fgets(char *buffer,int buff_size,FILE *stream)：从stream流中读取字符并将他们复制到buffer中，当读取到一个换行符或者字符数达到buffer_size-1个时就停止读取，并在缓冲区结尾添加一个nul字节<br>若没有读取到字符，就返回NULL，否则返回buffer对应的指针<br>int fputs(char const *buffer,FILE *stream)，传递给fputs的缓冲区必须包含一个字符串，并将该字符串写入流中，如果写入时发生了错误，则返回EOF</p></blockquote><p>char *gets(char *buffer)<br>int puts(char const *buffer)<br>两者功能与上述两个函数类似，流是标准输入/出，但是gets不会存储换行符，puts在写入一个字符串时，会再输出一个换行符<br>gets函数没有缓冲区长度，所以很可能导致缓冲区溢出</p><p>③二进制数据</p><blockquote><p>fread/fwrite：处理二进制数据的输入/出</p></blockquote><h3 id="3-标准函数库"><a href="#3-标准函数库" class="headerlink" title="3.标准函数库"></a>3.标准函数库</h3><p><strong>3.1整型函数</strong><br><strong>①算数</strong></p><blockquote><p><code>int abs(int value)</code>：返回<strong>绝对值</strong><br><code>div_t div(int x,int y)</code>：将第二个参数除以第一个参数，产生<strong>商</strong>和<strong>余数</strong>，其中商是<strong>最靠近精确解</strong>的整数，其中<code>div_t</code>是一个结构，其中<code>quot</code>是商。<code>rem</code>是余数</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 都有对应的处理长整型的版本</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> /操作符的除法运算结果并未精确定义，当其操作数任一为负数且不能整除时，商和精确解的舍入关系取决于编译器</div><p><strong>②随机数</strong></p><blockquote><p><code>int rand (void)</code>：返回一个0至RAND_MAX区间内的<strong>伪随机数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了得到特定范围的伪随机数，可以对其进行取模并添加偏移量</div><blockquote><p><code>void srand(unsigned int seed)</code>：利用<code>seed</code>对<code>rand</code>进行初始化</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> seed常常采用每天的时间，即srand((unsigned int)time(0))</div><p><strong>③字符串转化</strong></p><p><strong>3.2浮点型函数</strong><br><strong>①算数</strong><br><code>double sqrt(double x)</code>：取平方根<br><code>double exp(double x)</code>：返回以e的x次幂<br><code>double floor(double x)</code>：返回不大于参数的最大整数<br><code>double ceil(double x)</code>：返回不小于参数的最小整数<br><code>double fabs(double x)</code>：返回参数的绝对值<br><code>double fmod(double x,double y)</code>：返回x除以y的余数</p><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 参数需要在定义域内，结果需要在double所能表示的范围内</div><p><strong>②三角函数</strong>：<code>sin</code>、<code>cos</code>、<code>tan</code>、<code>asin</code>、<code>acos</code>、<code>atan</code></p><blockquote><p><code>double sin(double angle)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> sin、cos、tan的参数是弧度，asin、acos、atan的参数范围从-1至1</div><p><strong>③对数和指数函数</strong></p><blockquote><p><code>double exp(double x)</code>：e的x次幂<br><code>double pow(double x,double y)</code>：x的y次幂，其中x不能是负数，y必须是整数<br><code>double log(double x)</code>：以e为底的对数<br><code>double log10(double x)</code>：以10为底的对数</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以采用换底公式计算任意底数的对数</div><p><strong>④浮点数表示</strong></p><blockquote><p><code>double frexp(double value,int *exponent)</code>：该函数返回<code>fraction</code>，并将<code>exponent</code>存储到第二个参数指定位置，其中<code>fraction*2^exponent = value</code><br><code>double ldexp(double fraction,int exponent)</code>：配合以上函数，还原该浮点数</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 用于浮点格式不兼容的机器之间传递浮点数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 要记得包含math.h头文件，绝大部分参数和返回值都是double类型</div><p><strong>3.3时间与日期函数</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含time.h头文件</div><p><strong>①处理器时间</strong></p><blockquote><p><code>clock_t clock(void)</code>：返回从<strong>程序开始</strong>起处理器消耗的时间<br><code>clock_t</code>由编译器定义，通常是处理器时钟滴答的次数，可以将其除以<code>CLOCKS_PER_SEC</code>转化为秒</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果想要精确的执行时间，可以在程序（某段语句）开始处与结尾处，各放置一个clock()，将结果相减</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若操作系统不能追踪处理器时间，则返回已经流逝的实际时间数量</div><p><strong>②当天时间</strong></p><blockquote><p><code>time_t time(time_t *returned_value)</code>：返回当前的时期和时间，并存储到参数指向位置，当机器无法提供时间或者时间值太大，就返回-1</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的编译器有不同的格式，常见的形式是从某一特定时间开始流逝的秒数，在UNIX中，这个时间为1970年1月1日零点</div><p><strong>③日期和时间的转换</strong></p><blockquote><p><code>double difftime(time_t time1,time_t time2)</code>：计算<code>time1-time2</code>，并将其转化为秒</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不要直接调用两次time函数并相减</div><p><code>struct tm *gmtime(time_t const *time_value)</code>：将时间转换为<strong>世界协调时间</strong><br><code>struct tm *localtime(time_t const *time_value)</code>：将时间转换为<strong>当地时间</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> tm结构包含了很多与时间有关的成员</div><blockquote><p><code>char *ctime(time_t const *time_value)</code>：接收一个<code>time_t</code>的指针，返回一个对应时间的字符串<br><code>char *asctime(struct tm const *tm_ptr)</code>：将<code>tm</code>结构转化为与<code>ctime</code>结果一样的字符串</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 字符串格式是固定的，编译器通常将其保存在一个静态数组中，如果想要特定格式的字符串，可以调用strftime()</div><p><strong>3.4非本地跳转</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含setjmp.h头文件</div><p><strong>①含义</strong>：类似于<code>goto</code>语句，但是<strong>不局限于一个函数的作用域</strong>之内<br><strong>②相关函数</strong></p><blockquote><p><code>int setjmp(jmp_buf state)</code>：初始化一个<code>jmp_buf</code>变量，并将程序的状态信息保存到<strong>跳转缓冲区</strong>，调用<code>setjmp</code>的函数便称为<strong>顶层函数</strong><br><code>void longjmp(jump_buf state,int value)</code>：使得跳转缓冲区的状态被恢复，从而立即跳转到<strong>顶层函数</strong></p></blockquote><p><strong>3.5信号</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含signal.h头文件</div><p><strong>①含义</strong>：信号表示一种<strong>非程序本身</strong>引发的事件<br><strong>②标准定义的信号</strong></p><blockquote><p><code>SIGABRT</code>：程序请求异常终止，由<code>abort</code>函数引发，常见的错误是<strong>算数溢出</strong>以及<strong>除零错误</strong><br><code>SIGFPE</code>：发生一个算数错误<br><code>SIGILL</code>：检测到非法指令，比如<strong>指令版本不同</strong><br><code>SIGSEGV</code>：检测到对内存的非法访问，比如访问<strong>未分配给该程序的内存</strong>，或者出现<strong>边界对齐错误</strong><br><code>SIGINT</code>：受到一个交互性注意信号<br><code>SIGTERM</code>：受到一个终止程序的请求</p></blockquote><p><strong>③信号处理</strong></p><blockquote><p><code>int raise(int sig)</code>：显示地引发一个信号<br><code>void (*signal(int sig,void(*handler)(int))) (int)</code>：指定程序对信号的反应，简化后的原型为<code>void(*signal()) (int)</code>，则<code>signal</code>是一个返回类型为函数指针（对应信号以前的处理函数）的函数，其所接受参数<code>sig</code>为标准定义的信号，<code>handler</code>为希望信号发生时调用的函数，当函数调用失败时，返回<code>SIG_ERR</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还可以将signal函数第二个参数替换为SIG_DFL，恢复对该信号的缺省反应；或者替换为SIG_IGN，使该信号被忽略</div><p><strong>3.6执行环境</strong><br><strong>①终止程序</strong></p><blockquote><p><code>void abort(void)</code>：引发<code>SIGABRT</code>信号，若没有在程序中为其设置信号处理函数，则程序终止<br><code>void atexit(void(func)(void))</code>：把一些函数注册为<strong>退出函数</strong>，当程序<strong>正常终止（调用<code>exit()</code>函数）</strong>，退出函数将被调用</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意该退出函数的格式</div><blockquote><p><code>void exit(int status)</code>：当该函数被调用时，所有被<code>atexit()</code>注册的函数将按照他们注册的顺序被<strong>反序</strong>调用，随后刷新所有缓冲区，关闭所有文件，并删除所有临时文件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> main函数return语句相当将返回值传递给exit()并调用它</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 由atexit()注册的函数中不能包含exit()，其结果是未定义的</div><p><strong>②断言</strong></p><blockquote><p><code>void assert(int expression)</code>：当<code>expression</code>为假时，向<strong>标准错误</strong>打印一条诊断信息并<strong>终止程序</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上是一个宏，其诊断信息的格式由编译器定义</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过定义NDEBUG宏消除所有断言，可以将其定义为任意值</div><p><strong>③环境与系统</strong></p><blockquote><p><code>char *getenv(char const *name)</code>：在<strong>环境</strong>中查找一个特定的名字，如果找到则返回一个<strong>不能修改</strong>的字符指针，否则返回<code>NULL</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 环境：一个由编译器定义的名字/值对的列表</div><blockquote><p><code>void system(char const *command)</code>：将字符串传递给<strong>操作系统</strong>，将其作为一条命令，由<strong>系统的命令处理器</strong>运行</p></blockquote><p><strong>④排序与查找</strong></p><blockquote><p><code>qsort()</code>：以<strong>升序</strong>的方式对数组进行排序，与<strong>类型无关</strong>，其函数原型如下<br><code>void qsort(void *base,size_t n_elements,size_t el_size,int(*compare)(void const *,void const *))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中第一个参数指向需要排序的数组，第二个参数指定数组中元素的数目，第三个参数指定每个元素的长度，第四个参数时一个用于比较的函数指针</div><blockquote><p><code>bsearch()</code>：在一个已经<strong>排好序</strong>的数组中用<strong>二分法</strong>查找一个特定的元素，其函数原型如下<br><code>void *bsearch(void const *key,void const *base,size_t n_elements,size_t el_size,int(*compare)(void const *,void const *))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中第一个参数时需要查找的值，第二个参数指向查找的数组，第三个参数指定数组的数目，第四个参数是每个元素的长度，最后一个参数是用于比较的函数指针</div><p><strong>3.7本地化</strong><br><strong>①</strong><code>locale</code>：一组特定的参数，每个国家和地区都不同<br><strong>②设置</strong><code>locale</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客搭建</title>
      <link href="/2023/06/23/hexo-bo-ke-kuang-jia-da-jian-yi-ji-ge-xing-hua/"/>
      <url>/2023/06/23/hexo-bo-ke-kuang-jia-da-jian-yi-ji-ge-xing-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo个人博客搭建"><a href="#Hexo个人博客搭建" class="headerlink" title="Hexo个人博客搭建"></a>Hexo个人博客搭建</h1><h2 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h3><p><strong>1.1Node.js安装：</strong>详细过程略，记得在命令行中输入<code>node -v</code>检查<code>Node.js</code>是否在环境变量中，倘若不在，则手动将<code>Node.js</code>的<strong>安装路径</strong>添加到环境变量中，<strong>右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</strong>，在系统变量下找到名为<code>path</code>的变量名，选中<code>path</code>，或者双击，然后将你<code>node.js</code>的<strong>安装路径</strong>放在 <code>path</code>变量值的最后面，如果添加之前<code>path</code>值最后有<strong>英文的分号</strong>，则直接将路径添加进去即可，如果没有，先添加分号，然后点击保存。<br><strong>1.2npm包管理器设置：</strong><br>①设置npm的镜像源</p><pre class="line-numbers language-none"><code class="language-none"># 查看npm的配置npm config list# 默认源npm config set registry https://registry.npmjs.org# 临时改变镜像源npm --registry=https://registry.npm.taobao.org# 永久设置为淘宝镜像源npm config set registry https://registry.npm.taobao.org# 另一种方式，编辑 ~/.npmrc 加入下面内容registry = https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②设置npm的内置路径（可选）<br><a href="https://blog.csdn.net/jianleking/article/details/79130667">https://blog.csdn.net/jianleking/article/details/79130667</a><br><strong>1.3git安装：</strong>详细过程略，同理检查其是否在环境变量中</p><h3 id="2-GitHub设置"><a href="#2-GitHub设置" class="headerlink" title="2.GitHub设置"></a>2.GitHub设置</h3><p><strong>2.1创建仓库：</strong>名字必须是<code>&lt;用户名&gt;.github.io</code>，并勾选<code>Initialize this repository with a README</code><br><strong>2.2配置Git用户名和邮箱：</strong><br>①在<code>git bash</code>中输入如下命令</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name "此处填写你注册时的用户名"git config --global user.email "此处填写你注册时的邮箱"# 一般只要不报错，可以跳过下面寻找.gitconfig文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>②找到<code>.gitconfig</code>文件，文件存放位置在<code>C:/Users/[username]/.gitconfig</code>（未找到的话，请开启显示<strong>隐藏文件</strong>的功能），检查配置是否成功</p><h3 id="3-Hexo框架搭建"><a href="#3-Hexo框架搭建" class="headerlink" title="3.Hexo框架搭建"></a>3.Hexo框架搭建</h3><p><strong>3.1Hexo安装：</strong>选择一个位置存放博客，然后新建一个文件夹，先不要点进去，在<code>git bash</code>中输入如下命令</p><pre class="line-numbers language-none"><code class="language-none"># hexo框架的安装npm install -g hexo-cli# 等上一个命令完成后，在输入下面的命令hexo init &lt;新建文件夹的名称&gt;  #初始化文件夹cd &lt;新建文件夹的名称&gt;npm install  # 安装博客所需要的依赖文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2和GitHub建立连接</strong><br>①安装插件，在博客目录下的<code>git bash</code>中输入如下命令：<code>npm install hexo-deployer-git --save</code><br>②将本地目录与GitHub关联起来：<code>ssh-keygen -t rsa -C "你的邮箱地址"</code><br>③SSH密钥设置：在<code>C:/Users/[username]</code>目录下找到名为<code>.ssh</code>的文件夹，文件夹内会有两个文件，一个<code>id_rsa.pub</code>一个<code>id_rsa</code>，用文本编辑器打开<code>id_rsa.pub</code>，复制里面的的内容,然后打开Github，点击右上角的头像<code>Settings</code>选择<code>SSH and GPG keys</code>,点击<code>New SSH key</code>将之前复制的内容粘帖到<code>Key</code>的框中，上面的<code>Title</code>可以随意，点击<code>Add SSH key</code>完成添加，并在<code>git bash</code>中输入<code>ssh -T git@github.com</code>测试是否连接成功<br>④修改Hexo配置文件：打开<code>_config.yml</code>，滑到文件最底部，填入如下代码，并如下所示</p><pre class="line-numbers language-none"><code class="language-none">type: gitrepo: git@github.com:Github用户名/github用户名.github.io.git  //也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git            branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>⑤在浏览器中打开<code>https://&lt;用户名&gt;.github.io</code>，即可查看上传的网页</p><h2 id="博客个性化"><a href="#博客个性化" class="headerlink" title="博客个性化"></a>博客个性化</h2><h3 id="1-主题设置"><a href="#1-主题设置" class="headerlink" title="1.主题设置"></a>1.主题设置</h3><p><strong>1.1主题安装：</strong>在博客目录下执行下面的命令，即可进行主题的下载，这里选择的是<code>matery</code>主题，有两个版本，稳定版本和最新版本 (不定期更新优化)，自主选择版本</p><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/blinkfox/hexo-theme-matery themes/matery     # 稳定版git clone -b develop https://github.com/blinkfox/hexo-theme-matery themes/matery   #最新版(不定期进行优化更新)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>1.2修改博客主题：</strong>将博客配置文件中的<code>theme</code>值修改为你下载主题的<strong>文件夹名</strong>，其他<strong>博客配置文件修改</strong>可见官网（必要，修改博客配置文件后要运行执行 <code>hexo clean &amp;&amp; hexo g</code>，重新生成博客文件）<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><h3 id="2-自定义文件-x2F-插件配置"><a href="#2-自定义文件-x2F-插件配置" class="headerlink" title="2.自定义文件/插件配置"></a>2.自定义文件/插件配置</h3><p><strong>2.1代码高亮</strong><br>①下载：在博客文件夹下<code>git bash</code>中运行<code>npm i -S hexo-prism-plugin</code><br>②配置：修改Hexo根目录下<code>_config.yml</code>文件中<code>highlight.enable</code>的值为<code>false</code>，并新增<code>prism</code>插件相关的配置</p><pre class="line-numbers language-none"><code class="language-none">prism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.2搜索</strong><br>①下载：<code>npm install hexo-generator-search --save</code><br>②配置：在Hexo根目录下的<code>_config.yml</code>文件中，新增以下的配置项</p><pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.3中文链接转拼音</strong><br>①下载：<code>npm i hexo-permalink-pinyin --save</code><br>②配置:在Hexo根目录下的<code>_config.yml</code>文件中，新增以下的配置项</p><pre class="line-numbers language-none"><code class="language-none">permalink_pinyin:  enable: true  separator: '-' # default: '-'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.4文章字数统计插件</strong><br>①下载：<code>npm i --save hexo-wordcount</code><br>②配置：在Hexo根目录下的<code>_config.yml</code>文件中，新增以下的配置项</p><pre class="line-numbers language-none"><code class="language-none">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.5自定义标签设置</strong><br>①步骤<br>首先在主题目录下新建<code>scripts</code>目录，接着在此目录下新建<code>block.js</code>文件，填入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">hexo.extend.tag.register('wrong', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-danger"&gt;&lt;i class="fas fa-exclamation-triangle"&gt;&lt;/i&gt; ' + formattedContent + '&lt;/div&gt;';  }, {ends: true});    hexo.extend.tag.register('right', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-success"&gt;&lt;i class="fa fa-check-circle"&gt;&lt;/i&gt; ' + formattedContent + '&lt;/div&gt;';  }, {ends: true});    hexo.extend.tag.register('warning', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-warning"&gt;&lt;i class="fa fa-exclamation-circle"&gt;&lt;/i&gt; ' + formattedContent + '&lt;/div&gt;';  }, {ends: true});  hexo.extend.tag.register('list', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-list"&gt;&lt;i class="fas fa-list-ul"&gt;&lt;/i&gt; ' +'&lt;br&gt;'+formattedContent + '&lt;/div&gt;';  }, {ends: true});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后在<code>head.ejs</code>文件添加以下css样式：</p><pre class="line-numbers language-none"><code class="language-none">   &lt;style type="text/css"&gt;       .uk-alert {           margin-bottom: 5px;           padding: 5px;           background: #ebf7fd;           color: #2d7091;           border: 0px solid #ffffff;           border-radius: 4px;           text-shadow: 0 1px 0 #ffffff;       }       .uk-alert-success {           background: rgba(120, 199, 9, 0.1);           color: rgba(120, 199, 9);           border-left: 6px solid rgba(120, 199, 9);           font-weight: 600;       }       .uk-alert-warning {           background: #FFF8E9;           color: #FFB91F;           border-left: 6px solid #FFB91F;           font-weight: 600;       }       .uk-alert-danger {           background: #FFE6E6;           color: #FF7979;           border-left: 6px solid#FF7979;           font-weight: 600;       }       .uk-alert-list {           background: #ECF7FE;           color: #3CACF4;           border-left: 6px solid#3CACF4;           font-weight: 600;       }&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②解析：以warning部分作为例子</p><blockquote><p><code>block.js</code>文件最重要的参数主要有<code>warning</code>（决定了正文中的书写格式）、<code>div class</code>（决定了容器的名字，即彩色背景）和<code>i class</code>（决定了图标的样式）</p></blockquote><blockquote><p><code>head.ejs</code>文件中主要修改具体样式，详细可询问ChatGPT</p></blockquote><p>③示例<br>代码：</p><pre class="line-numbers language-none"><code class="language-none">{%wrong%}错误{%endwrong%}{%right%}正确{%endright%}{%warning%}警告{%endwarning%}{%list%}列表项1列表项2{%endlist%}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 错误</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 正确</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 警告</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 列表项1<br>列表项2</div><h3 id="3-主题配置文件修改"><a href="#3-主题配置文件修改" class="headerlink" title="3.主题配置文件修改"></a>3.主题配置文件修改</h3><p><strong>3.1修改页脚：</strong>主题文件的<code>/layout/_partial/footer.ejs</code>文件中，包括站点、使用的主题、访问量等<br><strong>3.2修改社交链接：</strong>在主题文件的<code>/layout/_partial/social-link.ejs</code>文件中，新增、修改你需要的社交链接地址<br><strong>3.3修改头像等图片：</strong>修改主题文件的<code>source/medias</code>文件中的图片文件<br><strong>3.4修改音乐播放器：</strong>在主题的<code>_config.yml</code>配置文件中激活music配置即可，详细如下所示</p><pre class="line-numbers language-none"><code class="language-none"># 是否在首页显示音乐music:  enable: true  title:            #非吸底模式有效    enable: true    show: 听听音乐  server: netease   #require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    #require song, playlist, album, search, artist  id: 503838841     #require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#配置文件中还可以修改部分配置信息</p><h2 id="博客书写"><a href="#博客书写" class="headerlink" title="博客书写"></a>博客书写</h2><h3 id="1-文章框架"><a href="#1-文章框架" class="headerlink" title="1.文章框架"></a>1.文章框架</h3><p><strong>1.1Front-matter</strong><br>在博客根文件夹下<code>scaffolds</code>文件夹下新增/修改<code>post.md</code>文件，即可修改默认样式，详细样式如下</p><pre class="line-numbers language-none"><code class="language-none">title: 文章名称seo_title: seo名称toc: true            # 是否生成目录indent: true         # 是否首行缩进comments: true       # 是否允许评论archive: true        # 是否显示在归档cover: false         # 是否显示封面mathjax: false       # 是否渲染公式pin: false           # 是否首页置顶top_meta: false      # 是否显示顶部信息bottom_meta: false   # 是否显示尾部信息sidebar: [toc]tag:  - 标签一  - 标签二categories: 分组keywords: 文章关键词date: 2021-13-13 00:00updated: 2021-13-13 00:00description: 文章摘要icons: [fas fa-fire red, fas fa-star green]references:  - title: 参考资料名称    url: https://参考资料地址headimg: https://文章头图thumbnail: https://右侧缩略图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.2标题：</strong><code>#</code>为一级标题，<code>##</code>为二级标题以此类推，最多六级，记住<code>#</code>和文字之间要有<strong>空格</strong></p><h3 id="2-正文修饰"><a href="#2-正文修饰" class="headerlink" title="2.正文修饰"></a>2.正文修饰</h3><p><strong>2.1加粗与倾斜</strong></p><pre class="line-numbers language-none"><code class="language-none">*[文本]* #倾斜**[文本]** #加粗***[文本]*** #加粗倾斜<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.2引用</strong><br>①格式：<code>&gt;</code>后添加<strong>空格</strong>和引用内容，不同的引用以及正文使用<strong>换行</strong>隔开<br>②实现效果：</p><blockquote><p>树1</p></blockquote><blockquote><p>树2</p></blockquote><p><strong>2.3超链接</strong><br>①格式：<code>[Link Text](link-address)</code><br>②实现效果：<a href="http://106.15.109.213/2020/07/25/markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/#6-%E5%BC%95%E7%94%A8%E6%AE%B5%E8%90%BD">参考文章</a><br><strong>2.4插入图片</strong><br>①单张图片</p><pre class="line-numbers language-none"><code class="language-none">#语法展示及示例！[Figure](URL www.xxx.com)#figure此处的文字有时作为图片标题显示，有时不显示，optional，可留空#URL处也可以不填写url，也可以选择上传本地图片，此时只需填写相对路径即可，#相对路径指的是在与此markdown文档同路径下的相对路径，可在此md文档同路径下新建img文件夹，#在此处填/img/xx.png 具体情况具体分析，或许在主题配置文件中亦有提及*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②多张图片布局组合排列</p><pre class="line-numbers language-none"><code class="language-none">{% gi total n1-n2-... %}  ![](url)  ![](url)  ![](url)  ![](url)  ![](url){% endgi %}#total为图片总的数量,n1为第一行的图片数量,n2为第二行的图片数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.5锚点：</strong>锚点与链接基本相同，区别在于锚点是在文章内部相互传送，但只能传送到n级标题的位置</p><pre class="line-numbers language-none"><code class="language-none">[显示内容](#标题)#注意此处/#代表的是‘标题’这一性质，而非标题的级别，因此不必加n个#来体现标题等级，会自动根据“标题”的内容匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2.6代码块：</strong>单行代码使用`包围，多行代码使用```包围</p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统（一）</title>
      <link href="/2023/06/23/shen-ru-li-jie-ji-suan-ji-xi-tong-yi/"/>
      <url>/2023/06/23/shen-ru-li-jie-ji-suan-ji-xi-tong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><h3 id="1-程序"><a href="#1-程序" class="headerlink" title="1.程序"></a>1.程序</h3><p><strong>1.1组成</strong><br>①位：计算机中的最小存储单元，信息量的最小单位，由0/1表示<br>②字：由八个位组成，计算机的最小寻址单位<br><strong>1.2编译过程</strong><br>①预处理阶段(.i)：根据程序中字符#开头的命令，修改C程序<br>②编译阶段(.s):将预处理后的文件翻译为汇编语言<br>③汇编阶段(.o):将.s文件翻译为机器语言指令，并将其打包为可重定位目标程序；生成的文件为包含指令编码的二进制文件<br>④链接阶段:将所有需要用到的.o文件链接到一起（比如主函数调用的函数对应的.o文件），形成可执行程序</p><h3 id="2-硬件"><a href="#2-硬件" class="headerlink" title="2.硬件"></a>2.硬件</h3><p><strong>2.1总线</strong>：贯穿整个系统的一个电子管道，携带字节信息并在各部件之间传递<br>#总线传递的信息长度通常为一个字，大部分机器的字长是4个字或8个字<br><strong>2.2I/O设备</strong>：系统与外界的联系通道，每个I/O设备通过<strong>控制器</strong>或<strong>适配器</strong>与I/O总线相连，控制器通常是设备或者系统电路板上的芯片组，适配器是一块插在主板插槽上的卡<br><strong>2.3主存</strong>：一个<strong>临时</strong>存储设备，用于存放程序和程序需要处理的数据，由一组<strong>动态随机存取存储器</strong>芯片组成，逻辑上是一个<strong>线性的字节数组</strong><br><strong>2.4处理器</strong>：执行存储在主存中指令的引擎，核心是<strong>程序计数器</strong>（PC），一个大小为一个字的存储设备，任何时刻都指向主存中某条指令的<strong>地址</strong>，此外还有一个寄存器和算术/逻辑单元</p><h3 id="3-高速缓存"><a href="#3-高速缓存" class="headerlink" title="3.高速缓存"></a>3.高速缓存</h3><p><strong>3.1背景</strong>：计算机工作时，需要大量的复制操作，而快速设备的造价远高于同类的低速设备，再加上处理器从<strong>自身寄存器</strong>读取数据的速度远远快于从主存中读取数据，所以在cpu中添加了L1,L2高速缓存存放处理器<strong>近期可能需要经常使用的数据</strong>,是一组<strong>静态随机访问存储器</strong><br><strong>3.2存储层次结构</strong>：如下图所示，在这个层次结构中，由上至下，设备的访问速度越来越慢，容量越来越大，每字节造价也越来越便宜，主要思想是<strong>上一层的存储器作为低一层存储器的高速缓存</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/CSAPP_1.png" alt="存储层次结构"></p><h3 id="4-操作系统"><a href="#4-操作系统" class="headerlink" title="4.操作系统"></a>4.操作系统</h3><p><strong>4.1基本功能</strong>：防止失控的应用程序滥用硬件资源，并提供<strong>简单一致</strong>的机制使应用程序能操作硬件<br><strong>4.2进程</strong><br>①定义：操作系统对<strong>正在运行</strong>的程序的一种抽象，在一个操作系统中可以运行多个进程，而每个进程都好像在独占硬件，实际上是<strong>并发运行</strong><br>②并发运行：一个处理器上的各个进程的指令是交替执行的，通过<strong>上下文切换</strong>完成<br>③上下文切换：上下文是<strong>一个进程运行所需的所有状态信息</strong>，上下文切换即<strong>保存</strong>当前进程的上下文，<strong>恢复</strong>新进程的上下文<br><strong>4.3线程</strong>：一个进程由多个线程组成，线程是进程的执行单元，每个线程运行在进程上下文中，并共享当前进程的代码和全局数据<br><strong>4.4虚拟内存</strong>：给每个进程提供其<strong>独占内存</strong>的假象，每个进程的<strong>看到的</strong>内存都是一样的，称为<strong>虚拟地址空间</strong>，详细如下图所示<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/CSAPP_2.png" alt="进程虚拟地址空间"><br>①程序数据和代码：对于<strong>所有</strong>进程来说，代码是从一<strong>固定位置</strong>开始的，紧接着是C<strong>全局变量</strong>对应的数据位置，代码和数据区是<strong>按照可执行文件初始化</strong>的<br>②运行时堆：运行时可动态扩展和收缩<br>③共享库：C标准库、数学库等<br>④栈：用于实现<strong>函数调用</strong>，每调用一个函数，栈会增加，每一个函数返回时，栈会减小<br>⑤内核虚拟内存：为<strong>内核</strong>保留的区域，只有内核能对其进行操作</p><h3 id="5-网络"><a href="#5-网络" class="headerlink" title="5.网络"></a>5.网络</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（二）</title>
      <link href="/2023/06/23/shu-ju-jie-gou-yu-suan-fa-er/"/>
      <url>/2023/06/23/shu-ju-jie-gou-yu-suan-fa-er/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法（一）"><a href="#数据结构与算法（一）" class="headerlink" title="数据结构与算法（一）"></a>数据结构与算法（一）</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1多项式的表示方法"><a href="#1-1多项式的表示方法" class="headerlink" title="1.1多项式的表示方法"></a>1.1多项式的表示方法</h4><p><strong>①采用数组表示</strong>：数组存储的内容为多项式各项系数，数组元素的<strong>下标</strong>为其对应x的指数<br><strong>②采用结构数组表示</strong>：结构中包含两个量，为每一项的系数与指数<br><strong>③采用链表表示</strong>：同结构数组，但是用链表形式</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同一个问题可以有不同的表示方法</div><h4 id="1-2链表"><a href="#1-2链表" class="headerlink" title="1.2链表"></a>1.2链表</h4><p><strong>①组成</strong>：多个<strong>节点</strong>链接为链表，每个节点主要由两部分组成，即存储数据元素的<strong>数据域</strong>和存储指针的<strong>指针域</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个链表都有一个头指针，头节点的数据域通常存放链表的整体信息（如长度等），创建一个链表只需要创建其头指针即可</div><p><strong>②分类</strong></p><blockquote><p><strong>单链表</strong>：每个结点只包含<strong>一个指针域</strong>，指针域存放<strong>指向下一个结点</strong>的指针，最后一个结点指针域为<strong>空指针</strong><br><strong>循环链表</strong>：终端结点的指针域指向头结点，且头结点和终端结点都有对应<strong>头指针</strong>和<strong>尾指针</strong>指向<br><strong>双向链表</strong>：结点比单链表多一个指针域，用于指向其<strong>前驱结点</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 遍历链表时，新建一个指针变量保存前一个节点的地址</div><h3 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表"></a>2.线性表</h3><h4 id="2-1线性表的抽象"><a href="#2-1线性表的抽象" class="headerlink" title="2.1线性表的抽象"></a>2.1线性表的抽象</h4><p><strong>①定义</strong>：<strong>零个或多个</strong>数据元素的<strong>有限序列</strong>，每个元素只有一个直接前驱元素，一个直接后继元素</p><blockquote><p><strong>广义表</strong>：线性表的推广，即线性表的元素不仅仅可以是单元素，也可以是一个<strong>线性表</strong>，可以采用<code>union</code>实现</p></blockquote><p><strong>②操作集</strong>：初始化、判断线性表是否已空/满、查找、插入删除等</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 任何复杂操作，都可以转化为基本操作的组合</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 每个操作都要考虑不合理情况并抛出异常</div><h4 id="2-2线性表的数组实现"><a href="#2-2线性表的数组实现" class="headerlink" title="2.2线性表的数组实现"></a>2.2线性表的数组实现</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 适用于频繁查找，很少进行插入和删除的场景，但是有个数上限</div><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">#define MAXSIZE 30typedef int ElemType; //如果要修改线性表的数据类型，直接修改这里即可typedef struct{  ElemType data[MAXSIZE];  int length; //线性表目前的长度}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>查找</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#define OK 1#define ERROR 0typedef int Status;Status  GetElem(SqList L,int i,ElemType *e){  if(L.length==0||i&lt;1||i&gt;L.length) //首先进行异常判断    return ERROR;  *e = L.data[i-1];  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 查找时，需要判断查找的位置是否合理</div><blockquote><p><strong>插入</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status ListInsert(SqList *L,int i,ElemType e) //注意这里传入的是结构的指针，因为要改变结构{  //首先进行异常检查  int k;  if(L-&gt;lenth==MAXSIZE)    return ERROR;  if(i&lt;1||i&gt;L-&gt;lenth+1) //注意i的含义对代码的影响    return ERROR;  //考虑插入位置对操作的影响  if(i&lt;=L-&gt;length)  {    for(k=L-&gt;length;k&gt;=i-1;k--) //后移元素      L-&gt;data[k+1]=L-&gt;data[k];  }  L-&gt;data[i-1]=e;  L-&gt;length++; //注意操作带来的额外影响    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>删除</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status ListDelete(SqList *L,int i){  int k;  //异常检查  if(L-&gt;length==0)    return ERROR;  if(i&lt;1||i&gt;L-&gt;length)    return ERROR;  //当删除位置不在线性表末尾时  if(i&lt;L-&gt;length)  {    for(k=i-1,k&lt;L-length,k++)      L-&gt;data[k]=L-&gt;data[k+1];  }  L-&gt;length--; //函数操作带来的额外影响  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当要对参数进行修改时，需要使用传址</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 这是用数组实现的，所以需要将对应位置的元素都向后移，从后向前迭代</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 异常排查：首先判断是否能插入（是否已满），随后判断插入位置是否合理，先判断能不能，在判断合不合理</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 还要考虑操作带来的副作用</div><h4 id="2-3线性表的单链表实现"><a href="#2-3线性表的单链表实现" class="headerlink" title="2.3线性表的单链表实现"></a>2.3线性表的单链表实现</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 适用于元素个数变化较大的场景，且无个数上限</div><p><strong>①结构代码</strong>：每个链表最重要的就是<strong>节点的构成</strong>和<strong>头指针</strong>，所以链表只需要用<strong>头结点/头结点的结构指针</strong>表示即可</p><pre class="line-numbers language-none"><code class="language-none">//单链表节点结构typedef struct Node{  ElemType data;  struct Node *next;}Node;typedef struct Node *LinkList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>创建</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于链表是一种动态结构，所以创建链表只需要创建其头指针即可</div><blockquote><p><strong>查找</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status GetElem(LinkList L,int i,ElemType *e) //传入L为链表的头节点的指针{  int j;  LinkList p;  p=L-&gt;next; //使p指向链表的第一个节点  j = 1;  //其中p作为判别条件是防止其超过链表范围，因为当p为空指针时，说明已经到达最后一个节点了  while(p &amp;&amp; j&lt;i)   {    p = p-&gt;next;    ++j;  }  if(!p || j&gt;i) //当p为空指针或者i小于1时，第i个元素不存在    return ERROR;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通过头指针以及链表指针域的关系遍历链表</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 同上，需要判断查找的元素位置是否合理</div><blockquote><p><strong>插入</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/*在已存在链表的第i个位置插入元素eStatus ListInsert(LinkList *L,int i,ElemType *e){  int j;  LinkList p,s;  p = *L;  j = 1；  while(p &amp;&amp; j&lt;i ) /*寻找第i个结点,循环结束时j = i-1；  {    p = p-&gt;next;    ++j;  }  if (!p || j&gt;i) /*当i为0或者第i个结点不存在时    return ERROR；  s = (LinkList)malloc(sizeof(Node));  s-&gt;data = e;  /*注意结点断开和相连的顺序  s-&gt;next = p-&gt;next;/*先将新节点添加进链表  p-&gt;next = s;/*再将旧链接断开并添加新链接}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意节点插入时，先将新节点插入，再将旧的链接断开</div><blockquote><p><strong>删除</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status LinkDelete(LinkList *L,int i,ElemType *e){  int j;  LinkList p,q;  p = *L;  j = 1;  while(p-&gt;next &amp;&amp; j&lt;i)  {    p = p-&gt;next;    ++j;  }  if (!p || j&gt;i) /*当i为0或者第i个结点不存在时    return ERROR；  q = p-&gt;next;  p-&gt;next = q-&gt;next;  *e = q-&gt;data;  free(q); /*记得要释放对应的空间  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>销毁</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status LinkClear(LinkList *L){  LinkList p,q;  p = (*L)-&gt;next;  while (p)  {    q = p-&gt;next;    free(p)    p=q  }  (*L)-&gt;next = NULL;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 链表节点内存通常都是通过动态分配获得，所以要记得释放</div><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><h4 id="3-1栈的抽象"><a href="#3-1栈的抽象" class="headerlink" title="3.1栈的抽象"></a>3.1栈的抽象</h4><p><strong>①定义</strong>：受到一定约束的线性表，只能在<strong>一端</strong>插入和弹出数据，<strong>后入先出</strong><br><strong>②操作集</strong>：初始化、判断是否已满（空）、压入元素、弹出元素、清空、销毁等</p><h4 id="3-2栈的一维数组实现"><a href="#3-2栈的一维数组实现" class="headerlink" title="3.2栈的一维数组实现"></a>3.2栈的一维数组实现</h4><p><strong>①结构代码</strong>：由一个记录元素的一维数组和一个记录<strong>栈顶元素位置</strong>的变量组成</p><pre class="line-numbers language-none"><code class="language-none">#define MaxSizetypedef struct SNode* Stackstruct SNode{  ElementType Data[MaxSize];  int Top = -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>压入元素</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">void Push(Stack PtrS,ElementType item){  if (PtrS-&gt;Top==Maxsize-1)  {    printf("栈已满")；    return；  }  else  {    PtrS-&gt;Data[++(PtrS-&gt;Top)]==item;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>弹出元素</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType Pop(Stack PtrS){  if(PtrS-&gt;Top==-1)  {    printf("栈空")；    return ；  }  else  return(PtrS-&gt;Data[(PtrS-&gt;Top)--]); /*注意--符号是后缀}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③一个数组实现两个栈</strong>：一个栈从数组左边开始，另一个栈从数组右边开始，当两个栈的Top挨在一起时（<code>Top2=Top1+1</code>），栈已满</p><h4 id="3-3栈的单向链表实现"><a href="#3-3栈的单向链表实现" class="headerlink" title="3.3栈的单向链表实现"></a>3.3栈的单向链表实现</h4><p><strong>①结构代码</strong>:以链表的头节点作为Top</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若以链表尾部作为TOP，则每次还需要遍历链表才能找到TOP所在位置</div><pre class="line-numbers language-none"><code class="language-none">typedef struct SNode* Stackstruct SNode{  ElementType Data;  struct SNode* Next;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>压入元素</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">void Push(ElementType item,Stack S) {  struct SNode *TmpCell;  TmpCell=(struct SNode *)malloc(sizeof(struct SNode));  TmpCell-&gt;Element = item;  TmpCell-&gt;Next = S-&gt;Next;  S-&gt;Next = TmpCell;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>弹出元素</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType Pop(Stack S){  struct SNode *FirstCell;  ElementType TopElem;  if(IsEmpty(S))  {    printf("栈空")；    return NULL；  }  else  {    FirstCell = S-&gt;Next; /*指向头节点    S-&gt;Next = FirstCell = S-&gt;Next;    TopElem = FirtCell-&gt;Element;    free(FirstCell);    return TopElem;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4栈的应用——计算机中的表达式计算"><a href="#3-4栈的应用——计算机中的表达式计算" class="headerlink" title="3.4栈的应用——计算机中的表达式计算"></a>3.4栈的应用——计算机中的表达式计算</h4><p><strong>①中缀表达式转化为后缀表达式</strong>：从左到右读取中缀表达式的每个对象，不同对象按照不同的情况处理</p><blockquote><p>运算数：直接输出<br>左括号：压入栈<br>右括号：将栈顶的运算符号弹出并输出，直到遇到左括号（出栈，不输出）<br>运算符：<br>（1）当优先级大于栈顶运算符时，将他压栈<br>（2）当优先级小于等于栈顶运算符时，将栈顶运算符弹出并且输出，再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈<br>（3）当所有对象处理完成，将栈中存留的运算符一并输出</p></blockquote><p><strong>②后缀表达式的计算</strong>：<strong>从左向右</strong>读取后缀表达式，当遇到运算符号时，根据该运算符号和其<strong>前面最近的两个运算数</strong>得到新的运算数，更新后缀表达式</p><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><h4 id="4-1队列的抽象"><a href="#4-1队列的抽象" class="headerlink" title="4.1队列的抽象"></a>4.1队列的抽象</h4><p><strong>①定义</strong>：受到一定约束的线性表，只能在一端插入，在另一端删除，<strong>先进先出</strong><br><strong>②操作集</strong>：初始化、判断是否已满（空）、压入元素、弹出元素等</p><h4 id="4-2队列的数组实现"><a href="#4-2队列的数组实现" class="headerlink" title="4.2队列的数组实现"></a>4.2队列的数组实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">#define MaxSizestruct QNode{  ElementType Data [MaxSize]；  int rear = -1;   int front = -1;};typedef struct QNode *Queue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中，<code>rear</code>是指向队尾的“指针”，<code>front</code>是指向队头的“指针”，插入一个元素时，<code>rear</code>加一，删除一个元素时，<code>front</code>加一</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 山不转水转！</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当rear和front可以在超过MaxSize且列表未满时再次从0开始（使用%），即为环形队列，但是只能使用n-1个空间或者添加一个状态标签，用于区分满和空</div><p><strong>②操作集实现</strong></p><blockquote><p><strong>入队列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">void AddQ(Queue PtrQ,ElementType item){  if((PtrQ-&gt;rear+1)%MaxSize==PtrQ-&gt;front)  {    printf("队列已满")；    return ；  }  PtrQ-&gt;rear=(PtrQ-&gt;rear+1)%MaxSize;  PtrQ-&gt;Data[PtrQ-&gt;rear]=item;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>出队列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType DeleteQ(Queue PtrQ){  if(PtrQ-&gt;front==PtrQ-&gt;rear)  {    printf("队列空")；    return ERROR；  }  else  {    PtrQ-&gt;front=(PtrQ-&gt;front+1)%MaxSize;    return PtrQ-&gt;Data[PtrQ-&gt;front];  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3队列的链表实现"><a href="#4-3队列的链表实现" class="headerlink" title="4.3队列的链表实现"></a>4.3队列的链表实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">struct Node{  ElementType Data;  struct Node *Next;};struct QNode{  struct Node *rear; /*指向队尾  struct Node *front; /*指向队头，列表的头节点，出队的一端};typedef struct QNode *Queue;Queue PtrQ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>出队列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType DeleteQ(Queue PtrQ){  struct Node *FrontCell; /*作为中间变量保存要删除的节点  ElementType FrontElem;  if(PtrQ-&gt;front==NULL)  {    print("队列空")；    return ERROR；  }  FrontCell = PtrQ-&gt;front;  if(PtrQ-&gt;front == PtrQ-&gt;rear)    PtrQ-&gt;front=PtrQ-&gt;rear=NULL;  else    PtrQ-&gt;front=PtrQ-&gt;front-&gt;Next;  FrontElem = FrontCell-&gt;data;  free(FrontCell);  return FrontElem;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>入队列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status AddQ(Queue PtrQ,ElementType Elem){  struct Node *FrontCell; /*作为中间变量保存要删除的节点  FrontCell = (struct Node *)malloc(sizeof(Node));  if(!FrontCell)    exit(OVERFLOW);  FrontCell-&gt;Data = Elem;  PtrQ-&gt;rear-&gt;next = FrontCell;  PtrQ-&gt;rear = FrontCell;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（一）</title>
      <link href="/2023/06/23/python-xue-xi-bi-ji-yi/"/>
      <url>/2023/06/23/python-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（一）"><a href="#python学习笔记（一）" class="headerlink" title="python学习笔记（一）"></a>python学习笔记（一）</h1><h2 id="python启蒙"><a href="#python启蒙" class="headerlink" title="python启蒙"></a>python启蒙</h2><h3 id="1-基本元素"><a href="#1-基本元素" class="headerlink" title="1.基本元素"></a>1.基本元素</h3><p><strong>1.1表达式</strong>：python中最基本的执行结构，由“<strong>对象</strong>”和<strong>操作符</strong>组成，并返回<strong>一个对象</strong><br><strong>1.2对象</strong>：即被存储的数据，类似于C语言中的字面值，如<code>1</code>、<code>"cat"</code>、<code>1.23456e2</code>等<br>①当一个对象被声明后，会给其分配对应的ID（地址）和内存，且数据类型不能更改<br>②基本数据类型：整型（int）、浮点型（float）、字符串（strs）、布尔类型（bool）、复数类型（a+bj）</p><blockquote><p>可以使用<code>type()</code>检查数据类型</p></blockquote><p>③可变类型与不可变类型</p><blockquote><p>不可变类型是指对象一旦创建，内容就<strong>不能被更改</strong>，常见的不可变类型包括整数、浮点数、布尔值、字符串和元组等，其对应的变量只能被<strong>覆盖</strong></p></blockquote><blockquote><p>可变类型是指变量的值可以被更改，常见的可变类型包括列表、集合和字典等</p></blockquote><p><strong>1.3变量</strong><br>①取名规则</p><blockquote><p>只能是一个词<br>只能包含<strong>字母、数字和下划线</strong><br>不能以数字开头<br>不能使用<strong>关键词</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一个好的变量名包含了数据对应的信息，常见的命名格式有my_cat和MyCat</div><p>②变量的本质</p><blockquote><p>变量是对象的一个<strong>引用</strong>，本身也占用一定的内存（存储对象的地址）<br><strong>没有变量</strong>指向的<strong>对象</strong>会被<strong>回收</strong>（垃圾回收机制）<br>变量名代表的内存地址是<strong>变化的</strong>，是<strong>上次赋值时</strong>新数据所在的内存的地址，而C语言<strong>变量名所代表的地址是不变的</strong>，<strong>变化的是该地址内存单元的数据</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 所以说如果两个变量指向是同一个可变类型对象，改变其中一个，另一个也随之改变</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_7.png" alt="变量的本质"></p><p><strong>1.4操作符</strong><br>①数字操作符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_1.png" alt="数字操作符"></p><blockquote><p><code>+</code>可以用于<strong>拼接字符串</strong>，比如<code>'a'+'b'</code>结果是<code>'ab'</code><br><code>*</code>可以用于<strong>字符串复制</strong>，比如<code>'a'*5</code>结果时<code>'aaaaa'</code></p></blockquote><p>②比较操作符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_3.png" alt="比较操作符"></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意<br>整型和浮点型之间是可以使用==正常比较的，但是整型、浮点型和字符串使用==只能得到False<br>&gt;、&lt;、≥、≤只能用于整型和浮点型</div><p>③增强的赋值操作符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_4.png" alt="赋值操作符"><br>④布尔操作符：<code>and</code>、<code>or</code>、<code>not</code></p><blockquote><p><code>not</code>优先级最高，随后是<code>and</code>，最后是<code>or</code></p></blockquote><p><strong>1.5注释</strong><br>①单行注释：以<code>#</code>开头<br>②多行注释：用三个单引号/双引号包围<br><strong>1.6类型转换</strong><br>①自动类型转换</p><blockquote><p>将一种类型的数据<strong>赋值</strong>给另外一种类型的变量时，<strong>表达式右边</strong>的类型<strong>转换为左边</strong>变量的类型<br>在不同类型的<strong>混合运算</strong>中，将参与运算的所有数据先转换为<strong>同一种类型</strong>，然后再进行计算</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_2.png" alt="混合运算下的类型转换"><br>②强制类型转换</p><blockquote><p><code>str()</code>：转化为字符串类型<br><code>int()</code>：转化为整数类型<br><code>float()</code>：转化为浮点数类型</p></blockquote><h3 id="2-控制流"><a href="#2-控制流" class="headerlink" title="2.控制流"></a>2.控制流</h3><p><strong>2.1基本格式</strong><br>①语句关键词后面的<strong>冒号</strong>，以及python使用<strong>换行符</strong>而不是分号作为语句终止符<br>②python的代码块不用花括号划分范围，而是<strong>根据代码的缩进</strong></p><blockquote><p>缩进<strong>增加</strong>时，代码块<strong>开始</strong><br>代码块可以包含其他代码块,缩进减少为零，或减<strong>少为外面包围代码块的缩进，代码块就结束了</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常以四个空格为一个缩进，不要使用制表键</div><p><strong>2.2条件语句</strong></p><pre class="line-numbers language-none"><code class="language-none">if(条件): #条件为结果为布尔值的表达式  statementelif(条件):  statementelse:  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一旦一个语句的条件为Ture，后面的语句会被忽略，所以要注意语句的顺序，或者说清晰化条件的范围，使其之间没有交集</div><p><strong>2.3循环语句</strong><br>①<code>while</code>循环语句</p><pre class="line-numbers language-none"><code class="language-none">while(条件):  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>②<code>for</code>循环语句</p><pre class="line-numbers language-none"><code class="language-none">for 控制变量 in range():   statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>缺省情况下，控制变量被初始化为0<br>在Python中，下划线<code>_</code>通常用作一个无用的变量名称，常用做控制变量的名称</p></blockquote><p><strong>2.4range函数</strong><br>①<code>range(a)</code>：0至<strong>a-1</strong>，取不到a<br>②<code>range(a,b)</code>：a至<strong>b-1</strong>，步长为1<br>③<code>range(a,b,i)</code>：a至<strong>b-1</strong>,步长为i</p><blockquote><p>range()的返回值是类似于<strong>列表</strong>的值（但是不是列表），所以也可以将循环中的<code>range()</code>换为一个列表，在每次迭代中，让变量<strong>依次</strong>设置为<strong>列表中的值</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一个常见的Python技巧，是在for循环中使用range(len(someList))，迭代列表的每一个下标</div><p><strong>2.5循环控制语句</strong><br>①break：遇到<code>break</code>语句，马上退出循环<br>②continue：遇到<code>continue</code>语句，马上跳回到循环开始处，重新对循环条件求值</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以结合条件语句对循环进行控制</div><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><p><strong>3.1格式</strong></p><pre class="line-numbers language-none"><code class="language-none">def 函数名(变元n):  statement  return expression #可以是变量，也可以是表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>①变元即形参<br>②<code>None</code>是<strong>NoneType数据类型</strong>的唯一值，代表没有值，相当于C中的<code>void</code><br>③关键字参数：某些函数有可选的关键字参数，在函数调用时可以指定，相当于修改函数的<strong>默认设置</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果需要传递多个同一位置的关键字参数，可以采用 | 管道命令将这些参数连接</div><p>④函数的参数可以有<strong>默认值</strong>，也支持使用<strong>可变参数</strong>（类型、个数均可变），所以Python并<strong>不需要</strong>像其他语言一样支持<strong>函数的重载</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 未知个数参数可以使用args关键字实现</div><pre class="line-numbers language-none"><code class="language-none"># 在参数名前面的*表示args是一个可变参数def add(*args):    total = 0    for val in args:        total += val    return total# 在调用add函数时可以传入0个或多个参数print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2作用域</strong><br>①局部作用域：在被调用<strong>函数内赋值</strong>（注意，如果在函数内没有对其进进行赋值，则为全局变量）的变量，局部作用域在<strong>函数被调用</strong>时创建，在<strong>函数返回时</strong>销毁<br>②全局作用域：在所有<strong>函数之外</strong>赋值的变量，属于<strong>全局作用域</strong>，全局作用域在<strong>程序开始时</strong>创建，在<strong>程序终止时</strong>销毁<br>③嵌套作用域：当一个函数1内部有另一个函数2时，对于函数1内部的函数2来说，函数1中的变量属于函数2的嵌套作用域<br>④内置作用域：Python内置的那些<strong>标识符</strong></p><blockquote><p><strong>联系</strong><br>内置作用域→全局作用域→嵌套作用域→局部作用域，从左往右依次内推，内部的作用域可以访问外部作用域中的变量，但是外部作用域不能访问内部作用域的变量，局部作用域不能访问<strong>其他局部作用域</strong>的变量<br>如果在不同的作用域中，你可以用相同的名字命名不同的变量<br>可以使用<code>global</code>关键字修饰变量使其变为<strong>全局变量</strong><br>可以使用<code>nonlocal</code>关键字修饰变量使其变为<strong>嵌套作用域变量</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收</div><p><strong>3.3异常处理</strong>：捕捉<strong>函数内部某些语句</strong>的错误<br>①<code>try</code>语句：将可<strong>能出错的语句</strong>放在<code>try</code>之后，当这些语句出错后，会立马跳到<code>except</code>语句</p><pre class="line-numbers language-none"><code class="language-none">try:  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>②<code>except</code>语句：后面常接一些错误提醒的<code>print</code>语句</p><pre class="line-numbers language-none"><code class="language-none">except 错误名:  print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>③<code>finally</code>语句：<code>finally</code>块的代码不论程序正常还是异常<strong>都</strong>会执行到</p><blockquote><p>该语句不是必须的，通常用于执行一些必要的<strong>清理操作</strong>，如关闭文件、释放资源、关闭数据库连接等</p></blockquote><p><strong>3.4模块</strong><br>①导入模块：<code>import 模块名,模块名n</code><br>②调用模块中函数/方法：模块名.函数名/方法名</p><blockquote><p>模块类似于C++中的命名空间，可以<strong>防止命名冲突</strong>，同时也封装了代码</p></blockquote><p>③模块的测试：写完自定义的模块之后，都会写一个测试代码，<strong>直接运行</strong>该模块，检验一些模块中各个功能是否能够成功运行</p><pre class="line-numbers language-none"><code class="language-none">def c2f(cel):    fah = cel * 1.8 + 32    return fahdef f2c(fah):    cel = (fah - 32) / 1.8    return celdef test():    print("测试数据：0 摄氏度 = %.2f 华氏度" % c2f(0))    print("测试数据：0 华氏度 = %.2f 摄氏度" % f2c(0))if __name__ == '__main__':test()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中<code>if __name__ == '__main__':</code>的作用是检测当前模块是否被直接运行（作为主程序），还是被导入到其他模块中作为一个模块使用<br><code>__name__</code>为python中的一个<strong>内置变量</strong>，当程序直接被执行时，其<code>__name__</code>的值为<code>'__main__'</code>，而当导入到其他模块中时，其<code>__name__ </code>值为自己的模块名。</p></blockquote><p><strong>3.5常用函数（待合并）</strong><br>①print()：将括号内的<strong>字符串</strong>显示在屏幕上<br>#所以要输出其他类型变量时，需要使用<code>str()</code>将其<strong>转换为字符串类型</strong><br>#占位符语法：</p><ul><li><code>print('%d + %d = %d' % (a, b, a + b))</code>,其中<code>%d</code>是整数的占位符，<code>%f</code>是小数的占位符，<code>%%</code>表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成<code>%%</code>），字符串之后的<code>%</code>后面跟的变量值会替换掉占位符然后输出到终端中。</li><li><code>print('{0} * {1} = {2}'.format(a, b, a * b))</code>，其中<code>{0}</code>等都是占位符，<code>0</code>为format方法的<strong>索引</strong>，<strong>可省略，即按照默认顺序插入</strong>，还可以使用更多的格式选项，用于指定值的<strong>格式</strong>，还可以利用语法糖简化写法，即<code>print(f'{a} * {b} = {a * b}')</code></li></ul><p>②input()：等待用户输入文本，并按下<strong>回车键</strong>，将其转化为一个<strong>字符串</strong></p><h3 id="4-面向对象编程"><a href="#4-面向对象编程" class="headerlink" title="4.面向对象编程"></a>4.面向对象编程</h3><p><strong>4.1类的定义</strong></p><pre class="line-numbers language-none"><code class="language-none">class Student(object):    # __init__是一个特殊方法用于在创建对象时进行初始化操作    # 通过这个方法我们可以为学生对象绑定name和age两个属性    def __init__(self, name, age):        self.name = name        self.age = age    def study(self, course_name):        print('%s正在学习%s.' % (self.name, course_name))    # PEP 8要求标识符的名字用全小写多个单词用下划线连接    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)    def watch_movie(self):        if self.age &lt; 18:            print('%s只能观看《熊出没》.' % self.name)        else:            print('%s正在观看岛国爱情大电影.' % self.name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①在Python中可以使用<code>class</code>关键字定义类，其中<code>object</code>是所有类的基类，即<strong>顶级父类</strong>，这意味着在Python中定义的任何类都可以调用<code>object</code>类的方法（如<code>__init__</code>方法），并继承<code>object</code>类的特性<br>②类中的函数被称为<strong>方法</strong>，以描述对象的动态特征，其中方法的<strong>第一个参数</strong>通常被命名为<code>self</code>，Python会自动将对象绑定到第一个参数上<br>③<code>__init__</code>方法定义了类的<strong>属性</strong>，这些属性是描述类的关键</p><p><strong>4.2对象的创建与使用</strong></p><pre class="line-numbers language-none"><code class="language-none">def main():    # 创建学生对象并指定姓名和年龄    stu1 = Student('骆昊', 38)    # 给对象发study消息    stu1.study('Python程序设计')    # 给对象发watch_av消息    stu1.watch_movie()    stu2 = Student('王大锤', 15)    stu2.study('思想品德')    stu2.watch_movie()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①可以通过<code>对象.方法名/属性名</code>访问类的方法和属性</p><blockquote><p>对象的创建不使用<code>__init__</code>方法，而是使用<strong>类名</strong>创建，使用类名创建对象实际上是通过<strong>调用构造函数</strong>来创建对象</p></blockquote><p>②属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用<strong>两个下划线</strong>作为开头</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> python程序员遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重</div><p><strong>4.3property装饰器</strong></p><pre class="line-numbers language-none"><code class="language-none">class Person(object):    def __init__(self, name, age):        self._name = name        self._age = age    # 访问器 - getter方法    @property    def name(self):        return self._name    # 访问器 - getter方法    @property    def age(self):        return self._age    # 修改器 - setter方法    @age.setter    def age(self, age):        self._age = age    def play(self):        if self._age &lt;= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)def main():    person = Person('王大锤', 12)    person.play()    person.age = 22    person.play()    # person.name = '白元芳'  # AttributeError: can't set attributeif __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①<code>@property</code>:将一个<strong>方法</strong>转换为相应的<strong>属性</strong>，将<strong>方法的调用方式</strong>变为<strong>属性的访问方式</strong></p><blockquote><p>具体而言，<code>@property</code>装饰器定义了一个<code>getter</code>方法，用于获取属性的值,如果没有<code>@property</code>的话，<code>person.age</code>应为<code>person.age()</code></p></blockquote><p>②在定义了<strong>访问器</strong>后,可以使用<code>age.setter</code>等装饰器定义对应的<code>setter</code>方法，记住要有<strong>对应的前缀</strong>，且方法名需要一致（即<code>age</code>）<br><strong>4.4静态方法和类方法：</strong>当类中需要一些方法，但是不是基于具体对象实例的，如在<strong>创建对象前</strong>验证其是否合理的方法<br>①静态方法：使用<code>@staticmethod</code>修饰器定义，直接通过<code>类名.方法名()</code>调用</p><blockquote><p>静态方法属于<strong>类本身</strong>，所以在定义时不需要<code>self</code>参数</p></blockquote><pre class="line-numbers language-none"><code class="language-none">from math import sqrtclass Triangle(object):    def __init__(self, a, b, c):        self._a = a        self._b = b        self._c = c    @staticmethod    def is_valid(a, b, c):        return a + b &gt; c and b + c &gt; a and a + c &gt; bdef main():    a, b, c = 3, 4, 5    # 静态方法和类方法都是通过给类发消息来调用的    if Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)    else:        print('无法构成三角形.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②类方法：使用<code>@classmethod</code>修饰器定义类方法，直接通过<code>类名.方法名()</code>调用</p><blockquote><p>方法的第一个参数约定名为<code>cls</code>，类似于<code>self</code>，但是<code>cls</code>代表是对应的类，允许在类方法内部访问<strong>类级别</strong>的属性和方法</p></blockquote><pre class="line-numbers language-none"><code class="language-none">from time import time, localtime, sleepclass Clock(object):    """数字时钟"""    def __init__(self, hour=0, minute=0, second=0):        self._hour = hour        self._minute = minute        self._second = second    @classmethod    def now(cls):        ctime = localtime(time())        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)def main():    # 通过类方法创建对象并获取系统时间    clock = Clock.now()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.5继承和继承</strong>：</p><pre class="line-numbers language-none"><code class="language-none">class Person(object):    """人"""    def __init__(self, name, age):        self._name = name        self._age = age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age = age    def play(self):        print('%s正在愉快的玩耍.' % self._name)    def watch_av(self):        if self._age &gt;= 18:            print('%s正在观看爱情动作片.' % self._name)        else:            print('%s只能观看《熊出没》.' % self._name)class Student(Person):    """学生"""    def __init__(self, name, age, grade):        super().__init__(name, age)        self._grade = grade    @property    def grade(self):        return self._grade    @grade.setter    def grade(self, grade):        self._grade = grade    def study(self, course):        print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person):    """老师"""    def __init__(self, name, age, title):        super().__init__(name, age)        self._title = title    @property    def title(self):        return self._title    @title.setter    def title(self, title):        self._title = title    def teach(self, course):        print('%s%s正在讲%s.' % (self._name, self._title, course))def main():    stu = Student('王大锤', 15, '初三')    stu.study('数学')    stu.watch_av()    t = Teacher('骆昊', 38, '砖家')    t.teach('Python程序设计')    t.watch_av()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①继承：子类除了继承父类提供的属性和方法，还可以定义自己<strong>特有</strong>的属性和方法，所以子类比父类拥有的更多的能力<br>②多态：子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，不同的子类表现不同</p><blockquote><p>抽象类是一种专门让其他类继承的类，<strong>不能创建对应的对象</strong>，子类可以重写其中的<strong>抽象方法</strong>从而实现多态</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果</div><pre class="line-numbers language-none"><code class="language-none">from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta):    """宠物"""    def __init__(self, nickname):        self._nickname = nickname    @abstractmethod    def make_voice(self):        """发出声音"""        passclass Dog(Pet):    """狗"""    def make_voice(self):        print('%s: 汪汪汪...' % self._nickname)class Cat(Pet):    """猫"""    def make_voice(self):        print('%s: 喵...喵...' % self._nickname)def main():    pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')]    for pet in pets:        pet.make_voice()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-列表"><a href="#5-列表" class="headerlink" title="5.列表"></a>5.列表</h3><p><strong>5.1声明</strong>：<code>列表名 = [表项1,...,表项n]</code></p><blockquote><p>表项的数据类型<strong>可以不是一致的</strong>，也可以是<strong>列表</strong>，如果全部都是大小相同列表的话，类似于C语言中的<strong>多维数组</strong></p></blockquote><p><strong>5.2访问</strong><br>①<code>列表名[i]</code>:访问列表中<strong>第i-1表项</strong></p><blockquote><p>python中<strong>有</strong>对应的<strong>下标检查</strong><br>当i前面有<strong>负号</strong>时，代表<strong>倒数</strong>第i个<br>当列表某个表项是列表时，如果想要访问其中元素，需要再次使用下标，即<code>列表名[i][j]</code></p></blockquote><p>②<code>列表名[i:j:n]</code>：访问列表的一部分（第i个下标到第j个下标,n为步长，默认为1），结果还是一个列表</p><blockquote><p>省略<strong>第一个下标</strong>相当于使用 0，或列表的<strong>开始</strong><br>省略<strong>第二个下标</strong>相当于使用列表的长度，意味着分片直至列表的<strong>末尾</strong><br>当n为<strong>负数</strong>时，表示从第j个下标到第i个下标，即<strong>反向切片</strong></p></blockquote><p><strong>5.3常用操作</strong><br>①操作符</p><blockquote><p><code>+</code>操作符可以<strong>连接</strong>两个列表，得到一个新列表，就像它将两个字符串合并成一个新字符串一样<br><code>*</code>操作符可以用于一个列表和一个整数，实现列表的<strong>复制</strong><br><code>del</code>语句将删除列表中下标处的值，表中被删除值后面的所有值，都将<strong>向前移动一个下标</strong><br><code>del spam[2]</code><br><code>in</code>和<code>not in</code>:连接两个值,一个要在列表中<strong>查找的值</strong>，以及待查找的<strong>列表</strong>。这些表达式将求值为<strong>布尔值</strong></p></blockquote><p>②常用方法</p><blockquote><p>index()：传入一个值，如果该值存在于列表中，就返回它<strong>第一次</strong>出现的下标<br>append()：将参数添加到列表<strong>末尾</strong><br>insert()：以在列表<strong>任意下标处</strong>插入一个值<br>remove()：将对应值从被调用的列表中删除<br>sort()：对于<code>数值</code>或<code>字符串</code>的列表，基于“ASCII字符顺序”排序</p></blockquote><p><strong>5.4元组和集合</strong><br>①元组：几乎与列表数据类型一样，但是元组输入时用<strong>圆括号()<strong>，而不是用方括号，且也是</strong>不可变数据类型</strong></p><blockquote><p>如果元组中只有<strong>一个值</strong>，你可以在括号内该值的后面跟上一个<strong>逗号</strong>，否则就是一个值，而不是包含一个值的元组<br>元组在创建<strong>时间</strong>和占用的<strong>空间</strong>上面都优于列表</p></blockquote><p>②集合：<code>set1 = {1, 2, 3, 3, 3, 2}</code>，是<strong>无序</strong>的可变数据类型</p><blockquote><p>不允许有重复元素，而且可以进行交集、并集、差集等运算</p></blockquote><p>③转换</p><blockquote></blockquote><p><code>list()</code>：返回传递给它们的值的列表版本<br><code>tuple()</code>：返回传递给它们的值的元组版本<br><code>set()</code>：返回集合版本</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在将可变数据类型传递给函数时，又不希望函数改变其值，可以在函数内部拷贝一份对应的值，这就需要使用copy模块的copy()函数（直接赋值传递的还是引用）</div><h3 id="6-字典"><a href="#6-字典" class="headerlink" title="6.字典"></a>6.字典</h3><p><strong>6.1声明：</strong><code>字典名 = {键1:值1,...,键n:值n};</code></p><blockquote><p>字典的键相当于相当于列表的<strong>下标</strong>，但是列表的下标只能时整数，而字典的键可以是<strong>其他数据类型</strong>，比如说字符串<br>字典是<strong>无序</strong>的，只要键名和对应的值完全相同，两个字典就是完全相同的<br>字典的<strong>键</strong>不能重复</p></blockquote><p><strong>6.2常用操作：</strong><br>①访问：<code>字典名[键名]</code><br>②添加/修改键值对：<code>字典名[键名]=值</code><br>③删除键值对：<code>del 字典名[键名]</code><br>④判断是否存在：<code>键名 in 字典名</code></p><p><strong>6.3常用方法：</strong><br>①<code>keys()</code>:返回<code>dict_keys</code>，类似于字典的键的列表<br>②<code>values()</code>：返回<code>dict_values</code>，类似于字典的值的列表<br>③<code>items()</code>：返回<code>dict_items</code>，类似于字典的键-值对的列表</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 这些返回值不能改变，常用于for循环判定条件中如for v in spam.values()用于遍历字典</div><p>④<code>get()</code>：它有两个参数，要取得其值的<strong>键</strong>，以及如果该键不存在时，返回的<strong>备用值</strong><br>⑤<code>setdefault()</code>:为字典中某个键设置一个默认值，当该键没有任何值时使用它，传递给该方法的第一个参数，是要<strong>检查的键</strong>，第二个参数，是如果<strong>该键不存在时要设置的值</strong>，即<code>spam.setdefault('color', 'black')</code></p><pre class="line-numbers language-none"><code class="language-none">#计算一个字符串中每个字符出现的次数message = 'It was a bright cold day in April, and the clocks were striking thirteen.'count = {}#for循环语句，即将character依次设置为message列表中的值for character in message:  count.setdefault(character, 0)  count[character] = count[character] + 1print(count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><p><strong>7.1声明</strong><br>①以<strong>单引号</strong>开始和结束</p><blockquote><p>但是这样会导致字符串不能包含单引号，可以使用对应的<strong>转义字符</strong><code>\'</code></p></blockquote><p>②以<strong>双引号</strong>开始和结束</p><blockquote><p>同理，不能包含双引号，可以使用对应的转义字符<code>\"</code></p></blockquote><p>③以<strong>3个单引号或3个双引号</strong>开始和结束，“三重引号”之间的所有<strong>引号、制表符或换行</strong>，都被认为是字符串的一部分缩进规则在这种字符串中不适用<br>④原始字符串：在字符串开始的<strong>引号之前加上r</strong>，完全忽略所有的转义字符，打印出字符串中所有的<strong>倒斜杠</strong></p><blockquote><p>字符串是<strong>不可变类型</strong>，可以看作是<strong>单个文本字符的元组（空格也算）</strong>，<code>name = 'cat'</code>相当于<code>name = ('c','a','t')</code></p></blockquote><p><strong>7.2常用方法</strong></p><blockquote><p><code>islower()/islower()</code>:如果字符串至少有一个字母，并且所有字母<strong>都是</strong>大写/小写,就会相应地返回布尔值 True。否则，该方法返回 False。<br><code>isalpha()</code>：如果字符串只包含字母，并且非空，返回True<br><code>isalnum()</code>：如果字符串只包含字母和数字，并且非空，返回True<br><code>isdecimal()</code>：如果字符串只包含数字字符，并且非空，返回 True<br><code>isspace()</code>：如果字符串只包含空格、制表符和换行，并且非空,返回 True<br><code>istitle()</code>:如果字符串仅包含以大写字母开头、后面都是小写字母的单词,返回 True<br><code>startswith()/endswith()</code>:如果它们所调用的字符串以该方法传入的字符串开始或结束,返回 True</p></blockquote><blockquote><p><code>upper()/lower()</code>：将原字符串的所有字母都被相应地转换为大写/小写，非字母字符保持不变，返回一个<strong>新</strong>字符串，而不是将旧字符串修改<br>因为 upper()和 lower()字符串方法本身返回字符串，可以在返回的字符串上继续调用字符串方法,如<code>'Hello'.upper().lower()</code></p></blockquote><blockquote><p><code>join()</code>:在一个字符串上调用，参数是一个字符串列表，返回一个字符串,返回的字符串由传入的列表中每个字符串连接而成。<br> <code>' '.join(['My', 'name', 'is', 'Simon'])</code>,返回结果是’My name is Simon’</p></blockquote><blockquote><p><code>split()</code>：传入一个分割字符串，指定它按照不同的字符串分割<br><code>'MyABCnameABCisABCSimon'.split('ABC')返回值为['My', 'name', 'is', 'Simon']</code></p></blockquote><blockquote><p><code>rjust()/ljust()/center()</code>:该方法的第一个参数为<strong>填充后</strong>的字符串的长度，第二个参数为<strong>填充使用的字符</strong>，默认是空格，分别为<br><code>'Hello'.rjust(20, '*')'***************Hello'</code><br><code>'Hello'.center(20, '=')'=======Hello========'</code></p></blockquote><blockquote><p><code>strip()/lstrip()/rstrip()</code>:删除字符串左边、右边或两边的空白字符（空格、制表符和换行符）有一个可选的字符串参数，指定两边的哪些<strong>字符</strong>应该删除（注意，删除的不一定和参数完全符合，可能是他们的组合）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">spam = 'SpamSpamBaconSpamEggsSpamSpam'spam.strip('ampS')'BaconSpamEggs'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><code>pyperclip</code>模块有<code>copy()</code>和<code>paste()</code>函数，可以向计算机的剪贴板发送文本，或从它接收文本,如果你的程序之外的某个程序改变了剪贴板的内容，<code>paste()</code>函数就会返回它</p></blockquote><p>7.生成式和生成器语法<br><a href="https://www.cnblogs.com/yyds/p/6281453.html">https://www.cnblogs.com/yyds/p/6281453.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（一）</title>
      <link href="/2023/06/23/shu-ju-jie-gou-yu-suan-fa-yi/"/>
      <url>/2023/06/23/shu-ju-jie-gou-yu-suan-fa-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-数据结构与算法之禅"><a href="#1-数据结构与算法之禅" class="headerlink" title="1.数据结构与算法之禅"></a>1.数据结构与算法之禅</h3><p>①解决问题方法的效率和<font color="red"><strong>数据的组织方式</strong></font>有关</p><blockquote><p>例如自己的书架随便堆放vs图书馆的图书分类</p></blockquote><p>②解决问题方法的效率和<font color="red"><strong>空间利用率</strong></font>有关</p><blockquote><p>例如递归打印数vs循环打印数<br>递归函数调用过程中会发生<strong>中断</strong>，系统需要使用一定空间保存<strong>当前函数的状态</strong></p></blockquote><p>③解决问题方法的效率和<font color="red"><strong>算法的巧妙程度</strong></font>有关</p><blockquote><p>详细见实例</p></blockquote><h3 id="2基本概念"><a href="#2基本概念" class="headerlink" title="2基本概念"></a>2基本概念</h3><p><strong>2.1数据结构</strong>：数据对象在计算机中的<strong>组织方式</strong></p><blockquote><p>逻辑结构：<strong>对象之间</strong>的相互关系，如<strong>集合</strong>结构、<strong>线性</strong>结构、<strong>树形</strong>结构和<strong>图</strong>结构<br>物理存储结构：在<strong>计算机中的存储方式</strong>，如数组是<strong>连续存储</strong>，而链表是<strong>链式存储</strong>（地址不连续）</p></blockquote><p><strong>2.2算法</strong>：一个<strong>有限指令集</strong>，在接受一些输入后（也可能不接受输入），经过<strong>有限</strong>的步骤后，得到一定的输出，且能<strong>处理不合理输入</strong></p><blockquote><p>每条指令不能有歧义，且在计算机处理范围内，不依赖任何具体实现手段<br>算法在设计时需要对<strong>各种数据</strong>都有处理的方式</p></blockquote><p><strong>2.3空间复杂度</strong>：根据算法写成的程序在执行时<strong>占用存储单元的长度</strong><br><strong>2.4时间复杂度</strong>：根据算法写成的程序在执行时<strong>耗费的时长</strong><br><strong>2.5抽象</strong>：仅仅描述“是什么”，并不涉及“如何做到”</p><blockquote><p>抽象数据结构包含名称、定义和操作集<br>数据结构的复杂操作都是由<strong>简单操作构成</strong>的</p></blockquote><h3 id="3-复杂度表示与计算"><a href="#3-复杂度表示与计算" class="headerlink" title="3.复杂度表示与计算"></a>3.复杂度表示与计算</h3><p><strong>3.1复杂度表示</strong>：空间复杂度用<code>S(n)</code>表示,时间复杂度用<code>T(n)</code>表示，其中<code>n</code>为<strong>问题的规模</strong>，即需要处理的数据的个数<br><strong>3.2渐进复杂度（大O表示法）</strong>：<code>T(n)=O(f(n))</code>表示存在一个常数<code>C</code>，使得在当<code>n</code>趋于正无穷时总有<code>T(n) ≤ C*f(n)</code>，简单来说，<code>f(n)</code>就是<code>T(n)</code>中的最高次幂</p><blockquote><p>常见的时间复杂度有：<code>O(1)</code>常数型；<code>O(log n)</code>对数型，<code>O(n)</code>线性型，<code>O(nlog n)</code>线性对数型，<code>O(n^2)</code>平方型，<code>O(n^3)</code>立方型，<code>O(n^k)k</code>次方型，<code>O(2^n)</code>指数型。</p></blockquote><p><strong>3.3（时间）复杂度计算</strong>：先找出算法中的<strong>基本语句</strong>，若这些基本语句中只有加减法，则这些语句耗时记为1，若该基本语句中有乘除法，则这些语句耗时记为乘除法的次数，然后再根据算法结构计算整个算法的复杂度。</p><blockquote><p>实质上就是计算函数运行了<strong>多少次乘法</strong><br>对于<code>for</code>循环，时间复杂度等于循环次数乘以循环体代码的复杂度<br>对于<code>if-else</code>结构，时间复杂度取其中复杂度最大的分支</p></blockquote><h2 id="二、经典算法实例——最大子列和问题"><a href="#二、经典算法实例——最大子列和问题" class="headerlink" title="二、经典算法实例——最大子列和问题"></a>二、经典算法实例——最大子列和问题</h2><h3 id="1-题干"><a href="#1-题干" class="headerlink" title="1.题干"></a>1.题干</h3><blockquote><p>给定N个整数的序列，求出其中<strong>连续</strong>n个子列和的最大值，其中n≤N</p></blockquote><h3 id="2-暴力穷举法"><a href="#2-暴力穷举法" class="headerlink" title="2.暴力穷举法"></a>2.暴力穷举法</h3><p><strong>2.1基本思想</strong>：求出所有连续子列和，从中找出最大的子列和，复杂度为<code>O(n^3)</code><br><strong>2.2代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum1(int A[],int N){  int ThisSum,MaxSum = 0;  int i,j,k;  for (i=0;i&lt;=N;i++) #确定起点  {    for(j=i;j&lt;=N;j++) #确定终点    {      ThisSum=0;      for(k=i;k&lt;=j,k++) #将第i到第j个叠加到一起      {        ThisSum=ThisSum+A[k];      }      if(ThisSum&gt;MaxSum)      MaxSum=ThisSum;    }  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-改进的暴力穷举法"><a href="#3-改进的暴力穷举法" class="headerlink" title="3.改进的暴力穷举法"></a>3.改进的暴力穷举法</h3><p><strong>3.1思想</strong>:该算法基于上述算法进行了一些改进，计算子列和时是在<strong>已经计算完成</strong>的子列和加上最新项更新获得，可以省去k循环，复杂度为<code>O(n^2)</code><br><strong>3.2代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum2(int A[],int N){  int ThisSum,MaxSum = 0;  int i,j;  for (i=0;i&lt;=N;i++)/*i是子列左端*/  {    ThisSum=0;    for(j=i;j&lt;=N;j++)/*j是子列右端*/    {      ThisSum=ThisSum+A[j];/*对于相同的i和不同的j，只需要在j-1的基础上累加最新项即可*/      if(ThisSum&gt;MaxSum)      MaxSum=ThisSum;    }  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-分而治之"><a href="#4-分而治之" class="headerlink" title="4.分而治之"></a>4.分而治之</h3><p><strong>4.1思想</strong>：基于二分法，将序列一直二分，最后分为多个最小单元即两个数据，两个数据的最大子列和只有三种情况，非常简单，求出最小单元的最大子列和，再向上求解，即<strong>将两个最小单元组成新的最小单元</strong>，以此类推，就可以解决整个列表的最大子列和问题，复杂度为<code>O(nlogn)</code><br><strong>4.2代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100000int MaxofThreeNum (int a, int b, int c)  \\ 求三个数中得最大值{   int maxSum;    maxSum = a &gt; b ? a : b;    maxSum = maxSum &gt; c ? maxSum : c;    return maxSum;}int DivideConquer(int data[], int left, int right){    int mid;    int leftMaxSum, rightMaxSum;    int leftBoardSum, rightBoardSum;    int leftMaxBoardSum, rightMaxBoardSum;   /* 退出条件 */    if (left == right)         return data[left];/* “分的过程” */    mid = (left + right) / 2; //找到中分点        /* 递归求两边的最大值 */    leftMaxSum = DivideConquer(data, left, mid);  // 左边最大值    rightMaxSum = DivideConquer(data, mid + 1, right);  // 右边最大值     /* 跨越边界的最大值 := leftMaxBoardSum + rightMaxBoardSum  */     leftMaxBoardSum = data[mid];     leftBoardSum = 0;     for (int i = mid; i &gt;= left; i--) {        leftBoardSum += data[i];        if (leftBoardSum &gt; leftMaxBoardSum)            leftMaxBoardSum = leftBoardSum;     }   //左边界扫描    rightMaxBoardSum = data[mid + 1];    rightBoardSum = 0;    for(int i = mid + 1; i &lt;= right; i++) {        rightBoardSum += data[i];        if(rightBoardSum &gt; rightMaxBoardSum)            rightMaxBoardSum = rightBoardSum;    }  //有边界扫描     /* 治的过程，最大值为左边的最大值、右边最大值，跨越边界最大值之中的最大值 */    return MaxofThreeNum(leftMaxSum, rightMaxSum, leftMaxBoardSum + rightMaxBoardSum);}int MaxSubSeqSum(int data[], int num)  // 改变函数接口{    return DivideConquer(data, 0, num - 1);}int main(){    int num;    int data[MAXN] = {0};    scanf("%d",&amp;num);    for (int i = 0; i &lt; num; i++) {        scanf("%d", &amp;data[i]);    }    printf("%d", MaxSubSeqSum(data, num));    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-在线处理"><a href="#5-在线处理" class="headerlink" title="5.在线处理"></a>5.在线处理</h3><p><strong>5.1思想</strong>：一开始子列左端为A[0]，然后逐个向右累加，若当前子列和为负数则舍去，因为一个负的子列和部分只会使得子列和变小,算法复杂度为<code>O(n)</code><br><strong>5.2代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum4(int A[],int N){  int ThisSum,MaxSum = 0;  int i;  for (i=0;i&lt;=N;i++)/*i是子列左端*/  {    ThisSum=ThisSum+A[i];    if(ThisSum&gt;=MaxSum)    MaxSum=ThisSum;    else    ThisSum=0;  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核设计与实现（二）</title>
      <link href="/2023/06/23/linux-nei-he-she-ji-yu-shi-xian-er/"/>
      <url>/2023/06/23/linux-nei-he-she-ji-yu-shi-xian-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核设计与实现（二）"><a href="#Linux内核设计与实现（二）" class="headerlink" title="Linux内核设计与实现（二）"></a>Linux内核设计与实现（二）</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><p><strong>1.1进程</strong>：<strong>正在执行</strong>的程序的<strong>实时结果</strong><br>①进程不仅仅是一段可执行程序代码，还包含其他资源，如打开的文件、挂起的信号、内核内部数据、处理器状态、一个或多个具有内存映射的内存地址空间、执行线程和存放全局变量的数据段等<br>②进程和程序不是一对一关系，可能多个进程执行的是一个程序<br><strong>1.2线程</strong>：在<strong>进程中活动的对象</strong>，每个线程都拥有独立的程序计数器、进程栈和一组进程寄存器<br>①<strong>内核调度的对象</strong>是线程，不是进程<br>②在Linux中，线程被看作是<strong>特殊的进程</strong><br>③线程可以<strong>共享虚拟内存</strong>，但是有其<strong>各自的虚拟处理器</strong><br><strong>1.3内核线程</strong>：独立运行在<strong>内核空间</strong>的标准进程，但是没有独立的地址空间，只能<strong>由内核线程创建</strong><br><strong>1.4进程上下文</strong>：</p><h3 id="2-进程描述符（task-struct）"><a href="#2-进程描述符（task-struct）" class="headerlink" title="2.进程描述符（task_struct）"></a>2.进程描述符（task_struct）</h3><p><strong>2.1定义</strong>：内核将进程的列表存放在名为<strong>任务队列</strong>的<strong>双向循环链表</strong>中，链表的每一项就是进程描述符，包含了<strong>内核管理一个进程的所有信息</strong>，类型为<code>task_struct</code>，定义在&lt;linxu/sched.h&gt;中<br><strong>2.2分配</strong><br>①通过<strong>slab分配器</strong>分配进程描述符，能达到<strong>对象复用</strong>和<strong>缓存着色</strong>的目的<br>②slab分配器分配进程描述符后，在<strong>进程内核栈的尾端</strong>创建<code>thread_info</code>结构，其中<code>task</code>域存放指向<strong>其进程描述符的指针</strong><br><strong>2.3访问</strong>：内核通过访问进程描述符处理进程<br>①thread_info结构：采用<strong>硬件体系结构对应的current宏</strong>访问thread_info结构访问其task域<br>②特殊寄存器：有的硬件体系结构拿出<strong>一个专门寄存器</strong>存放指向当前进程task_struct的指针<br><strong>2.4PID</strong>：每个进程的标志，PID号的最大值表示系统中允许同时存在的进程的最大数目<br><strong>2.5进程状态</strong>：进程描述符中的<strong>state域</strong>描述了进程当前状态<br>①TASK_RUNNING（运行）：正在执行或者在运行队列中等待执行<br>②TASK_INTERRUPTIBLE（可中断）：进程被<strong>阻塞（睡眠）</strong>，<strong>等待某些条件的达成</strong>状态便改为运行，可能<strong>被某些信号提前唤醒</strong><br>③TASK_UNINTERRUPTIBLE（不可中断）：进程在等待时必须不受干扰，或者等待的事件很快就会发生，<strong>不对信号做出响应</strong><br>④_TASK_TRACED（被跟踪）：被一些进程监视<br>⑤_TASK_STOPPED（停止）：<strong>没有投入运行也不能投入运行</strong>，进程退出运行，在接收到某些信号或者在调试时接收到任何信号便会变为这种状态<br>#进程状态可以通过某些函数调整，如<code>set_task_state()</code>函数<br><strong>2.6父子进程</strong>：每个进程描述符中都包含一个<code>parent</code>指针指向其父进程，也有一个名为<code>children</code>的子进程列表<br>#所有进程都是<code>init</code>进程的子进程</p><h3 id="3-进程的创建"><a href="#3-进程的创建" class="headerlink" title="3.进程的创建"></a>3.进程的创建</h3><p><strong>3.1Unix进程创建概述</strong>：<code>fork()</code><strong>拷贝当前进程</strong>创建一个子进程，该子进程和父进程区别仅仅在于PID和PPID（父进程号）和某些资源，<code>exec()</code>读取<strong>进程对应可执行文件</strong>将其载入地址空间运行<br>#Linux的<code>fork()</code>系统调用采用的是<strong>写时拷贝</strong>，不复制整个父进程的进程地址空间（<strong>父进程占用的内存页</strong>），而是和父进程<strong>共享</strong>，只有当<strong>需要写入时</strong>才创建自己的内存页,<strong>在不写入的情况下，<code>fork()</code>函数只是复制了父进程的页表项和给子进程创建唯一的PID</strong><br><strong>3.2fork()</strong><br>①过程概述：<code>fork()</code>→<code>clone()</code>系统调用→<code>do_fork()</code>→调用<code>copy_process()</code><br>②copy_process过程</p><ul><li>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>结构，和父进程相同</li><li>检查是否超出了资源的限制</li><li>子进程<code>task_struct</code>的一些信息被清零或初始化，以便和父进程相区分，并将状态设置为“不可中断”，防止其投入运行</li><li>更新子进程<code>task_struct</code>中的<code>flag</code>标志，去掉子进程的<strong>超级用户权限</strong>，设置其“没有调用过<code>exec()</code>”对应的标志，并分配一个PID</li><li>根据<code>fork()</code>传递给<code>clone()</code>的标志判断其是否能<strong>共享公共资源</strong>，如果不能，则拷贝一份</li><li>扫尾工作，并返回一个指向子进程的指针，返回成功则<strong>先将子进程投入运行</strong>，因为子进程会运行<code>exec()</code>进行写时拷贝，防止父进程运行后写入改变地址空间</li></ul><p>#如果创建的是线程的话，每个线程都有<strong>各自的进程描述符</strong>，描述<strong>地址空间</strong>、<strong>文件资源系统</strong>等<strong>共享资源</strong>，<strong>线程本身</strong>再去描述其<strong>独占</strong>的资源，需要传递参数标志给clone()指明需要共享的资源（查阅相关表格）<br>#<br>③vfork():除了不拷贝父进程的页表项外，其余和<code>fork()</code>功能一致，可以通过向<code>clone()</code>传递特殊标志实现<code>vfork()</code></p><h3 id="4-进程的终结"><a href="#4-进程的终结" class="headerlink" title="4.进程的终结"></a>4.进程的终结</h3><p><strong>4.1终结的产生</strong>：进程调用exit()系统调用<br>①主动调用<br>②程序主函数返回：C语言会在函数的返回点后调用<br>③接收到不能处理与忽略的信号和异常<br><strong>4.2exit()</strong><br>①概述：调用exit（）后，只与该进程相关的所有资源全部被释放，成为僵死进程，只剩下内存栈、thread_info结构和task_struct结构，等待父进程调用wait（）将其释放，父进程退出后，需要给子进程在当前线程组或者找一个线程或者init作为父进程<br>②详细过程：LKD P31页<br>父进程退出后，需要给子进程在当前线程组或者找一个线程或者init作为父进程</p><h3 id="5-进程调度"><a href="#5-进程调度" class="headerlink" title="5.进程调度"></a>5.进程调度</h3>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT制作（基础篇）</title>
      <link href="/2023/06/23/ppt-zhi-zuo-ji-chu-pian/"/>
      <url>/2023/06/23/ppt-zhi-zuo-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="PPT风格矩阵"><a href="#PPT风格矩阵" class="headerlink" title="PPT风格矩阵"></a>PPT风格矩阵</h1><h2 id="一、配色"><a href="#一、配色" class="headerlink" title="一、配色"></a>一、配色</h2><h3 id="1-主色"><a href="#1-主色" class="headerlink" title="1.主色"></a>1.主色</h3><p><strong>1.1根据logo选择</strong>：学校、企业logo<br><strong>1.2根据风格选择</strong>：比如说黑金风就是黑色和金色，科技风经常是蓝色和青色，党政风是红色和黄色<br><strong>1.3根据主题选择</strong>：比如说医疗行业对应的是蓝色<br>#可以在网上搜索对应关键字，提取配色</p><h3 id="2-辅助色"><a href="#2-辅助色" class="headerlink" title="2.辅助色"></a>2.辅助色</h3><p><strong>2.1邻近色</strong>：基于主色调整<strong>色调</strong>，用于区分不同<strong>维度</strong><br>①PPT内调整色调：右击色块→填充→其他颜色填充→颜色模式改为“HSL”→调整色调数值（跨度最好在<strong>45以内</strong>，20较佳）<br><strong>②<font color="red">注意：色调数值的界限时0-255</font>，所以-15相当于240，270相当于15</strong><br><strong>2.2梯度色</strong>：调整<strong>亮度</strong>，用于区分不同<strong>层级</strong><br>①右击色块→填充→其他颜色填充→颜色模式改为“HSL”→调整亮度数值（跨度最好在45以内，20较佳）<br>②设计选项卡→变体选项卡→颜色→自定义颜色→着色1，输入主色的色值即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_40.png" alt="辅助色矩阵"><br><strong>2.3tips</strong>：可以采用取色器提取对应的颜色<br><strong>2.4相关网站</strong><br>①<a href="https://color.adobe.com/zh/">https://color.adobe.com/zh/</a><br>②<a href="https://arco.design/palette/list">https://arco.design/palette/list</a><br>③<a href="https://colorsupplyyy.com/app">https://colorsupplyyy.com/app</a> 撞色<br>④<a href="https://webgradients.com/">https://webgradients.com/</a> 渐变色</p><h2 id="二、形状"><a href="#二、形状" class="headerlink" title="二、形状"></a>二、形状</h2><h3 id="1-形状轮廓"><a href="#1-形状轮廓" class="headerlink" title="1.形状轮廓"></a>1.形状轮廓</h3><p><strong>1.1矩形</strong>：工业、商务和力量<br><strong>1.2圆角矩形</strong>：卡通、儿童和女性<br><strong>1.3去角矩形</strong>：文化、国风和传统<br><strong>1.4平行四边形</strong>：运动、速度和竞赛<br><strong>1.5折角</strong>：科技、未来<br>#比较新颖的形状可以在素材网站上寻找，记得要下载<strong>矢量图</strong>（SVG）<br>#有弧度的图形：插入基础图形→右击→编辑顶点→每个顶点对应两个控点，拖动控点即可</p><h3 id="2-形状填充"><a href="#2-形状填充" class="headerlink" title="2.形状填充"></a>2.形状填充</h3><p><strong>2.1色块填充</strong>：纯色和渐变色<br><strong>2.2纹理填充</strong>：找到纹理素材→在ppt中将纹理图片和形状重叠→<strong>先选形状，后选纹理</strong>→形状选项卡→合并形状→剪除</p><h3 id="3-形状效果"><a href="#3-形状效果" class="headerlink" title="3.形状效果"></a>3.形状效果</h3><p><strong>3.1立体</strong>：设置渐变→两个颜色一致的光圈→第一个光圈亮度调整至70％→渐变类型调整为<strong>射线渐变</strong>，方向调整为<strong>从左上角</strong>，拖动光圈到合适位置（比如说15%和85%）→添加映像效果，选择第一个预设，透明度85％，大小20％左右，适当添加<strong>模糊</strong>效果<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_41.png" alt="立体"><br><strong>3.2光泽</strong>：设置渐变→选择线性渐变，方向调整为45°→左右两侧光圈设置为主色→中间添加一到两个光圈，颜色设置为背景色，透明度设置为100，调整光圈位置即可→将轮廓设置为实线→同上添加映像<br>①光泽效果最好在<strong>深色背景</strong>中使用<br>②轮廓线的亮度最好比主色高一些<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_42.png" alt="光泽"><br><strong>3.3新拟态</strong>：凹凸不平的图形<br>凸起：形状和背景色相同，去除轮廓，给两个相同的形状添加<strong>外阴影</strong>，方向对立（比如说右下45°和左上45°），一个阴影的色调比背景色暗，一个阴影的颜色比背景亮，然后重叠这两个形状<br>②凹陷：形状和背景色相同，去除轮廓，给两个相同的形状添加<strong>内阴影</strong>，方向对立（比如说右下45°和左上45°），一个阴影的色调比背景色暗，复制其中一个，对另一个进行图片纹理填充（剪切板）即可<br>#背景不能是纯白纯黑，可以是灰色，淡蓝色等<br>#适当调节阴影的<strong>距离</strong>和<strong>模糊</strong>使其更加柔和<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_43.png" alt="新拟态"><br><strong>3.4毛玻璃</strong>：对背景图做<strong>全屏虚化</strong>（100即可），再将正常背景图<strong>覆盖</strong>在上面，添加色块，将色块颜色改为<strong>幻灯片背景填充</strong>即可，还可以添加白色描边、内阴影<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_44.png" alt="毛玻璃"><br><strong>3.5发光：渐变透明</strong><br>①内发光：射线渐变（圆形）/路径渐变（调整方向），左光圈为背景色（透明度调节为100%），右光圈为发光色，调整光圈位置，设置好渐变参数后，先点击纯色填充，再点击渐变填充可以使得发光效果更强<br>②外发光：复制对应图形，柔化边缘，磅数可以适当大一些，将其与原图形重叠，调整大小即可<br>③发光平台：</p><ul><li>平面平台：渐变透明的梯形，从上往下的渐变，一个光圈为背景色，一个光圈为主色</li><li>多个平面平台：建立多个大小相等的<strong>矩形</strong>，给其添加上述渐变，组合，三维旋转（透视、适度宽松），将光源改为对比，调整y值和透视值即可</li></ul><p>#梯形、矩形和平行四边形（侧面）组合可以成为三维平台，其中正面的透明度应该比上平面的透明度低<br>#给边框添加<strong>光效</strong>素材，使其更漂亮<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_45.png" alt="发光"><br><strong>3.6tips</strong>：采用<strong>格式刷</strong>大量同化，点击某一样式，双击格式刷，再点击其他样式<br><strong>3.7相关网站</strong><br>①<a href="https://www.freepik.com/">https://www.freepik.com/</a><br>②<a href="https://huaban.com/">https://huaban.com/</a><br>③<a href="https://www.zcool.com/">https://www.zcool.com</a><br>④<a href="http://www.pinterest.com/">www.pinterest.com</a></p><h2 id="三、背景、字体和素材"><a href="#三、背景、字体和素材" class="headerlink" title="三、背景、字体和素材"></a>三、背景、字体和素材</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p><strong>1.1基调</strong><br>①基于环境：当环境比较明亮时采用浅色，当环境比较暗时采用深色<br>②基于主色：当主色为浅色时，采用深色背景，反之采用浅色背景<br>③基于风格：比如科技风经常采用深色渐变背景<br><strong>1.2类型</strong><br>①图片背景：常作为封面背景<br>②色块背景：常作为正文背景，可以是纯色，也可以是渐变色</p><ul><li><strong>浅色</strong>渐变背景：使用两个光圈，一个为主色，一个为白色，选择合适的渐变方向，<strong>提高主色光圈亮度</strong>即可（80%-90%）</li><li><strong>深色</strong>渐变背景：同上述光泽效果制作即可</li></ul><p><strong>1.3tips</strong>：可以修改<strong>幻灯片母版</strong>修改每一张幻灯片，视图选项卡→幻灯片母版</p><h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><p><strong>2.1种类</strong>：字体种类最好不超过两种，一般正文采用<strong>黑体</strong><br><strong>2.2风格</strong>：一般只有标题能使用风格字体，字体风格要和ppt整体风格相符合<br>①黑体：力量、动感和科技<br>②宋体：文化、庄严和雅致<br>③书法：豪迈、奔放和大气<br><strong>2.3粗细</strong>：使用粗体，不要使用ppt自带的字体加粗，而是采用字体本身的<strong>bold</strong>类型<br>light、regular和bold为常见的三种字体自重<br><strong>2.4tips</strong><br>①中文采用中文字体，西文采用西文字体（先整体设置中文，再设置英文）<br>②ppt主题字体设置：设计选项卡→变体分区→字体→自定义字体</p><h3 id="3-素材"><a href="#3-素材" class="headerlink" title="3.素材"></a>3.素材</h3><p><strong>3.1图标</strong>：填补/代替标题或小标题，使其更加生动饱满<br>①图标主要有填充型和线条型，不要混用<br>②素材网站<a href="https://www.flaticon.com/">https://www.flaticon.com/</a> <a href="https://iconpark.oceanengine.com/official">https://iconpark.oceanengine.com/official</a><br><strong>3.2图案修饰</strong>：图案修饰可以在以下素材网站上面寻找，不同的风格对应不同的素材，比如中国风有笔刷、祥云、卷轴等，使用这些素材对ppt进行装饰，<strong>填补空缺</strong>使其更加饱满，也可以将ppt中的<strong>某些形状、边框等替换为类似的素材</strong><br>①<a href="https://www.freepik.com/">https://www.freepik.com/</a><br>②<a href="https://huaban.com/">https://huaban.com/</a><br>③<a href="https://www.zcool.com/">https://www.zcool.com</a><br>④<a href="http://www.pinterest.com/">www.pinterest.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT制作（进阶篇）</title>
      <link href="/2023/06/23/ppt-zhi-zuo-jin-jie-pian/"/>
      <url>/2023/06/23/ppt-zhi-zuo-jin-jie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="PPT制作（进阶篇）"><a href="#PPT制作（进阶篇）" class="headerlink" title="PPT制作（进阶篇）"></a>PPT制作（进阶篇）</h1><h2 id="一、封面页"><a href="#一、封面页" class="headerlink" title="一、封面页"></a>一、封面页</h2><h3 id="1-标题排版"><a href="#1-标题排版" class="headerlink" title="1.标题排版"></a>1.标题排版</h3><p><strong>1.1换行有节奏</strong>：当标题过长时，可以将标题分为多行，每一行要<strong>完整且相对独立</strong>，且<strong>长短交错</strong>，否则会很呆板<br><strong>1.2对比有重点</strong>：使标题有层次感，突出重点<br>①调粗细：粗体（Bold）用于标题，标准（Regular）用于副标题、正文（比如说汇报人什么什么<br>②变大小：一般来说标题为第一层级，副标题为第二层级，正文为第三层级，不同信息层级字体大小成<strong>倍数关系</strong>，如（60-20-15）<br>③换颜色：将标题字体颜色更换为<strong>PPT主色</strong>，可以采用渐进色进行修饰<br>④改间距：调整各个层级之间的间距使其不要太拥挤<br>⑤特殊效果：如倾斜、错位排版等<br>#倾斜：选中文本框→形状格式→文本效果→转换→正方形→拖动控点控制文字的倾斜角度</p><h3 id="2-背景图片"><a href="#2-背景图片" class="headerlink" title="2.背景图片"></a>2.背景图片</h3><p><strong>2.1图片网站</strong><br>①unsplash.com<br>②<a href="http://www.pexels.com/">www.pexels.com</a><br>③pixabay.com<br><strong>2.2图片选择</strong><br>①语意关联：根据<strong>关键词</strong>寻找配图<br>②留白空间：根据标题的排版，选择一张对应位置有留白的图片<br>③色调匹配：图片色调要和PPT主色相符合</p><h3 id="3-构图形式"><a href="#3-构图形式" class="headerlink" title="3.构图形式"></a>3.构图形式</h3><p><strong>3.1布局选择</strong><br>①居中构图：当图片为上下构图时，采用居中布局，图片主体占图片的1/3<br>②居左布局：图片为左右构图时，采用居左布局，图片主体占图片的1/2<br>③根据图片留白放置标题<br><strong>tips：可以通过裁剪，获得想要的留白空间</strong><br><strong>3.2图形凸显</strong>：降低图片对文字的干扰<br>①色块：使用<strong>一定颜色的形状</strong>作为图片的衬底，调整透明度使其更为自然<br>②蒙版：渐变透明的蒙版<br>#全屏蒙版：插入全屏矩形→选择<strong>线性渐变</strong>→渐变方向<strong>根据封面布局</strong>选择，比如居中布局采用自上而下，居左布局采用自左向右→光圈颜色选择背景图片的主色→将<strong>非文字区域</strong>的光圈透明度调整为100→调整光圈位置，使其更加自然<br>#局部蒙版：插入刚好能覆盖文案的形状（比较推荐椭圆）→设置为无轮廓→选择<strong>路径渐变</strong>→光圈颜色采用图片的主色→右侧光圈透明度调节为100→调整光圈位置，将<strong>图片置于底层</strong><br><strong>tips：如果觉得蒙版破坏了图片主体，可以将图片主体扣出来</strong><br><strong>等距缩放，为了让左右和上下的边距相等，可以创建一个小正方形，置于形状的左上角，按住ctrl键缩放即可</strong></p><h2 id="二、排版"><a href="#二、排版" class="headerlink" title="二、排版"></a>二、排版</h2><h3 id="1-文字排版"><a href="#1-文字排版" class="headerlink" title="1.文字排版"></a>1.文字排版</h3><p><strong>1.1对齐</strong>：不要使用首行缩进，这样会导致文本不够饱满，最好采用<strong>两端对齐</strong><br><strong>1.2调整间距</strong><br>①本身：标题字号较大，采用1.0倍行距，正文字号比较小，采用1.2-1.5倍行距<br>②相互：<strong>标题和正文间距＞段落间距＞行间距＞字间距</strong><br>#可以采用<strong>分隔线</strong>突出重点段落，比如副标题<br><strong>1.3控制行长</strong>：行长最好<strong>略小于页面的二分之一</strong>，可以采用多段左右、上下分布，<strong>避免出现独字</strong></p><h3 id="2-内容排版"><a href="#2-内容排版" class="headerlink" title="2.内容排版"></a>2.内容排版</h3><p><strong>2.1梳理文案信息</strong><br>①分段：将一段文字内容分为<strong>独立的几个维度</strong><br>②精简：删除<strong>连接词和重复词语</strong>，提炼核心内容<br>③凸显层级和重要内容：大小对比、颜色对比、粗细对比、距离对比、下划线、色块、字体对比<br><strong>2.2确定版式布局</strong><br>①统一版心，利用<strong>参考线</strong>确定标题区域和正文区域<br>#可以先创建一个全屏矩形，然后等比缩放，调节至合适大小，分布在ppt四角<strong>确定留白区域</strong>，随后在非留白区域确定标题位置和正文位置，标题位置和正文位置之间<strong>相隔一个标题高度</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_1.png" alt="统一版心"><br>②内容分块：利用<strong>色块、形状</strong>等根据文案信息对正文位置进行分块<br>#注意色块、形状等<strong>修饰内容可以占用留白区域</strong>，只要正文内容按照格式排版即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_2.png" alt="内容分块"><br><strong>2.3内容可视化</strong><br>①图标：给小标题增加合适的图标<br>#素材网站:<a href="https://www.flaticon.com/">https://www.flaticon.com/</a> <a href="https://iconpark.oceanengine.com/official">https://iconpark.oceanengine.com/official</a> <a href="http://www.iconfont.cn/">www.iconfont.cn</a><br>#可以将图标截图，并将<strong>位图转化为矢量图</strong>，这样就可以在ppt中修改格式了<br>②图片：给<strong>文本块</strong>增加对应的图片背景等<br>③逻辑图示：流程图、带有<strong>关系暗示</strong>的图形等等<br>#并列、包含、流程、循环和层级<br>#素材网站：<a href="https://www.freepik.com/">https://www.freepik.com/</a><br><strong>2.4实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_3.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_4.png" alt="实例二"></p><h3 id="3-多点排版"><a href="#3-多点排版" class="headerlink" title="3.多点排版"></a>3.多点排版</h3><p><strong>3.1中心环绕式布局</strong><br>①全圆式布局：段落数量为<strong>偶数</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_5.png" alt="全圆式布局"><br>②半圆式布局：段落数量为<strong>奇数</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_6.png" alt="半圆式布局"><br>#可以利用等比例缩放绘制圆辅助线，并<strong>利用对齐</strong>将段落点贴近辅助线<br><strong>3.2确定中心点样式</strong><br>①基本形状：并不一定要局限于圆形，还可以是其他多边形<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_7.png" alt="基本图形"><br>②图片素材：选取符合主题的图片<br><strong>3.3丰富层次</strong><br>①文本层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_9.png" alt="文本层次"><br>②图形层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_8.png" alt="图形层次"></p><h3 id="4-多图排版"><a href="#4-多图排版" class="headerlink" title="4.多图排版"></a>4.多图排版</h3><p><strong>4.1尺寸</strong>：图片格式→裁剪→纵横比，将图片裁剪为比例一致的图片，然后再调整大小<br><strong>4.2间距</strong>：利用<strong>对齐</strong>，注意<strong>图片之间</strong>的间距要小于<strong>图片和页面之间</strong>的间距<br><strong>4.3效果</strong><br>①形状：将图片裁剪为特定形状，图片格式→裁剪→形状<br>②轮廓：给图片加上边框<br>③阴影：ctrl拖动复制图片→图片格式→艺术效果→虚化→调整虚化半径（调整为90）→柔化边缘→将该图片拖动到原图片底部<br>④映像：ctrl拖动复制图片→图片格式→映像效果→选择第一个预设→调整映像大小→增加模糊度<br>#可以设置好一张图片效果，然后采用<strong>格式</strong>刷快速复制<br><strong>4.4创意排版</strong><br>①瀑布流<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_10.png" alt="瀑布流"><br>②三维旋转<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_11.png" alt="平行预设"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_12.png" alt="角度预设"><br><strong>#要将光源改为对比</strong>，防止过曝</p><p><strong>5.创意排版</strong><br><strong>5.1分栏排版</strong>：利用<strong>色块、图片等</strong>将不同维度内容分隔开<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_34.png" alt="分栏排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_35.png" alt="示例"><br><strong>5.2拦腰排版</strong>：用于需要突出重点内容的<strong>总分关系</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_36.png" alt="拦腰排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_37.png" alt="示例"><br><strong>5.3卡片排版</strong>：变种的分栏排版，注意卡片组合起来要是一个规整的矩形（可以有无内容色块），<strong>形状和间距相同</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_38.png" alt="拦腰排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_39.png" alt="示例"></p><p>#配色可以采用主色+<strong>黑白灰</strong>/主色的梯度色<br>#当内容不够饱满时，可以插入<strong>图片</strong></p><h2 id="三、特殊要素"><a href="#三、特殊要素" class="headerlink" title="三、特殊要素"></a>三、特殊要素</h2><h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1.表格"></a>1.表格</h3><p><strong>1.1大小</strong><br>①整体大小：要<strong>占满版心</strong><br>②单元格大小：全选表格→<strong>布局选项卡</strong>调整单元格高度→然后双击单元格的<strong>竖边</strong>，使得<strong>单元格宽度匹配文本宽度</strong><br><strong>1.2样式</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_13.png" alt="表格样式"><br>①选择<strong>无样式</strong>的表格样式，随后自己编辑<br>②线条型表格的<strong>内部框线不宜太粗</strong>，防止喧宾夺主，<strong>表头</strong>、<strong>表尾</strong>和<strong>分割表格</strong>的框线可以适当增粗<br>③色块型表格，可以在表格<strong>底部</strong>添加<strong>对应大小颜色</strong>的色块，也可以对表格进行颜色填充，但是后者是对<strong>每个单元格</strong>进行对应填充且<strong>不能改变形状</strong>，在使用渐变色时还是使用前者<br><strong>1.3对齐</strong>：文本左对齐，数据右对齐<br>①如果遇到小数，位数要统一<br>②文本内容过多，可以分点介绍<br><strong>1.4突出重点</strong>：粗细、颜色、衬底<br><strong>1.5可视化</strong><br>①文本可视化：利用图标、图片代替文字或者作为背景<br>②数据可视化：比如百分比可以利用对应的进度条和饼状图代替<br><strong>1.6实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_14.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_15.png" alt="实例二"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_16.png" alt="实例三"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_17.png" alt="实例四"></p><h3 id="2-时间轴"><a href="#2-时间轴" class="headerlink" title="2.时间轴"></a>2.时间轴</h3><p><strong>2.1时间轴线</strong><br>①直线：渐变、箭头<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_18.png" alt="直线"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_21.png" alt="示例"><br>②不规则线条：曲线、折线<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_19.png" alt="曲线绘制"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_20.png" alt="示例"><br>#注意其中的技巧三，可以在<strong>ppt画面之外</strong>使其形成一个封闭图形，并进行<strong>颜色填充</strong>，如示例所示<br>③实物元素<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_22.png" alt="实物元素"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_23.png" alt="示例"><br><strong>2.2节点</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_24.png" alt="节点"><br>①还可以使用图标<br>②节点<strong>外发光</strong>效果：去除线条→<strong>偏移为中</strong>的<strong>阴影</strong>预设→透明度将为0→调整<strong>大小</strong>从而调节发光范围<br>③节点<strong>内发光</strong>效果：<strong>射线</strong>渐变→方向改为<strong>从中心</strong>→<strong>左侧</strong>光圈改为<strong>背景色</strong>，调整为<strong>完全透明</strong>→调整光圈位置即可<br><strong>2.3文案排版</strong><br>①文本层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_9.png" alt="文本层次"><br>②文本修饰：在节点和文案之间添加<strong>直线</strong>等元素进行<strong>联系</strong></p><h3 id="3-架构图"><a href="#3-架构图" class="headerlink" title="3.架构图"></a>3.架构图</h3><p><strong>3.1确定走向</strong><br>①自上而下：适合分支较<strong>少</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_25.png" alt="示例"><br>②自左向右：适合分支较<strong>多</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_26.png" alt="示例"><br>③中心扩散：适合分支较<strong>多</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_27.png" alt="示例"><br><strong>3.2元素形状</strong><br>①衬底图形<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_28.png" alt="衬底图形"><br>#还可以将这些基本图形<strong>结合</strong>到一起形成新的衬底<br>②连接线条<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_29.png" alt="连接线条"><br>#其中曲线型连接可以采用<strong>花括号</strong>和箭头等组合而来<br>#可以在形状格式中修改箭头、花括号的<strong>末端形状</strong><br><strong>3.3区分层级</strong><br>①颜色对比：不同层级采用不同的颜色（最好<strong>梯度色</strong>），其中衬底颜色和文字颜色<strong>色调要相反</strong>，即衬底为深色，文字就要为浅色<br>②虚实对比：当层级过多，颜色对比不够用时，末端可以采用<strong>无填充、虚线框</strong>的形式<br>③形状对比<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_30.png" alt="示例"></p><h3 id="4-图表"><a href="#4-图表" class="headerlink" title="4.图表"></a>4.图表</h3><p><strong>4.1确定样式</strong><br>①柱形图：大小比较，项目名较短<br>②条形图：大小比较，项目名较长<br>③饼状图：占比关系<br>④环形图表：占比关系，可以使用弧形和圆组合而成，调<strong>粗</strong>其线宽，改变其<strong>线端类型</strong>，将弧形置于顶层即可<br>⑤折线图：变化趋势</p><p>#直接<strong>插入图表</strong>即可<br><strong>4.2图标优化</strong><br>①柱/条形图</p><ul><li>弱化或者删除<strong>网格</strong>、<strong>图例</strong>和<strong>坐标轴</strong>元素</li><li>间隙宽度<strong>50%-100%</strong></li><li>突出重点，利用<strong>颜色</strong>和<strong>色块衬底</strong>即可</li></ul><p>②饼状图</p><ul><li>扇面<strong>从大到小顺时针排序</strong></li><li>扇面配色避免花哨，使用<strong>梯度色</strong>即可</li></ul><p>③折线图</p><ul><li>弱化或者删除<strong>网格</strong>、<strong>图例</strong>和<strong>坐标轴</strong>元素</li><li>如果无需精确呈现数据时，可使用<strong>平滑线</strong>（右击→设计数据系列格式→填充与线条→勾选平滑线选项）</li><li>可以将其改变为<strong>面积图</strong>，对其进行<strong>渐变填充</strong>，但是如果要使用<strong>平滑线</strong>的话，不能将其改变为面积图，应该先将其改变为<strong>平滑线</strong>→新建一页，将图表<strong>选择性粘贴</strong>为<strong>图片（增强型图元文件）</strong>→取消组合，提取曲线→利用曲线和目标颜色色块进行<strong>组合拆分</strong>，将对应颜色色块裁剪为目标形状<strong>填充回原幻灯片</strong>即可</li></ul><p>#图表不仅仅局限于ppt图表自带的修饰，还可以自己利用<strong>线条、形状</strong>等素材对图表进行修饰，比如说用<strong>文本框</strong>代替图表原本的<strong>标题</strong>，用色块和文本框代替图例等<br>#可以使用<strong>数据标签</strong>代替纵轴</p><p><strong>4.3布局</strong><br>①单个图表：占满版心即可<br>②多个图表：利用<strong>色块</strong>对页面进行分区，将图表放在对应的色块中</p><p><strong>4.4实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_31.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_32.png" alt="实例二"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_33.png" alt="实例三"></p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软技能 </tag>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（二）</title>
      <link href="/2023/06/23/c-yu-yan-xue-xi-bi-ji-er/"/>
      <url>/2023/06/23/c-yu-yan-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（二）"><a href="#C语言学习笔记（二）" class="headerlink" title="C语言学习笔记（二）"></a>C语言学习笔记（二）</h1><h2 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h2><h3 id="1-指针"><a href="#1-指针" class="headerlink" title="1.指针"></a>1.指针</h3><p><strong>1.1内存和地址</strong><br><strong>①比特/位</strong>：计算机的<strong>最小存储单位</strong>，可以存储1和0<br><strong>②字节</strong>：一个字节包含<strong>8个比特</strong>，包含存储<strong>一个字符</strong>所需要的位数，是计算机的<strong>最小寻址单位</strong><br><strong>③字</strong>：每个字由<strong>2（16位机器）或者4（32位机器）个字节</strong>组成，每个字的地址是其<strong>最左边或者最右边</strong>的字节的地址，每台机器规定不同<br><strong>④寻址</strong>：高级语言一般通过<strong>变量名</strong>而不是地址访问内存位置，<strong>变量名和地址的关系由编译器提供</strong>，<strong>硬件还是通过地址</strong>访问内存位置</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 边界对齐：整型值存储的起始位置只能是某些特定的字节，通常是2和4的倍数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个内存位置中存储的时一连串1和0，被解释为什么数据类型取决于我们的使用方式和声明方式，有些时候值可能是一样的但是被解释为了不同的数据类型</div><p><strong>1.2指针变量</strong>：存储某变量的地址的变量，通常为<strong>整数</strong>，指针变量也有其<strong>自己的地址</strong><br><strong>①声明格式</strong>：<code>[指向变量的数据类型] *[指针变量名] = &amp;[指向的变量]</code></p><blockquote><p><code>*</code>为<strong>间接访问操作符</strong>，可以通过它<strong>访问指针指向的地址</strong><br><code>&amp;</code>为<strong>取址符</strong>，通过它可以<strong>获得变量的地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对*指针变量进行操作相当于对其指向的变量进行操作</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 指针数据类型取决于指向的变量的数据类型，比如假设整数a的地址是100，不能使用*100 = 10对a进行赋值，因为100是字面量，缺省情况下是整型而不是指针变量，应该写为*（int*）100 = 10，该技巧只有在需要访问特定地址时才使用</div><p><strong>②未初始化的指针</strong></p><pre class="line-numbers language-none"><code class="language-none">int *a;*a = 12;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 指针需要进行初始化，因为声明一个指针并不会创建一个存储空间，所以其指向也未知，可能指向非法地址（内存错误）或者导致储存地址处于错误的边界（总线错误），所以一定要对指针进行初始化*可以初始化为空指针，但是要进行空指针检查）</div><p><strong>③NULL指针</strong>：表示这个指针<strong>没有指向任何地方</strong></p><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意对NULL指针进行引用是错误的，所以在对指针解引用时需要检查其是否为空指针</div><p><strong>④指针的指针</strong><br><code>int** a = &amp;b</code>：其中b是一个指向整型变量的指针，a表示一个指向指向整型变量指针的指针<br><strong>1.3指针与左右值</strong></p><pre class="line-numbers language-none"><code class="language-none">int a = 10；int* b = &amp;a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>①</strong>其中当<code>a</code>、<code>*b</code>（变量名）作为右值时，代表的是“10”，即对应位置储存的数据，作为左值时代表对应位置的地址<br><strong>②</strong><code>&amp;a</code>作为右值代表a的地址，不能作为左值，因为<code>&amp;a</code><strong>不能代表内存中某一特定位置</strong><br><strong>③</strong><code>b</code>作为右值是表示的是<code>a</code>的地址，作为左值表示的是<code>b</code>的地址<br><strong>1.4指针表达式</strong><br><strong>①</strong><code>*b+1</code>：表示对<code>a</code>中的数据加1，只能作为右值，<code>*（b+1）</code>相当于<code>a</code>后面一个内存的标识符，作为左值代表对应的地址，作为右值代表对应位置存储的数据。<br><strong>②</strong><code>++b</code>：作为右值表示该指针指向位置的后一个位置的地址，作为左值是非法的<br><strong>③</strong><code>b++</code>：作为右值表示的该指针指向位置的地址，随后该指针加一，作为左值是非法的，因为他是一个数值而不是一个容器<br><strong>④</strong><code>*++b</code>：作为右值表示该指针指向位置后一个位置存放的数据，作为的左值表示的是该指针指向位置后一个位置<br><strong>⑤</strong><code>*b++</code>：作为右值表示的是该指针指向位置存放的数据，作为左值表示的是该指针指向变量，随后该指针变量加一<br><strong>⑥</strong><code>++*b</code>：作为右值表示的是b指向变量存放数据的值加一</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ++/--的优先级高于*</div><p><strong>1.5指针的运算</strong><br><strong>①与整数加减法</strong>：当对指针加减一个整数n时，该指针会<strong>根据其指向的数据的类型调整自身大小</strong>（也适用于malloc分配的内存）</p><blockquote><p>比如某台机器上<code>float</code>占4个字节，对一个指向<code>float</code>变量的指针+n，该指针的大小会增加4n</p></blockquote><p><strong>②<code>==</code>与<code>!=</code></strong></p><blockquote><p>可以用于任意两个指针，判断两个指针是否相同</p></blockquote><p><strong>③指针之间的减法</strong></p><blockquote><p>只有当两个指针都指向<strong>同一数组</strong>中的元素时，才允许用一个指针减去另一个指针，得到的数据类型是<strong>ptrdiff_t</strong>，这是一种有符号整数，表示两个指针指向位置的距离（以数组元素的长度为单位）</p></blockquote><p><strong>④关系运算（大于/小于）</strong>：只能用于<strong>同一个数组</strong>内的元素</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> ③④中同一数组的元素还包括数组末尾后一位元素，但是不包括数组开头前一位元素</div><p><strong>1.6函数指针</strong><br><strong>①格式</strong>：<code>返回类型 (*f)()</code></p><blockquote><p>可以解释为<code>f</code>被间接引用后是一个函数，该函数的返回值是一个整型，所以f为一个函数指针<br><code>()</code>为函数调用操作符，<code>f()</code>的结果是函数的返回值</p></blockquote><p><strong>②初始化：</strong><code>返回类型 (*f)(参数列表) = 函数名</code></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在函数指针初始化时，其参数列表需要与之对应</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中函数名在编译时会被转换为函数指针，故可以不用取址符号</div><p><strong>③函数指针数组</strong>：<code>返回类型 (*f[]) ();</code></p><blockquote><p><code>()</code>和<code>[]</code>均为第一优先级，结合性<strong>从左向右</strong>，优先级均高于<code>*</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">double  (*oper_func[])(double,double) = {a,b,c...};result = oper_func[1](i,j);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>④用途</strong>：构造泛型函数</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 泛型函数：可以处理不同数据类型的函数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数指针可以作为一个参数提供给另一个函数，使得该函数可以在另一个函数中使用，这些函数被称为回调函数</div><blockquote><p>将函数中与数据类型相关的操作替换为<strong>一系列等价的函数</strong>，需要使用哪一类数据类型的对应操作，传递对应的函数指针即可<br>将传递给<strong>函数以及回调函数</strong>的数据类型替换<code>*void</code>，<code>*void</code>用于接收不同数据类型的指针</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在使用这些数据的指针时，必须要强制转换为正确的数据类型</div><pre class="line-numbers language-none"><code class="language-none">/*比较函数的整数版本int compare_ints(void const *a,void const *b){if(*(int *)a = *(int *)b)return 0;elsereturn 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h3><p><strong>2.1源文件格式</strong></p><pre class="line-numbers language-none"><code class="language-none">返回类型 函数名（形参类型1 形参名1，...形参类型n 形参名n）{statement；    return expression；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>return</code>语句不一定出现在末尾，没有<code>return</code>语句的函数称为<strong>过程</strong><br><strong>类型、形参和statement</strong>都不是必须的，因此最简单的函数可以写为</p></blockquote><pre class="line-numbers language-none"><code class="language-none">void function （void）{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这种函数可以达到存根的目的,即为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数要考虑异常情况</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 函数中的形参是实参的一个副本，修改形参不能修改实参，如果想要修改实参，需要传递实参的地址</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 当本该有参数的地方没有参数时，必须要使用void占据位置</div><p><strong>2.2函数声明</strong><br><strong>①格式</strong>：<code>返回类型 函数名(形参类型n 形参名n);</code></p><blockquote><p>向编译器<strong>提供函数相关信息</strong>，如果没有对应的函数声明，函数会被调用，但是传递给函数的参数会进行<strong>缺省参数提升</strong>（<code>char</code>和<code>short</code>被转换为<code>int</code>，<code>float</code>被转化为<code>double</code>），且默认返回一个<strong>整型</strong><br>函数声明的结尾是有一个<strong>分号</strong>的，而函数定义没有</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 大部分时候将函数定义在单独的C文件中，然后将函数声明置于同一个头文件中，主函数文件使用include命令调用即可</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当调用函数时输入的变量类型不匹配，编译器会根据函数声明强制转换变量类型</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 函数原型不要写在代码块中，因为代码块中的函数原型有代码块作用域，可能会覆盖原来的函数声明</div><p><strong>2.3利用函数实现黑盒</strong>：利用<code>static</code>关键字修饰<strong>函数内置数据和函数</strong>，使其变为函数文件私有，外界不能访问<br><strong>2.4递归函数</strong>：直接或者间接<strong>调用自身</strong>的函数，当递归函数<strong>不再满足某个条件</strong>时，便停止调用自身<br>以下为递归函数的例子</p><pre class="line-numbers language-none"><code class="language-none">binary_to_ascii(unsigned int value){unsigned int a;a = value/10;if(a!=0)binary_to_ascii(a)putchar(value%10+‘0)’;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>递归的<strong>实现过程</strong>（假设一开始<code>value</code>的值为4267）<br>①当函数被调用时，变量创建在堆栈中，之前调用函数的变量依旧保持在堆栈之中，但是<strong>被新函数的变量掩盖所以不能被访问</strong>（堆栈的特性）<br>②所以当递归函数调用自身时，每次新的调用都会创建一批新的变量掩盖原来的变量<br>③函数刚调用时，堆栈中出现了<code>value[1] = 4267</code>和<code>a[1] = 426</code><br>④当函数判断条件符合，又对函数进行第二次调用，堆栈中<code>value[2] = 426</code>、<code>a[2] = 42</code>掩盖了原先的<code>value</code>和<code>a</code><br>⑤第三次调用，<code>value[3] = 42</code>，<code>a[3] = 4</code><br>⑥第四次调用，<code>value[4] = 4</code>，<code>a[4] = 0</code>，至此，停止递归，然后函数开始打印输出，并开始释放销毁堆栈中的对应变量，<strong>从顶端的变量开始释放</strong>（堆栈的特性），从<code>[4]</code>到<code>[3]</code>到<code>[2]</code>再到<code>[1]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 递归函数需要设置限制条件，且每次递归调用之后就越接近该限制条件</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 递归的计算代价非常大，如果可以使用循环等解决问题，不要使用递归</div><p><strong>2.5可变参数列表</strong><br><strong>①实现</strong>：通过宏实现，定义于<code>stdarg.h</code>头文件中，该头文件中声明了一个<code>va_list</code>类型和三个宏<code>va_start</code>、<code>va_arg</code>和<code>va_end</code><br><strong>②用法</strong>：</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdarg.h&gt;/*用于计算输入数字的平均数float average (int n_value,...){va_list number_n;int count;float sum = 0;va_start(number_n,n_value);for (count=0;count&lt;n_value;count+=1){sum = sum+va_arg(number_n,int);}va_end(number_n);return sum/n_value;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在函数体内部定义<code>va_list</code>类型参数，该参数代表可变参数列表<br>使用<code>va_statr</code>初始化<code>va_list</code>类型参数，该宏接收的第一个参数是<code>va_list</code>类型参数<code>number_n</code>，第二个参数是可变参数列表的前一个参数<code>n_value</code><br>使用<code>va_arg</code>代替可变参数进行计算，该宏接收的第一个参数是<code>va_list</code>类型参数<code>number_n</code>，第二个参数是可变参数列表的<strong>数据类型</strong><br>使用<code>va_end</code>注销可变参数列表</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要使用该宏，则函数必须要有一个已确定的参数（上例中的n_value）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意函数形参部分的写法，可变参数列表用...代替，在书写函数声明时，也需要注意</div><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><p><strong>3.1声明格式</strong>：<code>数据类型 数组名[数组大小]</code><br><strong>①数组名</strong>：数组名的值是一个<strong>指针常量</strong>（注意是常量，所以不能改变），指向数组的起始位置</p><blockquote><p>数组名不仅仅只是一个指针常量，还包含了<strong>数组长度</strong>等信息，在创建数组的时候编译器会根据其长度为<strong>数组</strong>划分对应的内存空间，随后为数组名划分内存；而创建指针的时候，<strong>只为指针本身划分内存</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只有数组名在表达式中被使用了，编译器才会创建对应的指针常量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 数组名在一些情况下不是一个指针，而是代表整个数组，比如sizeof（数组名）会返回整个数组的长度，&amp;数组名产生的是一个数组的指针，而不是一个指向指针的指针</div><p><strong>②下标引用</strong>：<code>a[b]</code>相当于<code>*(a+b)</code>，<strong>所以下标从0开始</strong></p><blockquote><p>在C语言中，下标引用可以应用于<strong>所有的指针</strong>，不仅仅局限于数组</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 指针间接访问的效率大于等于下标引用效率，详细见《C与指针》p145-p150</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意检查数组越界问题</div><p><strong>3.2数组与函数</strong>：数组做为<strong>形参</strong>，格式可以是<code>(数据类型 数组名[])</code>也可以是指针类型<code>(数据类型 *指针名)</code></p><blockquote><p>函数在声明数组参数时不需要指定他的长度，因为他只接受数组的地址，而不为其分配内存，所以如果需要知道数组的<strong>大小</strong>，还需要<strong>另一个形参</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数组名传给形参是以传值的形式传递的，所以在函数中，对应指针变量是可以被修改的，但是不会影响到原来的数组名的值</div><p><strong>3.3初始化</strong><br><strong>①格式</strong>：<code>数据类型 数组名[] = {值1,值2,…}</code></p><blockquote><p>当数组为<strong>静态变量</strong>时，在<strong>程序执行前</strong>便被初始化，缺省情况下为<strong>0</strong><br>数组为<strong>自动变量</strong>（存储在堆栈中），在缺省情况下<strong>无法被初始化</strong>（因为每次程序流经过堆栈，堆栈中变量的位置是不固定的）</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 被初始化后，每次执行流经过数组的作用域时，数组又会被初始化一次（因为之前在作用域结束后被销毁），所以，对于那些非常大的数组 ，可以考虑将其设为static，减少其初始化次数</div><p><strong>②不完整的初始化</strong></p><blockquote><p>缺少元素：<strong>优先填充前面的</strong>，缺少的被命名为0<br>缺少数组长度：编译器将其设置为刚好能够<strong>容纳所有初始值</strong>的大小</p></blockquote><p><strong>③字符数组的初始化</strong>:<code>char a[] = “b”</code>相当于<code>char a = {'b',0}</code></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有在初始化字符数组时“b”才代表一个初始化列表，其他场合都为字符串常量，如下，message1是一个字符数组，message2是一个指向字符串字面值的指针</div><pre class="line-numbers language-none"><code class="language-none">char message1[] = "hello";char *message2 = "hello";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3.4多维数组</strong><br><strong>①声明</strong>：<code>数据类型 数组名 [维度1][维度2]…[维度N]</code></p><blockquote><p><code>int a [3][6][9]</code>：可以解读为a数组有包含3个变量，这3个变量是个包含6个变量的数组，同时这6个变量又是包含9个变量的数组</p></blockquote><p><strong>②存储形式</strong>：按照<strong>最右边的下标</strong>率先变化，比如<code>int *b = &amp;a[1][3]</code>,<code>b++</code>为<code>a[2][0]</code><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_1.png" alt="a[3][4]"><br><strong>③数组名</strong>：类比一维数组，将n维数组看为一个<strong>元素是n-1维数组的一维数组</strong>，数组名即<strong>指向第一个n-1维数组的指针</strong></p><blockquote><p><code>int a[3][4]</code>，将其看成有三个包含四个元素的一维数组<br><code>a</code>：一个指向第一个包含<strong>四个整型元素的数组</strong>的指针<br><code>a+1</code>:指向的<strong>第二个四元素的一维数组</strong>的指针（指针的加减法法则是根据指针的类型决定的）<br><code>*(a+1)</code>：指向第二个包含四个元素数组的<strong>第一个整型元素的指针</strong>,注意这个还不是其中所包含的数据<br><code>*a+1</code>:指向第一个包含四个元素数组的第二个元素的指针<br><code>*(*a+1)</code>：为第一个包含四个元素数组的<strong>第二个元素</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一层一层解引用，n维数组要解引用n次，才能获得数据</div><p><strong>④多维数组的初始化</strong></p><blockquote><p>以二维数组为例<br><code>int a[][] = {元素1、元素2…};</code><br>定义后，通过<code>a[i][j] = 数值;</code>，一个一个赋值<br><code>int a[][] = {{数组1}，{数组2}…};</code> </p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 层层套娃</div><p><strong>3.5多维数组与指针</strong><br><strong>①指向数组的指针</strong>：<code>数组元素数据类型 (*指针名)[数组元素个数] = 二维数组名</code></p><blockquote><p><strong>下标引用的优先级比间接访问高</strong>，但是由于括号的存在，先执行的是间接访问，这样就将<code>p</code>定义为一个指针，<strong>它指向的对象进行下标引用得到的是一个整型</strong>，所以他是一个指向一维数组的指针，指向二维数组的第一行，该指针进行加法时，是<strong>以一个数组为单位移动</strong>的</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这里的数组元素个数与之对应，如int (*p)[4] = a;</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将数组传递给一个函数，本质上是传递一个对应的指针，对于多维数组，就是传递一个指向数组的指针，对应函数原型应写为`void func1(int (*a)[4])`或者`void func1(int a[][4])`</div><p><strong>②指向元素的指针</strong>：<code>数组元素数据类型 *p = &amp;数组名[0][0]</code>或者<code>数组元素数据类型 *p = 数组名[0]</code>（以二维数组为例）</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 注意后者是没有&amp;符号的，因为后者就是一个指向元素的指针！</div><p><strong>③指针数组</strong>：<code>数据类型* 数组名[个数]</code></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 与指向数组的指针仅仅只有一个括号之差</div><h3 id="4-结构"><a href="#4-结构" class="headerlink" title="4.结构"></a>4.结构</h3><p><strong>4.1格式</strong><br><strong>①定义</strong></p><pre class="line-numbers language-none"><code class="language-none">struct [结构类型名称]{结构成员表(每个成员的类型和名字);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 结构变量是标量类型，所以相同的结构变量可以相互赋值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将结构定义在一个头文件中，使用include包含即可</div><p><strong>②声明</strong>：<code>struct 结构类型名称 结构名</code></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用typedef关键字为结构定义新的名字</div><pre class="line-numbers language-none"><code class="language-none">typedef struct{结构成员表(每个成员的类型和名字);}[结构类型名称];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③初始化与赋值</strong>：<code>struct 结构名 变量名 = {成员1，成员2，成员3}</code></p><pre class="line-numbers language-none"><code class="language-none">struct X{int a;short b[3];simple c;};struct X x1 = {10,{1,2,3},{25,'x'}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④结构成员的访问</strong></p><blockquote><p><code>.</code>操作符：<code>结构名.成员名</code><br><code>-&gt;</code>操作符：<code>对应结构指针-&gt;成员名</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这两个操作符优先级相同，比*和[]高，结合性从左向右</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 假设px是结构x的指针，px指向的地址和结构第一个成员的地址是一样的，但是*px代表的是整个结构</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当结构需要作为函数参数时，可以传递该结构的指针，效率较高，可以用const关键词防止对结构体的修改</div><p><strong>4.2结构的引用</strong><br><strong>①结构的自引用</strong>：结构内部成员为自己本身是非法的，但是可以<strong>包含自己的指针类型</strong></p><pre class="line-numbers language-none"><code class="language-none">//非法，因为在声明next成员时，Node还有没被声明typedef struct{  ElemType data;  struct Node *next;}Node;//合法typedef struct Node{  ElemType data;  struct Node *next;}Node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为结构在定义时内存大小是不确定的，而结构指针的内存大小在结构创建前就已经确定</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意不能使用之前没有定义的结构标签</div><p><strong>②结构之间的引用</strong>：当需要定义几种之间<strong>存在联系</strong>的结构，可以采用不完整声明</p><pre class="line-numbers language-none"><code class="language-none">struct B; //B的不完整声明struct A{struct *B;};struct B{struct A;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意，A中不能以B为成员，只能以B的指针为成员，因为不完整声明导致B的大小不能确定</div><p><strong>4.3结构的存储分配</strong><br><strong>①</strong>正常情况下，编译器按照<strong>成员列表顺序</strong>一个一个给每个成员分配内存<br><strong>②</strong>当成员的存储需要满足正确的边界对齐条件，成员之间会出现未填充的内存空间</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 边界对齐：访问特定类型变量的时候经常在特定的内存地址访问</div><blockquote><p>假设一台机器的整型值长度为4字节，且要求其<strong>起始存储位置</strong>必须能被4整除，而结构的起始位置也必须满足<strong>成员中边界要求最严格</strong>的对齐条件，则以下结构在内存中的存储情况如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">struct X{char a;int b;char c;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_3.png" alt="内存分配情况"><br><strong>③对边界要求最严格的成员应该首先出现</strong>，这样可以<strong>节省内存</strong></p><pre class="line-numbers language-none"><code class="language-none">struct X{int b;char a;char c;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_4.png" alt="内存分配情况"><br><strong>④常用函数</strong>：<code>sizeof</code>可以得到一个结构的整体长度，<strong>包括因为边界对齐跳过的字节</strong>，<code>offsetof</code>可以确定结构中某个成员的位置（偏离结构存储起始位置的字节数）<br><strong>4.4位段</strong><br><strong>①声明格式</strong>：一种特殊的结构，成员必须是<code>int</code>、<code>signed</code>、<code>unsigned</code>类型，成员名后面是<strong>一个冒号和一个整数，该整数表示该成员占用的位的数目</strong></p><pre class="line-numbers language-none"><code class="language-none">struct WeiDuan{unsigned a : 7;unsigned b : 6;unsigned c : 19;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 位段可以将长度为奇数的数据包装在一起，并且可以访问一个整型值的部分内容（这些部分内容可能有特定的含义）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 显示的用signed和unsigned声明位段比较好，如果仅仅将位段声明为int类型，被解释为有符号数还是无符号数由编译器决定</div><p><strong>②位段的移植性问题</strong></p><blockquote><p>很多编译器将位段<strong>成员</strong>的长度限制在<strong>一个整型值</strong>之内，32位机器上可以使用的位段声明可能在16位机器上无法使用<br>位段的内存是<strong>从左向右</strong>分配还是<strong>从右向左</strong>分配由机器决定<br>当位段的<strong>总位数不是8的倍数时</strong>，其内存分配是否要“边界对齐”取决于编译器</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 任何使用位段实现的任务，都可以通过移位和屏蔽实现，但是会麻烦一些</div><p><strong>4.5联合</strong><br><strong>①声明格式</strong></p><pre class="line-numbers language-none"><code class="language-none">union{float f;int i;}fi;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>联合各个成员<strong>共用内存中的一个位置以及数据</strong>，当联合的某个成员被访问时，则将该联合所在位置的位以该成员类型解释被访问，换句话说，<strong>联合的各个成员决定了这些位是如何被解释的</strong></p></blockquote><p><strong>②联合的变体</strong>：联合各个成员的长度可以不同，比如说两个结构</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当联合中各个成员具有不同的长度，联合的长度就是它最长成员的长度</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当成员之间大小相差太大时，可以将联合的成员修改为不同数据类型的指针，这样就不会造成空间浪费</div><p><strong>③联合的初始化</strong></p><pre class="line-numbers language-none"><code class="language-none">union{int a;float b;char c[4];}x = {5};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 联合变量的初始值只有一个，且必须是联合第一个成员类型的数据</div><h3 id="5-动态内存分配"><a href="#5-动态内存分配" class="headerlink" title="5.动态内存分配"></a>5.动态内存分配</h3><p><strong>5.1内存分配</strong><br><strong>①</strong><code>malloc()</code>:从<strong>内存池</strong>中提取一块<strong>连续</strong>的内存，并返回一个<strong>指向这块内存的指针</strong>，如果内存池没有合适的内存则返回<strong>NULL</strong>，这块内存<strong>没有被初始化</strong></p><blockquote><p>格式：<code>p = malloc（size）;</code><br><code>malloc()</code>返回值是<code>void *</code>，可以转化为任何类型的指针<br><code>size</code>为需要分配的<strong>字节数</strong>，其类型是<code>size_t</code>，一个<strong>无符号类型</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> malloc()返回内存的起始位置始终满足边界对齐条件</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将size替换为n*sizeof（数据类型），n为数量，还可以提高程序的可移植性</div><p><strong>②</strong><code>calloc()</code>：和<code>malloc</code>一样用于分配内存，但是<code>calloc</code>会将内存内所有元素初始化为0，会消耗一定的时间</p><blockquote><p>格式：<code>p = calloc(num,size);</code><br>其中<code>num</code>为元素的个数，<code>size</code>为每个元素的大小，类型均为size_t</p></blockquote><p><strong>③</strong><code>realloc()</code>：<strong>修改</strong>一个已经分配的内存块的大小，新增加的内存添加到原先内存块的<strong>尾部</strong>，没有被初始化，如果用于缩小原来的内存块，则将<strong>尾部</strong>的内存块拿掉</p><blockquote><p>格式：<code>p = realloc(ptr,size);</code><br>其中<code>ptr</code>是需要调整大小的指针，<code>size</code>是调整后内存的大小</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> C语言中，void*可以赋值给其他类型指针，但是在其他语言如C++中不行，故最好在前面加一个强制类型转换</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若原先的内存块大小无法改变，则realloc会重新划分一块内存，并释放原来的内存，所以要使用realloc返回的指针</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 动态分配得到的指针是变量，但是我们不希望他改变，因为最后还需要释放掉，故有需要可以构建该指针的副本对内存进行操作</div><p><strong>5.2内存释放</strong>：当分配的内存不再使用时，需要使用<code>free()</code>将其释放<br><strong>①函数原型</strong>：<code>void free (void *pointer)</code><br><strong>②使用格式</strong>：<code>free (p)</code><br><strong>5.3常见错误</strong><br><strong>①</strong>对NULL指针进行解引用<br><strong>②</strong>对分配的内存操作时越界<br><strong>③</strong>释放并为动态分配的内存<br><strong>④</strong>释放动态内存的一部分<br><strong>⑤</strong>访问一块已经被释放的内存，尤其是当内存分配指针被备份时<br><strong>⑥</strong>内存释放不及时，导致内存泄漏</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核设计与实现（一）</title>
      <link href="/2023/06/23/linux-nei-he-she-ji-yu-shi-xian-yi/"/>
      <url>/2023/06/23/linux-nei-he-she-ji-yu-shi-xian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核设计与实现（一）"><a href="#Linux内核设计与实现（一）" class="headerlink" title="Linux内核设计与实现（一）"></a>Linux内核设计与实现（一）</h1><h2 id="Linux内核基础"><a href="#Linux内核基础" class="headerlink" title="Linux内核基础"></a>Linux内核基础</h2><h3 id="1-Unix和Linux"><a href="#1-Unix和Linux" class="headerlink" title="1.Unix和Linux"></a>1.Unix和Linux</h3><p><strong>1.1Unix系统特点</strong><br>①简洁：只有几百个系统调用且设计目的简单明确<br>②一切皆文件：对数据和设备的操作可以通过同一套接口完成<br>③C语言编写：移植能力强<br>④进程创建十分迅速，提供了一套十分简单稳定的进程间通信元语<br>#Linux是类Unix系统，没有直接使用Unix源码，但是<strong>设计理念一致</strong>且保证了<strong>应用程序编程接口的一致</strong><br><strong>1.2Linux和Unix的差异</strong><br>①Linux支持动态加载和卸载内核模块<br>②Linux支持对称多处理（SMP）机制<br>③linux内核可以抢占<br>④Linux不区分进程和线程<br>⑤Linux提供具有设备类的面向对象的设备模型、热插拔事件</p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p><strong>2.1内核空间</strong>：内核等相关程序运行的空间，拥有<strong>受保护的内存空间</strong>和访问硬件的<strong>所有权利</strong><br><strong>2.2用户空间</strong>：应用程序执行的空间，应用程序在用户空间只能看到系统允许他们使用的部分系统资源，只能使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划分给<strong>其他应用程序的内存空间</strong><br>#当内核运行时，系统以内核态进入内核空间，当用户程序运行时，系统以用户态进入用户空间<br><strong>2.3系统调用</strong>：应用程序通过系统调用陷入内核，应用程序调用库函数，库函数通过系统调用接口调用<strong>内核子系统/设备驱动程序</strong><br><strong>2.4单内核</strong>：内核以<strong>单个静态二进制文件</strong>的形式存放在磁盘中，运行在一个<strong>单独的地址空间</strong>上，内核之间的通信耗时可忽略不计<br><strong>2.5微内核</strong>：内核功能被划分为<strong>多个独立的过程</strong>，每个过程叫做一个<strong>服务器</strong>，每个服务器独立运行在<strong>各自的地址空间</strong>上，除了强烈要求特权服务的服务器运行在特权模式下，其他服务器运行在<strong>用户空间</strong>，每个服务器采用<strong>进程间通信机制</strong>沟通，可靠性更强，一个服务器出现问题不会祸及其他服务器，且服务器<strong>可以加载也可以卸载</strong><br>#Linux是<strong>单内核</strong>，但是汲取了微内核的精髓——模块化设计、抢占式内核、支持内核线程及动态装载内核模块</p><h3 id="3-Linux版本"><a href="#3-Linux版本" class="headerlink" title="3.Linux版本"></a>3.Linux版本</h3><p><strong>[主版本号].[从版本号].[修订版本号].[稳定版本号]</strong><br>#稳定版本号是偶数则是稳定版，反之为开发版</p><h3 id="4-简述编译内核"><a href="#4-简述编译内核" class="headerlink" title="4.简述编译内核"></a>4.简述编译内核</h3><p><strong>4.1获得内核源码</strong>：在<a href="http://www.kernel.org/">Linux内核官网</a>下载<br>①使用git clone和git pull获得内核源码<br>②自行下载安装，有bzip2和gzip两种形式，其中bzip2是默认和首选下载格式，采用tar命令解压，解压后的源码在linux-x.y.z.目录下（x.y.z.为Linux版本号）<br>③安装内核补丁进行版本的更迭<br><strong>4.2安装内核源码</strong>：系统本身的内核源码<strong>位于/usr/src/linux目录</strong>下，但是<strong>不能将该源码树用于开发</strong>，因为<strong>编译C库</strong>所用的内核版本链接到该棵树。应该建立<strong>自己的主目录</strong>，仅仅以<strong>root身份</strong>安装新内核到该目录，系统本身目录不进行任何更改<br><strong>4.3配置内核</strong>：将自己需要的<strong>特定功能和驱动程序</strong>编进内核（根目录下.config文件），常见内核配置工具如下<br>①make config<br>#遍历所有配置项，要求用户选择选项，耗时长，不推荐<br>②make menuconfig或者make gconfig<br>#图形界面，推荐<br>③make defconfig<br>#基于默认配置为你的体系结构创建一个配置<br>④make oldconfig<br>#根据.config文件生成/更新配置<br>#配置选项CONFIG_IKCONFIG_PROC将<strong>完整压缩</strong>的配置文件存放在/proc/config.gz下，可以采用zcat /proc/config.gz &gt; .config及make oldconfig克隆当前配置<br><strong>4.4编译内核</strong><br>①编译内核：make<br>②减少编译垃圾信息：make &gt; ../detritus或者make &gt; dev/null<br>#前者将编译信息重定向到该文件中，后者的/dev/null是个永无返回值的黑洞，但是警告和错误信息还是会打印出来<br>③将编译过程拆分为多个并行的作业：make -jn<br>#其中n为作业数，一般<strong>每个处理器上衍生出一两个作业</strong><br><strong>4.5安装新内核</strong>：根据启动引导工具的说明操作即可</p><h3 id="5-内核开发的特点"><a href="#5-内核开发的特点" class="headerlink" title="5.内核开发的特点"></a>5.内核开发的特点</h3><p><strong>5.1不能访问C库及标准C头文件</strong>:对于内核来说，C库<strong>太大且低效</strong>了<br>#不过大部分常用的C库函数在内核中已经得到了实现，比如string库对应&lt;linux/string.h&gt;<br>#基本的头文件位于内核源码树<strong>顶级目录的include目录</strong>下<br>#体系结构相关头文件位于arch/[architecture]/include/asm目录下,以asm为前缀，如&lt;asm/ioctl.h&gt;<br><strong>5.2必须使用GUN C</strong><br><strong>5.3没有内存保护机制</strong>：当内核自身发生了内存错误会导致oops<br>#内核中的内存<strong>不分页</strong><br><strong>5.4不要轻易使用浮点数</strong>：在内核中使用浮点数，不仅仅要人工保存和回复浮点寄存器，还需要一些繁琐的操作<br><strong>5.5容积小且固定的栈</strong>：内核栈大小随体系结构改变<br><strong>5.6同步和并发</strong>：内核的许多特性要求可以并发的访问共享数据，这就可能产生竞争<br><strong>5.7可移植性的重要性</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（一）</title>
      <link href="/2023/06/23/c-yu-yan-xue-xi-bi-ji-yi/"/>
      <url>/2023/06/23/c-yu-yan-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（一）"><a href="#C语言学习笔记（一）" class="headerlink" title="C语言学习笔记（一）"></a>C语言学习笔记（一）</h1><h2 id="C语言启蒙"><a href="#C语言启蒙" class="headerlink" title="C语言启蒙"></a>C语言启蒙</h2><h3 id="1-C语言程序组成简介"><a href="#1-C语言程序组成简介" class="headerlink" title="1.C语言程序组成简介"></a>1.C语言程序组成简介</h3><p><strong>1.1空白</strong>：换行、tab和空格键，使得程序更加美观<br><strong>1.2注释</strong>：解释程序，debug<br><strong>①单行注释</strong>：以<code>//</code>开始、以换行符结束<br><strong>②多行注释</strong>：以<code>/*</code>开始，以<code>*/</code>结束<br><strong>③预处理注释</strong>：用于注释<strong>包含注释</strong>的代码块</p><pre class="line-numbers language-none"><code class="language-none">#if 0  statement#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 多行注释不能嵌套，第一个/*到第一个*/之间都视为注释</div><p><strong>1.3预处理命令</strong><br><strong>①</strong><code>#include&lt;文件名&gt;</code>：将对应文件内容逐字写到对应位置<br><strong>②</strong><code>#define 变量名 值</code>：将变量名（<strong>大写</strong>）对应位置替换为对应值</p><p><strong>1.4函数原型（声明）</strong>：告诉编译器调用函数的特征（参数和返回值的个数和类型）</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果有一些函数声明经常需要使用，可以将他们的函数声明写到一个头文件中，再调用#include宏将该头文件写入即可</div><p><strong>1.5main函数</strong>：程序执行的<strong>起点</strong>和终点（无异常）</p><pre class="line-numbers language-none"><code class="language-none">int main (void){  statement;  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2.基本数据类型"></a>2.基本数据类型</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 基本数据类型有整型、浮点数、指针和聚合类型，这里只介绍整型和浮点型</div><p><strong>2.1整型</strong><br><strong>①类型：字符<code>char</code>、短整型<code>short int</code>、整型<code>int</code>和长整型<code>long int</code></strong></p><blockquote><p><code>char</code>本质上是一个小整型，占<strong>一个字节（8位）</strong><br><code>short int</code>至少占<strong>16位</strong>，<code>long int</code>至少占<strong>32位</strong>，<code>int</code>位数<strong>由编译器决定</strong>，通常是这种机器<strong>最为高效的位数</strong>，32位系统最可能是32位，64位系统最可能是64位，一些嵌入式系统可能是16位或者更小</p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 长整型≥整型≥短整型，但是他们能表示的范围是不同的</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在C11的标准中追加stdint.h避免了位数的不确定如：int32_t就是指4个字节的，int8_t就是一个字节</div><p><strong>②有符号数（signed）和无符号数（unsigned）</strong></p><blockquote><p>对于<code>int</code>、<code>short int</code>、<code>long int</code>来说，缺省情况下为<strong>有符号数</strong>，有符号可表示正负数和0，无符号只能表示正数<br>对于<code>char</code>来说，分为<code>char</code>、<code>singed char</code>和<code>unsigned char</code>，其中<code>char</code>的带符号与否<strong>取决于编译器</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了提高程序的可移植性，需要将char限制在其余两者的交集（0~127）内，且只对显式声明为有符号数和无符号数再对其进行数值运算</div><p><strong>③字面值：被初始化以后就不能改变</strong></p><blockquote><p><strong>整型字面值</strong>：在缺省情况下，字面值类型就是<strong>能表示</strong>该字面量的<strong>最短的类型</strong>，也可以通过<strong>添加后缀</strong>改变字面值的类型，一般采用十进制写法，也可采用其他进制（需要特殊前缀）<br><strong>字符型字面值</strong>：‘[内容]’，类型总是<code>int</code>，不能添加后缀改变<br><strong>字符串字面值</strong>：“[内容]”，以<code>NUL</code>字节结尾，所以内容中不能存在<code>NUL</code><br><strong>浮点数字面值</strong>：通常是<code>double</code>，可以通过后缀改变其类型</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在C语言中，没有显示的字符串类型，字符串被视为以NUL字节结尾的字符数组，字符串常量在表达式中实质上是该字符数组所在地址</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在ANSI C中，字符串常量不允许改变，如果需要修改字符串，把它存储于字符数组变量中</div><p><strong>④枚举类型</strong>：被命名的<strong>整型常数集合</strong>，枚举相当于其被赋予的整型字面值</p><blockquote><p>命名格式：<code>enum 枚举类型名{枚举1,枚举2,枚举3…} ；</code><br>如果不对枚举进行赋值，则枚举从0开始，依次增大1，如果对有的被赋值，有的没有，则没有被赋值的枚举<strong>比前者大1</strong></p></blockquote><p><strong>2.2浮点类型</strong><br><strong>①<code>float</code>单精度浮点数</strong><br><strong>②<code>double</code>双精度浮点数</strong><br><strong>③<code>long double</code>扩展精度浮点数，只有某些机器支持扩展精度</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ANSI C没有规定浮点类型的长度，long double≥doubl≥float，字面量在缺省情况下一般为double，除非在后面添加l、f后缀</div><h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h3><p><strong>3.1变量的声明</strong>：<code>说明符 声明表达式列表</code><br><strong>①说明符</strong>：用于指明变量的<strong>基本类型</strong>、<strong>存储类型</strong>和<strong>作用域</strong>，可以有一个，也可以有多个<br><strong>②声明表达式</strong>：声明/定义变量<br><strong>③声明以及定义</strong></p><blockquote><p><strong>声明</strong>：用于向程序表明变量的<strong>类型和名字</strong><br><strong>定义</strong>：用于为变量<strong>分配存储空间</strong>，还可为变量<strong>指定初始值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于int a;，如果a是全局变量的话就是声明，是局部变量的话就是定义</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以利用extern修饰局部变量表明是变量的声明，该关键词含义是此变量/函数是在别处定义的，要在此处引用</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明（extern）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 变量可以声明多次，而只能定义一次</div><pre class="line-numbers language-none"><code class="language-none">include &lt;stdio.h&gt;int a;int a;int main(){return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该程序正常工作</p></blockquote><pre class="line-numbers language-none"><code class="language-none">include &lt;stdio.h&gt;int main(){int a;    int a;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该程序由于<strong>重复定义</strong>错误</p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在声明变量时不要赋值，否则就是定义了</div><p><strong>④声明/定义的解释</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 变量的声明可以理解为，变量通过声明表达式的运算得到说明符，如int a[]可以理解为变量a通过下标运算得到一个整数，则a就是一个数组，本质上是一个指向整型的指针</div><p><strong>3.2typedef</strong><br><strong>①格式</strong>：只要在<strong>变量定义</strong>前面加上typedef，就成了类型定义，对应变量名即称为新的类型名<br>如<code>typedef int (*function_t) (int param);</code>，在这里<code>function_t</code>则称为了对应的函数指针的类型名<br><strong>②与define的区别</strong>：<code>define</code>只是简单的替换，如下，<code>a</code>被定义为一个指针，而<code>b</code>被定义为一个字符</p><pre class="line-numbers language-none"><code class="language-none">#define char* ptr_to_charptr_to_char a,b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在进行句法分析的时候，typedef和存储类型指示符是等价的，故该关键词不能和static等存储类型指示符一起用</div><p><strong>3.3const常量</strong>：使得变量被初始化后不得被更改<br><strong>①</strong><code>const</code>修饰指针时，需要注意<code>const</code>修饰的是指针还是指针指向的值</p><pre class="line-numbers language-none"><code class="language-none">int const *a：指针指向的值不能被修改int * const a：指针无法被修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②</strong><code>const</code>只能用于允许使用变量的地方，比如数组的大小就最好使用<code>define</code></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数中被const修饰的形参获得对应的实参的值后无法被改变，当你不希望函数改变该值时，可以使用const修饰该形参</div><p><strong>3.4作用域</strong>：变量只能在一定的区域中才能被访问，即变量<strong>能被访问的区域</strong><br><strong>①代码块作用域</strong>：在<strong>代码块中</strong>的变量</p><blockquote><p>代码块中变量的作用域<strong>于代码块开头开始，到代码块结尾结束</strong><br>在<strong>嵌套</strong>的代码块中，倘若内层有变量和外层某一个变量同名，则内层无法访问外层的对应变量（<strong>外层变量被覆盖，包括静态变量</strong>）<br><strong>非嵌套</strong>的代码块，每个代码块的变量无法被另一个代码块访问（<strong>代码块之间变量隔离</strong>）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在ANSI C中，函数形参的作用域在函数最外层代码块内（动态变量）</div><p><strong>②文件作用域</strong>：在<strong>函数外</strong>声明的变量都具有文件作用域（<code>extern</code>属性），从他们<strong>声明之处到所处源文件结尾</strong>都可以访问</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用include包含到该文件的变量属于文件作用域</div><p><strong>③原型作用域</strong>：只适用于<strong>函数原型（不是函数）</strong>中声明的参数名，只存在那个括号内<br><strong>④函数作用域</strong>：只适用于语句标签，一个函数中所有<strong>语句标签必须唯一</strong></p><p><strong>3.5链接属性</strong>：变量的链接属性决定如何处理在<strong>不同文件中的同名变量</strong><br><strong>①none（无）</strong>：只能在其<strong>所在代码块中</strong>被访问。<br><strong>②internal（内部）</strong>：<strong>同一个源文件</strong>中的所有同名变量都是同一个实体，可以在<strong>该源文件</strong>中被访问<br><strong>③external（外部）</strong>：<strong>所有源文件</strong>的所有同名变量是同一个实体，可以被所有源文件访问</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在缺省情况下，在函数外的链接属性为external，其余none</div><blockquote><p>可以用关键字<code>extern</code>和<code>static</code>修改标识符的链接属性<br><code>static</code>可以将<code>external</code>属性变量改为<code>internal</code>，<strong>使其为该源文件私有</strong>，防止其被其他源文件调用</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> static不能将none属性的变量改为internal</div><blockquote><p><code>extern</code>可以给标识符赋予<code>external</code>链接属性（只需要在声明处添加即可），则<strong>所有源文件都能访问该变量</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 拥有extern属性的变量在单个源文件中，从头到尾都可以访问，在有多个源文件时，其他源文件也可以访问</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意拥有extern属性的变量只是可以被其他文件访问，若要在其他源文件中使用，需要在使用的源文件中添加对应变量的声明（需要加上extern关键词）</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在多个文件中定义同名的全局变量会导致链接错误，因此建议在一个文件中定义一个全局变量，并通过extern关键字在其他文件中进行引用（可以声明在头文件中）</div><p>如果使用extern修饰局部变量的效果是什么？？？<br><strong>3.6存储类型</strong>（静态变量和全局变量的区别？？？？）<br><strong>①静态内存</strong>：在<strong>代码块之外</strong>声明的变量被称为<strong>静态变量</strong>，无法改变其存储类型，在<strong>程序运行之前</strong>创建，在程序的<strong>整个执行期间</strong>始终存在<br><strong>②堆栈</strong>：在<strong>代码块内</strong>声明的变量被称为<strong>动态变量</strong>，存储在<strong>堆栈</strong>中，当<strong>程序执行流到达该代码块时，才被创建，执行流离开该代码块时，该变量被销毁</strong>，当该代码块重复执行时（比如循环），<strong>内存位置不固定</strong><br><strong>③硬件寄存器</strong>：称为<strong>寄存器变量</strong>，<strong>访问效率更高</strong>，可以把<strong>高频使用</strong>的变量声明为寄存器变量，寄存器变量的<strong>生命周期和动态变量</strong>相同</p><blockquote><p>可以使用<strong>static</strong>关键字将<strong>动态变量</strong>转化为<strong>静态变量</strong>，其<strong>作用域不会改变</strong>，原先的值也不会改变，但是<strong>不能修饰形参</strong><br>使用<strong>register</strong>关键字将<strong>动态变量</strong>转化为<strong>寄存器变量</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 寄存器变量是一种请求，编译器可能忽略该请求，同时，当寄存器数量不足是，寄存器变量也可能转变为自动变量，且只要声明为寄存器变量，就不能对其取址</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 全局变量总是静态变量</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> static关键词用于函数定义或者修饰代码块外部的变量时，用于修改变量的链接属性，当修饰代码块内部的变量时，用于修改变量的存储类型</div><p><strong>3.7C程序内存分布</strong><br><strong>①代码段</strong>：存放<strong>程序执行代码</strong>的内存区域，在<strong>程序运行前</strong>就已经确定，同时其中也包括一些只读的常量<br><strong>②初始化数据段</strong>：存放<strong>已初始化的全局变量</strong>，在进程运行时静态分配<br><strong>③未初始化数据段</strong>：存放程序中<strong>未初始化的全局变量</strong>和<strong>静态变量</strong>，默认为0，在进程运行时静态分配<br><strong>④栈</strong>：按内存地址<strong>由高到低</strong>扩张，最大长度编译时确定，<strong>自动变量以及函数调用时所需的信息</strong>（如每次函数调用返回地址、寄存器的值）存放在此段。递归函数每次调用自身时，就会使用一个新的栈帧存放其数据。<br><strong>⑤堆</strong>：自由申请的空间，按内存地址<strong>由低到高</strong>方向扩张，其长度由系统内存/虚拟内存上限决定，通常在堆中进行<strong>动态存储分配</strong>。</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个线程都会有自己的栈，但是堆空间是共用的。</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 自动变量因为其地址只有在其创建时确定，故其缺省情况下的初始值是垃圾</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_2.png" alt="C程序内存分布"></p><h3 id="4-语句"><a href="#4-语句" class="headerlink" title="4.语句"></a>4.语句</h3><p><strong>4.1空语句</strong>：本身只包含一个分号，用于不需要操作但是<strong>语法要求</strong>出现一条完整语句的场合<br><strong>4.2表达式语句</strong>：意如其名，就是一个表达式，常见的表达式语句如下</p><blockquote><p>每个表达式语句都有其<strong>对应返回值</strong>，但是没有其他操作的情况下，该返回值<strong>不被保存</strong></p></blockquote><p><strong>4.3代码块</strong>：被一对花括号囊括的多条语句，在语法上相当于<strong>一条语句</strong><br><strong>4.4条件语句</strong></p><pre class="line-numbers language-none"><code class="language-none">if （expression）{statement;}else if (expression){statement;}else {statement；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>出现<code>if</code>嵌套时，<code>else</code>从句属于<strong>最靠近</strong>他的<strong>不完整</strong>的<code>if</code>从句</p></blockquote><p><strong>4.5循环语句</strong><br><strong>①while循环</strong></p><pre class="line-numbers language-none"><code class="language-none">while （expression）{statement;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②for循环</strong></p><pre class="line-numbers language-none"><code class="language-none">for （初始化语句; 条件语句;调整语句）{statement;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>初始化语句在循环一开始执行，条件语句在每一次循环开始之前执行，调整语句在每一次循环后执行</strong></p></blockquote><p><strong>③do while循环</strong></p><pre class="line-numbers language-none"><code class="language-none">do{statement;}while(expression);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>while语句相比，do while语句会先执行语句然后再判断条件是否成立</p></blockquote><p><strong>④switch循环</strong></p><pre class="line-numbers language-none"><code class="language-none">switch（expression）{    case expression_n：  statement；      break；    default：      statement；      break；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> expression的结果必须是整数，C语言中没有布尔类型，非零值为真，零值为假，缺省情况下，真值为1，假值为0</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在循环中可以使用break语句，用于永久终止循环，使用continue语句终止当前的循环</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若循环是嵌套的，则break和continue语句，只能终止其所在的循环</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 当执行到匹配到case语句后，执行流会一直往下直到switch语句结束(包括default子句)，所以要在每个case语句下添加break及时退出，同时这也是一种特性，可以加以利用</div><p><strong>4.6goto语句</strong></p><pre class="line-numbers language-none"><code class="language-none">biaoqian:goto biaoqian;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>标签就是标识符后面加一个冒号<br>可以通过goto语句跳出嵌套循环</p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 非必要不使用goto语句</div><h3 id="5-操作符"><a href="#5-操作符" class="headerlink" title="5.操作符"></a>5.操作符</h3><p><strong>5.1算术操作符</strong>：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>（取余）</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> /操作符只有当两个操作数都为整型时，才做整型运算，%只能接受两个整型</div><p><strong>5.2关系操作符</strong>：<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code>、<code>==</code><br><strong>5.3逻辑操作符</strong>：<code>&amp;&amp;</code>（与）、<code>||</code>（或）、<code>^</code>（异）、<code>！</code>（否）</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 短路求值，通过第一个操作数能判断结果就不会判断后面的操作数，且要求操作数均为整数</div><p><strong>5.4赋值操作符</strong>：<code>=</code><br><strong>①</strong>赋值表达式语句的<strong>返回值是左操作数的新值</strong>，所以可以连等<code>a=b=10</code><br><strong>②复合赋值符</strong>：比如<code>+=</code>，<code>a += （expression）</code>代表<code> a = a+（expression）</code></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当a比较复杂或者其中有需要编译器实时计算的项，采用复合赋值符可以提高效率</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 赋值语句，这样会使得左值丢失位数</div><p><strong>5.5条件操作符</strong>：<code>expression1 ？ expression2 ： expression3</code></p><blockquote><p>如果<code>expression1</code>值为真，则该表达式结果为<code>expression2</code>，反之为<code>expression3</code></p></blockquote><p><strong>5.6逗号操作符</strong>：<code>expression1,expression2,...,expressionN</code>,<code>expression</code>都会被求值，但是整个表达式的值是<strong>最后一个表达式</strong>的值<br><strong>5.7单目操作符</strong>：<code>&amp;</code>（取址）、<code>*</code>（引用）、<code>sizeof()</code>（判断类型长度）、<code>~</code>（求补，位取相反）、<code>++/--</code>（递增/递减）</p><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 强制类型转换的优先级非常高</div><p><strong>5.7移位操作符</strong><br><strong>①左移<code>&lt;&lt;</code><strong>：最左边的几位被丢弃，右边多出来的几位</strong>由0补齐</strong><br><strong>②右移<code>&gt;&gt;</code><strong>：可以选择两种移位方案，一种是</strong>逻辑移位</strong>，用<strong>0</strong>补充，一种是<strong>算数移位</strong>，补充的<strong>取决于符号数</strong>，对于<strong>无符号数</strong>，采用的都是<strong>逻辑移位</strong>，对于<strong>有符号数</strong>，采用逻辑移位还是算数移位<strong>取决于编译器</strong>，可能会影响程序的移植性</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 两边的操作数都必须是整型，需要移动的位数必须正数，且不能超过被操作数的位数</div><p><strong>5.8位操作符</strong>：对操作数的<strong>各个位</strong>执行逻辑运算（<code>&amp;</code>与，<code>|</code>或，异或<code>^</code>）</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 位操作符优先级比移位操作符高</div><p><code>value = value | 1 &lt;&lt; bit_number;</code>即将<code>bit_number</code>对应位置转换为1</p><p><strong>5.9左值和右值</strong>：左值就是可以出现在赋值符左边的东西，右值就是可以出现在赋值符右边的东西</p><blockquote><p>左值相当于一个<strong>容器</strong>，可以储存结果的地方，一个内存位置，右值则是一个<strong>可以被储存的数据</strong><br>变量<code>a</code>可以表示一个容器，也可以表示一个数据，<code>a+1</code>只能是一个数据\</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 左值是一个确切知道地址的容器</div><p><strong>5.10类型转换</strong><br><strong>①隐式类型转换</strong><br>在C中的整型算数运算总是以<strong>缺省整型类型精度</strong>进行的，所以操作数是<strong>字符型</strong>和<strong>短整型</strong>时，在使用之前会先被<strong>转化为普通整型</strong>再进行运算，如果要将结果存储到字符型和短整型中，则会将结果进行截短。<br><strong>②算数转换</strong><br>当多操作数进行运算时，且操作数属于不同的类型，则会<strong>将精度低的数据类型转化为精度高的数据类型进行运算</strong><br><strong>③强制类型转换</strong>:<code>(类型) [操作数/表达式]</code><br><code>int a = 5000；</code><br><code>int b = 25；</code><br><code>long c = a*b；</code></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在16位机器上，第三个算式可能会产生溢出，可以在运算前将 a、b中的一个或者两个转化为long即可<br>强制类型转换可能会导致精度的损失，因为位数不同</div><p><strong>5.11优先级和结合性</strong><br><strong>①优先级</strong>：标识运算符在表达式中的<strong>运算顺序</strong><br><strong>②结合性</strong>：当一个运算对象两侧运算符的<strong>优先级别相同时</strong>, 运算对象与运算符的结合顺序</p><blockquote><p>比如<code>*a++</code>，其中<code>*</code>和<code>++</code>为同一优先级，结合性为右到左，先进行<code>a++</code>，再进行<code>*(a++)</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 表达式的求值顺序不一定完全按照优先级和结合性求值，如c + --c，我们并不知道c是否是在执行了--c后再与其相加，结果取决于编译器，面对有副作用的操作符需要小心</div><h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h3><p><strong>6.1定义</strong>：一串以<code>'/0'</code>结尾的字符 </p><blockquote><p><code>'/0'</code>的位模式全为0，也叫<strong>NUL字节</strong>，是字符串的<strong>终止符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> NUL字节不是字符串的一部分，字符串长度不包括终止符的长度</div><p><strong>6.2基本操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含string.h头文件</div><p><strong>①</strong><code>strlen()</code>：<strong>测量字符串长度</strong>，即字符串包含的<strong>字符个数</strong></p><blockquote><p>该函数返回的长度的数据类型为<code>size_t</code>，是一个<strong>无符号数</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 两个无符号数a、b相互比较时，应该使用a&gt;b，而不是a-b&gt;0，因为无符号数运算结果为无符号数，无符号数永远大于0</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 大部分字符串相关函数都是根据终止符判断字符串长度，所以使用者要确保操作后字符串不会溢出，否则会缺少终止符</div><p><strong>②</strong><code>strcpy()</code>：<strong>复制字符串</strong>，但是如果复制的字符串长度<strong>超出了容器的限度</strong>，则会<strong>覆盖其后面的内存空间</strong></p><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 大部分字符串函数不允许两个数组参数重叠，否则函数的返回值是未定义的</div><p><strong>③</strong><code>strcat()</code>：<strong>连接字符串</strong>，将一个字符串添加到另一个字符串后面<br><strong>④</strong><code>strcmp()</code>：<strong>字符串比较</strong>，进行的是<strong>字典比较</strong></p><blockquote><p><strong>字典比较</strong>：对两个字符串的逐个字符从头进行比较，只要比较出一个字符大小即可判断结果，<code>'/0'</code>小于任何字符<br><strong>⑤长度受限的字符串函数</strong>：为了<strong>防止目标数组溢出</strong>，定义了对应函数的长度受限版本，接受一个长度参数，用于限制操作的字符个数，如<code>strncpy()</code></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 但是这些函数可能导致目标数组**不是以“/0”结尾**，可能会**导致程序崩溃**</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以在函数调用完后将字符数组的最后一个元素改为NUL</div><p><strong>6.3字符串查找</strong><br><strong>①字符查找</strong></p><blockquote><p><code>strchr()</code>：返回对应字符<strong>第一次</strong>出现的位置<br><code>strrchr()</code>：返回对应字符<strong>最后一次</strong>出现的位置<br><code>strpbrk()</code>：返回<strong>一组字符中任意一个字符</strong>第一次出现的位置<br><code>strtok()</code>：删除字符串中的所有<strong>标记字符</strong>，其第二个参数是一个字符串，也就是<strong>标记字符的集合</strong><br><strong>②字串查找</strong><br><code>strstr()</code>：返回<strong>子串</strong>第一次出现的起始位置</p></blockquote><p><strong>6.4字符操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含ctype.h头文件</div><p><strong>①字符分类</strong>：根据对应分类函数定义，判断该字符是否为该类型</p><blockquote><p><code>isspace()</code>：是否为空白字符<br><code>isdigit()</code>：是否为数字</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还有很多类似函数，可自行查询</div><p><strong>②字符转换</strong>：转换字符的大小写</p><blockquote><p><code>tolower()</code>：转换为小写形式<br><code>toupper()</code>：转化为大写形式</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 直接测试或者操纵字符可能会影响程序的移植性，比如if(ch&gt;='A' &amp;&amp; ch&lt;='Z')判断ch是否为大写字母，在使用EBCDIC字符集上的机器上将失败，但是使用isupper(ch)则无限制</div><p><strong>6.5内存操作</strong>：遇到<code>NUL</code>字节不会停止，用于<strong>处理内部包含NUL字节的数据</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法引言</title>
      <link href="/2023/11/14/xian-xing-jie-gou/"/>
      <url>/2023/11/14/xian-xing-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同样的问题，不同的方法效率不同，对于计算机的处理方法，主要有以下三个影响因素</div><p><strong>①数据的组织方式</strong></p><blockquote><p>如<strong>书架</strong>上<strong>书</strong>可以<strong>随便放</strong>，也可以<strong>分类放</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 前者方便存放，后者方便查找</div><p><strong>②空间利用率</strong></p><blockquote><p>如<strong>循环</strong>和<strong>递归</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 递归需要保存结束前所有函数调用的上下文</div><p><strong>③算法的巧妙程度</strong></p><blockquote><p>详情见<strong>实例</strong></p></blockquote><h4 id="1-2算法"><a href="#1-2算法" class="headerlink" title="1.2算法"></a>1.2算法</h4><p><strong>①定义</strong></p><blockquote><p>一个<strong>有限指令集</strong>，在接受一些<strong>输入</strong>后（<strong>也可能不接受输入</strong>），经过<strong>有限的步骤</strong>后，得到一定的<strong>输出</strong>，且能<strong>处理不合理输入</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每条指令不能有歧义，且在计算机处理范围内，不依赖任何具体实现手段</div><p><strong>②指标</strong></p><blockquote><p><strong>空间复杂度</strong><code>S(n)</code>：执行时<strong>占用存储单元的长度</strong></p></blockquote><blockquote><p><strong>时间复杂度</strong><code>T(n)</code>：执行时<strong>耗费的时长</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> n为问题的规模，即需要处理的数据的个数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常时间复杂度和空间复杂度并不能兼得，需要做出取舍</div><h4 id="1-3数据结构"><a href="#1-3数据结构" class="headerlink" title="1.3数据结构"></a>1.3数据结构</h4><p><strong>①定义</strong></p><blockquote><p><strong>数据对象</strong>在计算机中的<strong>组织方式</strong></p></blockquote><p><strong>②逻辑结构</strong></p><blockquote><p><strong>对象之间</strong>的相互关系</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要有集合结构、线性结构、树形结构和图结构</div><p><strong>③物理存储结构</strong></p><blockquote><p>在<strong>计算机中的存储方式</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要有连续存储和链式存储（地址不连续）</div><h4 id="1-4递归"><a href="#1-4递归" class="headerlink" title="1.4递归"></a>1.4递归</h4><p><strong>①定义</strong></p><blockquote><p><strong>递</strong>：程序不断<strong>调用自身</strong>，并设置一个<strong>终止条件</strong>，<strong>每次调用</strong>都更加<strong>靠近这个终止条件</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常终止条件是传入的参数为某一值，然后每次调用都靠近这个值</div><blockquote><p><strong>归</strong>：当<strong>触发终止条件</strong>，便从<strong>根据终止条件对应的值</strong>开始<strong>逐层返回</strong>，计算最终结果</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 终止条件对应的结果是一个确切的结果，否则无法完成递归</div><p><strong>②举例</strong></p><blockquote><p>计算从<code>1</code>到<code>n</code>的<strong>总和</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 递归的本质就是将问题分解为更小的子问题，天然适合处理分分治问题</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每次调用函数，都需要向栈中压入返回地址、参数等信息，直到返回才被释放，且由一定时间开销。所以递归的复杂度都较高</div><pre class="line-numbers language-none"><code class="language-none">int sum(int n){  //终止条件  if (n==1)      return 1;  //递  int jmp = sum(n-1);  //归  return n+jmp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_0.png" alt="递归过程"></p><h3 id="2-复杂度分析"><a href="#2-复杂度分析" class="headerlink" title="2.复杂度分析"></a>2.复杂度分析</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①复杂度估算</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 复杂度计算的是其随问题规模增大时的变化趋势，即T(n)/S(n)的函数渐进上界</div><blockquote><p><strong>函数渐进上界</strong>：对于<strong>函数</strong><code>T(n)</code>，若存在<strong>正实数</strong><code>c</code>和<strong>实数</strong><code>n0</code>，当<code>n &gt; n0</code>时，均有<code>T(n) &lt;= cf(n)</code>，则<code>f(n)</code>为其<strong>渐进上界</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由定义可知，渐进上界通常为函数的最高阶</div><p><strong>②算法相关空间</strong></p><blockquote><p><strong>输入空间</strong>：存储算法的<strong>输入数据</strong></p></blockquote><blockquote><p><strong>暂存空间</strong>：存储算法在<strong>运行过程</strong>中的<strong>变量</strong>、<strong>函数上下文</strong>等数据</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还可分为存储变量等数据的数据空间，保存调用函数上下文的的栈帧数据，以及保存编译后程序指令的指令空间</div><blockquote><p><strong>输出空间</strong>：存储算法的<strong>输出数据</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 调用的函数 */int func() {    // 执行某些操作...    return 0;}int algorithm(int n) // 输入空间{     const int a = 0;   // 数据空间（常量）    int b = 0;         // 数据空间（变量）    int c = func();    // 栈帧空间（调用函数）    return a + b + c;  // 输出空间}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2时间复杂度"><a href="#2-2时间复杂度" class="headerlink" title="2.2时间复杂度"></a>2.2时间复杂度</h4><p><strong>①估算思路</strong></p><blockquote><p>所有<strong>与n无关</strong>的部分看作<code>1</code>，因为其最后为<code>T(n)</code>的<strong>常数部分</strong></p></blockquote><blockquote><p><strong>与n有关</strong>的部分，将其分为<strong>多个独立部分</strong>，<strong>分别计算</strong>其复杂度，取其中<strong>最大的</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每种部分的复杂度不尽相同，需要自己分析，本质上是算其中基本语句的执行次数，如单层循环的复杂度为n</div><blockquote><p>如果有<strong>嵌套类型</strong>，先从<strong>最里层嵌套</strong>计算，<strong>每一层嵌套的复杂度相乘</strong>得到<strong>嵌套部分的复杂度</strong></p></blockquote><p><strong>②常见类型</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 以最差时间复杂度为例</div><blockquote><p><code>O(n^2)</code>：<strong>两层嵌套循环</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int quadratic(int n){    int count = 0;    // 循环次数与数组长度成平方关系    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            count++;        }    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(2^n)</code>：以下<strong>递归次数为n</strong>，每次递归都将<strong>一分为二</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 指数阶（递归实现） */int expRecur(int n){    if (n == 1)        return 1;    return expRecur(n - 1) + expRecur(n - 1) + 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(logn)</code>：以下只需要<strong>迭代logn次</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int logarithmic(float n){    int count = 0;    while (n &gt; 1) {        n = n / 2;        count++;    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(n!)</code>：以下<strong>循环n次</strong>，<strong>第一次</strong>循环<strong>分裂出n个</strong>，<strong>第二次</strong>循环<strong>每个都分裂出n-1个</strong>，依次类推</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 阶乘阶（递归实现） */int factorialRecur(int n) {    if (n == 0)        return 1;    int count = 0;    for (int i = 0; i &lt; n; i++) {        count += factorialRecur(n - 1);    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3空间复杂度"><a href="#2-3空间复杂度" class="headerlink" title="2.3空间复杂度"></a>2.3空间复杂度</h4><p><strong>①估算思路</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常只关心最差空间复杂度，其中最差指最差输入数据和峰值内存占用</div><blockquote><p>分别计算<strong>各个空间</strong>的<strong>空间复杂度</strong>，取<strong>最大值</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 空间复杂度的计算主要计算占用的内存数量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 其中递归函数需要注意栈帧空间的大小</div><blockquote><p>如下，<strong>迭代</strong>过程<strong>每次调用</strong>完就<strong>释放了栈帧空间</strong>，空间复杂度为<code>O(1)</code>，<strong>递归</strong>过程每次调用<strong>没有释放栈帧空间</strong>，故空间复杂度为<code>O(n)</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int func() {    // 执行某些操作    return 0;}/* 循环 O(1) */void loop(int n) {    for (int i = 0; i &lt; n; i++) {        func();    }}/* 递归 O(n) */void recur(int n) {    if (n == 1) return;    return recur(n - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②常见类型</strong></p><blockquote><p><code>O(n^2)</code>：构建<code>n*n</code>的<strong>矩阵</strong></p></blockquote><blockquote><p><code>O(2^n)</code>：构建<code>n</code>层的<strong>二叉树</strong></p></blockquote><hr><h3 id="3-经典算法实例"><a href="#3-经典算法实例" class="headerlink" title="3.经典算法实例"></a>3.经典算法实例</h3><blockquote><p><strong>最大子列和问题</strong>：给定<strong>N个整数</strong>的序列，求出其中<strong>连续n个子列和</strong>的<strong>最大值</strong>，其中<code>n≤N</code></p></blockquote><h4 id="3-1-暴力穷举法"><a href="#3-1-暴力穷举法" class="headerlink" title="3.1.暴力穷举法"></a>3.1.暴力穷举法</h4><p><strong>①基本思想</strong></p><blockquote><p>求出<strong>所有连续子列和</strong>，从中找出<strong>最大</strong>的子列和，<strong>时间复杂度</strong>为<code>O(n^3)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum1(int A[],int N){  int ThisSum,MaxSum = 0;  int i,j,k;  for (i=0;i&lt;=N;i++) #确定起点  {    for(j=i;j&lt;=N;j++) #确定终点    {      ThisSum=0;      for(k=i;k&lt;=j,k++) #将第i到第j个叠加到一起      {        ThisSum=ThisSum+A[k];      }      if(ThisSum&gt;MaxSum)      MaxSum=ThisSum;    }  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2改进的暴力穷举法"><a href="#3-2改进的暴力穷举法" class="headerlink" title="3.2改进的暴力穷举法"></a>3.2改进的暴力穷举法</h4><p><strong>①思想</strong></p><blockquote><p>基于上述算法做出了一定<strong>改进</strong>。计算子列和是在<strong>已经计算完成</strong>的子列和<strong>加上最新项</strong>更新获得，可以<strong>省去k循环</strong>，<strong>时间复杂度</strong>为<code>O(n^2)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum2(int A[],int N){  int ThisSum,MaxSum = 0;  int i,j;  for (i=0;i&lt;=N;i++)/*i是子列左端*/  {    ThisSum=0;    for(j=i;j&lt;=N;j++)/*j是子列右端*/    {      ThisSum=ThisSum+A[j];/*对于相同的i和不同的j，只需要在j-1的基础上累加最新项即可*/      if(ThisSum&gt;MaxSum)      MaxSum=ThisSum;    }  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3分而治之"><a href="#3-3分而治之" class="headerlink" title="3.3分而治之"></a>3.3分而治之</h4><p><strong>①思想</strong>：？<br><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100000int MaxofThreeNum (int a, int b, int c)  \\ 求三个数中得最大值{   int maxSum;    maxSum = a &gt; b ? a : b;    maxSum = maxSum &gt; c ? maxSum : c;    return maxSum;}int DivideConquer(int data[], int left, int right){    int mid;    int leftMaxSum, rightMaxSum;    int leftBoardSum, rightBoardSum;    int leftMaxBoardSum, rightMaxBoardSum;   /* 退出条件 */    if (left == right)         return data[left];/* “分的过程” */    mid = (left + right) / 2; //找到中分点        /* 递归求两边的最大值 */    leftMaxSum = DivideConquer(data, left, mid);  // 左边最大值    rightMaxSum = DivideConquer(data, mid + 1, right);  // 右边最大值     /* 跨越边界的最大值 := leftMaxBoardSum + rightMaxBoardSum  */     leftMaxBoardSum = data[mid];     leftBoardSum = 0;     for (int i = mid; i &gt;= left; i--) {        leftBoardSum += data[i];        if (leftBoardSum &gt; leftMaxBoardSum)            leftMaxBoardSum = leftBoardSum;     }   //左边界扫描    rightMaxBoardSum = data[mid + 1];    rightBoardSum = 0;    for(int i = mid + 1; i &lt;= right; i++) {        rightBoardSum += data[i];        if(rightBoardSum &gt; rightMaxBoardSum)            rightMaxBoardSum = rightBoardSum;    }  //有边界扫描     /* 治的过程，最大值为左边的最大值、右边最大值，跨越边界最大值之中的最大值 */    return MaxofThreeNum(leftMaxSum, rightMaxSum, leftMaxBoardSum + rightMaxBoardSum);}int MaxSubSeqSum(int data[], int num)  // 改变函数接口{    return DivideConquer(data, 0, num - 1);}int main(){    int num;    int data[MAXN] = {0};    scanf("%d",&amp;num);    for (int i = 0; i &lt; num; i++) {        scanf("%d", &amp;data[i]);    }    printf("%d", MaxSubSeqSum(data, num));    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-在线处理"><a href="#5-在线处理" class="headerlink" title="5.在线处理"></a>5.在线处理</h4><p><strong>①思想</strong></p><blockquote><p>一开始<strong>子列左端为A[0]<strong>，逐个</strong>向右累加</strong>，若当前子列和<strong>为负数则舍去</strong>，因为一个<strong>负的子列和部分只会使得子列和变小</strong>,算法时间复杂度为<code>O(n)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum4(int A[],int N){  int ThisSum,MaxSum = 0;  int i;  for (i=0;i&lt;=N;i++)/*i是子列左端*/  {    ThisSum=ThisSum+A[i];    if(ThisSum&gt;=MaxSum)    MaxSum=ThisSum;    else    ThisSum=0;  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图结构（下）</title>
      <link href="/2023/11/13/tu-jie-gou-xia/"/>
      <url>/2023/11/13/tu-jie-gou-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="图结构（下）"><a href="#图结构（下）" class="headerlink" title="图结构（下）"></a>图结构（下）</h2><h3 id="1-图的最短路径"><a href="#1-图的最短路径" class="headerlink" title="1.图的最短路径"></a>1.图的最短路径</h3><h4 id="4-1无权图单源最短路径"><a href="#4-1无权图单源最短路径" class="headerlink" title="4.1无权图单源最短路径"></a>4.1无权图单源最短路径</h4><p><strong>①思路</strong></p><blockquote><p>从起点出发，先找到和他距离为1的<strong>没有访问过</strong>的节点，然后在此基础上寻找距离为2的节点，以此类推，直到找到终点</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_22.png" alt="思路"><br><strong>②伪码描述</strong></p><blockquote><p>其中<code>dist</code>数组将没访问的节点与原点的距离设置为一个负数，可以同时起到<code>Visited</code>函数作用<br><code>path</code>记录的是最短路径中，当前节点的上一个节点信息</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_23.png" alt="伪码描述"></p><h4 id="4-2有权图单源最短路径"><a href="#4-2有权图单源最短路径" class="headerlink" title="4.2有权图单源最短路径"></a>4.2有权图单源最短路径</h4><p><strong>①思路</strong>：选定原点<code>s</code>，然后访问其<strong>邻接点</strong>，计算其路径长度并存储在<code>dist[]</code>中（<code>dist[]</code>记录的是原点<strong>经过已收录点</strong>到对应点的距离，初始值都为<strong>正无穷</strong>），选择一个<code>dist[]</code><strong>最小的未收录的点</strong>收录，随后访问收录点的<strong>未收录邻接点</strong>，更新<code>dist[]</code>，在更新的过程中，要注意新收录点可能会影响其邻接点的<code>dist[]</code>，即<strong>只经过旧收录点的路径不是最短的了</strong>，需要更新<code>dist[]</code>和<code>path[]</code>，以此类推，直到所有点都被收录。<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_24.png" alt="Dijkstra"><br><strong>②伪码描述</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_25.png" alt="伪码描述"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_26.png" alt="时间复杂度"></p><h4 id="4-3多源最短路算法"><a href="#4-3多源最短路算法" class="headerlink" title="4.3多源最短路算法"></a>4.3多源最短路算法</h4><p><strong>①思路</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_27.png" alt="Floyd"><br><strong>②伪码描述</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_28.png" alt="伪码描述"></p><h3 id="2-最小生成树"><a href="#2-最小生成树" class="headerlink" title="2.最小生成树"></a>2.最小生成树</h3><h4 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h4><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_29.png" alt="最小生成树"></p><h4 id="2-2贪心算法"><a href="#2-2贪心算法" class="headerlink" title="2.2贪心算法"></a>2.2贪心算法</h4><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_30.png" alt="贪心算法"></p><h4 id="2-3prim算法"><a href="#2-3prim算法" class="headerlink" title="2.3prim算法"></a>2.3prim算法</h4><p>①思路：先选择一个起点，选择其<strong>权重最小的邻接点</strong>并收录，随后选择<strong>已收录点</strong>的权重最小的邻接点，但是不能构成回路，以此类推，直到收录所有的点<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_31.png" alt="伪码描述"></p><h4 id="2-4Kruskal算法"><a href="#2-4Kruskal算法" class="headerlink" title="2.4Kruskal算法"></a>2.4Kruskal算法</h4><p>①思路：选择其中<strong>未被选择的权值最小的边</strong>（可以是多条）将顶点连接起来，以此类推，但是在过程中不能形成回路，直到收录了V-1条边<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_32.png" alt="伪码描述"></p><blockquote><p>回路的检查：一开始将所有顶点看作为独立集合，新加边就是合并集合，如果新加入的边的两边顶点已经是一个集合的了，则会形成回路</p></blockquote><h3 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h3><p><strong>6.1定义</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_33.png" alt="拓扑排序"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_34.png" alt="例子"><br><strong>6.2算法</strong><br>①思想：每次输出所有<strong>没有前驱节点</strong>的节点<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_35.png" alt="伪码描述"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_36.png" alt="算法改进"></p><h3 id="4-关键路径（项目管理问题）"><a href="#4-关键路径（项目管理问题）" class="headerlink" title="4.关键路径（项目管理问题）"></a>4.关键路径（项目管理问题）</h3><p><strong>7.1定义</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_37.png" alt="定义"><br><strong>7.2思路</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_38.png" alt="思路"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（下）</title>
      <link href="/2023/11/11/ji-suan-ji-wang-luo-xia/"/>
      <url>/2023/11/11/ji-suan-ji-wang-luo-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（二）"><a href="#计算机网络（二）" class="headerlink" title="计算机网络（二）"></a>计算机网络（二）</h1><h2 id="计算机网络进阶"><a href="#计算机网络进阶" class="headerlink" title="计算机网络进阶"></a>计算机网络进阶</h2><h3 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1.网络层"></a>1.网络层</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><p><strong>①任务</strong></p><blockquote><p>实现<strong>数据包</strong>在<strong>各个网络之间</strong>的传输</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通过IP数据报传递源IP地址和目的IP地址等信息</div><p><strong>②IP地址</strong></p><blockquote><p><strong>因特网</strong>给<strong>每台主机/路由器的每个接口</strong>分配的<strong>全世界</strong>范围内<strong>唯一的标识符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要分为网络号和主机号两部分，前者用于标识不同网络，后者用于标识网络下的不同接口</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 与MAC地址不同，传输过程中，源IP地址和目的ip地址始终保持不变</div><blockquote><p>如一个<strong>主机A</strong>经过<strong>路由B</strong>发送给<strong>主机C</strong>，<code>IP源地址:目的IP地址</code>在<strong>两段链路</strong>中均为<code>IPA:IPC</code></p></blockquote><p><strong>③地址解析协议APR</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 基于APR协议根据IP地址找到对应的MAC地址</div><blockquote><p><strong>每台主机</strong>都有一个<strong>APR高速缓存表</strong>，记录了<strong>其他主机</strong>的<strong>IP地址</strong>和<strong>MAC地址</strong>的<strong>对应关系</strong></p></blockquote><blockquote><p>若<strong>发送方</strong>无法在<strong>APR高速缓存表</strong>中<strong>根据IP地址</strong>到<strong>接受方</strong>的<strong>MAC地址</strong>，则发送<strong>请求报文</strong>给<strong>其他所有主机</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 请求报文包含了发送方的IP地址和MAC地址，以及接收方的IP地址</div><blockquote><p><strong>接收方</strong>接收到<strong>请求报文</strong>后，将<strong>发送方的IP地址和MAC地址</strong>记录到自己的<strong>APR高速缓存表</strong>中，并给其发送<strong>响应报文</strong>，<strong>发送方</strong>接受到<strong>响应报文</strong>后其<strong>记录</strong>下来并<strong>使用</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 响应报文包含接收方的IP地址和MAC地址</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> APR协议不能跨网络使用</div><h4 id="1-2IP地址应用"><a href="#1-2IP地址应用" class="headerlink" title="1.2IP地址应用"></a>1.2IP地址应用</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以IPv4地址为例</div><p><strong>①表示</strong></p><blockquote><p><strong>IPv4地址</strong>本质上是<strong>一串32位的比特</strong>，将<strong>每8位作为一组</strong>，转化为<strong>十进制</strong>并<strong>使用<code>.</code>隔开</strong></p></blockquote><p><strong>②编址方式</strong></p><blockquote><p><strong>分类编址</strong>：将<strong>IP地址</strong>分为<strong>几类</strong>，<strong>格式不同</strong>，分配给<strong>不同的接口</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要是网络号和主机号的占比不同，从而导致可指派的网络数量和每个网络可分配的IP地址不同</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 分类编址并不灵活，导致一些分类使用较少，使得地址无法被充分利用</div><blockquote><p><strong>划分子网</strong>：在<strong>分类编址的基础</strong>上，将<strong>主机号的一部分</strong>作为<strong>子网号</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 子网掩码的格式决定借用几位作为子网号</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_6.png" alt="子网掩码"></p><blockquote><p><strong>无分类编址</strong>：在<strong>IPv4地址后</strong>加上<code>/[数字]</code>，标识<strong>网络号前缀所占比特数量</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 依旧通过子网掩码计算对应的网络号</div><p><strong>③应用规划</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将IPv4地址块划分为几个小的地址块分配给不同网络</div><blockquote><p><strong>定长的子网掩码</strong>：使用<strong>同一个子网掩码</strong>划分子网</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个子网所分配的IP地址数量相同，容易造成IP地址的浪费</div><blockquote><p><strong>变长的子网掩码</strong>：使用<strong>不同子网掩码</strong>划分子网</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根据每个网络所需的IP地址数量决定主机号位数，从而决定子网掩码的格式</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 子网掩码只是一种划分方法</div><h4 id="1-3IP数据报的传递"><a href="#1-3IP数据报的传递" class="headerlink" title="1.3IP数据报的传递"></a>1.3IP数据报的传递</h4><p><strong>①路由器</strong></p><blockquote><p><strong>路由器</strong>的<strong>不同接口</strong>连接<strong>不同网络</strong>，接口的<strong>IP地址</strong>也被称为<strong>默认网关</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个路由器都会在路由表中记录其接口的IP地址，即与其相连的网络信息，并将这些信息传递给与之相连的路由器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 路由器详细记录自身的接口的IP地址信息，粗略记录与之相连的路由器接口的IP地址信息</div><blockquote><p><strong>路由聚合</strong>：记录<strong>其他路由器</strong>的<strong>信息</strong>时，寻找其路由表<strong>所有表项的共同前缀</strong>，并记录在<strong>一个表项中</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_7.png" alt="路由聚合"><br><strong>②过程概述</strong></p><blockquote><p>若<strong>发送方</strong>和<strong>接收方</strong>处于<strong>同一网络</strong>，<strong>直接转发</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将发送方和接收方IP地址与一方地址掩码相与，若结果相同，则两者在同一网络</div><blockquote><p>若两者<strong>不在同一网络</strong>，则在<strong>路由表</strong>中查找<strong>目的网络</strong>，将其<strong>转发</strong>到对应<strong>接口/路由器</strong>，从而传递到<strong>对应网络</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将目的地址，和表项的地址掩码相与，若结果和表项网络地址一致，则找到目的网络</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_8.png" alt="IP数据报的传递"></p><h4 id="1-4路由选择协议"><a href="#1-4路由选择协议" class="headerlink" title="1.4路由选择协议"></a>1.4路由选择协议</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了实现信息在路由器之间传递，需要向路由表中填充信息，包含目的网络地址、对应接口和辅助信息</div><blockquote><p><strong>静态路由配置</strong>：<strong>人工配置</strong>网络路由</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 开销小，但是不能及时适应网络状态变化，一般只在小规模网络中使用</div><blockquote><p><strong>动态路由配置</strong>：通过<strong>路由选择协议</strong>自动获取<strong>路由信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将因特网分为多个自治系统AS，系统内采用内部网关协议进行路由选择，系统之间采用外部网关协议进行路由选择</div><p><strong>②路由信息协议RIP</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种内部网关协议，将路由器到直连网络的距离定义为1，到非直连网络的距离定义为经过的路由器数目加一</div><blockquote><p><strong>一开始</strong>，路由器只知道<strong>自己到直连网络的距离</strong>为<code>1</code></p></blockquote><blockquote><p><strong>每个路由器</strong>和<strong>相邻路由器</strong>周期性<strong>交换信息</strong>并<strong>更新路由表</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当接收到的路由信息中，有新的/更好的路由信息，则添加/替换</div><blockquote><p>经过<strong>若干次交换和更新</strong>后，<strong>每个路由器</strong>都知道<strong>到达本AS内各个网络的最短距离</strong>和<strong>下一跳地址</strong></p></blockquote><p><strong>③开放最短路径优先OSPF协议</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种内部网关协议，用某一指标（距离、带宽和时延等）描述链路</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为了适应更大的网络，可以将AS划分为更小的区域进行管理</div><blockquote><p><strong>每个路由器</strong>都会记录其<strong>相邻路由器</strong>，并通过<strong>周期性发送问候分组</strong>维护</p></blockquote><blockquote><p><strong>每个路由器</strong>将其到<strong>直连网络</strong>和<strong>邻居路由器</strong>的<strong>链路状态（LSA）</strong>发送给<strong>其他所有路由器</strong></p></blockquote><blockquote><p><strong>每个路由器</strong>都有一个<strong>数据链路状态库LSDB</strong>存储<strong>LSA</strong>，最后<strong>LSDB</strong>将存储<strong>所有链路信息</strong></p></blockquote><blockquote><p><strong>每个路由器</strong>基于<strong>LSDB</strong>进行<strong>最短路径优先</strong>计算，构建出<strong>各自到达其他路由器的最短路径</strong>，从而构建各自的<strong>路由表</strong></p></blockquote><p><strong>④边界网关协议BGP</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种外部网关协议，由于不同的AS路由度量标准不一，只能尽力寻找一条能达到目的AS的相对较好的路由</div><blockquote><p><strong>每个AS</strong>都有<strong>一个路由器</strong>作为<strong>BGP发言人</strong>，<strong>不同的AS</strong>通过各自的<strong>BGP发言人</strong>连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> BGP发言人除了运行BGP协议，还需要运行其所在AS的内部网关协议</div><blockquote><p><strong>BGP发言人</strong>之间通过建立<strong>TCP连接</strong>交换<strong>路由信息</strong>，并从中找出<strong>到达各自自治系统</strong>的<strong>不存在回路</strong>的路由</p></blockquote><h4 id="1-5虚拟专用网"><a href="#1-5虚拟专用网" class="headerlink" title="1.5虚拟专用网"></a>1.5虚拟专用网</h4><h3 id="2-运输层"><a href="#2-运输层" class="headerlink" title="2.运输层"></a>2.运输层</h3><h4 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h4><p><strong>①任务</strong></p><blockquote><p>为运行在<strong>不同主机</strong>上的<strong>进程</strong>提供直接的<strong>通信服务</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 网络通信的最终实体还是进程而非主机</div><p><strong>②端口号</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于不同操作系统的进程标识符不同，故统一采用16比特的端口号区分不同进程</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 端口号只有本地意义，不同计算机的相同端口号没有联系</div><blockquote><p><strong>熟知端口号</strong>：<code>0~1023</code>，分配给了TCP/IP体系中<strong>最重要的应用协议</strong>，如<strong>HTTP</strong>使用<code>80</code>，<strong>DNS</strong>使用<code>53</code></p></blockquote><blockquote><p><strong>登记端口号</strong>：<code>1024~49151</code>，为<strong>没有熟知端口号</strong>的<strong>应用程序（windows桌面应用）</strong>使用，需要<strong>在IANA机构登记</strong>以防止重复</p></blockquote><blockquote><p><strong>短暂端口号</strong>：<code>49152~65535</code>，留给<strong>客户进程（如浏览器）</strong>选择<strong>短暂使用</strong>，</p></blockquote><p><strong>③UDP和TCP</strong></p><blockquote><p><strong>UDP协议</strong>：支持<strong>单播</strong>、<strong>多播</strong>和<strong>广播</strong>，可以<strong>随时</strong>发送数据，提供<strong>不可靠传输</strong>服务</p></blockquote><blockquote><p><strong>TCP协议</strong>：<strong>仅仅</strong>支持<strong>单播</strong>，需要<strong>先建立连接</strong>然后<strong>发送数据</strong>，<strong>发送完数据</strong>后还需要<strong>释放连接</strong>，提供<strong>可靠传输</strong>服务</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> UDP以应用报文为单位进行封装，而TCP将应用报文划分为多个字节流，从发送缓存取出一部分或全部字节进行封装</div><p><strong>④TCP报文段首部格式</strong></p><blockquote><p><strong>源端口</strong>：标识<strong>发送</strong>TCP报文段的<strong>进程</strong></p></blockquote><blockquote><p><strong>目的端口</strong>：标识<strong>接收</strong>TCP报文段的<strong>进程</strong></p></blockquote><blockquote><p><strong>序号</strong>：指出TCP报文段<strong>数据载荷第一个字节</strong>的<strong>序号</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该序号指的时其再所有数据中的位置，而不是在TCP报文段的位置</div><blockquote><p><strong>确认号</strong>：指出<strong>期望接收</strong>到对方<strong>下一个TCP报文段的数据载荷第一个字节的序号</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同时也是对之前受到数据的确认，若确认号为n，表示序号为n-1前的数据都被正确接收</div><blockquote><p><strong>ACK</strong>：当该位为<code>1</code>，<strong>确认号有效</strong>，若为<code>0</code>，则<strong>无效</strong></p></blockquote><blockquote><p><strong>SYN</strong>：TCP<strong>建立连接</strong>时<strong>同步序号</strong></p></blockquote><blockquote><p><strong>FIN</strong>：用于<strong>释放TCP连接</strong>，为<code>1</code>时表示为<strong>TCP连接释放报文段</strong></p></blockquote><blockquote><p><strong>RST</strong>：用于<strong>复位TCP连接</strong>，为<code>1</code>时表示<strong>TCP连接出现异常</strong>，需要<strong>释放连接并重新建立</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> RST置1还可用于拒绝一个非法的报文段或者拒绝打开一个TCP连接</div><blockquote><p><strong>窗口</strong>：指出<strong>发送方</strong>的<strong>接收窗口长度</strong></p></blockquote><blockquote><p><strong>填充字段</strong>：由于有些内容<strong>长度可变</strong>，需要使用填充<strong>使报文段首部能被4整除</strong></p></blockquote><h4 id="2-2TCP连接"><a href="#2-2TCP连接" class="headerlink" title="2.2TCP连接"></a>2.2TCP连接</h4><p><strong>①创建</strong></p><blockquote><p><strong>被请求方</strong>首先<strong>创建传输控制块</strong>，随后进入<strong>监听状态</strong>，称为<strong>被动打开连接</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用于存储TCP连接的重要信息，如TCP连接表等</div><blockquote><p><strong>请求方</strong>建立<strong>传输控制块</strong>，随后发送<strong>TCP连接请求报文段</strong>，并进入<strong>同步已发送状态</strong>，称为<strong>主动打开连接</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> TCP连接请求报文段SYN被置为1，表明为TCP连接请求报文段，不能携带数据，序号初始化为x</div><blockquote><p><strong>被请求方</strong>接收到<strong>TCP连接请求报文段</strong>后，如果<strong>同意建立连接</strong>，则发送<strong>TCP连接请求确认报文段</strong>，进入<strong>同步已接收状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段SYN和ACK置为1，确认号为x+1，表示对TCP连接请求报文段的确认，序号初始化为y</div><blockquote><p><strong>请求方</strong>接收到<strong>TCP连接请求确认报文段</strong>后，发送<strong>二次确认报文段</strong>，进入<strong>连接建立状态</strong>，<strong>被请求方</strong>接收到<strong>二次确认报文段</strong>之后也进入<strong>连接建立状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段ACK置为1，确认号为y+1，表示对TCP连接请求确认报文段的确认，序号被设为x+1</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二次确认报文段用于防止失效的TCP连接请求报文段突然又传送到被接受方，导致其进入同步已接受状态，引发错误</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_9.png" alt="TCP连接的建立"><br><strong>②释放</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 两方都可释放连接，以请求方主动释放连接为例</div><blockquote><p><strong>请求方</strong>发送<strong>TCP连接释放报文段1</strong>，进入<strong>终止等待1状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段FIN，ACK置1，声明其为TCP连接释放报文段1，设置序号u以及确认号为v</div><blockquote><p><strong>被请求方</strong>接收到<strong>TCP连接释放报文段1</strong>之后，发送<strong>TCP确认报文段1</strong>，并进入<strong>关闭等待状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段ACK置1，设置序号v以及确认号u+1</div><blockquote><p><strong>请求方</strong>接收到<strong>TCP确认报文段1</strong>之后，进入<strong>终止等待2状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 此时被请求方还能向请求方发送数据</div><blockquote><p><strong>被请求方完成数据通信</strong>，进程通知其<strong>释放连接</strong>，发送<strong>TCP连接释放报文段2</strong>，并进入<strong>最后确认状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段FIN，ACK置1，设置序号w，因为可能又发送了一些数据，设置确认号u+1，对一开始的重复确认</div><blockquote><p><strong>请求方</strong>接收到<strong>TCP连接释放报文段2</strong>后，发送<strong>TCP确认报文段</strong>，等待<strong>2倍MSL时间</strong>后进入<strong>关闭状态</strong>，<strong>被请求方</strong>接收到<strong>TCP确认报文段2</strong>后进入<strong>关闭状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段ACK置1，设置序号u+1以及确认号w+1，对TCP连接释放报文段2进行确认</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> MSL为最长报文寿命，等待这么长时间防止确认报文段丢失</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_11.png" alt="TCP连接的释放"></p><h4 id="2-3TCP功能"><a href="#2-3TCP功能" class="headerlink" title="2.3TCP功能"></a>2.3TCP功能</h4><p><strong>①流量控制</strong></p><blockquote><p><strong>控制</strong>发送方的<strong>发送速率</strong>，<strong>便于</strong>接收方<strong>接收</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 接收方根据自己接收窗口的大小动态调整发送方的发送窗口，只有落入发送窗口的数据可以被发送</div><p><strong>②拥塞控制</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 拥塞指网络中某一资源供不应求，会导致网络的性能下降，使用拥塞窗口限制发送窗口大小</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 发送窗口通常取拥塞窗口和接收窗口的小值</div><blockquote><p><strong>慢开始</strong>：<strong>一开始</strong>,<strong>拥塞窗口</strong>大小为<code>1</code>，并随着<strong>发送轮次</strong>的<strong>增大</strong>而<strong>指数级增大</strong></p></blockquote><blockquote><p><strong>拥塞避免</strong>：当<strong>拥塞窗口</strong>增大到<strong>慢开始门限</strong>，不再<strong>指数级增长</strong>，改为<strong>线性增长</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当重传计时器超时，即视为拥塞，慢开始门限变为拥塞时拥塞窗口的一半，并将拥塞窗口变为1，重新开始以上流程</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 然后，重传计时器超时可能并不代表拥塞，而是对应报文丢失，会降低网络的性能</div><blockquote><p><strong>快重传</strong>：<strong>接收方</strong>一旦<strong>接收到数据</strong>就<strong>立即</strong>发送对应的<strong>确认分组</strong>，即使收到了<strong>失序的分组</strong>，当<strong>重复</strong>收到<strong>同一个分组的三个确认分组</strong>，<strong>立即重传</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 排除了其他原因导致的重传计时器超时</div><blockquote><p><strong>快恢复</strong>：执行<strong>快重传</strong>后，<strong>慢开始门限</strong>和<strong>拥塞窗口</strong>调整为<strong>当前窗口的一半</strong>，并执行<strong>拥塞避免算法</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_10.png" alt="拥塞控制"><br><strong>③超时重传</strong></p><blockquote><p><strong>重传时限</strong>最好<strong>略大于</strong>数据的<strong>往返时间RTT</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同数据经过的网络不同，往返时间也不同，将每次测量的到的RTT样本加权计算并更新平均往返时间RTT</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 报文段重传会导致样本失效，若仅仅丢弃该样本，可能导致重传时限无法更新导致被反复重传</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 所以每次报文段重传适当增大重传时限</div><p><strong>④可靠传输</strong></p><blockquote><p><strong>发送方</strong>：只有落入<strong>发送窗口</strong>的<strong>字节</strong>才能被<strong>发送</strong>，当收到了<strong>新的确认分组</strong>，<strong>发送窗口后沿向前移动</strong>到<strong>确认号位置</strong>，若<strong>重复收到三次同样的确认号</strong>，则<strong>重发对应的字节</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 发送窗口前沿会受到后沿和窗口大小的影响，可能向前移动，不动甚至是收缩</div><blockquote><p><strong>接收方</strong>：只有落入<strong>接收窗口</strong>的<strong>字节</strong>才能被<strong>接收</strong>，每当<strong>收到数据</strong>，会发送<strong>确认分组</strong>，确认号为<strong>最小的失序字节序号</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 易知可靠传输主要依靠接收方的确认分组实现，所以除了每次收到数据，每隔一段时间也要发送确认分组</div><h3 id="3-应用层"><a href="#3-应用层" class="headerlink" title="3.应用层"></a>3.应用层</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①任务</strong></p><blockquote><p>通过<strong>应用进程的交互</strong>，实现<strong>特定网络应用</strong>，也是<strong>设计和建设计算机网络</strong>的<strong>最终目的</strong></p></blockquote><p><strong>②进程关系</strong></p><blockquote><p><strong>客户/服务器方式</strong>：进程分为<strong>客户端</strong>和<strong>服务器端</strong>，<strong>客户端</strong>向<strong>服务器端请求服务</strong>，<strong>服务器端收到请求后</strong>为其<strong>提供服务</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 服务器端总是处于运行状态，并具有固定的端口号，等待客户端的请求</div><blockquote><p><strong>对等方式</strong>：各个进程是<strong>对等的</strong>，既<strong>请求服务</strong>，也<strong>提供服务</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可扩展性好，成本低</div><h4 id="3-2域名系统DNS"><a href="#3-2域名系统DNS" class="headerlink" title="3.2域名系统DNS"></a>3.2域名系统DNS</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将域名转化为IP地址，这样就可以通过便于记忆的域名寻找对应主机了</div><p><strong>①域名结构</strong></p><blockquote><p>由<strong>多级域名</strong>组成，<strong>级别越低</strong>的域名写在<strong>越左边</strong>，使用<code>.</code><strong>隔开</strong></p></blockquote><blockquote><p><strong>顶级域名</strong>：<strong>国家顶级域名</strong>、<strong>通用顶级域名</strong>和<strong>反向域</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如cn表示中国，com表示企业公司，org表示非营利性组织</div><blockquote><p><strong>二级域名</strong>：由<strong>国家自行决定</strong>，我国将其分为<strong>类别域名</strong>和<strong>行政区域名</strong>两大类</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二级域名以下还能层层划分，表现为一种树形结构</div><p><strong>②域名服务器</strong></p><blockquote><p><strong>根域名服务器</strong>：记录所有<strong>顶级域名服务器</strong>的<strong>域名</strong>以及<strong>IP地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二级域名以下还能层层划分，表现为一种树形结构</div><blockquote><p><strong>顶级域名服务器</strong>：记录再<strong>该顶级域名服务器</strong>注册的所有<strong>二级域名</strong></p></blockquote><blockquote><p><strong>权限域名服务器</strong>：记录<strong>某个区域</strong>的<strong>所有主机</strong>的域名</p></blockquote><blockquote><p><strong>本地域名服务器</strong>：当<strong>一个主机</strong>发出<strong>DNS请求</strong>时，先传送到<strong>本地域名服务器</strong>，由其<strong>转发</strong>到<strong>以上三种服务器</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本地域名服务器起到代理的作用，需要直接配置在使用该域名服务器的主机上</div><p><strong>③工作原理</strong></p><blockquote><p>当访问<strong>域名</strong>时，<strong>用户主机</strong>会在<strong>自己的DNS高速缓存</strong>中寻找域名<strong>对应的IP地址</strong></p></blockquote><blockquote><p>若没有，发送<strong>DNS查询报文</strong>给<strong>本地域名服务器</strong>，<strong>本地域名服务器</strong>在<strong>上述三种域名服务器</strong>找到<strong>对应域名</strong>后返回给<strong>主机</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本地域名服务器向上层的查询方式可分为递归查询和迭代查询两种，递归查询代价太大，简单介绍迭代查询</div><blockquote><p><strong>本地域名服务器</strong>先向<strong>根域名服务器</strong>查询，得到对应的<strong>顶级域名服务器</strong>地址，随后从对应<strong>顶级域名服务器</strong>获得对应<strong>权限域名服务器</strong>地址，最后从<strong>权限域名服务器</strong>查找到<strong>目的域名的IP地址</strong></p></blockquote><h4 id="3-3电子邮件"><a href="#3-3电子邮件" class="headerlink" title="3.3电子邮件"></a>3.3电子邮件</h4><p><strong>①组成</strong></p><blockquote><p><strong>用户代理</strong>：<strong>用户</strong>与<strong>电子邮件系统</strong>的接口，即<strong>客户端软件</strong></p></blockquote><blockquote><p><strong>邮件服务器</strong>：<strong>电子邮件系统</strong>的<strong>基础设施</strong>，用于<strong>发送</strong>和<strong>接收邮件</strong>，并<strong>维护用户的邮箱</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 邮件服务器可以看做为多个邮箱的集合</div><p><strong>②工作原理</strong></p><blockquote><p><strong>发送方</strong>使用<strong>用户代理</strong>通过<strong>邮件发送协议</strong>向<strong>发送方邮件服务器</strong>发送邮件</p></blockquote><blockquote><p><strong>发送方邮件服务器</strong>通过<strong>邮件发送协议</strong>向<strong>接收方邮件服务器</strong>发送邮件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 常用的邮件发送协议为SMTP，两方建立TCP连接后，通过SMTP命令和应答报文段实现通信</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> SMTP协议只能传送ASCLL码文本数据，不能传送二进制对象</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过MIME协议将非ASCLL码数据转化为ASCLL码数据，再使用SMTP协议进行传输</div><blockquote><p><strong>接收方</strong>使用<strong>用户代理</strong>通过<strong>邮件接收协议</strong>从<strong>接收方邮件服务器</strong>读取邮件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 邮件读取协议有POP和IMAP，前者只能从邮件服务器下载文件，后者可以在自己的计算机上操控邮件服务的邮箱</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若发送时采用了MIME，接收时也需要使用MIME将ASCLL码文本数据转化为非ASCLL码文本数据</div><h4 id="3-4万维网"><a href="#3-4万维网" class="headerlink" title="3.4万维网"></a>3.4万维网</h4><p><strong>①引言</strong></p><blockquote><p><strong>定义</strong>：一个<strong>大规模</strong>、<strong>联机式</strong>的<strong>信息储藏所</strong>，是运行在因特网上的一个<strong>分布式应用</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> HTML文档描述网页的结构和内容，CSS文档描述网页的样式，JavaScript文档控制网页的行为</div><blockquote><p><strong>网页基本组成</strong>：<strong>HTML文档</strong>、<strong>CSS文档</strong>、<strong>JavaScript文档</strong>以及一些<strong>资源文件（如图片）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> HTML文档描述网页的结构和内容，CSS文档描述网页的样式，JavaScript文档控制网页的行为</div><blockquote><p><strong>URL资源定位符</strong>：指明<strong>资源的位置</strong>，<strong>格式</strong>为<code>[协议]://[主机]:[端口]/[路径]</code></p></blockquote><p><strong>②HTTP协议</strong></p><blockquote><p><strong>定义</strong>：万维网<strong>客户端</strong>和<strong>服务端</strong>的<strong>通信格式</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 客户端和服务端首先建立TCP连接，客户端向服务端发送请求报文，服务端返回响应报文</div><blockquote><p><strong>请求报文</strong>：主要由<strong>一个请求行</strong>和<strong>多个首部行</strong>组成，以<strong>换行结尾（很少会在换行后跟实体主体）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 请求行指明方法、URL和HTTP版本，首部行指明请求细节</div><blockquote><p><strong>响应报文</strong>：由<strong>一个状态行</strong>和<strong>多个首部行</strong>，以<strong>换行结尾（有时会在换行后跟实体主体）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 状态行表明返回结果，如接受请求、请求错误或找不到页面等，首部行和请求报文对应</div><p><strong>③工作原理</strong></p><blockquote><p>在<strong>浏览器中输入域名</strong>，<strong>客户端</strong>和<strong>服务端</strong>建立<strong>TCP连接</strong>，客户端发送<strong>HTTP请求报文</strong>给对应的<strong>服务端</strong>，<strong>服务端</strong>返回<strong>HTTP响应报文</strong>，<strong>浏览器</strong>对<strong>HTTP响应报文</strong>进行<strong>解析</strong>，获得<strong>网站内容</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 浏览器的内核是渲染引擎，不同浏览器的显示效果不同</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将最近的一些请求和响应存放在web缓存中，若新请求与web缓存某请求相同，直接返回对应的响应，不再建立连接</div><p><strong>④Cookie</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对无状态的HTTP进行状态化</div><blockquote><p>当<strong>用户</strong>的浏览器进程<strong>首次</strong>向<strong>某网页服务端</strong>发送<strong>HTTP请求报文</strong>，<strong>该网页服务端</strong>会创建一个<strong>cookie识别码</strong>并<strong>记录用户访问该网站的各种信息</strong></p></blockquote><blockquote><p><strong>该网页服务端</strong>通过<strong>HTTP响应报文</strong>传回该<strong>Cookie识别码</strong>，<strong>客户端</strong>将其记录在对应的<strong>Cookie文件</strong>中</p></blockquote><blockquote><p>下次用户<strong>再访问该网页</strong>，会向<strong>HTTP请求报文</strong>中添加对应的<strong>Cookie识别码</strong>，<strong>网页服务端</strong>识别<strong>Cookie识别码</strong>后<strong>根据记录信息</strong>返回<strong>特定的网页</strong></p></blockquote><h4 id="3-5其他常见协议"><a href="#3-5其他常见协议" class="headerlink" title="3.5其他常见协议"></a>3.5其他常见协议</h4><p><strong>①动态主机配置协议DHCP</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 各个主机从DHCP服务器请求IP地址、子网掩码、默认网关等网络配置信息</div><blockquote><p><strong>DHCP客户端</strong>广播发送<strong>DHCP发现报文</strong>，其中包含<strong>事务ID</strong>和<strong>客户端的MAC地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为DHCP客户并不知道网络中有多少个DHCP服务器，故广播发送</div><blockquote><p><strong>DHCP服务器端</strong>接收到<strong>DHCP发现报文</strong>之后，根据<strong>客户端的MAC地址</strong>查找从<strong>数据库</strong>中查找对应的<strong>配置信息</strong>，如果<strong>没有找到</strong>则采用<strong>默认配置信息</strong>，并<strong>广播</strong>发送<strong>DHCP提供报文</strong>，其中包含<strong>事务ID</strong>和<strong>网络配置信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 服务端会采用ARP协议检测分配的IP是否被占用再分配</div><blockquote><p><strong>客户端</strong>接收<strong>DHCP提供报文</strong>，并根据<strong>事务ID</strong>判断<strong>是否属于自己</strong>，若属于，则<strong>接收并使用</strong>其中<strong>配置信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若网络中有多个DHCP服务端，则可能受到多个DHCP提供报文，选择最先到达的</div><blockquote><p><strong>DHCP客户端</strong>广播发送<strong>DHCP请求报文</strong>，其中包含<strong>事务ID</strong>、<strong>客户端的MAC地址</strong>和<strong>选择的服务端的IP地址</strong>等信息</p></blockquote><blockquote><p><strong>选择的DHCP服务端</strong>广播发送<strong>DHCP确认报文</strong>，<strong>客户端</strong>接收后就<strong>可以使用相关网络配</strong>置了</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 服务端向客户端发送报文均采用广播发送，因为直到现在客户端才有自己的IP地址</div><p><strong>②文件传送协议FTP</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件有存取权限</div><blockquote><p><strong>FTP客户端</strong>和<strong>FTP服务端</strong>建立<strong>TCP连接</strong>，并传输<strong>FTP相关控制命令</strong></p></blockquote><blockquote><p>当两者<strong>有数据需要传输时</strong>，再<strong>另外</strong>建立一个<strong>TCP连接</strong>作为<strong>数据通道</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> FTP常常用于在计算机之间批量传输文件，如XFTP软件</div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 《计算机网络自顶向下》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（五）</title>
      <link href="/2023/11/10/shu-ju-jie-gou-yu-suan-fa-wu/"/>
      <url>/2023/11/10/shu-ju-jie-gou-yu-suan-fa-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法（五）"><a href="#数据结构与算法（五）" class="headerlink" title="数据结构与算法（五）"></a>数据结构与算法（五）</h1><h2 id="树形结构（下）"><a href="#树形结构（下）" class="headerlink" title="树形结构（下）"></a>树形结构（下）</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h3><h4 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种满足特殊条件的完全二叉树，常使用数组实现，便于访问根节点，即堆顶</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 堆常用于实现优先队列，大顶堆相当于元素按从大到小顺序出队的优先队列</div><blockquote><p><strong>大顶堆</strong>：<strong>任意节点</strong>的值<strong>大于</strong>其<strong>子节点</strong>的值</p></blockquote><blockquote><p><strong>小顶堆</strong>：<strong>任意节点</strong>的值<strong>小于</strong>其<strong>子节点</strong>的值</p></blockquote><h4 id="1-2堆的实现"><a href="#1-2堆的实现" class="headerlink" title="1.2堆的实现"></a>1.2堆的实现</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以最大堆为例</div><p><strong>①基本操作</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 获取左子节点索引 */int left(MaxHeap *maxHeap, int i) {    return 2 * i + 1;}/* 获取右子节点索引 */int right(MaxHeap *maxHeap, int i) {    return 2 * i + 2;}/* 获取父节点索引 */int parent(MaxHeap *maxHeap, int i) {    return (i - 1) / 2;}/* 访问堆顶元素 */int peek(MaxHeap *maxHeap) {    return maxHeap-&gt;data[0];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②元素入堆</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(logn)</div><blockquote><p>先将其<strong>添加到堆底</strong>，即<strong>底层最靠右的节点</strong></p></blockquote><blockquote><p>比较其和<strong>父节点的关系</strong>，若<strong>不满足</strong>堆的定义，则<strong>交换两者</strong>位置，直到<strong>满足</strong>或者<strong>到达根节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 也称为从低至顶堆化</div><pre class="line-numbers language-none"><code class="language-none">/* 元素入堆 */void push(MaxHeap *maxHeap, int val) {    // 默认情况下，不应该添加这么多节点    if (maxHeap-&gt;size == MAX_SIZE) {        printf("heap is full!");        return;    }    // 添加节点    maxHeap-&gt;data[maxHeap-&gt;size] = val;    maxHeap-&gt;size++;    // 从底至顶堆化    siftUp(maxHeap, maxHeap-&gt;size - 1);}/* 从节点 i 开始，从底至顶堆化 */void siftUp(MaxHeap *maxHeap, int i) {    while (true) {        // 获取节点 i 的父节点        int p = parent(maxHeap, i);        // 当“越过根节点”或“节点无须修复”时，结束堆化        if (p &lt; 0 || maxHeap-&gt;data[i] &lt;= maxHeap-&gt;data[p]) {            break;        }        // 交换两节点        swap(maxHeap, i, p);        // 循环向上堆化        i = p;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③元素出堆</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(logn)</div><blockquote><p>交换<strong>堆顶元素</strong>和<strong>堆底元素</strong>，并弹出<strong>堆底元素</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 不直接弹出堆顶元素，否则所有节点的索引都会发生变化</div><blockquote><p>比较<strong>堆顶元素</strong>和其<strong>子节点</strong>，将其和<strong>最大的子节点</strong>交换，直至<strong>遇到叶节点</strong>或者<strong>满足最大堆的条件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 也称为从顶至底堆化</div><pre class="line-numbers language-none"><code class="language-none">/* 元素出堆 */int pop(MaxHeap *maxHeap) {    // 判空处理    if (isEmpty(maxHeap)) {        printf("heap is empty!");        return INT_MAX;    }    // 交换根节点与最右叶节点（即交换首元素与尾元素）    swap(maxHeap, 0, size(maxHeap) - 1);    // 删除节点    int val = maxHeap-&gt;data[maxHeap-&gt;size - 1];    maxHeap-&gt;size--;    // 从顶至底堆化    siftDown(maxHeap, 0);    // 返回堆顶元素    return val;}/* 从节点 i 开始，从顶至底堆化 */void siftDown(MaxHeap *maxHeap, int i) {    while (true) {        // 判断节点 i, l, r 中值最大的节点，记为 max        int l = left(maxHeap, i);        int r = right(maxHeap, i);        int max = i;        if (l &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[l] &gt; maxHeap-&gt;data[max]) {            max = l;        }        if (r &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[r] &gt; maxHeap-&gt;data[max]) {            max = r;        }        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出        if (max == i) {            break;        }        // 交换两节点        swap(maxHeap, i, max);        // 循环向下堆化        i = max;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④堆的建立</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为0(n)</div><blockquote><p>将各元素<strong>无序添加</strong>到堆中，以<strong>层序遍历的倒序（即自底向上）</strong>遍历节点，<strong>依次</strong>将所有<strong>非叶节点从顶至底堆化</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 堆化节点后，以该节点为根节点的子树就形成一个合法的子堆，自底向上遍历保证当前节点的子树已经是合法的子堆</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是利用分治，将整个堆分为根节点和左子堆和右子堆，以此类推，分到最后就是父节点和左右儿子节点的比较</div><pre class="line-numbers language-none"><code class="language-none">/* 构造函数，根据切片建堆 */MaxHeap *newMaxHeap(int nums[], int size) {    // 所有元素入堆    MaxHeap *maxHeap = (MaxHeap *)malloc(sizeof(MaxHeap));    maxHeap-&gt;size = size;    memcpy(maxHeap-&gt;data, nums, size * sizeof(int));    for (int i = parent(maxHeap, size - 1); i &gt;= 0; i--) {        // 堆化除叶节点以外的其他所有节点        siftDown(maxHeap, i);    }    return maxHeap;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3TOPk问题"><a href="#1-3TOPk问题" class="headerlink" title="1.3TOPk问题"></a>1.3TOPk问题</h4><blockquote><p>给定一个<strong>长度为n</strong>的<strong>无序数组</strong><code>nums</code>，请返回数组中<strong>前k大</strong>的元素。</p></blockquote><p><strong>①遍历选择</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nk)</div><blockquote><p>进行<strong>k轮遍历</strong>，<strong>每轮</strong>从中提取第<code>1、2...k</code>大的元素</p></blockquote><p><strong>②排序</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nlogn)</div><blockquote><p>先对<strong>数组</strong><code>nums</code>进行<strong>排序</strong>，再返回<strong>最右边的k个元素</strong></p></blockquote><p><strong>③堆排序</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nlogk)</div><blockquote><p>将数组的<strong>前k个元素</strong>依次<strong>入堆</strong>，并<strong>堆化为小顶堆</strong></p></blockquote><blockquote><p>从<strong>第k+1个元素</strong>开始，若当前元素<strong>大于堆顶元素</strong>，则将<strong>堆顶元素出堆</strong>，并将<strong>当前元素入堆</strong></p></blockquote><h3 id="3-哈夫曼树"><a href="#3-哈夫曼树" class="headerlink" title="3.哈夫曼树"></a>3.哈夫曼树</h3><p><strong>3.1定义</strong>：最优二叉树，即每个<strong>叶子结点</strong>到根节点的带权路径长度之和最小<br><strong>3.2构造</strong><br><strong>①总体思想</strong>：将所有节点按照大小排序（可以用堆的方法），每次把权值最小的两棵二叉树合并，比如说1、2、3、4、5，合并一次变为3（1、2）、3、4、5，然后变为6（3（1、2）、3）、4、5，以此类推<br><strong>②代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_14.png" alt="哈夫曼树的构造"><br><strong>3.3哈夫曼编码</strong>:为了使得出现频率高的字符编码短些，出现频率低的字符编码长些，可以将哈夫曼树的节点路径看作为1和0，左节点为0，右节点为1，<strong>编码长度就是路径长度</strong>，按照字符出现频率构造哈夫曼树即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_13.png" alt="哈夫曼编码"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeoVim工作流</title>
      <link href="/2023/11/10/neovim-gong-zuo-liu/"/>
      <url>/2023/11/10/neovim-gong-zuo-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="NeoVim"><a href="#NeoVim" class="headerlink" title="NeoVim"></a>NeoVim</h1><h2 id="NeoVim工作流"><a href="#NeoVim工作流" class="headerlink" title="NeoVim工作流"></a>NeoVim工作流</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1NeoVim安装"><a href="#1-1NeoVim安装" class="headerlink" title="1.1NeoVim安装"></a>1.1NeoVim安装</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以Ubuntu系统为例</div><blockquote><p>在<strong>命令行</strong>中输入<code>sudo snap install nvim --classic</code>即可，下载完后，输入<code>nvim</code>即可打开<strong>NeoVim</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用snap能下载到最新版本，或者自己去官网下载</div><h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeoVim编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技能大作用</title>
      <link href="/2023/11/10/xiao-ji-neng-da-zuo-yong/"/>
      <url>/2023/11/10/xiao-ji-neng-da-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="小技能大作用"><a href="#小技能大作用" class="headerlink" title="小技能大作用"></a>小技能大作用</h1><h2 id="容易被人忽视的小技能"><a href="#容易被人忽视的小技能" class="headerlink" title="容易被人忽视的小技能"></a>容易被人忽视的小技能</h2><h3 id="1-信息检索"><a href="#1-信息检索" class="headerlink" title="1.信息检索"></a>1.信息检索</h3><h4 id="1-1搜索语法"><a href="#1-1搜索语法" class="headerlink" title="1.1搜索语法"></a>1.1搜索语法</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要介绍谷歌的搜索语法，因为谷歌目前最准确</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 搜索语法主要是一些限制性语句，用于精准定位</div><p><strong>①关键词限制</strong></p><blockquote><p><code>intitle:[关键词]</code>：<strong>标题</strong>需要包含对应<strong>关键词</strong></p></blockquote><blockquote><p><code>allintitle:[关键词1] [关键词2]...[关键词n]</code>：同上，<strong>标题</strong>需要<strong>同时</strong>包含<strong>多个关键词</strong></p></blockquote><blockquote><p><code>intext:[关键词1] [关键词2]...[关键词n]</code>：<strong>文章内容</strong>中必须<strong>同时</strong>包含对应<strong>关键词</strong></p></blockquote><blockquote><p><code>inurl:[关键词]</code>：<strong>链接</strong>必须包含的<strong>关键词</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这些关键词也可以使用英文双引号""进行限制，表示关键词连续完整出现，否则可能是同音字和近义词等</div><p><strong>②其他限制</strong></p><blockquote><p><code>site:[完整的域名]</code> ：限制<strong>来源网址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 与inurl不同，增加该限制后，来源网址是唯一的</div><blockquote><p><code>imagesize[长x宽]:[lenthxwidth]</code>:限制<strong>图片大小</strong></p></blockquote><blockquote><p><code>filetype:[文件后缀]</code>：限制<strong>文件格式</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 关键词之间以及限制选项之间需要使用空格隔开</div><h4 id="1-2资源网站"><a href="#1-2资源网站" class="headerlink" title="1.2资源网站"></a>1.2资源网站</h4><blockquote><p><strong>搜索引擎</strong>：google</p></blockquote><blockquote><p><strong>报告</strong>：199it.com</p></blockquote><blockquote><p><strong>学术论文</strong>：谷歌学术、scihub</p></blockquote><blockquote><p><strong>电子书</strong>：zlibarary、鸠摩搜书</p></blockquote><blockquote><p><strong>视频</strong>：coursera、youtube</p></blockquote><blockquote><p><strong>素材</strong>：pexels、piaxbay</p></blockquote><blockquote><p><strong>网盘搜索引擎</strong>：如<strong>百度云盘</strong>的<strong>盘搜搜</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以在save.tube上从其中对应网站下载高清素材，且有版权的网站都有对应的下载器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 直接谷歌xx行业必逛的网站、best xxx sites或者在similarsites中输入域名找相似网站</div><h4 id="1-3在线工具"><a href="#1-3在线工具" class="headerlink" title="1.3在线工具"></a>1.3在线工具</h4><blockquote><p><strong>canva</strong>：一款<strong>在线设计</strong>工具，可以制作<strong>海报</strong>、<strong>视频</strong>和<strong>概念图</strong>等</p></blockquote><blockquote><p><strong>remove</strong>：<strong>抠图</strong></p></blockquote><blockquote><p><strong>腾讯智影</strong>：<strong>文字转语音</strong></p></blockquote><blockquote><p><strong>clipchamp</strong>：<strong>在线剪辑视频</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/11/07/pai-xu-suan-fa/"/>
      <url>/2023/11/07/pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 默认按照从小到大排序</div><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p><strong>1.1思路</strong>：从头比较相邻的两个元素，如果两个元素满足设定的大小关系，则不变，反之则调换位置，这样可以把最小/大的元素放在末尾，随机再对n-1个元素再次使用冒泡排序，总共重复n-1次<br><strong>1.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_39.png" alt="冒泡排序"></p><blockquote><p>其中<code>flag</code>的作用就是判断是否已经排序好</p></blockquote><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><p><strong>2.1思路</strong>：类似于打扑克理牌的过程，一开始我们手里有一张牌，即<code>A[0]</code>，随后从A[1]开始往手里加牌，和<strong>手里的牌的最后一位</strong>（即<code>A[P-1]</code>）开始向前比较，如果比新牌大，则交换新牌和他的位置，直到找到新牌的位置（即前一张牌小于新牌）<br><strong>2.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_40.png" alt="插入排序"></p><blockquote><p>注意中间变量的作用</p></blockquote><h3 id="3-希尔排序（改进的插入排序）"><a href="#3-希尔排序（改进的插入排序）" class="headerlink" title="3.希尔排序（改进的插入排序）"></a>3.希尔排序（改进的插入排序）</h3><p><strong>3.1逆序对</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_41.png" alt="逆序对"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_42.png" alt="改进思路"><br><strong>3.2思路</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_43.png" alt="基本思路"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_44.png" alt="不足"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_45.png" alt="改进"></p><h3 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4.选择排序"></a>4.选择排序</h3><p><strong>4.1思路</strong>：首先找到全部元素中的最小元素，放在最前面，然后再找到剩余元素的最小元素，放在第二位，以此类推<br><strong>4.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_46.png" alt="选择排序"></p><h3 id="5-堆排序（改进的选择排序）"><a href="#5-堆排序（改进的选择排序）" class="headerlink" title="5.堆排序（改进的选择排序）"></a>5.堆排序（改进的选择排序）</h3><p><strong>5.1思路</strong>：选择排序的瓶颈主要是如何<strong>快速找到最小元</strong>，所以可以采用最小堆来找到最小元素<br><strong>5.2代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_47.png" alt="堆排序"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_48.png" alt="改进的堆排序"></p><blockquote><p>改进的堆排序将数组调整为最大堆，然后将根节点和最后元素交换，然后将最大元素排除在外，重复以上步骤</p></blockquote><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><p><strong>6.1思路</strong>：主要采用的是<strong>分而治之</strong>的思想，将整个序列一直二分，直到将其分为最小单元即只有两个单元，然后将其转化为有序子列并成为新的最小单元，以此类推，直到整个序列都被排序</p><blockquote><p>两个<strong>有序子列</strong>的合并：已知两个有序子列，以及一个足够容纳两个子列的空容器，首先比较两个子序列的第一个位置上的元素，选择较小的那个放进容器，然后被选择的子序列的位置向后挪一位，以此类推完成排序<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_49.png" alt="有序子列的归并"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_50.png" alt="有序子列的归并代码实现"><br><strong>6.2代码实现</strong><br><strong>①递归实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_51.png" alt="递归实现"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_52.png" alt="统一接口"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_53.png" alt="注意事项"><br><strong>②非递归实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_54.png" alt="非递归实现"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_55.png" alt="统一接口"></p></blockquote><h3 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 小规模数据采用简单排序（如插入排序），大规模数据采用快速排序</div><p><strong>7.1思路</strong>：挑选一个主元，将序列分为大于该主元和小于该主元的两部分，然后在对这两部分实施上述类似的操作</p><blockquote><p>快速排序可以保证在划分子集后，主元所在位置都是它<strong>最终的正确位置</strong></p></blockquote><p><strong>7.2代码实现</strong><br><strong>①主元的选取</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_56.png" alt="主元的选取"></p><blockquote><p>这样选取主元之后，<code>Right</code>和<code>Left</code>元素都不用考虑了</p></blockquote><p><strong>②子集划分</strong>：如下图，选取后的主元为6，考虑中间的元素（理由见上），最左端和最右端都有一个指针，当左端（右端）指针指向元素小于（大于）主元时，向右（左）移动指针，<strong>反之则停下，当两边指针都停下时交换对应元素</strong>，随后继续迭代，当左端指针大于右端时，交换主元和左端指针位置，完成子集划分<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_57.png" alt="子集划分——开始"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_58.png" alt="子集划分——结束"><br><strong>③算法主体</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_59.png" alt="快速排序"></p><h3 id="8-基于表排序的物理排序"><a href="#8-基于表排序的物理排序" class="headerlink" title="8.基于表排序的物理排序"></a>8.基于表排序的物理排序</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 之前的算法都需要频繁地交换元素，对于元素较大的序列效率较差，可以先进行表排序，减少交换元素的次数</div><p><strong>8.1表排序</strong>：不直接排序元素本身，而是排序其指针（位置），需要一个新的数组存储<strong>排序后的位置</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_60.png" alt="表排序"><br><strong>8.2物理排序</strong>：进行完表排序后，发现其排列组成了若干个独立的环，如下图所示，<code>table[0]</code>→<code>A[3]</code>→<code>table[3]</code>→<code>A[1]</code>→<code>table[1]</code>→<code>A[5]</code>→<code>table[5]</code>→<code>A[0]</code>→<code>table[0]</code>形成了一个独立的环，分别调整这些环，将环的一项拆除（将对应的数据存到临时变量中），并根据其<code>table[]</code>的值将对应数据放入其中，**并将其<code>table[i]</code>改为对应的<code>i</code>**，表示这个数据的位置是调整过的，直到空位<code>table[]</code>对应位置满足<code>table[i]==i</code>，表示环结束，将存在临时变量中的数据存到对应空位中。<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_61.png" alt="物理排序"></p><h3 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9.基数排序"></a>9.基数排序</h3><p><strong>9.1桶排序</strong>：建立一个<strong>指针数组</strong>，每个指针对应一个<strong>链表</strong>，每个链表代表一种情况，将符合该情况的数据插入该链表即可，排序完后依次从每个桶中提取数据即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_62.png" alt="桶排序"><br><strong>9.2基数排序</strong>：实际上就是多次的桶排序，如下例，一个三位数如果将每一个数都看作为一种情况，则需要1000个桶，不划算，可以每次只看三位数的某一位，假设从个位数看到百位数，则只需要十个桶，看三次即可，第一次将个位数符合情况的插入到各个桶中，<strong>根据第一次桶排序的顺序</strong>，观察其十位数，插入到对应的桶中，以此类推，观察完所有特征即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_63.png" alt="基数排序"><br><strong>9.3多关键字排序</strong><br><strong>①主位优先</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_64.png" alt="主位优先"><br><strong>②次位优先</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_65.png" alt="次位优先"></p><blockquote><p>注意题中需要的顺序，如果主位优先中第二步也采用桶排序，则获得的顺序是13组，而不是4组，要注意如果只使用桶排序，<strong>关键字的顺序</strong>是非常重要的</p></blockquote><h3 id="10-小结"><a href="#10-小结" class="headerlink" title="10.小结"></a>10.小结</h3><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_66.png" alt="小结"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图结构（上）</title>
      <link href="/2023/11/07/tu-jie-gou-shang/"/>
      <url>/2023/11/07/tu-jie-gou-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法—图结构（上）"><a href="#数据结构与算法—图结构（上）" class="headerlink" title="数据结构与算法—图结构（上）"></a>数据结构与算法—图结构（上）</h1><h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1图"><a href="#1-1图" class="headerlink" title="1.1图"></a>1.1图</h4><p><strong>①定义</strong></p><blockquote><p><strong>图</strong>：由一个<strong>非空</strong>的<strong>有限顶点集合</strong><code>V</code>和一个<strong>有限边集合</strong><code>E</code>组成</p></blockquote><p><strong>②分类</strong></p><blockquote><p><strong>有向图/无向图</strong>：图中的<strong>边有/无方向</strong></p></blockquote><blockquote><p><strong>非连通图/连通图</strong>：图中是/否有顶点<strong>没有边与其他顶点相连</strong></p></blockquote><blockquote><p><strong>有权图/无权图</strong>：图中的<strong>边是否有权重</strong></p></blockquote><h4 id="1-2图的表示"><a href="#1-2图的表示" class="headerlink" title="1.2图的表示"></a>1.2图的表示</h4><p><strong>①邻接矩阵</strong></p><blockquote><p>若<strong>顶点数</strong>为<code>n</code>，则<strong>邻接矩阵</strong>为一<code>nxn</code>的<strong>矩阵G</strong>，若<code>G[i][j]</code><strong>非零</strong>，表示<strong>有边从顶点i指向顶点j</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若边无权重，用1表示，若边有权重，修改对应数值即可</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若图为无向图，对应邻接矩阵为对角线为0的对称矩阵，可以使用数组存储矩阵对角线以下元素，节省空间</div><blockquote><p><strong>数组长度</strong>为<code>n(n+1)/2</code>，<code>G[i][j]</code>在数组中<strong>对应下标</strong>为<code>i(i+1)/2+j</code></p></blockquote><p><strong>②邻接表</strong></p><blockquote><p>若<strong>顶点数</strong>为<code>n</code>，则<strong>邻接表</strong>为<strong>长度为n的数组</strong>，<strong>每个元素</strong>存储一<strong>链表</strong>，存储了<strong>该顶点</strong>的<strong>所有邻接顶点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相比邻接矩阵，邻接表节省了内存空间，但是增删查改的效率不如邻接矩阵</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将链表转化为搜索树和哈希表等提高效率</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_13.png" alt="图的表示"></p><h3 id="2-图的基本实现"><a href="#2-图的基本实现" class="headerlink" title="2.图的基本实现"></a>2.图的基本实现</h3><h4 id="2-1邻接矩阵实现"><a href="#2-1邻接矩阵实现" class="headerlink" title="2.1邻接矩阵实现"></a>2.1邻接矩阵实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 基于邻接矩阵实现的无向图结构体 */typedef struct {    int vertices[MAX_SIZE];    int adjMat[MAX_SIZE][MAX_SIZE];    int size;} GraphAdjMat;/* 构造函数 */GraphAdjMat *newGraphAdjMat() {    GraphAdjMat *graph = (GraphAdjMat *)malloc(sizeof(GraphAdjMat));    graph-&gt;size = 0;    for (int i = 0; i &lt; MAX_SIZE; i++) {        for (int j = 0; j &lt; MAX_SIZE; j++) {            graph-&gt;adjMat[i][j] = 0;        }    }    return graph;}/* 析构函数 */void delGraphAdjMat(GraphAdjMat *graph) {    free(graph);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②顶点操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 添加顶点即添加一行一列，时间复杂度为O(n)，删除顶点即删除一行一列，时间复杂度为O(n^2)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将所有顶点添加入初始图，即为图的初始化，时间复杂度为O(n^2)</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 删除顶点最坏情况即删除首行首列，需要移动(n-1)^2个顶点</div><pre class="line-numbers language-none"><code class="language-none">/* 添加顶点 */void addVertex(GraphAdjMat *graph, int val) {    if (graph-&gt;size == MAX_SIZE) {        fprintf(stderr, "图的顶点数量已达最大值\n");        return;    }    // 添加第 n 个顶点，并将第 n 行和列置零    int n = graph-&gt;size;    graph-&gt;vertices[n] = val;    for (int i = 0; i &lt;= n; i++) {        graph-&gt;adjMat[n][i] = graph-&gt;adjMat[i][n] = 0;    }    graph-&gt;size++;}/* 删除顶点 */void removeVertex(GraphAdjMat *graph, int index) {    if (index &lt; 0 || index &gt;= graph-&gt;size) {        fprintf(stderr, "顶点索引越界\n");        return;    }    // 在顶点列表中移除索引 index 的顶点    for (int i = index; i &lt; graph-&gt;size - 1; i++) {        graph-&gt;vertices[i] = graph-&gt;vertices[i + 1];    }    // 在邻接矩阵中删除索引 index 的行    for (int i = index; i &lt; graph-&gt;size - 1; i++) {        for (int j = 0; j &lt; graph-&gt;size; j++) {            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i + 1][j];        }    }    // 在邻接矩阵中删除索引 index 的列    for (int i = 0; i &lt; graph-&gt;size; i++) {        for (int j = index; j &lt; graph-&gt;size - 1; j++) {            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i][j + 1];        }    }    graph-&gt;size--;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③边操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度均为O(1)</div><pre class="line-numbers language-none"><code class="language-none">/* 添加边 */// 参数 i, j 对应 vertices 元素索引void addEdge(GraphAdjMat *graph, int i, int j) {    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {        fprintf(stderr, "边索引越界或相等\n");        return;    }    graph-&gt;adjMat[i][j] = 1;    graph-&gt;adjMat[j][i] = 1;}/* 删除边 */// 参数 i, j 对应 vertices 元素索引void removeEdge(GraphAdjMat *graph, int i, int j) {    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {        fprintf(stderr, "边索引越界或相等\n");        return;    }    graph-&gt;adjMat[i][j] = 0;    graph-&gt;adjMat[j][i] = 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2邻接表实现"><a href="#2-2邻接表实现" class="headerlink" title="2.2邻接表实现"></a>2.2邻接表实现</h4><blockquote><p>与<strong>邻接矩阵</strong>不同，<strong>邻接表</strong>的<strong>顶点总数</strong><code>n</code>和<strong>总边数</strong><code>m</code>均是有意义的<br><strong>①结构代码</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用列表组代替链表，邻接表本质上时顶点与邻接顶点列表的对应关系，故使用哈希表存储邻接表</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若邻接表中顶点和索引相对应，则需要移动之后的所有顶点，效率较低</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每个顶点对应唯一的Vertex实例，删除某一顶点无需改动其他顶点</div><pre class="line-numbers language-none"><code class="language-none">/* 节点结构体 */typedef struct AdjListNode {    Vertex *vertex;           // 顶点    struct AdjListNode *next; // 后继节点} AdjListNode;/* 查找顶点对应的节点 */AdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {    for (int i = 0; i &lt; graph-&gt;size; i++) {        if (graph-&gt;heads[i]-&gt;vertex == vet) {            return graph-&gt;heads[i];        }    }    return NULL;}/* 添加边辅助函数 */void addEdgeHelper(AdjListNode *head, Vertex *vet) {    AdjListNode *node = (AdjListNode *)malloc(sizeof(AdjListNode));    node-&gt;vertex = vet;    // 头插法    node-&gt;next = head-&gt;next;    head-&gt;next = node;}/* 删除边辅助函数 */void removeEdgeHelper(AdjListNode *head, Vertex *vet) {    AdjListNode *pre = head;    AdjListNode *cur = head-&gt;next;    // 在链表中搜索 vet 对应节点    while (cur != NULL &amp;&amp; cur-&gt;vertex != vet) {        pre = cur;        cur = cur-&gt;next;    }    if (cur == NULL)        return;    // 将 vet 对应节点从链表中删除    pre-&gt;next = cur-&gt;next;    // 释放内存    free(cur);}/* 基于邻接表实现的无向图类 */typedef struct {    AdjListNode *heads[MAX_SIZE]; // 节点数组    int size;                     // 节点数量} GraphAdjList;/* 构造函数 */GraphAdjList *newGraphAdjList() {    GraphAdjList *graph = (GraphAdjList *)malloc(sizeof(GraphAdjList));    if (!graph) {        return NULL;    }    graph-&gt;size = 0;    for (int i = 0; i &lt; MAX_SIZE; i++) {        graph-&gt;heads[i] = NULL;    }    return graph;}/* 析构函数 */void delGraphAdjList(GraphAdjList *graph) {    for (int i = 0; i &lt; graph-&gt;size; i++) {        AdjListNode *cur = graph-&gt;heads[i];        while (cur != NULL) {            AdjListNode *next = cur-&gt;next;            if (cur != graph-&gt;heads[i]) {                free(cur);            }            cur = next;        }        free(graph-&gt;heads[i]-&gt;vertex);        free(graph-&gt;heads[i]);    }    free(graph);}/* 查找顶点对应的节点 */AdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {    for (int i = 0; i &lt; graph-&gt;size; i++) {        if (graph-&gt;heads[i]-&gt;vertex == vet) {            return graph-&gt;heads[i];        }    }    return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②边操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 添加边直接在列表末尾添加即可，时间复杂度为O(1)，删除边需要遍历链表，时间复杂度为O(m)</div><pre class="line-numbers language-none"><code class="language-none">/* 添加边 */void addEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {    AdjListNode *head1 = findNode(graph, vet1);    AdjListNode *head2 = findNode(graph, vet2);    assert(head1 != NULL &amp;&amp; head2 != NULL &amp;&amp; head1 != head2);    // 添加边 vet1 - vet2    addEdgeHelper(head1, vet2);    addEdgeHelper(head2, vet1);}/* 删除边 */void removeEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {    AdjListNode *head1 = findNode(graph, vet1);    AdjListNode *head2 = findNode(graph, vet2);    assert(head1 != NULL &amp;&amp; head2 != NULL);    // 删除边 vet1 - vet2    removeEdgeHelper(head1, head2-&gt;vertex);    removeEdgeHelper(head2, head1-&gt;vertex);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③顶点操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 添加顶点只需要添加邻接表项，时间复杂度为O(1)，删除顶点需要遍历邻接表以及对应的边，时间复杂度为O(m+n)</div><pre class="line-numbers language-none"><code class="language-none">/* 添加顶点 */void addVertex(GraphAdjList *graph, Vertex *vet) {    assert(graph != NULL &amp;&amp; graph-&gt;size &lt; MAX_SIZE);    AdjListNode *head = (AdjListNode *)malloc(sizeof(AdjListNode));    head-&gt;vertex = vet;    head-&gt;next = NULL;    // 在邻接表中添加一个新链表    graph-&gt;heads[graph-&gt;size++] = head;}/* 删除顶点 */void removeVertex(GraphAdjList *graph, Vertex *vet) {    AdjListNode *node = findNode(graph, vet);    assert(node != NULL);    // 在邻接表中删除顶点 vet 对应的链表    AdjListNode *cur = node, *pre = NULL;    while (cur) {        pre = cur;        cur = cur-&gt;next;        free(pre);    }    // 遍历其他顶点的链表，删除所有包含 vet 的边    for (int i = 0; i &lt; graph-&gt;size; i++) {        cur = graph-&gt;heads[i];        pre = NULL;        while (cur) {            pre = cur;            cur = cur-&gt;next;            if (cur &amp;&amp; cur-&gt;vertex == vet) {                pre-&gt;next = cur-&gt;next;                free(cur);                break;            }        }    }    // 将该顶点之后的顶点向前移动，以填补空缺    int i;    for (i = 0; i &lt; graph-&gt;size; i++) {        if (graph-&gt;heads[i] == node)            break;    }    for (int j = i; j &lt; graph-&gt;size - 1; j++) {        graph-&gt;heads[j] = graph-&gt;heads[j + 1];    }    graph-&gt;size--;    free(vet);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3.图的遍历"></a>3.图的遍历</h3><h4 id="3-1广度优先遍历BFS"><a href="#3-1广度优先遍历BFS" class="headerlink" title="3.1广度优先遍历BFS"></a>3.1广度优先遍历BFS</h4><p><strong>①思想</strong></p><blockquote><p>从<strong>某个节点</strong>出发，<strong>优先遍历</strong>该节点所有<strong>邻接节点</strong>，随后<strong>广度优先遍历</strong>其各个<strong>邻接节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于树的先序遍历，一层层向外扩张</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 广度优先遍历的序列不是唯一的，因为相同距离的节点访问顺序是随机的</div><p><strong>②代码实现</strong></p><blockquote><p>将<strong>起点入队</strong>，<strong>队首出队</strong>并<strong>记录访问</strong>，并将该顶点<strong>所有邻接顶点入队</strong>，如此<strong>循环</strong>，直到<strong>访问所有顶点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 所有顶点都会入队出队，且所有边都会被访问两次，故时间复杂度为O(n+m)</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 已经访问过的节点不再入队</div><pre class="line-numbers language-none"><code class="language-none">/* 节点队列结构体 */typedef struct {    Vertex *vertices[MAX_SIZE];    int front, rear, size;} Queue;/* 构造函数 */Queue *newQueue() {    Queue *q = (Queue *)malloc(sizeof(Queue));    q-&gt;front = q-&gt;rear = q-&gt;size = 0;    return q;}/* 判断队列是否为空 */int isEmpty(Queue *q) {    return q-&gt;size == 0;}/* 入队操作 */void enqueue(Queue *q, Vertex *vet) {    q-&gt;vertices[q-&gt;rear] = vet;    q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE;    q-&gt;size++;}/* 出队操作 */Vertex *dequeue(Queue *q) {    Vertex *vet = q-&gt;vertices[q-&gt;front];    q-&gt;front = (q-&gt;front + 1) % MAX_SIZE;    q-&gt;size--;    return vet;}/* 检查顶点是否已被访问 */int isVisited(Vertex **visited, int size, Vertex *vet) {    // 遍历查找节点，使用 O(n) 时间    for (int i = 0; i &lt; size; i++) {        if (visited[i] == vet)            return 1;    }    return 0;}/* 广度优先遍历 BFS */// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点void graphBFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize, Vertex **visited, int *visitedSize) {    // 队列用于实现 BFS    Queue *queue = newQueue();    enqueue(queue, startVet);    visited[(*visitedSize)++] = startVet;    // 以顶点 vet 为起点，循环直至访问完所有顶点    while (!isEmpty(queue)) {        Vertex *vet = dequeue(queue); // 队首顶点出队        res[(*resSize)++] = vet;      // 记录访问顶点        // 遍历该顶点的所有邻接顶点        AdjListNode *node = findNode(graph, vet);        while (node != NULL) {            // 跳过已被访问过的顶点            if (!isVisited(visited, *visitedSize, node-&gt;vertex)) {                enqueue(queue, node-&gt;vertex);             // 只入队未访问的顶点                visited[(*visitedSize)++] = node-&gt;vertex; // 标记该顶点已被访问            }            node = node-&gt;next;        }    }    // 释放内存    free(queue);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2深度优先遍历DFS"><a href="#3-2深度优先遍历DFS" class="headerlink" title="3.2深度优先遍历DFS"></a>3.2深度优先遍历DFS</h4><p><strong>①思想</strong></p><blockquote><p>从<strong>某一节点</strong>出发，不断访问<strong>当前节点</strong>的<strong>某个邻接节点</strong>，直到<strong>尽头返回</strong>，<strong>返回后再继续向后走</strong>，以此类推，直到<strong>所有顶点遍历完成</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 深度优先遍历是一种优先走到底，无路可走再回头的遍历方式，同样，深度优先遍历的序列也不是唯一的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以人为设置节点的访问优先级，从而统一遍历后序列</div><p><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 所有顶点都会被访问，所有边都会被访问两次，故时间复杂度为O(n+m)</div><pre class="line-numbers language-none"><code class="language-none">/* 检查顶点是否已被访问 */int isVisited(Vertex **res, int size, Vertex *vet) {    // 遍历查找节点，使用 O(n) 时间    for (int i = 0; i &lt; size; i++) {        if (res[i] == vet) {            return 1;        }    }    return 0;}/* 深度优先遍历 DFS 辅助函数 */void dfs(GraphAdjList *graph, Vertex **res, int *resSize, Vertex *vet) {    // 记录访问顶点    res[(*resSize)++] = vet;    // 遍历该顶点的所有邻接顶点    AdjListNode *node = findNode(graph, vet);    while (node != NULL) {        // 跳过已被访问过的顶点        if (!isVisited(res, *resSize, node-&gt;vertex)) {            // 递归访问邻接顶点            dfs(graph, res, resSize, node-&gt;vertex);        }        node = node-&gt;next;    }}/* 深度优先遍历 DFS */// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点void graphDFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize) {    dfs(graph, res, resSize, startVet);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（四）</title>
      <link href="/2023/11/07/shu-ju-jie-gou-yu-suan-fa-si/"/>
      <url>/2023/11/07/shu-ju-jie-gou-yu-suan-fa-si/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法（四）"><a href="#数据结构与算法（四）" class="headerlink" title="数据结构与算法（四）"></a>数据结构与算法（四）</h1><h2 id="树形结构（上）"><a href="#树形结构（上）" class="headerlink" title="树形结构（上）"></a>树形结构（上）</h2><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h3><h4 id="1-1树"><a href="#1-1树" class="headerlink" title="1.1树"></a>1.1树</h4><p><strong>①定义</strong></p><blockquote><p>每个树都有一个<strong>根节点</strong>，<strong>其余节点</strong>可分为<strong>互不相交的子树</strong>，且只有<strong>一个父节点</strong>和<strong>若干个子节点</strong>，<strong>没有子节点</strong>的节点称为<strong>叶节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 树明显是基于递归定义的，所以有关树的很多算法都用到了递归思想</div><p><strong>②儿子兄弟表示法</strong></p><blockquote><p><strong>每个节点</strong>存储<strong>两个指针</strong>，<strong>左指针</strong>指向<strong>最左的儿子节点</strong>，<strong>右指针</strong>指向<strong>相邻兄弟节点</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 所有的树都可以通过儿子兄弟表示法转化为二叉树，所以树的主要研究对象为二叉树</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_3.png" alt="儿子-兄弟表示法"></p><h4 id="1-2二叉树"><a href="#1-2二叉树" class="headerlink" title="1.2二叉树"></a>1.2二叉树</h4><p><strong>①定义</strong></p><blockquote><p>由<strong>根节点</strong>和同为<strong>二叉树</strong>的<strong>左子树</strong>和<strong>右子树</strong>组成，即<strong>每个节点</strong>最多只能有<strong>两个子节点</strong>，称为<strong>左节点</strong>和<strong>右节点</strong></p></blockquote><p><strong>②特殊二叉树</strong></p><blockquote><p><strong>完美二叉树</strong>：当二叉树有<strong>n层</strong>时，有<strong>2^n-1个节点</strong>，<strong>叶子节点</strong>只能出现在<strong>最下面一层</strong></p></blockquote><blockquote><p><strong>完全二叉树</strong>：对二叉树中节点<strong>从上至下</strong>，<strong>从左往右</strong>进行<strong>编号</strong>，<strong>编号为i</strong>的节点与<strong>满二叉树</strong>中<strong>编号为i</strong>的节点<strong>位置相同</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 完全二叉树即从某一叶节点缺失所有右边的兄弟节点，左边的兄弟节点不缺失的完美二叉树</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_4.png" alt="特殊二叉树"></p><h4 id="1-3二叉树的存储结构"><a href="#1-3二叉树的存储结构" class="headerlink" title="1.3二叉树的存储结构"></a>1.3二叉树的存储结构</h4><p><strong>①链表</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二叉树通常使用链表存储，缺省情况下树使用链表实现</div><blockquote><p><strong>节点结构</strong>分别有<strong>指向左子节点的指针</strong>和<strong>指向右子节点的指针</strong>，<strong>整个二叉树</strong>只需要知道其<strong>根节点指针</strong>即可<br><strong>②数组</strong><br>将二叉树转化为<strong>广义的完全二叉树</strong>，<strong>从上至下</strong>，<strong>从左往右</strong>进行<strong>编号</strong>，节点的<strong>编号</strong>就是其在<strong>数组的索引</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不存在的节点表示为空</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若一节点为i，则其左子节点为2i+1，右子节点为2i+2，父节点为(i-1)/2，访问速度较快</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 数组需要连续内存空间，不适合存储数据量过大的树，且若二叉树和完全二叉树相差较大时，会造成巨大的空间浪费</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_7.png" alt="二叉树的数组表示"></p><h3 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2.二叉树的遍历"></a>2.二叉树的遍历</h3><h4 id="2-1层序遍历"><a href="#2-1层序遍历" class="headerlink" title="2.1层序遍历"></a>2.1层序遍历</h4><p><strong>①定义</strong></p><blockquote><p><strong>向下逐层</strong>遍历二叉树，<strong>每一层</strong>按照<strong>从左到右</strong>的顺序<strong>访问节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 层序遍历本质上是广度优先遍历，体现了一种“一圈一圈向外扩展”的逐层遍历方式</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 层序遍历的逐层推进和队列的先进先出本质上一样的</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_5.png" alt="层序遍历"><br><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">//时间复杂度和空间复杂度均为O(n)int *levelOrder(TreeNode *root, int *size) {    /* 辅助队列 */    int front, rear;    int index, *arr;    TreeNode *node;    TreeNode **queue;    /*动态申请队列，队列保存的是节点指针，所以最终表现形态为节点指针的指针*/    queue = (TreeNode **)malloc(sizeof(TreeNode *) * MAX_SIZE);    // 队列伪指针    front = 0, rear = 0;    // 加入根节点    queue[rear++] = root;    // 初始化一个列表，用于保存遍历序列    /* 辅助数组 */    arr = (int *)malloc(sizeof(int) * MAX_SIZE);    // 数组指针    index = 0;    /*利用队列实现层序遍历*/    while (front &lt; rear) {        // 队列出队        node = queue[front++];        // 保存节点值        arr[index++] = node-&gt;val;        if (node-&gt;left != NULL) {            // 左子节点入队            queue[rear++] = node-&gt;left;        }        if (node-&gt;right != NULL) {            // 右子节点入队            queue[rear++] = node-&gt;right;        }    }    // 更新数组长度的值    *size = index;    arr = realloc(arr, sizeof(int) * (*size));    // 释放辅助数组空间    free(queue);    return arr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2前序、中序和后续遍历"><a href="#2-2前序、中序和后续遍历" class="headerlink" title="2.2前序、中序和后续遍历"></a>2.2前序、中序和后续遍历</h4><p><strong>①定义</strong></p><blockquote><p><strong>前序遍历</strong>：先访问<strong>根节点</strong>，<strong>前序遍历</strong>其<strong>左子树</strong>，再<strong>前序遍历</strong>其<strong>右子树</strong></p></blockquote><blockquote><p><strong>中序遍历</strong>：<strong>中序遍历</strong>其<strong>左子树</strong>，访问<strong>根节点</strong>，再<strong>中序遍历</strong>其<strong>右子树</strong></p></blockquote><blockquote><p><strong>后序遍历</strong>：<strong>后序遍历</strong>其<strong>左子树</strong>，<strong>后续遍历</strong>其<strong>右子树</strong>，访问其<strong>根节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这三种遍历本质上是深度优先遍历，体现了一种“先走到尽头，再回溯继续”的遍历方式</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对于一个节点，有三次访问的时刻，即第一次访问（没有访问其子节点），从左子树返回访问和从右子树返回访问，三种遍历方式就是分别再三次访问时输出</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_6.png" alt="前序、中序和后续遍历"><br><strong>②三种遍历的递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">//时间复杂度和空间复杂度均为O(n)/* 前序遍历 */void preOrder(TreeNode *root, int *size) {    if (root == NULL)        return;    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树    arr[(*size)++] = root-&gt;val;    preOrder(root-&gt;left, size);    preOrder(root-&gt;right, size);}/* 中序遍历 */void inOrder(TreeNode *root, int *size) {    if (root == NULL)        return;    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树    inOrder(root-&gt;left, size);    arr[(*size)++] = root-&gt;val;    inOrder(root-&gt;right, size);}/* 后序遍历 */void postOrder(TreeNode *root, int *size) {    if (root == NULL)        return;    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点    postOrder(root-&gt;left, size);    postOrder(root-&gt;right, size);    arr[(*size)++] = root-&gt;val;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3.二叉搜索树"></a>3.二叉搜索树</h3><h4 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h4><blockquote><p><strong>左子树</strong>中<strong>所有节点</strong>的值<code>&lt;</code><strong>根节点</strong>的值<code>&lt;</code><strong>右子树</strong>中<strong>所有节点</strong>的值，且其<strong>左右子树</strong>都是<strong>二叉搜索树</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二叉搜索树的中序遍历序列是升序的，所以从二叉搜索树中获取有序数据时间复杂度仅仅为O(n)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二叉搜索树的增删查改操作的时间复杂度均为O(logn)</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 二叉搜索树不允许存在重复节点</div><h4 id="3-2查找"><a href="#3-2查找" class="headerlink" title="3.2查找"></a>3.2查找</h4><p><strong>①递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType x,BinTree BST){  /*没找到，递归退出条件  if(!Bst)    return NULL;  /*递归查找  if(x&gt;Bst-&gt;Data)    return Find(x,BST-&gt;Right);  else if(x&lt;Bst-&gt;Data)    return Find(x,BST-&gt;Left);  /*成功找到，递归退出条件  else    return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType x,BinTree BST){  while(BST)  {    if(x &gt; BST-&gt;Data)      BST = BST-&gt;Right;    else if(x &lt; BST-&gt;Data)      BST = BST-&gt;Left;    else      return BST;  }  return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3插入"><a href="#3-3插入" class="headerlink" title="3.3插入"></a>3.3插入</h4><p><strong>①递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Insert(ElementType x,BinTree BST){  /*递归退出条件，找到对应插入位置，即一个空位置  if(!BST)  {    BST = malloc(sizeof(struct TreeNode));    BST-&gt;Data = x;    BST-&gt;Left = BST-&gt;Right =NULL;  }  else  {    if(x &lt; BST-&gt;Data)      BST-&gt;Left = Insert(x,BST-&gt;Left);     else if(x &gt; BST-&gt;Data)      BST-&gt;Right = Insert(x,BST-&gt;Right);  }  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Insert(ElementType x,BinTree BST){  while(BST)  {    if(x &gt; BST-&gt;Data)    {      if(!BST-&gt;Right)      {      BST-&gt;Right = malloc(sizeof(struct TreeNode));      BST-&gt;Right-&gt;Data = x;      BST-&gt;Right-&gt;Right = BST-&gt;Right-&gt;Left = NULL;      return BST-&gt;Right      }      else      BST = BST-&gt;Right    }    else if(x &lt; BST-&gt;Data)    {      if(!BST-&gt;Left)      {      BST-&gt;Left = malloc(sizeof(struct TreeNode));      BST-&gt;Left-&gt;Data = x;      BST-&gt;Left-&gt;Right = BST-&gt;Left-&gt;Left = NULL;      return BST-&gt;Right      }      else      BST = BST-&gt;Left;    }    else     return BST;  }  BST = malloc(sizeof(struct TreeNode));  BST-&gt;Data = x;  BST-&gt;Left = Bst-&gt;Right = NULL;  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4删除"><a href="#3-4删除" class="headerlink" title="3.4删除"></a>3.4删除</h4><p><strong>①思路</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要保证删除节点后的二叉树依旧是搜索二叉树，所以对于不同的节点，删除操作是不同的</div><blockquote><p><strong>叶节点</strong>：<strong>直接删除</strong>即可</p></blockquote><blockquote><p><strong>节点的度为1</strong>：将<strong>待删除节点</strong>替换为<strong>子节点</strong></p></blockquote><blockquote><p><strong>节点的度为2</strong>：将其<strong>右子树最小元素</strong>或者<strong>左子树最大元素</strong>代替之</p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Delete(ElementType x,BinTree BST){  Position Tmp;  if(!BST)    print("未找到该元素")；  else if(x &lt; BST-&gt;Data)    BST-&gt;Left = Delete(x,BST-&gt;Left);  else if(x &gt; BST-&gt;Data)    BST-&gt;Right = Delete(x,BST-&gt;Right);  else    /*当有两个孩子    if(BST-&gt;Left &amp;&amp; BST-&gt;Right)    {      /*找到其右子树最小元素替代之      Tmp = FindMin(BST-&gt;Right);      BST-&gt;Data = Tmp-&gt;Data;      /*删除其右子树最小元素      BST-&gt;Right = Delete(BST-&gt;Data,BST-&gt;Right);    }    /*有一个或者没有孩子    else    {      Tmp = BST      if(!BST-&gt;Left)        BST = BST-&gt;Right      else if(!BST-&gt;Right)        BST = BST-&gt;Left;      free(Tmp)    }  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-AVL树"><a href="#4-AVL树" class="headerlink" title="4.AVL树"></a>4.AVL树</h3><h4 id="4-1引言"><a href="#4-1引言" class="headerlink" title="4.1引言"></a>4.1引言</h4><p><strong>①树的退化</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 多次插入和删除，可能导致树退化为链表，很多操作将从O(logn)变为O(n)</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_8.png" alt="树的退化"></p><p><strong>②定义</strong></p><blockquote><p><strong>平衡二叉树</strong>：<strong>空树</strong>或者<strong>任意节点</strong>左右子树<strong>高度差</strong>绝对值<strong>不超过1</strong></p></blockquote><blockquote><p><strong>AVL树</strong>：既是<strong>平衡二叉树</strong>，又是<strong>二叉搜索树</strong></p></blockquote><blockquote><p><strong>平衡因子</strong>：节点<strong>左子树的高度</strong>减去<strong>右子树的高度</strong>，<strong>空节点</strong>的平衡因子为<code>0</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 节点的高度为从距离该节点最远的叶节点到该节点所经过的边的数量</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 树越平衡，同等个数节点的高度就越小，操作的时间复杂度就越小，所以AVL树的数据操作性能很优秀</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当节点的平衡因子绝对值超过1，则该节点失衡</div><p><strong>③树的平衡</strong></p><blockquote><p>从<strong>底部向顶部</strong>调整<strong>失衡节点</strong>，因为<strong>顶部的失衡</strong>主要由<strong>底部的失衡累计</strong>而来</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上就是如何调整平衡因子绝对值为2的节点，且依旧保持搜索二叉树的性质，可分为以下四种情况</div><h4 id="4-2AVL树旋转"><a href="#4-2AVL树旋转" class="headerlink" title="4.2AVL树旋转"></a>4.2AVL树旋转</h4><p><strong>①右旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>大于1</strong>，且<strong>子节点</strong>平衡因子<strong>大于等于0</strong>，采用<strong>右旋</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若失衡节点的子节点有右节点，则需要将该右节点变为旋转后失衡节点的左节点</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_9.png" alt="右旋"><br><strong>②左旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>小于-1</strong>，且<strong>子节点</strong>平衡因子<strong>小于等于0</strong>，采用<strong>左旋</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若失衡节点的子节点有左节点，则需要将该左节点变为旋转后失衡节点的右节点</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 易知左旋和右旋的操作为镜像关系</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_10.png" alt="左旋"><br><strong>③先左旋后右旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>大于1</strong>，且<strong>子节点</strong>平衡因子<strong>小于0</strong>，采用<strong>先左旋后右旋</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_11.png" alt="LR旋转"><br><strong>④先右旋后左旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>小于-1</strong>，且<strong>子节点</strong>平衡因子<strong>大于0</strong>，采用<strong>先右旋后左旋</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同理先右旋后左旋和先左旋后右旋也为镜像关系</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_12.png" alt="RL旋转"></p><h4 id="4-3AVL树的实现"><a href="#4-3AVL树的实现" class="headerlink" title="4.3AVL树的实现"></a>4.3AVL树的实现</h4><p><strong>①结构与特性</strong></p><pre class="line-numbers language-none"><code class="language-none">/* AVL 树节点结构体 */TreeNode struct TreeNode {    int val;    int height;    struct TreeNode *left;    struct TreeNode *right;} TreeNode;/* 构造函数 */TreeNode *newTreeNode(int val) {    TreeNode *node;    node = (TreeNode *)malloc(sizeof(TreeNode));    node-&gt;val = val;    node-&gt;height = 0;    node-&gt;left = NULL;    node-&gt;right = NULL;    return node;}/* 获取节点高度 */int height(TreeNode *node) {    // 空节点高度为 -1 ，叶节点高度为 0    if (node != NULL) {        return node-&gt;height;    }    return -1;}/* 更新节点高度 */void updateHeight(TreeNode *node) {    int lh = height(node-&gt;left);    int rh = height(node-&gt;right);    // 节点高度等于最高子树高度 + 1    if (lh &gt; rh) {        node-&gt;height = lh + 1;    } else {        node-&gt;height = rh + 1;    }}/* 获取节点高度 */int height(TreeNode *node) {    // 空节点高度为 -1 ，叶节点高度为 0    if (node != NULL) {        return node-&gt;height;    }    return -1;}/* 更新节点高度 */void updateHeight(TreeNode *node) {    int lh = height(node-&gt;left);    int rh = height(node-&gt;right);    // 节点高度等于最高子树高度 + 1    if (lh &gt; rh) {        node-&gt;height = lh + 1;    } else {        node-&gt;height = rh + 1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②旋转操作</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 执行旋转操作，使该子树重新恢复平衡 */TreeNode *rotate(TreeNode *node) {    // 获取节点 node 的平衡因子    int bf = balanceFactor(node);    // 左偏树    if (bf &gt; 1) {        if (balanceFactor(node-&gt;left) &gt;= 0) {            // 右旋            return rightRotate(node);        } else {            // 先左旋后右旋            node-&gt;left = leftRotate(node-&gt;left);            return rightRotate(node);        }    }    // 右偏树    if (bf &lt; -1) {        if (balanceFactor(node-&gt;right) &lt;= 0) {            // 左旋            return leftRotate(node);        } else {            // 先右旋后左旋            node-&gt;right = rightRotate(node-&gt;right);            return leftRotate(node);        }    }    // 平衡树，无须旋转，直接返回    return node;}/* 右旋操作 */TreeNode *rightRotate(TreeNode *node) {    TreeNode *child, *grandChild;    child = node-&gt;left;    grandChild = child-&gt;right;    // 以 child 为原点，将 node 向右旋转    child-&gt;right = node;    node-&gt;left = grandChild;    // 更新节点高度    updateHeight(node);    updateHeight(child);    // 返回旋转后子树的根节点    return child;}/* 左旋操作 */TreeNode *leftRotate(TreeNode *node) {    TreeNode *child, *grandChild;    child = node-&gt;right;    grandChild = child-&gt;left;    // 以 child 为原点，将 node 向左旋转    child-&gt;left = node;    node-&gt;right = grandChild;    // 更新节点高度    updateHeight(node);    updateHeight(child);    // 返回旋转后子树的根节点    return child;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③增删查改</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 查找和修改操作和搜索二叉树一致</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 插入和删除操作可能会影响二叉树的平衡性，故在操作后需要从底至顶地执行旋转操作，使所有失衡节点恢复平衡</div><pre class="line-numbers language-none"><code class="language-none">/* 插入节点 */void insert(AVLTree *tree, int val) {    tree-&gt;root = insertHelper(tree-&gt;root, val);}/* 递归插入节点（辅助函数） */TreeNode *insertHelper(TreeNode *node, int val) {    if (node == NULL) {        return newTreeNode(val);    }    /* 1. 查找插入位置，并插入节点 */    if (val &lt; node-&gt;val) {        node-&gt;left = insertHelper(node-&gt;left, val);    } else if (val &gt; node-&gt;val) {        node-&gt;right = insertHelper(node-&gt;right, val);    } else {        // 重复节点不插入，直接返回        return node;    }    // 更新节点高度    updateHeight(node);    /* 2. 执行旋转操作，使该子树重新恢复平衡 */    node = rotate(node);    // 返回子树的根节点    return node;}/* 删除节点 */// 由于引入了 stdio.h ，此处无法使用 remove 关键词void removeItem(AVLTree *tree, int val) {    TreeNode *root = removeHelper(tree-&gt;root, val);}/* 递归删除节点（辅助函数） */TreeNode *removeHelper(TreeNode *node, int val) {    TreeNode *child, *grandChild;    if (node == NULL) {        return NULL;    }    /* 1. 查找节点，并删除之 */    if (val &lt; node-&gt;val) {        node-&gt;left = removeHelper(node-&gt;left, val);    } else if (val &gt; node-&gt;val) {        node-&gt;right = removeHelper(node-&gt;right, val);    } else {        if (node-&gt;left == NULL || node-&gt;right == NULL) {            child = node-&gt;left;            if (node-&gt;right != NULL) {                child = node-&gt;right;            }            // 子节点数量 = 0 ，直接删除 node 并返回            if (child == NULL) {                return NULL;            } else {                // 子节点数量 = 1 ，直接删除 node                node = child;            }        } else {            // 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点            TreeNode *temp = node-&gt;right;            while (temp-&gt;left != NULL) {                temp = temp-&gt;left;            }            int tempVal = temp-&gt;val;            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);            node-&gt;val = tempVal;        }    }    // 更新节点高度    updateHeight(node);    /* 2. 执行旋转操作，使该子树重新恢复平衡 */    node = rotate(node);    // 返回子树的根节点    return node;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（二）</title>
      <link href="/2023/11/07/shu-ju-jie-gou-yu-suan-fa-er/"/>
      <url>/2023/11/07/shu-ju-jie-gou-yu-suan-fa-er/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1数组和链表"><a href="#1-1数组和链表" class="headerlink" title="1.1数组和链表"></a>1.1数组和链表</h4><p><strong>①数组</strong></p><blockquote><p>一段<strong>连续的内存空间</strong>，其<strong>数组名</strong>记录了其<strong>起始位置</strong>，可以通过<strong>索引</strong>访问<strong>对应位置</strong>的内存单元</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数组的大小通常是一开始就确定的，但也可以通过一些手段构成动态数组，如C语言的malloc()</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 数组的元素访问非常块，元素地址=起始地址+元素长度x元素索引</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 由于数组是一段连续的内存空间，所以是有限的，可能会出现扩容问题，且移动一个元素会影响其后所有元素</div><p><strong>②链表</strong></p><blockquote><p>多个<strong>零星的内存空间</strong>通过<strong>指针</strong>链接在一起，每个链表有一个<strong>头节点</strong>，记录链表<strong>起始位置</strong>，并通过<strong>各个节点存储的指针</strong>访问<strong>对应节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根据各个节点的链接关系，链表可分为单链表、双向链表和环形链表</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 链表分散于内存各处，更加灵活，内存允许的情况下可以无限增长，且移动一个节点只会影响与其相连的节点</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 链表需要存储指针信息，需要占用更多的内存，且查询节点需要使用指针，速度较慢</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_1.png" alt="数组与链表"></p><h4 id="1-2抽象"><a href="#1-2抽象" class="headerlink" title="1.2抽象"></a>1.2抽象</h4><p><strong>①概述</strong></p><blockquote><p>只关心<strong>是什么</strong>，而不关心<strong>如何做到</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据结构的抽象就是描述其定义及其操作集</div><p><strong>②定义</strong></p><blockquote><p><strong>线性表</strong>：<strong>零个或多个</strong>数据元素的<strong>有限序列</strong>，<strong>每个元素</strong>只有<strong>一个直接前驱元素</strong>，<strong>一个直接后继元素</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 线性表的元素可以是任何结构，如线性表，但是线性表存储的元素必须统一</div><blockquote><p><strong>栈</strong>：受到<strong>一定约束</strong>的<strong>线性表</strong>，只能在<strong>一端插入和弹出</strong>数据，<strong>后入先出</strong></p></blockquote><blockquote><p><strong>队列</strong>：受到<strong>一定约束</strong>的<strong>线性表</strong>，只能在<strong>一端插入</strong>，在<strong>另一端删除</strong>，<strong>先进先出</strong></p></blockquote><p><strong>③操作集</strong></p><blockquote><p>每个<strong>数据结构</strong>的<strong>操作集</strong>都只需要包含一些<strong>基本且独立</strong>的操作</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 任何复杂操作，都可以转化为操作集的组合</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个操作的实现都要考虑不合理情况并抛出异常，以及操作带来的副作用</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_2.png" alt="线性结构"></p><hr><h3 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表"></a>2.线性表</h3><h4 id="2-1数组实现"><a href="#2-1数组实现" class="headerlink" title="2.1数组实现"></a>2.1数组实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">#define MAXSIZE 30typedef int ElemType; //如果要修改线性表的数据类型，直接修改这里即可typedef struct{  ElemType data[MAXSIZE];  int length; //线性表目前的长度}SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>查找</strong>：获取<strong>对应位置</strong>的<strong>数据</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 需要判断查找的位置是否合理</div><pre class="line-numbers language-none"><code class="language-none">#define OK 1#define ERROR 0typedef int Status;Status  GetElem(SqList L,int i,ElemType *e){  if(L.length==0||i&lt;1||i&gt;L.length) //首先进行异常判断    return ERROR;  *e = L.data[i-1];  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>插入</strong>：将<strong>指定数据</strong>添加到<strong>指定位置</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 需要判断插入位置是否合理，以及该操作带来的副作用</div><pre class="line-numbers language-none"><code class="language-none">Status ListInsert(SqList *L,int i,ElemType e) //注意这里传入的是结构的指针，因为要改变结构{  //首先进行异常检查  int k;  if(L-&gt;lenth==MAXSIZE)    return ERROR;  if(i&lt;1||i&gt;L-&gt;lenth+1) //注意i的含义对代码的影响    return ERROR;  //考虑插入位置对操作的影响  if(i&lt;=L-&gt;length)  {    for(k=L-&gt;length;k&gt;=i-1;k--) //后移元素      L-&gt;data[k+1]=L-&gt;data[k];  }  L-&gt;data[i-1]=e;  L-&gt;length++; //注意操作带来的额外影响    return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>删除</strong>：删除<strong>指定位置</strong>数据并<strong>整理</strong>线性表</p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status ListDelete(SqList *L,int i){  int k;  //异常检查  if(L-&gt;length==0)    return ERROR;  if(i&lt;1||i&gt;L-&gt;length)    return ERROR;  //当删除位置不在线性表末尾时  if(i&lt;L-&gt;length)  {    for(k=i-1,k&lt;L-length,k++)      L-&gt;data[k]=L-&gt;data[k+1];  }  L-&gt;length--; //函数操作带来的额外影响  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2链表实现"><a href="#2-2链表实现" class="headerlink" title="2.2链表实现"></a>2.2链表实现</h4><p><strong>①结构代码</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 链表由节点组成，且链接关系也存储在节点中，所以指明了节点的结构就是指明了链表的结构</div><pre class="line-numbers language-none"><code class="language-none">//单链表节点结构typedef struct Node{  ElemType data;  struct Node *next;}Node;typedef struct Node *LinkList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>创建</strong>：链表是一种<strong>动态结构</strong>，指明其<strong>头节点</strong>即可</p></blockquote><blockquote><p><strong>查找</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status GetElem(LinkList L,int i,ElemType *e) //传入L为链表的头节点的指针{  int j;  LinkList p;  p=L-&gt;next; //使p指向链表的第一个节点  j = 1;  //其中p作为判别条件是防止其超过链表范围，因为当p为空指针时，说明已经到达最后一个节点了  while(p &amp;&amp; j&lt;i)   {    p = p-&gt;next;    ++j;  }  if(!p || j&gt;i) //当p为空指针或者i小于1时，第i个元素不存在    return ERROR;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>插入</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意节点插入时，先将新节点插入，再将旧的链接断开</div><pre class="line-numbers language-none"><code class="language-none">/*在已存在链表的第i个位置插入元素eStatus ListInsert(LinkList *L,int i,ElemType *e){  int j;  LinkList p,s;  p = *L;  j = 1；  while(p &amp;&amp; j&lt;i ) /*寻找第i个结点,循环结束时j = i-1；  {    p = p-&gt;next;    ++j;  }  if (!p || j&gt;i) /*当i为0或者第i个结点不存在时    return ERROR；  s = (LinkList)malloc(sizeof(Node));  s-&gt;data = e;  /*注意结点断开和相连的顺序  s-&gt;next = p-&gt;next;/*先将新节点添加进链表  p-&gt;next = s;/*再将旧链接断开并添加新链接}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>删除</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对于没有回收机制的语言，需要注意释放动态分配获得的内存</div><pre class="line-numbers language-none"><code class="language-none">Status LinkDelete(LinkList *L,int i,ElemType *e){  int j;  LinkList p,q;  p = *L;  j = 1;  while(p-&gt;next &amp;&amp; j&lt;i)  {    p = p-&gt;next;    ++j;  }  if (!p || j&gt;i) /*当i为0或者第i个结点不存在时    return ERROR；  q = p-&gt;next;  p-&gt;next = q-&gt;next;  *e = q-&gt;data;  free(q); /*记得要释放对应的空间  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>销毁</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status LinkClear(LinkList *L){  LinkList p,q;  p = (*L)-&gt;next;  while (p)  {    q = p-&gt;next;    free(p)    p=q  }  (*L)-&gt;next = NULL;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><h4 id="3-1数组实现"><a href="#3-1数组实现" class="headerlink" title="3.1数组实现"></a>3.1数组实现</h4><p><strong>①结构代码</strong></p><blockquote><p>由一个<strong>记录元素的一维数组</strong>和一个<strong>记录栈顶元素位置</strong>的<strong>变量</strong>组成</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#define MaxSizetypedef struct SNode* Stackstruct SNode{  ElementType Data[MaxSize];  int Top = -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>压入元素</strong>：将<strong>指定元素</strong>放在<strong>栈顶上面</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">void Push(Stack PtrS,ElementType item){  if (PtrS-&gt;Top==Maxsize-1)  {    printf("栈已满")；    return；  }  else  {    PtrS-&gt;Data[++(PtrS-&gt;Top)]==item;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>弹出元素</strong>：将<strong>栈顶元素</strong>删除</p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType Pop(Stack PtrS){  if(PtrS-&gt;Top==-1)  {    printf("栈空")；    return ；  }  else  return(PtrS-&gt;Data[(PtrS-&gt;Top)--]); /*注意--符号是后缀}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2链表实现"><a href="#3-2链表实现" class="headerlink" title="3.2链表实现"></a>3.2链表实现</h4><p><strong>①结构代码</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以链表的头节点作为TOP，方便查找</div><pre class="line-numbers language-none"><code class="language-none">typedef struct SNode* Stackstruct SNode{  ElementType Data;  struct SNode* Next;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>压入元素</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">void Push(ElementType item,Stack S) {  struct SNode *TmpCell;  TmpCell=(struct SNode *)malloc(sizeof(struct SNode));  TmpCell-&gt;Element = item;  TmpCell-&gt;Next = S-&gt;Next;  S-&gt;Next = TmpCell;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>弹出元素</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType Pop(Stack S){  struct SNode *FirstCell;  ElementType TopElem;  if(IsEmpty(S))  {    printf("栈空")；    return NULL；  }  else  {    FirstCell = S-&gt;Next; /*指向头节点    S-&gt;Next = FirstCell = S-&gt;Next;    TopElem = FirtCell-&gt;Element;    free(FirstCell);    return TopElem;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><h4 id="4-1数组实现"><a href="#4-1数组实现" class="headerlink" title="4.1数组实现"></a>4.1数组实现</h4><p><strong>①结构代码</strong></p><blockquote><p><code>rear</code>是指向<strong>队尾的“指针”</strong>，<code>front</code>是指向<strong>队头的“指针”</strong>，<strong>插入</strong>一个元素时，<code>rear</code><strong>加一</strong>，<strong>删除</strong>一个元素时，<code>front</code><strong>加一</strong>，</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当“指针”可以在超过MaxSize且列表未满时，对MaxSize取余再次从0开始，需要一个状态标签判断队列是否已满</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 山不转水转！</div><pre class="line-numbers language-none"><code class="language-none">#define MaxSizestruct QNode{  ElementType Data [MaxSize]；  int rear = -1;   int front = -1;};typedef struct QNode *Queue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>入队列</strong>：将<strong>指定元素</strong>添加到<strong>队尾</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">void AddQ(Queue PtrQ,ElementType item){  if((PtrQ-&gt;rear+1)%MaxSize==PtrQ-&gt;front)  {    printf("队列已满")；    return ；  }  PtrQ-&gt;rear=(PtrQ-&gt;rear+1)%MaxSize;  PtrQ-&gt;Data[PtrQ-&gt;rear]=item;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>出队列</strong>：删除<strong>队头元素</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType DeleteQ(Queue PtrQ){  if(PtrQ-&gt;front==PtrQ-&gt;rear)  {    printf("队列空")；    return ERROR；  }  else  {    PtrQ-&gt;front=(PtrQ-&gt;front+1)%MaxSize;    return PtrQ-&gt;Data[PtrQ-&gt;front];  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2链表实现"><a href="#4-2链表实现" class="headerlink" title="4.2链表实现"></a>4.2链表实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">struct Node{  ElementType Data;  struct Node *Next;};struct QNode{  struct Node *rear; /*指向队尾  struct Node *front; /*指向队头，列表的头节点，出队的一端};typedef struct QNode *Queue;Queue PtrQ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><blockquote><p><strong>出队列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">ElementType DeleteQ(Queue PtrQ){  struct Node *FrontCell; /*作为中间变量保存要删除的节点  ElementType FrontElem;  if(PtrQ-&gt;front==NULL)  {    print("队列空")；    return ERROR；  }  FrontCell = PtrQ-&gt;front;  if(PtrQ-&gt;front == PtrQ-&gt;rear)    PtrQ-&gt;front=PtrQ-&gt;rear=NULL;  else    PtrQ-&gt;front=PtrQ-&gt;front-&gt;Next;  FrontElem = FrontCell-&gt;data;  free(FrontCell);  return FrontElem;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>入队列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Status AddQ(Queue PtrQ,ElementType Elem){  struct Node *FrontCell; /*作为中间变量保存要删除的节点  FrontCell = (struct Node *)malloc(sizeof(Node));  if(!FrontCell)    exit(OVERFLOW);  FrontCell-&gt;Data = Elem;  PtrQ-&gt;rear-&gt;next = FrontCell;  PtrQ-&gt;rear = FrontCell;  return OK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（二）</title>
      <link href="/2023/11/07/hui-bian-yu-yan-er/"/>
      <url>/2023/11/07/hui-bian-yu-yan-er/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（二）"><a href="#汇编语言（二）" class="headerlink" title="汇编语言（二）"></a>汇编语言（二）</h1><h2 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h2><h3 id="1-程序分段"><a href="#1-程序分段" class="headerlink" title="1.程序分段"></a>1.程序分段</h3><blockquote><p>主要可分为<strong>数据段、栈段和程序段</strong></p></blockquote><h4 id="1-1内存申请"><a href="#1-1内存申请" class="headerlink" title="1.1内存申请"></a>1.1内存申请</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 定义了多少数据，就相当于申请了对应长度的内存空间</div><p><strong>①相关指令</strong></p><blockquote><p><code>db</code>：定义<strong>字节型数据</strong><br><code>db 数据1,数据2,...,数据N</code></p></blockquote><blockquote><p><code>dw</code>：定义<strong>字型数据</strong><br><code>dw 数据1,数据2,...,数据N</code></p></blockquote><blockquote><p><code>dd</code>：定义<strong>双字数据</strong><br><code>dd 数据1,数据2,...,数据N</code></p></blockquote><blockquote><p><code>dup</code>：配合<code>db</code>、<code>dw</code>、<code>dd</code>进行<strong>重复数据的定义</strong><br><code>dd 重复次数 dup (重复数据列表)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> dd 3 dup (0,1,2)相当于dd 0,1,2,0,1,2,0,1,2</div><p><strong>②实例</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于dw指令在程序开头，故这些数据的地址从CS:0开始</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h    mov bx,0    mov ax,0    mov cx,8  s: add ax.cs:[bx]    add bx,2    loop s    mov ax,400ch    int 21h  code ends  end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③程序跟踪</strong></p><blockquote><p>使用<code>-u</code>查看程序内容，这些内容实际上是<code>dw</code><strong>定义的数据</strong>，但是被<code>debug</code>程序<strong>强行翻译为指令</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_18.png" alt="查看程序"></p><blockquote><p>使用<code>-r</code>查看<strong>前十六个字节</strong>的详细内容</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_19.png" alt="查看"></p><h4 id="1-2设置程序入口"><a href="#1-2设置程序入口" class="headerlink" title="1.2设置程序入口"></a>1.2设置程序入口</h4><p><strong>①<code>start</code>伪指令</strong>：将<code>CS:IP</code>指向对应地址</p><blockquote><p>上述程序<strong>不能正常运行</strong>，因为程序入口是<strong>数据强行翻译的指令</strong></p></blockquote><p><strong>②实例</strong></p><blockquote><p><code>end start</code>伪指令不仅仅描述<strong>程序的结束</strong>，也描述了<strong>程序的入口</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstart: mov bx,0    mov ax,0    mov cx,8 s: add ax.cs:[bx]    add bx,2    loop s    mov ax,400ch    int 21h  code ends  end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3栈机制"><a href="#1-3栈机制" class="headerlink" title="1.3栈机制"></a>1.3栈机制</h4><p><strong>①引言</strong></p><blockquote><p><strong>概述</strong>：可以把<strong>一段内存</strong>当作<strong>栈</strong>来使用<br><code>push 容器</code>：将容器中数据放入<strong>栈顶</strong><br><code>pop 容器</code>：将栈顶数据弹出并<strong>存入容器</strong>中</p></blockquote><blockquote><p><strong>相关寄存器</strong><br>段寄存器<code>SS</code>和寄存器<code>SP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> SS:SP指向栈顶的物理地址</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 指定了SS，也就相当于指定了一段内存作为栈，一个栈段最大为64KB</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_2.png" alt="CPU的栈机制"><br><strong>②push和pop的详细过程</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_3.png" alt="push"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_4.png" alt="pop"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 执行pop后，原来的栈顶元素并不会消失，直到被新push的元素覆盖</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 当栈满时push元素以及当栈空时pop元素，都会发生越界问题，需要自己注意</div><p><strong>③实例</strong></p><blockquote><p><strong>概述</strong>：将一段内存中数据<strong>反序排列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segment;定义16个字型数据，其中0为字节型数据，将这段空间当作栈来使用dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;设置栈顶指针，注意栈是从高地址向低地址增长start: mov ax,cs    mov ss,ax    mov sp,30h    mov bx,0    mov cx,8;将对应元素放入栈中s:  push cs:[bx]    add bx,2    loop s;重置循环相关寄存器    mov bx,0    mov cs,8;将栈中元素依次放入原来的位置，但是顺序颠倒s0: pop cs:[bx]    add bx,2    loop s0    mov ax,4c00h    int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 栈的地址空间需要自己申请，并将ss:sp指向对应位置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 栈从高地址向低地址增长</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用栈时要注意出栈、入栈顺序</div><h4 id="1-4使用多个段"><a href="#1-4使用多个段" class="headerlink" title="1.4使用多个段"></a>1.4使用多个段</h4><p><strong>①意义</strong></p><blockquote><p>将<strong>不同的类型数据</strong>放入<strong>不同的段</strong>中<br>使用<strong>更大的内存空间</strong></p></blockquote><p><strong>②实例</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:code,ds:data,ss:stackdata segment;定义8个字型数据dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment;申请栈空间dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segment;设置栈顶指针，注意栈是从高地址向低地址增长start: mov ax,stack ;注意段寄存器名换为段名    mov ss,ax    mov sp,20h ;为什么变为20h？;ds指向data段    mov ax,data    mov ds,ax    mov bx,0    mov cx,8;将对应元素放入栈中s:  push [bx]    add bx,2    loop s;重置循环相关寄存器    mov bx,0    mov cs,8;将栈中元素依次放入原来的位置，但是顺序颠倒s0: pop [bx]    add bx,2    loop s0    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 定义段，还需要申请一定大小的的内存</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> assume指令只是将段寄存器和对应段的名称联系到一起，并没有设定段寄存器的值，因为assume本质上还是一个伪指令，伪指令并不能控制cpu，还是需要修改ds、ss的值以访问对应段</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 段名本质上是一个字面值，不能直接将其存入段寄存器中</div><pre class="line-numbers language-none"><code class="language-none">mov ax,datamov ds,ax;而不是mov ds,data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-转移"><a href="#2-转移" class="headerlink" title="2.转移"></a>2.转移</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①转移指令</strong></p><blockquote><p>可以修改<code>IP</code>寄存器或者<strong>同时</strong>修改<code>CS</code>和<code>IP</code>寄存器的指令</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 转移指令可以控制CPU执行某一处代码</div><p><strong>②分类</strong></p><blockquote><p><strong>段内转移</strong>：只修改<code>IP</code><br><strong>段间转移</strong>：同时修改<code>CS</code>和<code>IP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 段内转移也可分为短转移和近转移</div><blockquote><p><strong>短转移</strong>：<code>IP</code>修改范围为<code>-128~127</code><br><strong>近转移</strong>：<code>IP</code>修改范围为<code>-32768~32767</code></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意这个范围限制，如果超出了对应的范围，会出错</div><p><strong>③<code>offset</code>操作符</strong></p><blockquote><p>取得<strong>标号</strong>的<strong>偏移地址</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentstart: mov ax,offset start ;相当于mov ax，0，代码段的偏移地址从0开始s:     mov ax,offset s ;相当于mov ax，3，因为前一条指令占两个字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> seg会取得标号的段地址</div><h4 id="2-2跳转指令"><a href="#2-2跳转指令" class="headerlink" title="2.2跳转指令"></a>2.2跳转指令</h4><p><strong>①格式</strong></p><blockquote><p><strong>标号转移</strong><br><code>jmp short 标号</code>：<strong>段内短转移</strong><br><code>jmp near ptr 标号</code>：<strong>段内近转移</strong><br><code>jmp far ptr 标号</code>：<strong>段间转移</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 标号实际上标识了一个地址</div><blockquote><p><strong>地址转移</strong><br><code>jmp 段地址：偏移地址</code>：将<code>CS:IP</code>修改为对应的地址<br><code>jmp 寄存器名</code>：将<code>IP</code>的值改为<strong>寄存器中数据</strong><br><code>jmp word ptr 内存单元地址</code>：从对应地址处读取<strong>一个字</strong>，用于修改<code>IP</code><br><code>jmp dword ptr 内存单元地址</code>从对应地址处读取<strong>两个字</strong>，<strong>高地址</strong>的字用于修改<code>CS</code>，<strong>低地址</strong>的字用于修改<code>IP</code></p></blockquote><blockquote><p><strong>条件转移</strong><br><code>jcxz 标号</code>：如果<code>cx</code><strong>寄存器</strong>的值为0，则跳转到<strong>标号</strong>处，只能<strong>段内短转移</strong></p></blockquote><p><strong>②段内转移原理</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentstart: mov ax,0       jmp short s       add ax,1s:     inc axcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在<code>debug</code>中将上述程序其翻译为<strong>机器指令</strong>，可知<code>jmp short s</code>对应<strong>机器指令</strong>为<code>EB03</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_21.png" alt="对应机器指令"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_22.png" alt="转移原理"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 段内转移对应机器指令并不包含目的地址信息，段内短转移是对IP进行八位位移，段内近转移是对IP进行十六位位移</div><p><strong>③段间转移原理</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentstart: mov ax,0       mov bx,0       jmp far ptr s       db 256 dup (0)s:     add ax,1       inc axcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对应<strong>机器指令</strong>如下，<code>jmp far ptr s</code>对应机器指令为<code>EA0B01BD0B</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_23.png" alt="对应机器指令"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 段间转移对应机器指令包含目的地址信息，BD0B为对应段地址0BBDH，0B01为对应偏移地址010BH</div><h4 id="2-3循环指令"><a href="#2-3循环指令" class="headerlink" title="2.3循环指令"></a>2.3循环指令</h4><p><strong>①格式</strong>：<code>loop 标号</code></p><blockquote><p>当cpu执行到<code>loop</code>指令时，首先将<strong>循环寄存器</strong><code>cx</code>中的值<strong>减一</strong>，若cx中的值<strong>不为零</strong>，则<strong>返回标号处</strong>执行程序，反之向下执行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 循环指令本质上是一个短转移</div><p><strong>②实例</strong></p><blockquote><p>以下汇编程序计算了<code>2^12</code>的值</p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segment    mov ax,2    mov cx,11s:  add ax.ax    loop s    mov ax,4c00h    int 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③多重循环</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为只有一个循环寄存器，若要多重循环，则每次开始内层循环时，将外层循环的cx中的数值保存起来，在执行外层的循环时，再恢复外层循环的cx数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以用栈、寄存器和某块特定内存（数据域中申请）存储数据</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codesg,ds:datasg,ss:stacksgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0 ;定义一个栈段，容量为16字节stacksg endscodesg segmentstart:mov ax,stacksg ;将栈寄存器指向定义的栈段    mov ss,ax    mov sp,16    mov ax datasg ;找到对应的数据段    mov ds,ax    mov bx,0    mov cx,4s0: push cx ;保存外层循环的值    mov si,0    mov cx,3 ;将cx设置为内层循环的次数s:  mov al,[bx+si]    and al,11011111b ;将对应字母转化为大写    mov [bx+si],al    inc si ;si每次加1，进行精定位    loop s    add bx,16 ;bx每次加16，进行粗定位，移动到下一行    pop cx        loop s0    mov ax,4c00H    int 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_20.png" alt="图解"></p><h4 id="2-4栈跳转"><a href="#2-4栈跳转" class="headerlink" title="2.4栈跳转"></a>2.4栈跳转</h4><p><strong>①相关指令</strong></p><blockquote><p><code>ret</code>：使用<strong>栈中的数据</strong>修改<code>IP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于pop IP</div><blockquote><p><code>retf</code>：使用<strong>栈中的数据</strong>修改<code>CS</code>和<code>IP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于pop IP和pop CS</div><blockquote><p><code>call 标号</code>：将当前<code>IP</code><strong>压入栈</strong>中，并<strong>转移到标号处</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push IP和jmp near ptr 标号</div><blockquote><p><code>call 16位寄存器</code>：将当前<code>IP</code><strong>压入栈</strong>中，并将<code>IP</code>设置为<strong>对应寄存器值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push IP和jmp 16位寄存器</div><blockquote><p><code>call word ptr 内存单元地址</code>：将当前<code>IP</code><strong>压入栈</strong>中，并将<code>IP</code>设置为<strong>对应内存单元数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push IP和jmp word ptr 内存单元地址</div><blockquote><p><code>call dword ptr 内存单元地址</code>：将当前<code>CS</code>和<code>IP</code><strong>压入栈</strong>中，并将<code>CS</code>和<code>IP</code>设置为<strong>对应内存单元数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push CS、push IP和jmp dword ptr 内存单元地址</div><p><strong>②<code>call</code>和<code>ret</code>的配合使用</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart: mov ax,1       mov cx,3       call s       mov bx,ax       mov ax,4c00h       int 21s:     add ax,ax       loop s       retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>程序过程概述</strong></p></blockquote><blockquote><p><strong>（1）</strong>当CPU读取<code>call s</code>指令后，<code>IP</code>指向了<strong>其后面</strong>的指令<code>mov bx,ax</code>，随后执行<code>call s</code>指令，将<strong>当前的<code>IP</code>值</strong>（<code>mov bx,ax</code>的偏移地址）<strong>压栈</strong>，并将<code>IP</code>指向标号<code>s</code><br><strong>（2）</strong>执行标号<code>s</code>处的循环，即<code>2^3</code><br><strong>（3）</strong>CPU读取<code>ret</code>指令，<code>IP</code>指向<code>ret</code>指令后的内存单元，CPU执行<code>ret</code>指令，此时<code>IP</code>指向<code>mov bx,ax</code>，随后执行至完成</p></blockquote><h3 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3.模块化"></a>3.模块化</h3><h4 id="3-1模板"><a href="#3-1模板" class="headerlink" title="3.1模板"></a>3.1模板</h4><pre class="line-numbers language-none"><code class="language-none">assume cd:codecode segmentmain:    ... ;主程序内容    mov ax,4c00h    int 21hsub1:    ... ;子程序1内容    sub2:    ... ;子程序2内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2实例"><a href="#3-2实例" class="headerlink" title="3.2实例"></a>3.2实例</h4><blockquote><p>计算<strong>一组数据</strong>的三次方，并保存在<strong>其后</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segment    dw 1,2,3,4,5,6,7,8    dd 0,0,0,0,0,0,0,0data endscode segementstart: mov ax,data       mov ds,ax       mov si,0       mov di,16       mov cx,8s:     mov bx,[si]       call cube       mov [di],ax       mov [di].2,dx       add si,2       add di,4       loop s       mov ax,4c00h       int 21hcube:  mov ax,bx       mul bx       mul bx       retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3批量数据传递"><a href="#3-3批量数据传递" class="headerlink" title="3.3批量数据传递"></a>3.3批量数据传递</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 利用循环以及寄存器</div><blockquote><p>将一段数据全部转化为<strong>大写</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segment    db 'conversation'data endscode segmentstart: mov ax,data       mov ds,ax       mov si,0       mov cx,12       call capital       mov ax,4c00h       int 21hcapital: and byte ptr [si],11011111b         inc si         loop capital         retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4寄存器冲突"><a href="#3-4寄存器冲突" class="headerlink" title="3.4寄存器冲突"></a>3.4寄存器冲突</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 子程序和主程序寄存器冲突，在子程序开始之前将所有用到的寄存器中的内容保存起来，在子程序返回前在恢复</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segment    db 'word',0    db 'unix',0    db 'wind',0    db 'good',0data endscode segmentstart: mov ax,data       mov ds,ax       mov bx,0       mov cx,4s:     mov si,bx       call capital       add bx,5       loop scapital: push cx         push sichange:  mov cl,[si]         mov ch,0         jcxz ok         and byte ptr [si],11011111b         inc si         jmp short changeok:      pop si         pop cx         retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
            <tag> 《汇编语言》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（一）</title>
      <link href="/2023/11/07/hui-bian-yu-yan-yi/"/>
      <url>/2023/11/07/hui-bian-yu-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="汇编语言启蒙"><a href="#汇编语言启蒙" class="headerlink" title="汇编语言启蒙"></a>汇编语言启蒙</h2><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 以下内容主要以8086CPU为例，该CPU是16位结构，注意这个大前提</div><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1汇编语言"><a href="#1-1汇编语言" class="headerlink" title="1.1汇编语言"></a>1.1汇编语言</h4><p><strong>①组成</strong></p><blockquote><p><strong>汇编指令</strong>：机器指令便于记忆的格式，有对应的<strong>机器码</strong><br><strong>伪指令</strong>：没有对应的机器码，由<strong>编译器执行</strong>，计算机并不执行<br><strong>符号</strong>：由<strong>编译器识别</strong>，没有对应的机器码</p></blockquote><p><strong>②机器语言</strong></p><blockquote><p><strong>机器指令</strong>的集合，机器指令是一系列<strong>二进制数字</strong>，计算机将机器指令转化为一系列的<strong>高低电平</strong>，使电子器件受到驱动</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这个工作由微处理器（如CPU）完成，每一种微处理器都有其机器指令集</div><h4 id="1-2指令与数据"><a href="#1-2指令与数据" class="headerlink" title="1.2指令与数据"></a>1.2指令与数据</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 两者本质上都是一串二进制数据，也并没有特殊的格式区别它们，取决于CPU如何解释它们</div><p><strong>①进制</strong></p><blockquote><p><strong>二进制</strong>：以字母<code>B</code>结尾<br><strong>八进制</strong>：以字母<code>O</code>或者<code>Q</code>结尾<br><strong>十进制</strong>：以字母<code>D</code>结尾，或者没有结尾字母<br><strong>十六进制</strong>：以字母<code>H</code>结尾</p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 十六进制的数据，在汇编源程序中不能以字母开头，需要在前面加0，如A000H需要改为0A000H</div><p><strong>②ASCLL编码</strong></p><blockquote><p>用<strong>单引号</strong><code>''</code>表示对应信息<strong>按照字符</strong>给出，<strong>编译器</strong>将其转化为对应的<code>ASCLL</code>编码<br><code>'unIX'</code>等价于<code>75H,6EH,49H,58H</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 小写字母的ASCLL码比对应大写字母的ASCLL码大20H</div><p><strong>③逻辑位操作</strong></p><blockquote><p><code>and</code>：按位进行<strong>与</strong>运算<br><code>or</code>：按位进行<strong>或</strong>运算</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以通过该逻辑运算将对应的位设为1/0</div><pre class="line-numbers language-none"><code class="language-none">and al,10111111 ;将第6位设为0or al,01000000 ;将第6位设为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过改变位改变字母大小写，大写字母的ASCLL码第5位为0，小写字母对应位置为1，这样不需要判断大小写</div><p><strong>③移位操作</strong></p><blockquote><p><code>shl</code>：<strong>左</strong>移位<br><code>shr</code>：<strong>右</strong>移位</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这条指令将移出的位存储在CF标志中，并用0填充缺失的位</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只能操作内存单元或者寄存器，不能操作字面量</div><h4 id="1-3相关硬件概念"><a href="#1-3相关硬件概念" class="headerlink" title="1.3相关硬件概念"></a>1.3相关硬件概念</h4><p><strong>①主板和接口卡</strong></p><blockquote><p><strong>主板</strong>：主板上一些主要器件通过<strong>总线</strong>相连，如<strong>CPU</strong>、<strong>存储器</strong>、<strong>外围芯片组</strong>和<strong>扩展插槽</strong>等<br><strong>接口卡</strong>：插在<strong>扩展插槽</strong>上，CPU通过控制接口卡控制<strong>外部设备</strong>，如鼠标、屏幕和键盘等</p></blockquote><p><strong>②CPU</strong></p><blockquote><p><strong>组成</strong><br><strong>运算器</strong>：信息处理<br><strong>寄存器</strong>：信息存储，一般能存储的<strong>位数不高</strong>，主要都是<strong>和CPU密切相关的信息</strong><br><strong>控制器</strong>：控制各种器件工作</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 出于兼容性的考虑，一个寄存器可分多个寄存器，通常最小单位8位（因为一个内存单元是8位），如一个16位寄存器ax可以看成两个8位寄存器al和ah</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过改变寄存器内容实现对CPU的控制</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当指令操作al导致溢出时，溢出的位不会存储到ah中，因为它将al当作一个独立的寄存器</div><p><strong>③总线</strong></p><blockquote><p>CPU和<strong>其他部件</strong>交流的通道，物理上是一根根<strong>导线的集合</strong>，可分为以下三类</p></blockquote><blockquote><p><strong>地址总线</strong>：指定存储单元</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 地址总线的宽度（根数）为N，则其能对2^N个单元寻址</div><blockquote><p><strong>数据总线</strong>：传输数据</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据总线的宽度（根数）为N，则一次能传输N位的数据</div><blockquote><p><strong>控制总线</strong>：传输控制指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据总线的宽度（根数）为N，则有N种控制指令（激活则为高电平）</div><p><strong>④存储器</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 依据读写属性分类</div><blockquote><p><strong>随机存储器</strong>：<strong>可读可写</strong>，但是必须<strong>带电存储</strong>，关机后存储内容消失<br><strong>只读存储器</strong>：只能读取，存储内容<strong>不会丢失</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 依据功能分类</div><blockquote><p><strong>随机存储器</strong>：存放CPU使用的<strong>大部分数据和程序</strong><br><strong>装有BIOS的ROM</strong>：BIOS是主板和各类接口卡中的软件，可通过它对该硬件进行<strong>最基本的输入和输出</strong><br><strong>接口卡上的RAM</strong>：某些接口卡需要<strong>对大量输入输出数据进行暂时存储</strong>，则会装有RAM，如显示卡的显存</p></blockquote><p><strong>⑤端口</strong></p><blockquote><p><strong>PC系统</strong>中，除了<strong>存储器</strong>，还有<strong>其他芯片</strong>通过<strong>总线</strong>和CPU相连，如<strong>接口卡</strong>和<strong>主板</strong>上的<strong>接口芯片</strong>等，这些芯片都有一组可以由CPU读写的<strong>寄存器</strong>，称之为<strong>端口</strong>，每个端口都有一个<strong>对应的地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 端口只能用in和out指令进行读写，且需要用特定的寄存器访问端口</div><hr><h3 id="2-内存与地址"><a href="#2-内存与地址" class="headerlink" title="2.内存与地址"></a>2.内存与地址</h3><h4 id="2-1内存地址空间"><a href="#2-1内存地址空间" class="headerlink" title="2.1内存地址空间"></a>2.1内存地址空间</h4><p><strong>①存储单元</strong></p><blockquote><p>每个存储器被划分为<strong>若干个存储单元</strong>，每个存储单元存储<strong>一个字节</strong></p></blockquote><p><strong>②逻辑存储器</strong></p><blockquote><p>CPU在操作<strong>物理存储器</strong>时，将他们<strong>总的</strong>看作为一个由若干存储单元组成的<strong>逻辑存储器</strong>，每个存储器占<strong>一段地址空间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内存地址空间的大小受到地址总线宽度的影响</div><h4 id="2-2物理地址"><a href="#2-2物理地址" class="headerlink" title="2.2物理地址"></a>2.2物理地址</h4><blockquote><p>一个单元<strong>真实唯一</strong>的地址，也是CPU通过<strong>地址总线</strong>发出的地址</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 物理地址的详细计算方法和具体的CPU有关，其中最重要的就是它是多少位结构</div><p><strong>①十六位结构</strong></p><blockquote><p><strong>运算器一次处理</strong>最多<strong>16位</strong>的数据<br><strong>寄存器最大长度</strong>为<strong>16位</strong><br><strong>寄存器和运算器的通路</strong>为<strong>16位</strong></p></blockquote><p><strong>②地址加法器</strong>：计算<strong>物理地址</strong>，<code>物理地址 = 段地址*16+偏移地址</code>，也可以表示为<code>段地址:偏移地址</code></p><blockquote><p>易知每一段的起始地址为<strong>16的倍数</strong>，每一段的长度为<strong>64KB</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 8086CPU地址总线宽度为20，但是它本身一次性只能传输16位数据，如果直接从CPU内部发出地址信号，则只能达到64KB的寻址能力，故需要使用地址加法器扩大其寻址能力（16位乘以16则为20位）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 同一个物理地址可以使用不同的段地址和偏移地址表示</div><h4 id="2-3寻址"><a href="#2-3寻址" class="headerlink" title="2.3寻址"></a>2.3寻址</h4><p><strong>①段地址</strong>：由<strong>段寄存器</strong>提供</p><blockquote><p>8086CPU有四个段寄存器，<code>CS</code>、<code>DS</code>、<code>ES</code>和<code>SS</code>，其中<code>CS</code>和<code>SS</code>有对应的<strong>特殊用途</strong>，其余可供自由使用</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省时，cpu会根据情况自动读取段寄存器中的值作为默认段地址，可以添加段前缀显示表明段地址</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个寄存器都有其特殊用途，如乘除法需要使用ax，bx，只是CS、SS等寄存器被占用频率非常高，故最好不要随便使用</div><blockquote><p><strong>段前缀</strong>：<code>段前缀:[偏移地址]</code><br>段前缀通常是<strong>段寄存器名</strong>，如<code>mov ax,ds:[bx]</code></p></blockquote><p><strong>②偏移地址</strong>：可以通过<code>[]</code>给出，其中可以放置<strong>立即数</strong>和<strong>寻址寄存器</strong>，也可以<strong>混合使用</strong></p><blockquote><p><strong>立即数</strong>：直接<strong>包含在机器指令中</strong>的数据，执行前位于cpu的<strong>指令缓冲器</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如100、'a'等，类似于C中的字面值</div><blockquote><p><strong>寻址寄存器</strong>：8086CPU提供了<code>bx</code>，<code>bp</code>，<code>si</code>，<code>di</code>四个寄存器</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> si和di寄存器，不能分为两个八位寄存器</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 其中bx和bp不能同时出现，si和di也不能同时出现</div><blockquote><p><strong>混合使用</strong>：如<code>[bx+si+8]</code>、<code>[bp+di]</code>、<code>[bx+9]</code>，也可以写成<code>[bx].8[si]</code>、<code>[bx].9</code>、<code>[bx]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若含有bp，则段地址默认为ss段寄存器中的数据，其余默认为ds段寄存器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 用段寄存器指定段，用偏移地址访问段</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 汇编语言中偏移地址是以存储单元为单位计算的，并没有像C语言那么智能</div><h4 id="2-4内存访问"><a href="#2-4内存访问" class="headerlink" title="2.4内存访问"></a>2.4内存访问</h4><p><strong>①<code>mov</code>指令</strong>：</p><blockquote><p><code>mov [container],[data]</code><br>将<strong>数据</strong>送入一个<strong>容器</strong>中</p></blockquote><blockquote><p><strong>容器</strong>：类似于<strong>C的左值</strong>，可以是<strong>寄存器名</strong>，<strong>内存单元地址</strong><br><strong>数据</strong>：类似于<strong>C的右值</strong>，可以是<strong>字面量</strong>、<strong>寄存器名</strong>以及<strong>内存单元地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> mov ax,bx类似于C中ax = bx</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 8086CPU不支持通过立即数直接修改段寄存器的值（mov DS,xxxxH），需要先修改一个通用寄存器的值，然后将该寄存器的值送入DS（mov ds,ax）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 与在debug中不同的是，mov ax,[0]指令在一些编译器中的意义等同于mov ax,0，为了防止歧义需要添加段前缀，或者将0存入bx中，采用mov ax,[bx]</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在赋值的时候，需要保证两边的内存大小是一样的</div><blockquote><p>若需要将一个<strong>小内存</strong>的值<strong>传入</strong>到<strong>大内存值</strong>中（如累加，需要使用一个大内存作为容器<strong>防止溢出</strong>），可以用一个<strong>大内存容器</strong>作为<strong>中介</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">mov dx,bl ;错误mov al,blmov ah,0add dx,ax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②数据长度信息</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 访问内存不仅仅需要直到其起始地址，还需要知道操作的内存长度</div><blockquote><p><strong>寄存器名</strong>：如<code>mov ax,xxx</code>或者<code>mov xxx,ax</code>则表示<strong>处理的数据长度为一个字</strong>，因为<code>ax</code>寄存器长度为<strong>一个字</strong><br>同理<code>mov al,xxx</code>或者<code>mov xxx,al</code>表示进行<strong>字节操作</strong></p></blockquote><blockquote><p><strong>显示指明</strong>：<code>word ptr</code>指明访问的内存为<strong>字单元</strong>，<code>byte ptr</code>指明是<strong>字节单元</strong><br>如<code>mov word ptr ds:[0],1</code>和<code>mov byte ptr ds:[0],1</code>,两者修改的<strong>内存长度</strong>不一样，前者修改的是<code>ds:[0]</code>和<code>ds:[1]</code>，后者修改的是<code>ds;[0]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个字需要两个内存单位，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> push、pop只执行字操作</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在没有寄存器参与的内存单元访问指令中，必须要显示指明操作内存长度</div><h4 id="2-5指令的访问"><a href="#2-5指令的访问" class="headerlink" title="2.5指令的访问"></a>2.5指令的访问</h4><p><strong>①相关寄存器</strong></p><blockquote><p><strong><code>CS</code>段寄存器</strong>：用于提供<strong>当前要实施指令</strong>的<strong>段地址</strong><br><strong><code>IP</code>寄存器</strong>：搭配<code>CS</code><strong>段寄存器</strong>使用，8086CPU将<code>CS:IP</code>作为当前要实施的指令的<strong>物理地址</strong></p></blockquote><p><strong>②过程概述</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_1.png" alt="初始状态"></p><blockquote><p><code>CS</code>和<code>IP</code>寄存器的值送入<strong>地址加法器</strong>中，获得指令的<strong>物理地址</strong><br><strong>地址加法器</strong>将物理地址送入<strong>控制输入输出电路</strong><br><strong>控制输入输出电路</strong>将物理地址送入<strong>地址总线</strong><br><strong>数据总线</strong>将对应物理地址<strong>对应的指令</strong>送入CPU</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如图，一条指令占据多个内存单元，数据总线输入的是整条指令，而不仅仅是对应物理地址对应的内存单元的数据</div><blockquote><p><strong>控制输入输出电路</strong>将对应指令送入<strong>指令缓冲器</strong><br><code>IP</code>的值自动增加，指向<strong>下一条指令</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若刚刚读入的指令长度为N个字节，则IP增加3</div><blockquote><p><strong>执行</strong>指令缓冲器中的指令，并重复上述过程执行<strong>下一条指令</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> CS:IP对应内存位置的数据即为指令，CPU根据这个区分指令和数据</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以修改CS和IP寄存器的值，指向我们的代码段，用于执行该段代码</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> mov指令可以修改大部分寄存器的地址，但是不能修改CS和IP的地址，需要用跳转修改</div><hr><h3 id="3-汇编程序概述"><a href="#3-汇编程序概述" class="headerlink" title="3.汇编程序概述"></a>3.汇编程序概述</h3><h4 id="3-1汇编程序执行概述"><a href="#3-1汇编程序执行概述" class="headerlink" title="3.1汇编程序执行概述"></a>3.1汇编程序执行概述</h4><p><strong>①编写汇编源程序</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 汇编语言的源文件后缀为.asm</div><p><strong>②对源程序进行编译链接</strong></p><blockquote><p>编译产生<strong>目标文件</strong><br>链接源文件产生<strong>可执行文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可执行文件包括两部分，一部分为程序和数据，另一部分为相关描述信息（程序有多大，占用多大内存）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中伪指令在编译时均转化为相关描述信息</div><p><strong>③执行程序</strong></p><blockquote><p>每个<strong>操作系统</strong>都有类似于<strong>命令解释器</strong>的程序用于执行程序，<strong>命令解释器</strong>会先找到对应程序并将其<strong>载入内存</strong>，随后设置<code>CS:IP</code>指向<strong>程序的入口</strong>，命令解释器<strong>停止运行</strong>，并运行对应程序，最后对应程序运行<strong>结束</strong>，<strong>返回</strong>到命令解解释程序</p></blockquote><h4 id="3-2汇编源程序框架"><a href="#3-2汇编源程序框架" class="headerlink" title="3.2汇编源程序框架"></a>3.2汇编源程序框架</h4><p><strong>①框架</strong></p><blockquote><p>汇编指令才是<strong>机器执行</strong>的指令，其余都变成了<strong>描述信息</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_5.png" alt="指令和伪指令"></p><blockquote><p><strong>程序返回</strong>：一个程序结束后，将<strong>CPU的控制权</strong>还给使他运行的程序</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在汇编程序的最后一个段中结尾处添加以下两行指令即可</div><pre class="line-numbers language-none"><code class="language-none">mov ax,4c00Hint 21H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②常用伪指令</strong></p><blockquote><p><code>assume 段寄存器名:段名</code>：将某个段和某个<strong>段寄存器</strong>联系到一起</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 段和段寄存器的关联将决定这个段的作用，如代码段和CS联系到一起，栈段和SS联系到一起</div><blockquote><p><code>段名 segment</code>：说明一个段<strong>开始</strong><br><code>段名 ends</code>：说明一个段<strong>结束</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个汇编程序由多个段组成，段名最后会被处理为一个段地址</div><blockquote><p><code>end</code>：一个汇编程序的<strong>结束标记</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不要搞混end和ends</div><p><strong>②常用汇编指令</strong></p><blockquote><p><code>add</code>：加法指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> add ax,bx类似于C中ax = ax + bx</div><blockquote><p><code>sub</code>：减法指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> sub ax,bx类似于C中ax = ax - bx</div><blockquote><p><code>inc</code>：递增指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> inc ax类似于ax = ax+1</div><blockquote><p><code>dec</code>：递减指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> dec ax类似于ax = ax-1</div><blockquote><p><code>div</code>：除法指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> div 容器，容器（不能是ax，dx相关寄存器）中为除数，若除数为8位，则被除数为16位，放在ax中，结束后al存商，ah存余数，若除数为16位，则被除数为32位，高位放在dx中，低位放在ax中，结束后ax存商，dx存余数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 根据被除数的范围选取除法的类别，16位寄存器能表示的值的上限为65535</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用内存单元时，需要使用word ptr和byte ptr指明内存单元的长度</div><blockquote><p><code>mul</code>：乘法法指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> </div><h4 id="3-3源文件的编译"><a href="#3-3源文件的编译" class="headerlink" title="3.3源文件的编译"></a>3.3源文件的编译</h4><p><strong>①运行编译器</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_6.png" alt="masm编译器"></p><blockquote><p>本篇采用微软的<code>masm</code>编译器</p></blockquote><p><strong>②导入源文件</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_7.png" alt="导入源文件"></p><blockquote><p>如果源文件在<strong>编译器工作路径下</strong>，输入<strong>文件名</strong>即可，否则需要指明<strong>完整路径</strong><br>如果源程序不是<code>.asm</code>文件，则需要输入<strong>全名</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 编译后将在指定路径（在对应冒号后输入路径即可）生成可执行文件（.obj文件），缺省情况下当前路径</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 编译过程中还会提示你生成一些中间文件，如列表文件（.lst）和交叉引用文件（.crf），可忽略（直接enter）</div><h4 id="3-4链接目标文件"><a href="#3-4链接目标文件" class="headerlink" title="3.4链接目标文件"></a>3.4链接目标文件</h4><p><strong>①运行链接器</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_8.png" alt="Overlay Linker链接器"></p><blockquote><p>本篇采用微软的<code>Overlay Linker</code></p></blockquote><p><strong>②导入目标文件</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_9.png" alt="导入目标文件"></p><blockquote><p>路径和文件名的规则<strong>同编译器</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 链接过程中还会提示你生成一些中间文件，如映像文件（.map），可忽略（直接enter）</div><p><strong>③链接库文件</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_10.png" alt="链接库文件"></p><blockquote><p>如果程序中调用了<strong>库文件中的子程序</strong>，则需要链接对应的库</p></blockquote><h4 id="3-5简化的编译和链接"><a href="#3-5简化的编译和链接" class="headerlink" title="3.5简化的编译和链接"></a>3.5简化的编译和链接</h4><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_11.png" alt="简化的编译"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_12.png" alt="简化的链接"></p><blockquote><p>将跳过一些<strong>非必要步骤</strong>，即生成中间文件和链接库</p></blockquote><h4 id="3-6跟踪程序执行过程"><a href="#3-6跟踪程序执行过程" class="headerlink" title="3.6跟踪程序执行过程"></a>3.6跟踪程序执行过程</h4><blockquote><p>本篇采用微软的<code>debug</code>程序</p></blockquote><p><strong>①导入可执行文件</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_14.png" alt="简化的链接"></p><p><strong>②可执行文件的加载过程</strong></p><blockquote><p><code>DOS</code>系统中可执行文件的加载过程，其中<code>SA</code>存放在<code>ds</code>寄存器中，<code>DOS</code>系统使用<code>PSP</code>用来与程序通信</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_15.png" alt="可执行文件的内存情况"></p><p><strong>③查看寄存器状态</strong></p><blockquote><p>输入<code>-r</code>查看寄存器</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_13.png" alt="简化的链接"></p><p><strong>④查看程序内容</strong></p><blockquote><p>输入<code>-u</code>查看程序内容</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_16.png" alt="查看程序内容"></p><p><strong>⑤单步执行程序</strong></p><blockquote><p>输入<code>-t</code>单步执行指令</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当执行到int 21时，需要使用-p执行</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_17.png" alt="单步执行程序"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
            <tag> 《汇编语言》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（三）</title>
      <link href="/2023/11/07/hui-bian-yu-yan-san/"/>
      <url>/2023/11/07/hui-bian-yu-yan-san/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（三）"><a href="#汇编语言（三）" class="headerlink" title="汇编语言（三）"></a>汇编语言（三）</h1><h2 id="汇编语言进阶"><a href="#汇编语言进阶" class="headerlink" title="汇编语言进阶"></a>汇编语言进阶</h2><h3 id="1-状态寄存器"><a href="#1-状态寄存器" class="headerlink" title="1.状态寄存器"></a>1.状态寄存器</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPU内部的一种特殊的寄存器，其中每一位都用于记录特定的信息，主要介绍8086的标志寄存器</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个指令是否影响标志寄存器，以及影响哪些部分，都是不同的</div><blockquote><p><strong>相关指令</strong>的<strong>执行结果</strong><br>为CPU执行<strong>相关指令</strong>提供<strong>行为依据</strong><br>控制CPU的相关<strong>工作方式</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_24.png" alt="8086的标志寄存器"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_26.png" alt="debug中的8086标志寄存器"></p><h4 id="1-2标志"><a href="#1-2标志" class="headerlink" title="1.2标志"></a>1.2标志</h4><p><strong>①ZF标志</strong></p><blockquote><p>记录<strong>相关指令</strong>的计算结果是否为<code>0</code>，如果为<code>0</code>，则该位为<code>1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要是add之类的运算指令以及逻辑运算指令</div><p><strong>②PF标志</strong></p><blockquote><p>记录<strong>相关指令</strong>执行后，其结果<code>bit</code>位中<code>1</code>的个数是否为<strong>偶数</strong>，若为偶数，则为<code>1</code></p></blockquote><p><strong>③SF标志</strong></p><blockquote><p>记录<strong>相关指令</strong>执行后，其结果是否为<strong>负</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这个标志的前提是进行有符号运算</div><blockquote><p>计算机常用<strong>补码</strong>描述<strong>有符号数</strong>，如<code>10000001B</code>可以看作是<strong>无符号数</strong><code>129</code>，也可以看作<strong>有符号数</strong><code>-127</code></p></blockquote><p><strong>④CF标志</strong></p><blockquote><p>记录了<strong>无符号运算</strong>时运算结果的<strong>最高有效位</strong>像<strong>更高位</strong>的<strong>进位值/借位值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF的含义取决于其被什么指令设置，如果为加法指令，则表示进位值，如果为减法指令，则表示借位值</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_25.png" alt="有效位"></p><p><strong>⑤OF标志</strong></p><blockquote><p>记录<strong>有符号运算</strong>的结果是否发生了<strong>溢出</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意，只要执行了对应的指令，相关标志位就会发生改变，无论是有符号运算还是无符号运算，只是某些标志位只在某种特定情况下有意义罢了</div><blockquote><p>如执行<code>0F0H+88H</code>，<code>CF</code>会变为<code>1</code>，因为如果这是一个<strong>无符号运算</strong>，会产生<strong>进位</strong>，<code>OF</code>也会变为<code>1</code>，因为如果这是一个<strong>有符号运算</strong>，会发生<strong>溢出</strong></p></blockquote><h4 id="1-3相关指令"><a href="#1-3相关指令" class="headerlink" title="1.3相关指令"></a>1.3相关指令</h4><p><strong>①<code>adc</code>指令</strong></p><blockquote><p><strong>格式</strong>：<code>adc ax,bx</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 带进位加法指令,adc ax,bx相当于ax+bx+CF</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以利用adc指令实现更大数据的加法运算</div><blockquote><p>计算<code>1EF0001000H+2010001EF0H</code>，将<strong>最高16位</strong>放在<code>ax</code>中，<strong>次高16位</strong>放在<code>bx</code>中，<strong>低16位</strong>放在<code>cx</code>中，更大的数据同理</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mov ax,001EHmov bx,0F000Hmov cx,1000Hadd cx,1EF0Hadc bx,1000Hadc ax,0020H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②<code>sbb</code>指令</strong></p><blockquote><p><strong>格式</strong>：<code>sbb ax,bx</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 带进位减法指令，sbb ax,bx相当于ax-bx-CF</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同上，可以利用sbb实现更大数据的减法运算</div><p><strong>③<code>cmp</code>指令</strong></p><blockquote><p><strong>格式</strong>：<code>cmp ax,bx</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 比较指令，功能相当于减法指令，但是不保存结果，只影响标志寄存器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过标志寄存器状态判断参数大小关系</div><blockquote><p><code>ZF</code>：判断两者是否<strong>相等</strong></p></blockquote><blockquote><p><strong>无符号数</strong><br><code>CF</code>：若为<code>1</code>，则<code>ax &lt; bx</code>，反之则<code>ax ≥ bx</code></p></blockquote><blockquote><p><strong>有符号数</strong><br><code>SF</code>：若为1，则逻辑上<code>ax &lt; bx</code>，反之逻辑上<code>ax ≥ bx</code><br><code>OF</code>：判断是否溢出，若<strong>溢出</strong>，则真实大小关系和逻辑大小关系<strong>相反</strong>，反之则一致</p></blockquote><p><strong>④基于比较结果的条件转移</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 检测相关标志，从而转移到标号处，可以配合cmp指令使用，以下列举无符号数的相关指令</div><blockquote><p><code>je 标号</code>：<strong>相等</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ZF标志为1</div><blockquote><p><code>jne 标号</code>：<strong>不等</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ZF标志为0</div><blockquote><p><code>jb 标号</code>：<strong>低于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为1</div><blockquote><p><code>jnb 标号</code>：<strong>不低于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为0</div><blockquote><p><code>ja 标号</code>：<strong>高于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为0且ZF标志为0</div><blockquote><p><code>jna 标号</code>：<strong>不高于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为1且ZF标志为1</div><p><strong>⑤串传送指令</strong></p><blockquote><p><strong>DF标志</strong>：控制<strong>串处理过程</strong>中相关寄存器（<code>si</code>和<code>di</code>）<strong>移动方向</strong>，若为<code>0</code>，则<strong>增加</strong>，反之则减少</p></blockquote><blockquote><p><strong>串传送指令</strong><br><code>movsb</code>：将<code>ds:[si]</code>中数据移动到<code>es:[di]</code>，并根据DF标志移动<code>si</code>和<code>di</code>，每次操作<strong>1个内存单位</strong><br><code>movsw</code>：同上，但是每次操作<strong>2个内存单位</strong></p></blockquote><blockquote><p><strong>相关辅助指令</strong><br><code>rep 串传送指令</code>：根据<code>cx</code>的值，<strong>重复执行</strong>其后的串传送指令<br><code>cld</code>：将<strong>DF标志</strong>设为<code>0</code><br><code>std</code>：将<strong>DF标志</strong>设为<code>1</code></p></blockquote><p><strong>⑥访问标志寄存器</strong></p><blockquote><p><code>pushf</code>：将<strong>整个标志寄存器</strong>的值压栈<br><code>popf</code>：从栈中弹出数据，送入<strong>标志寄存器</strong></p></blockquote><hr><h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2.中断"></a>2.中断</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①定义</strong></p><blockquote><p>当CPU接收到<strong>中断信息</strong>后，<strong>执行完</strong>当前正在执行的指令后，<strong>不再向下执行</strong>，转去处理中断信息</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 中断的优先级不一定是最高的，比如在修改栈顶地址过程中发生中断，他是不会响应中断的</div><p><strong>②内中断</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以8086CPU为例</div><blockquote><p><strong>除法错误</strong>，中断类型码为<code>0</code><br><strong>单步执行</strong>，中断类型码为<code>1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当TF标志为1，则产生单步中断</div><blockquote><p><strong>执行<code>into</code>指令</strong>，中断类型码为<code>4</code><br><strong>执行<code>int</code>指令</strong>，指令格式为<code>int n</code>，其中<code>n</code>为中断类型码</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 利用int指令主动引发中断</div><p><strong>③外中断</strong></p><blockquote><p><strong>可屏蔽外中断</strong>：<strong>可以不响应</strong>的中断，</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 是否相应外中断由IF标志决定，可以通过指令设置其状态</div><blockquote><p><strong>不可屏蔽外中断</strong>：执行完当前指令，<strong>立即响应</strong></p></blockquote><h4 id="2-2中断处理程序"><a href="#2-2中断处理程序" class="headerlink" title="2.2中断处理程序"></a>2.2中断处理程序</h4><p><strong>①中断向量表</strong></p><blockquote><p>提供<strong>中断类型码</strong>与其对应<strong>中断处理程序入口地址</strong>的关系，一个表项占<strong>两个内存单元</strong>，<strong>高地址字</strong>存放<strong>段地址</strong>，<strong>低地址字</strong>存放<strong>偏移地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 中断向量表保存在内存特定位置，对于8086CPU，放在内存0000:0000至0000:03FF</div><p><strong>②中断过程</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以8086CPU为例，由CPU自动执行</div><blockquote><p>从<strong>中断信息</strong>中获取<strong>中断类型码</strong><br><strong>标志寄存器</strong>的值<strong>入栈</strong>，并将标志寄存器的<strong>TF标志</strong>和<strong>IF标志</strong>设为<code>0</code><br><code>CS</code>和<code>IP</code>的值<strong>入栈</strong><br>根据<strong>终端类型码</strong>将<code>CS:IP</code>指向<strong>中断程序入口地址</strong></p></blockquote><p><strong>③中断程序常规步骤</strong></p><blockquote><p>保存<strong>用到的寄存器</strong><code>-&gt;</code>处理中断<code>-&gt;</code><strong>恢复</strong>用到的寄存器<code>-&gt;</code>用<code>iret</code>指令返回</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> iret指令相当于pop IP、pop CS和popf</div><p><strong>④BIOS</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 系统板的ROM中存放的程序（基本输入输出系统），主要包括对硬件系统的检测和初始化程序，以及各种中断例程</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一个中断例程通常包含多个子程序，根据相关寄存器决定执行哪个子程序以及相关效果</div><blockquote><p>如以下常用的<strong>中断例程</strong>，设置<code>ax</code>表示使用<strong>程序返回</strong>功能</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mov ax,4c00hint 21h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_27.png" alt="BIOS安装过程"></p><h4 id="2-3自定义中断处理程序"><a href="#2-3自定义中断处理程序" class="headerlink" title="2.3自定义中断处理程序"></a>2.3自定义中断处理程序</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以8086下除法溢出为例，编写程序安装自定义中断程序</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart: mov ax,cs       mov ds,ax         ;设置ds:si指向中断程序源地址       mov si,offset do0        mov ax,0       mov es,ax         ;设置es:di指向中断程序最终目标地址       mov di,200h       mov cx,offset do0end-offset do0 ;设置串传输的长度       cld ;设置传输方向       rep movsb       ;设置中断向量表       mov ax,0       mov es,ax       mov word ptr es:[0*4],200h       mov word ptr es:[0*4+2],0       mov ax,4c00h       int 21hdo0：  jmp short do0start       db "overflow"do0start: mov ax,cs          mov ds,ax   ;将ds:si指向字符串          mov si,202h          mov ax,0b800h          mov es,ax         ;设置es:di指向显存空间的中间位置          mov di,12*160+36*2          mov cx,9s:        mov al,[si]          mov es:[di],al          inc si          add di,2          loop s          mov ax 4c00h          int 21hdo0end: nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>①申请空间</strong></p><blockquote><p>由于CPU<strong>随时</strong>都有可能收到<strong>中断信息</strong>，所以中断处理程序必须<strong>一直存储在某段内存空间中</strong>，所以需要申请一段<strong>不会被别的程序使用</strong>的空间</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在这里为了简便，直接使用了0000:0200至0000:02FF这段空间，因为这段空间是8086中断向量表空余空间，不会被使用</div><p><strong>②安装</strong></p><blockquote><p><strong>安装中断处理程序</strong>主要分为两步，即将<strong>编写的程序复制到申请的空间中</strong>，并将对应<strong>中断向量表项设置为申请空间起始地址</strong></p></blockquote><p><strong>③编写中断程序</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在中断程序中使用寄存器，需要先将其中内容保存字栈中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 本例中直接退出程序，如果中断过后还需要返回程序，则需要将mov ax 4c00h和int 21h替换为iret指令</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 中断处理程序用到的数据(如overflow)需要在中断处理程序中申请，并记得设置程序的执行起点</div><h3 id="3-子程序"><a href="#3-子程序" class="headerlink" title="3.子程序"></a>3.子程序</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①带长度信息的标号</strong></p><blockquote><p><strong>标号</strong>实质上就是<strong>对应位置的起始地址</strong>，一些标号<strong>不带长度信息（如<code>a</code>）</strong>，一些标号<strong>带长度信息（如<code>b</code>）</strong>，格式上表现为<strong>后面</strong>是否跟一个<strong>冒号</strong><code>:</code>，以及对应<strong>描述大小的伪指令</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume ds:datadata segmenta: dw 1,2,3,4,5,6,7,8b  dw 1,2,3,4,5,6,7,8c  dw a,bdata ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 带有长度的标号相当于一个对应长度的内存单元</div><pre class="line-numbers language-none"><code class="language-none">mov a,2 ;错误，没有指定长度信息mov word ptr a,2mov b,2 ;相当于mov word ptr cs:[16],2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>②<code>assume</code>详解</strong></p><blockquote><p><code>assume</code>将<strong>对应段寄存器</strong>和<strong>对应段</strong>联系在一起，表现为位于<strong>对应段</strong>的<strong>标号</strong>自动取<strong>对应段寄存器</strong>中的内容作为<strong>段地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以下三条指令是等价的，因为标号b在data段中，会默认取ds寄存器中内容为段地址</div><pre class="line-numbers language-none"><code class="language-none">mov ax,b[bx+si+3]mov ax,ds:0[bx+si+3]mov ax,0[bx+si+3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若想使用标号访问数据，需要使用使用伪指令assume将标号所在段和一个段寄存器联系起来，否则编译器无法确定标号的段地址处于哪个寄存器中，但是并没有直接将对应寄存器的值修改为关联地址</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 后面有:的地址标号，只能在代码段中使用</div><h4 id="3-2直接定址表"><a href="#3-2直接定址表" class="headerlink" title="3.2直接定址表"></a>3.2直接定址表</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种映射关系，如0~15和十六进制的0~F，本质上是一种以空间换时间的做法</div><blockquote><p>以下为利用<strong>直接定址表</strong>求对应<code>sin</code>值的<strong>子程序</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">showsin: jmp short show         ;存放各个标号的地址         table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180         ;各个角度对应的sin值的字符串         ag0  db '0',0         ag30 db '0.5',0         ag60 db '0.866',0         ag90 db '1',0         ag120 db '0.866',0         ag150 db '0.5',0         ag180 ad '0',0show:    push bx         push es         push si         mov bx,0b800h         mov es,bx         ;用ax传递的角度除以30作为相对于table的偏移量，取得对应字符串的偏移地址，放在bx中         mov ah,0         mov bl,30         div bl         mov bl,al         mov bh,0         add bx,bx         mov bx,table[bx]         ;显示对应字符串         mov si,160*12+40*2shows:   mov ah,cs:[bx]         cmp ah,0         je showret         mov es:[si],ah         inc bx         add si,2         jmp short showsshowret: pop si         pop es         pop bx         ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3可选效果的程序"><a href="#3-3可选效果的程序" class="headerlink" title="3.3可选效果的程序"></a>3.3可选效果的程序</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 利用直接定址表实现程序不同功能</div><blockquote><p>一个子程序<code>setscreen</code>，当<code>ah</code>为<strong>不同的值</strong>时，实现4种<strong>不同的功能</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">setscreen: jmp short set           table dw sub1,sub2,sub3,sub4set:       push bx           cmp ah,3 ;判断异常情况，即是否超出了功能号范围           ja sret           mov bl,ah           mov bh,0           add bx,bx ;计算ah功能号对应位置           call word ptr table[bx]sret:      pop bx           ret;清空屏幕：将显存中当前屏幕中字符全部设为空格符sub1:      push bx           push cx           push es           mov bx,0b800h           mov es,bx           mov bx,0           mov cx,2000sub1s:     mov byte ptr es:[bx],' '           add bx,2           loop sub1s           pop es           pop cx           pop bx           ret;设置前景色：将显存中当前屏幕处于奇地址属性字节的0、1、2位设置为al对应值sub2:      push bx           push cx           push es           mov bx,0b800h           mov es,bx           mov bx,1           mov cx,2000sub2s:     and byte ptr es:[bx],11111000b           or es:[bx],al           add bx,2           loop sub2s           pop es           pop cx           pop bx           ret;设置背景色：将显存中当前屏幕处于奇地址属性字节的4、5、6位设置为al对应值 sub3:     push bx           push cx           push es           mov cl,4           shl al,cl           mov bx,0b800h           mov es,bx           mov bx,1           mov cx,2000sub3s:     and byte ptr es:[bx],10001111b           or es:[bx],al           add bx,2           loop sub2s           pop es           pop cx           pop bx           ret  ;向上滚动一行：依次将n+1行的内容复制到第n行，最后一行为空sub4:      push cx           push si           push di           push es           push ds           mov si,0b800h           mov es,si           mov ds,si           mov si,160 ;将ds:si指向n+1行           mov di,0 ;将es:di指向n行           cld           mov cx,24 ;共复制24行sub4s:     push cx           mov cx,160           rep movsb  ;复制           pop cx           loop sub4s           mov cx,80           mov si,0sub4s1:    mov byte ptr [160*24+si],' '           add si,2           loop sub4s1           pop ds           pop es           pop di           pop si           pop cx           ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
            <tag> 《汇编语言》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）</title>
      <link href="/2023/11/07/ji-suan-ji-wang-luo-yi/"/>
      <url>/2023/11/07/ji-suan-ji-wang-luo-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（一）"><a href="#计算机网络（一）" class="headerlink" title="计算机网络（一）"></a>计算机网络（一）</h1><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h4><p><strong>①网络</strong></p><blockquote><p>由若干<strong>节点</strong>和连接节点的<strong>链路</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 按照拓扑类型可分为总线型、星型、环形和网状型</div><p><strong>②互联网</strong></p><blockquote><p><strong>多个网络</strong>由<strong>路由器</strong>互联，形成<strong>互联网</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因特网是最大的互联网，使用TCP/IP协议</div><p><strong>③ISP</strong></p><blockquote><p><strong>因特网服务提供商</strong>，如中国<strong>电信</strong>、中国<strong>联通</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于树结构，只要有子节点就是父节点，所以个人也可以成为某种意义上的ISP</div><p><strong>④分组交换</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 计算机网络传输信息方式</div><blockquote><p>将<strong>数据</strong>分成<strong>多个包</strong>，每个包由<strong>描述信息</strong>和<strong>数据部分</strong>组成</p></blockquote><blockquote><p><strong>路由器</strong>收到包后，<strong>暂时存储</strong>，根据<strong>描述信息</strong>送到<strong>下一个路由器</strong>，直到送到<strong>目标地址</strong></p></blockquote><blockquote><p><strong>目的地址</strong>收到<strong>所有包</strong>后，根据<strong>描述信息</strong>将其<strong>组合到一起</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 无需建立连接、线路利用率高、出错时重发数据量小</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 有转发时延、需要传递额外的信息、出错频率变大</div><p><strong>⑤网络性能指标</strong></p><blockquote><p><strong>速率</strong>：<strong>设备</strong>在<strong>单位时间</strong>传递的<strong>比特数</strong></p></blockquote><blockquote><p><strong>带宽</strong>：<strong>网络</strong>中<strong>一个点</strong>到<strong>另一个点</strong>的<strong>最高速率</strong></p></blockquote><blockquote><p><strong>吞吐量</strong>：<strong>单位时间</strong>内能<strong>通过整个网络</strong>的数据量，受到<strong>带宽</strong>和<strong>速率</strong>的限制</p></blockquote><blockquote><p><strong>时延</strong>：由<strong>发送时延</strong>、<strong>传播时延</strong>和<strong>处理时延</strong>组成</p></blockquote><blockquote><p><strong>利用率</strong>：网络中所有<strong>信道利用率</strong>的<strong>加权平均</strong></p></blockquote><blockquote><p><strong>丢包率</strong>：一定时间内，<strong>丢失的分组</strong>数量占<strong>总分组</strong>数量的<strong>比例</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 利用率最好保持在50%左右，因为利用率越高，时延越大</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当分包出现误码，或者网络拥塞时会被丢弃，主要为后者</div><h4 id="1-2TCP-x2F-IP体系结构"><a href="#1-2TCP-x2F-IP体系结构" class="headerlink" title="1.2TCP/IP体系结构"></a>1.2TCP/IP体系结构</h4><p><strong>①构成</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 真实的TCP/IP结构只有应用层、运输层、网络层和接口层四层，为了方便理解，将接口层拆解为链路层和物理层</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 网络层是核心</div><blockquote><p><strong>应用层</strong>：解决<strong>进程间的交互</strong>问题</p></blockquote><blockquote><p><strong>运输层</strong>：解决<strong>进程</strong>之间<strong>基于网络通信</strong>的问题</p></blockquote><blockquote><p><strong>网络层</strong>：解决多个<strong>分组</strong>在<strong>网络间传输</strong>的问题</p></blockquote><blockquote><p><strong>链路层</strong>：解决<strong>分组</strong>在<strong>一个网络中传输</strong>的问题</p></blockquote><blockquote><p><strong>物理层</strong>：解决使用<strong>何种信号传输比特</strong>的问题</p></blockquote><p><strong>②基本概念</strong></p><blockquote><p><strong>实体</strong>：可以<strong>发送和接收消息</strong>的<strong>硬件</strong>或者<strong>软件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 收发双方相同层次的对应实体为对等实体</div><blockquote><p><strong>协议</strong>：控制两个<strong>对等实体</strong>进行<strong>逻辑通信的规则</strong>，<strong>对等层次</strong>之间交换的<strong>数据包</strong>称为<strong>协议数据单元PDU</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如应用层的HTTP协议，运输层的TCP协议，网络层的IP协议，链路层的CSMA协议，物理层的曼彻斯特编码等</div><blockquote><p><strong>服务</strong>：<strong>下层</strong>给<strong>相邻上层</strong>提供的<strong>功能接口</strong>，<strong>相邻层</strong>之间交换的<strong>数据包</strong>称为<strong>服务数据单元SDU</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相邻两层通过服务访问点交换信息，通过服务原语沟通</div><p><strong>③工作原理概述</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上层层包装，层层读取信息，以用户向一个网站服务器发出访问申请为例</div><blockquote><p><strong>应用层</strong>将<strong>HTTP报文</strong>发送给<strong>运输层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> HTTP报文用于个人电脑和服务端的通信</div><blockquote><p><strong>运输层</strong>给<strong>HTTP报文</strong>添加<strong>TCP首部</strong>，形成<strong>TCP报文段</strong>，并将其发送给<strong>网络层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> TCP首部用于区分进程并实现可靠传输</div><blockquote><p><strong>网络层</strong>给<strong>TCP报文段</strong>添加<strong>IP首部</strong>，形成<strong>IP数据报</strong>，并将其发送给<strong>链路层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> IP首部使其可被路由器转发</div><blockquote><p><strong>链路层</strong>给<strong>IP数据报</strong>添加<strong>ETH首部</strong>和<strong>ETH尾部</strong>，形成<strong>帧</strong>，并将其发送给<strong>物理层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ETH首部包含了目的地址和源地址，ETH尾部用于检查其是否有误码</div><blockquote><p><strong>物理层</strong>将<strong>帧</strong>转化为<strong>01序列</strong>，添加<strong>前导码</strong>，发送到<strong>下一个端口</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 前导码让下一个端口做好接收准备</div><blockquote><p>运送到<strong>路由器</strong>后，一层一层<strong>读取信息（如从IP首部获得转发端口）</strong>，再一层一层<strong>包装</strong>发送到<strong>下一个端口</strong>，如此往复，直到<strong>到达目的地</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 路由器由于没有进程，所以没有应用端和运输端</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_1.png" alt="TCP/IP体系结构工作原理"></p><h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①协议</strong></p><blockquote><p><strong>比特流传递时</strong>的<strong>描述信息</strong>，可分为<strong>机械特性</strong>、<strong>电气特性</strong>、<strong>功能特性</strong>和<strong>过程特性</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 物理层考虑的是如何在不同的传输媒体上传输数据比特流，传输媒体可分为导引型（如光纤）和非导引型（如wifi）</div><p><strong>②传输方式</strong></p><blockquote><p><strong>串行传输</strong>：一次发送<strong>一个比特</strong><br><strong>并行传输</strong>：一次发送<strong>多个比特</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 计算机内部通信采用并行传输，计算机之间通信采用串行传输</div><blockquote><p><strong>同步传输</strong>：<strong>字节</strong>之间<strong>没有间隔</strong>，需要保证<strong>收发双方时钟同步</strong><br><strong>异步传输</strong>：<strong>字节</strong>之间有<strong>不固定的间隔</strong>，在<strong>每个字节前后</strong>加上<strong>起始位</strong>和<strong>结束位</strong></p></blockquote><h4 id="2-2编码与调制"><a href="#2-2编码与调制" class="headerlink" title="2.2编码与调制"></a>2.2编码与调制</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于数字信号和模拟信号，编码和调制的含义不同，计算机网络主要使用数字信号，故只介绍数字信号</div><blockquote><p><strong>编码</strong>：<strong>不改变信号性质</strong>，仅仅对<strong>信号波形</strong>进行变换</p></blockquote><blockquote><p><strong>调制</strong>：将<strong>数字信号</strong>的<strong>频率范围搬移到较高的频段</strong>，并<strong>转化为模拟信号</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_2.png" alt="信号传递过程"></p><p><strong>②编码方法</strong></p><blockquote><p><strong>曼彻斯特编码</strong>：在<strong>每个码元</strong>的<strong>中间时刻</strong>发生<strong>跳变</strong>，使用<strong>正负跳变</strong>表示比特</p></blockquote><blockquote><p><strong>差分曼彻斯特编码</strong>：跳变<strong>仅仅表示时钟</strong>，使用<strong>码元开始处电平是否变化</strong>表示比特</p></blockquote><p><strong>③调制方法</strong></p><blockquote><p><strong>基本调制方法</strong>有<strong>调幅</strong>、<strong>调频</strong>和<strong>调相</strong>，但是这样<strong>一个码元</strong>只包含<strong>一个比特信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 采用混合调制方法，如正交振幅调制QAM，一个码元可以表示16种信息</div><h4 id="2-3信道极限容量"><a href="#2-3信道极限容量" class="headerlink" title="2.3信道极限容量"></a>2.3信道极限容量</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当信号通过信道传输时，可能会导致失真，失真严重时将无法识别</div><blockquote><p><strong>影响因素</strong>：<strong>码元传输速率</strong>、<strong>信号传输距离</strong>、<strong>噪声干扰</strong>和<strong>传输媒体质量</strong>等</p></blockquote><p><strong>②奈式准则</strong></p><blockquote><p>为了避免<strong>码间串扰</strong>。<strong>码元传输速率</strong>是有<strong>上限</strong>的</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 奈式准则是理想情况（无噪声），实际上能传输的最高码元速率要远低于奈式准则给出的</div><p><strong>③香农公式</strong></p><blockquote><p>给出了<strong>带宽受限</strong>且有<strong>高斯白噪声干扰</strong>的信道的<strong>极限信息传输速率</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 想要提高信息的传输速率必须采用更好的调制方法和信道的信噪比</div><h3 id="3-链路层"><a href="#3-链路层" class="headerlink" title="3.链路层"></a>3.链路层</h3><h4 id="3-1基本功能"><a href="#3-1基本功能" class="headerlink" title="3.1基本功能"></a>3.1基本功能</h4><p><strong>①包装成帧</strong></p><blockquote><p><strong>帧头</strong>和<strong>帧尾</strong>包含重要的<strong>控制信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要内容为目的地址、源地址和帧校验序列</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果帧的其他部分也包含帧定界标志，需要与真正的帧定界符相区分，如插入“转义字符”</div><p><strong>②差错检测</strong></p><blockquote><p><strong>传输过程</strong>中，<strong>比特</strong>可能发生<strong>反转</strong>或者<strong>丢失</strong>，通过<strong>帧校验序列</strong>检测</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 常用的检测方法为循环冗余检测，两边对数据采用同样的算法，若结果一致则无误码</div><p><strong>③可靠传输</strong></p><blockquote><p>当出现<strong>分组错误</strong>、<strong>分组丢失</strong>、<strong>分组失序</strong>和<strong>分组重复</strong>等错误时，需要发送方<strong>重新发送</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可靠传输不是必须的，通常误码率高时（如无线传输），需要可靠传输服务</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可靠传输这一概念并不局限于链路层</div><h4 id="3-2可靠传输协议"><a href="#3-2可靠传输协议" class="headerlink" title="3.2可靠传输协议"></a>3.2可靠传输协议</h4><p><strong>①停止等待协议SW</strong></p><blockquote><p><strong>接收方</strong>：每次<strong>接收一个分组</strong>，若接收到<strong>正确的分组</strong>，发送<strong>确认分组</strong>，<strong>反之</strong>则发送<strong>否认分组</strong></p></blockquote><blockquote><p><strong>发送方</strong>：每次<strong>发送一个分组</strong>，只有<strong>接收到确认分组</strong>后再<strong>发送下一分组</strong>，接收到<strong>否认分组</strong>则<strong>重新发送</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 成功确认的分组将会从缓存中删除</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用超时计时器以防分组丢失，给分组添加序号防止分组重复和分组迟到</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该方法的信道利用率较低，因为每次发送一个分组就需要等待一个往返时间</div><p><strong>②回退N帧协议GBN</strong></p><blockquote><p><strong>发送方</strong>：每次<strong>发送N个分组</strong>，若<strong>N个分组均正确</strong>，则发送<strong>下一批分组</strong>，若收到<strong>NAKy否认分组</strong>，则这一批分组中<strong>y以及y之后的分组全部重发</strong></p></blockquote><blockquote><p><strong>接收方</strong>：每次接<strong>收一个分组</strong>并<strong>逐个确认</strong>，若接收到的<strong>第x个分组以及之前的分组全部正确</strong>，则发送<strong>ACKx确认分组</strong>，若<strong>第y个分组发生错误</strong>，则发送<strong>NAKy否认分组</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每次可以发送多个分组，提高了信道的利用率</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 一个分组的错误会导致后续分组的重传，当信道质量较差时，效率较低</div><p><strong>③选择重传协议SR</strong></p><blockquote><p><strong>发送方</strong>：<strong>可发送的分组范围</strong>称为<strong>发送窗口</strong>，<strong>落入发送窗口</strong>且<strong>没有被发送</strong>的分组会被<strong>发送</strong>，<strong>发送窗口</strong>一直<strong>向前移动</strong>，只有收到<strong>确认分组</strong>的位置才能<strong>顺利通过</strong>，否则会被<strong>卡住（超时或者收到错误分组）</strong>，被<strong>卡住</strong>的地方<strong>重新发送</strong></p></blockquote><blockquote><p><strong>接收方</strong>：<strong>接收的分组范围</strong>称为<strong>接收窗口</strong>，<strong>落入接收窗口</strong>的分组会被<strong>逐个确认</strong>，并发送<strong>对应的信号</strong>，<strong>接收窗口</strong>一直<strong>向前移动</strong>，只有<strong>确认正确</strong>的位置才能<strong>顺利通过</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 减小了错误分组对发送其他分组的影响</div><h4 id="3-3PPP协议"><a href="#3-3PPP协议" class="headerlink" title="3.3PPP协议"></a>3.3PPP协议</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> PPP协议是目前使用最广泛的点对点数据链路层协议</div><p><strong>①构成</strong></p><blockquote><p>对各种<strong>协议数据报</strong>的<strong>封装方法</strong>，即如何<strong>封装成帧</strong></p></blockquote><blockquote><p><strong>链路控制协议LCP</strong>，用于控制<strong>不同数据链路</strong>的连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如面向字节的异步链路和面向比特的同步链路</div><blockquote><p><strong>网络控制协议NCPs</strong>，用于<strong>支持</strong>不同的<strong>网络层协议</strong></p></blockquote><p><strong>②帧格式</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 帧头包含标志字段、地址字段、控制字段和协议字段，帧尾包含帧检验序列和标志字段</div><blockquote><p><strong>标志字段</strong>：PPP帧的<strong>定界符</strong>，取值为<code>0x7E</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当数据部分出现标志字段，采用字节填充法或者比特填充法改变其序列，接收方再将其转换回来即可</div><blockquote><p><strong>地址字段</strong>：包含<strong>源MAC地址</strong>和<strong>目的MAC地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> MAC地址是每个接口唯一的标识，也被称为硬件地址/物理地址，地址字段中的MAC地址会随着链路的改变改变</div><blockquote><p>假设从<code>MAC1</code>发送到<code>MAC2</code>再到<code>MAC3</code>，<strong>地址字段</strong>在<strong>两段链路</strong>上分别为<code>MAC1:MAC2</code>和<code>MAC2:MAC3</code></p></blockquote><blockquote><p><strong>控制字段</strong>：</p></blockquote><blockquote><p><strong>协议字段</strong>：指明帧的<strong>数据部分</strong>交给什么<strong>网络协议</strong>处理</p></blockquote><blockquote><p><strong>帧检验序列</strong>：用于<strong>检查</strong>帧是否有<strong>误码</strong></p></blockquote><p><strong>③状态</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_3.png" alt="PPP协议状态"></p><h4 id="3-4共享式局域网"><a href="#3-4共享式局域网" class="headerlink" title="3.4共享式局域网"></a>3.4共享式局域网</h4><p><strong>①概念</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在有线领域，交换式局域网已经取代了共享式局域网，无线领域由于其广播天性采用的依旧是共享式局域网</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 协调多个发送和接收站点对一个共享传输媒体的占用</div><blockquote><p><strong>静态划分信道</strong>：将<strong>信道资源</strong>划分给<strong>不同的用户</strong>，如<strong>频分多址</strong>、<strong>时分多址</strong>和<strong>码分多址</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该类方法不灵活，通常在无线网络的物理层中使用，而不在数据链路层使用</div><blockquote><p><strong>动态接入控制</strong>：<strong>各个站点</strong>通过<strong>竞争</strong>获得<strong>链路的使用权</strong>，现在<strong>主要采用</strong>的是<strong>随机接入</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当总线空闲时，所有站点都可以发送帧，当两个设备的帧信号在总线上相遇，即发生了碰撞</div><p><strong>②CSMA/CD协议</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要应用于使用广播信道的有线局域网</div><blockquote><p><strong>多址接入MA</strong>：<strong>多个设备</strong>连接在<strong>一条总线</strong>上，<strong>竞争</strong>使用</p></blockquote><blockquote><p><strong>载波监听CS</strong>：每个设备在<strong>发送帧之前</strong>，<strong>检测总线</strong>是否<strong>空闲（有96比特时间）</strong>，如果<strong>有则发送</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 96比特时间为发送96个比特所需要的时间，也称为帧间最小间隔，使得所有站点可以平等的竞争信道，同时也可作为定界符</div><blockquote><p><strong>碰撞检测CD</strong>：每个<strong>发送帧</strong>的设备<strong>边发送边检测碰撞</strong>，一旦<strong>总线</strong>上出现<strong>碰撞</strong>，则立即<strong>停止发送</strong>，一段时间后<strong>重新发送</strong>，</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将链路端到端的往返时间称为争用期，若站点在发送信号后经过争用期还没检测到碰撞，则判定不会发生碰撞</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若连续发生多次碰撞，则使用退避算法调整各个站点的回避时间，减小碰撞概率</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 帧的长度不能太小，必须保证发送该帧的时间大于争用期，否则无法在发送前检测碰撞，需要进行填充，同时也不能太大，否则会占用总线时间过长</div><p><strong>③CSMA/CA协议</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要应用于使用广播信道的无线局域网，因为无线信道很难检测碰撞，且意义不大，故采用碰撞避免CA</div><blockquote><p><strong>帧间间隔IFS</strong>：所有<strong>站点</strong>必须在<strong>持续检测</strong>到<strong>信道空闲</strong>一段<strong>指定时间</strong>才能发送帧，这段时间即<strong>帧间间隔</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 不同帧的帧间间隔不同，越高优先级帧的帧间间隔越短，用于减少碰撞，其中SIFS帧是最短的帧间间隔，保证一个站点能做好准备</div><blockquote><p><strong>退避时间</strong>：在<strong>某些情况</strong>下，一些站点<strong>发送帧</strong>时在<strong>帧间间隔</strong>的基础上还需要<strong>再等待退避时间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如一个站点成功发送帧后需要连续发送下一个帧时，以避免一个站点长时间占用信道</div><blockquote><p><strong>信道预约</strong>：<strong>源站</strong>在<strong>发送帧之前</strong>发送一个<strong>RTS帧</strong>，<strong>目的站</strong>收到后<strong>返回</strong>一个<strong>CTS帧</strong>，<strong>源站收到CTS帧</strong>后，<strong>其他站暂停</strong>发送帧，直到<strong>通信完成</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> RTS帧和CTS帧很短，发生碰撞以及碰撞产生的开销很小，但是可以保证通信不受干扰，所以是值得的</div><blockquote><p><strong>虚拟载波监听</strong>：<strong>RTS帧</strong>和<strong>CTS帧</strong>以及<strong>数据帧</strong>都包含了<strong>对应通信时长</strong>，所以<strong>其他站</strong>点只需要监听到<strong>三个帧中的一个</strong>，就能知道<strong>信道占用时间</strong></p></blockquote><h4 id="3-5交换式局域网"><a href="#3-5交换式局域网" class="headerlink" title="3.5交换式局域网"></a>3.5交换式局域网</h4><p><strong>①交换机</strong></p><blockquote><p>根据<strong>帧</strong>的<strong>目标mac地址</strong>，直接<strong>单独转发</strong>到<strong>目标主机</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 与共享信道不同，交换机中，每个MAC地址都有对应的接口，从而形成不同的信道，在互不干扰的情况下并行工作</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当多个主机给同一个主机发送帧时，交换机会将多个帧缓存起来，再逐个发送给目标主机</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_4.png" alt="交换机工作原理"><br><strong>②交换机帧转发过程</strong></p><blockquote><p>当交换机<strong>接收到帧</strong>后，会将<strong>发送方</strong>的<strong>MAC地址</strong>和<strong>接口号</strong>登记到<strong>帧交换表</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 也称为交换机的自学习，如果已经登记过，便不会再次登记，随着工作的推进，记录将会越来越长</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 帧交换表的记录项是有时效的，因为由于设备损坏等原因，接口对应的MAC地址可能会改变</div><blockquote><p>读取<strong>帧的目的地址</strong>，并在<strong>帧交换表</strong>中查找<strong>接口号</strong>，若<strong>找到</strong>则<strong>直接发送</strong></p></blockquote><blockquote><p>若<strong>没有</strong>找到<strong>目的地址</strong>对应的<strong>帧交换表项</strong>，则会对<strong>所有其他接口</strong>发送该帧</p></blockquote><blockquote><p><strong>目的主机</strong>收到后<strong>接受该帧</strong>，<strong>其他主机丢弃该帧</strong></p></blockquote><p><strong>③生成树协议STP</strong></p><blockquote><p>为了提高<strong>以太网</strong>的<strong>可靠性</strong>，需要添加<strong>冗余链路</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是环形链路可能造成广播帧在各个交换机之间反复转发</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 交换机需要选择性的阻碍某些接口，以确保连通整个网络的同时又不形成环路</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次物理拓扑发生变化时，都将进行生成树的重新计算</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_5.png" alt="生成树协议"><br><strong>④虚拟局域网VLAN</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 广播帧的发送较为频繁，若每次广播帧都会被整个以太网的所有主机接收，则会十分浪费网络资源</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 需要使用虚拟局域网技术将以太网分为多个广播域，一个广播域的广播帧不会被另一个广播域接收</div><blockquote><p><strong>每个端口</strong>有对应的标识<strong>PVID</strong>，每当<strong>端口发送帧</strong>时，会给其插入<strong>对应的VLAN标记</strong></p></blockquote><blockquote><p>当<strong>其余端口</strong>接收到<strong>帧</strong>时，基于<strong>端口的规则</strong>，根据<strong>PVID和VLAN标记的关系</strong>决定<strong>是否接受</strong>该帧</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 交换机端口类型有Access、Trunk、Hybrid三种，其中Access常用于连接用户计算机，Trunk常用于交换机之间的连接，Hybrid皆可</div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 《计算机网络自顶向下》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（一）</title>
      <link href="/2023/11/07/ji-suan-ji-zu-cheng-yuan-li-yi/"/>
      <url>/2023/11/07/ji-suan-ji-zu-cheng-yuan-li-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（一）"><a href="#计算机组成原理（一）" class="headerlink" title="计算机组成原理（一）"></a>计算机组成原理（一）</h1><h2 id="计算机组成原理启蒙"><a href="#计算机组成原理启蒙" class="headerlink" title="计算机组成原理启蒙"></a>计算机组成原理启蒙</h2><h3 id="1-计算机基本组成"><a href="#1-计算机基本组成" class="headerlink" title="1.计算机基本组成"></a>1.计算机基本组成</h3><h4 id="1-1冯诺依曼结构"><a href="#1-1冯诺依曼结构" class="headerlink" title="1.1冯诺依曼结构"></a>1.1冯诺依曼结构</h4><p><strong>①特点</strong></p><blockquote><p>计算机由<strong>运算器、控制器、存储器、输入/输出设备</strong>五大部分组成</p></blockquote><blockquote><p>指令和数据以<strong>同等地位</strong>存储，用<strong>二进制</strong>表示</p></blockquote><blockquote><p>指令由<strong>操作码</strong>和<strong>地址码</strong>组成</p></blockquote><blockquote><p>以<strong>运算器</strong>为中心</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 以运算器为中心导致运算器成为瓶颈，故再次基础上对其进行改进</div><p><strong>②以存储器为核心</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_1.png" alt="以存储器为核心的冯诺依曼结构"></p><h4 id="1-2存储器"><a href="#1-2存储器" class="headerlink" title="1.2存储器"></a>1.2存储器</h4><p><strong>①组成</strong></p><blockquote><p><strong>存储体</strong>：由多个<strong>存储单元</strong>构成，存储单元存放<strong>一串二进制代码</strong></p></blockquote><blockquote><p><strong>MAR</strong>：存储器<strong>地址寄存器</strong>，反映存储<strong>单元个数</strong></p></blockquote><blockquote><p><strong>MDR</strong>：存储器<strong>数据寄存器</strong>，反映存储器<strong>字长</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> MAR相当于存储器的地址线，MDR相当于存储器的数据线</div><p><strong>②结构图示</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_2.png" alt="存储器结构"></p><h4 id="1-3运算器"><a href="#1-3运算器" class="headerlink" title="1.3运算器"></a>1.3运算器</h4><p><strong>①组成</strong></p><blockquote><p><strong>ALU</strong>：<strong>算数逻辑单元</strong>，主要进行运算的单元</p></blockquote><blockquote><p><strong>相关寄存器</strong>：<code>ACC</code>、<code>MQ</code>、<code>X</code>寄存器，不同的<strong>指令</strong>，这些寄存器的<strong>用途不同</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不同的CPU运算器都是不同的，尤其是寄存器的个数及其用途</div><p><strong>②结构</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_3.png" alt="运算器结构"></p><p><strong>③乘法指令过程</strong></p><blockquote><p>通过<strong>取数指令</strong>，将<strong>被乘数</strong>放入<strong>ACC</strong>中（由编程者执行）<br>根据<strong>乘法指令的地址码</strong>取出<strong>乘数</strong>放在<strong>MQ</strong>中<br>将<strong>ACC中数据</strong>送入<strong>X</strong>，并清空<strong>ACC</strong>（设置为0），用于存放乘法指令的<strong>中间结果</strong><br><strong>ALU</strong>将<strong>结果</strong>放在<strong>ACC</strong>和<strong>MQ</strong>中</p></blockquote><h4 id="1-4控制器"><a href="#1-4控制器" class="headerlink" title="1.4控制器"></a>1.4控制器</h4><blockquote><p><strong>解释</strong>指令，并保证指令的<strong>按序执行</strong></p></blockquote><p><strong>①组成</strong></p><blockquote><p><strong>PC</strong>：存放当前<strong>欲执行指令的地址</strong></p></blockquote><blockquote><p><strong>IR</strong>：存放当前<strong>欲执行的指令</strong></p></blockquote><blockquote><p><strong>CU</strong>：<strong>执行</strong>指令</p></blockquote><p><strong>②结构</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_4.png" alt="控制器结构"></p><h4 id="1-5一条指令的完成过程"><a href="#1-5一条指令的完成过程" class="headerlink" title="1.5一条指令的完成过程"></a>1.5一条指令的完成过程</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以取数指令为例</div><blockquote><p><strong>PC</strong>将<strong>指令地址</strong>送入<strong>MAR</strong><br><strong>MAR</strong>从存储体中<strong>取出取数指令</strong>放入<strong>MDR</strong><br><strong>MDR</strong>将<strong>指令</strong>送入<strong>IR</strong><br><strong>IR</strong>将指令的<strong>操作码</strong>送入<strong>CU</strong>，<strong>地址码</strong>送入<strong>MAR</strong><br>在<strong>CU</strong>的控制下，从存储体中取出<strong>对应数据</strong>放入<strong>MDR</strong>，随后送入<strong>ACC</strong><br>随后<strong>PC+1</strong>等待<strong>下一条指令</strong></p></blockquote><h3 id="2-系统总线"><a href="#2-系统总线" class="headerlink" title="2.系统总线"></a>2.系统总线</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①定义</strong></p><blockquote><p>连接各个部件的<strong>信息传输线</strong>，是各个部件<strong>共享的传输介质</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一根总线在同一时间只能被一组设备使用</div><p><strong>②总线的分类</strong></p><blockquote><p><strong>片内总线</strong>：<strong>芯片内部</strong>的总线</p></blockquote><blockquote><p><strong>系统总线</strong>：<strong>计算机各部件之间</strong>的总线</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还可细分位数据总线、地址总线和控制总线</div><blockquote><p><strong>通信总线</strong>：<strong>计算机系统之间</strong>或者计算机系统<strong>与其他系统</strong>的通信</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通信总线还可细分位串行通信总线和并行通信总线</div><p><strong>③总线性能指标</strong></p><blockquote><p><strong>总线宽度</strong>：数据线的<strong>根数</strong></p></blockquote><blockquote><p><strong>标准传输率</strong>：<strong>每秒</strong>传输的<strong>最大字节数</strong></p></blockquote><blockquote><p><strong>时钟同步/异步</strong>：是否有<strong>同步时钟</strong></p></blockquote><blockquote><p><strong>总线复用</strong>：<strong>地址线</strong>与<strong>数据线</strong>是否复用，总线复用能<strong>有效减少芯片的管脚数</strong></p></blockquote><blockquote><p><strong>信号线数</strong>、<strong>总线控制方式</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 总线标准：一种对总线性能指标的规定，如USB和PCI等</div><h4 id="2-2总线结构"><a href="#2-2总线结构" class="headerlink" title="2.2总线结构"></a>2.2总线结构</h4><p><strong>①四总线结构</strong></p><blockquote><p><strong>高速总线</strong>连接<strong>高速设备</strong>，<strong>扩展总线</strong>连接<strong>低速设备</strong><br><code>cache</code>用于解决CPU和主存<strong>处理速度差</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_5.png" alt="四总线结构"></p><p><strong>②PCI总线结构</strong></p><blockquote><p>其中<strong>设备能接的地方</strong>也能接<code>PCI桥</code>，从而实现<strong>设备分级</strong>，经过越多的桥，速度越慢</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_6.png" alt="PCI总线结构"></p><h4 id="2-3总线占用控制"><a href="#2-3总线占用控制" class="headerlink" title="2.3总线占用控制"></a>2.3总线占用控制</h4><p><strong>①设备分类</strong></p><blockquote><p><strong>主设备</strong>：对总线有<strong>控制权</strong><br><strong>从设备</strong>：只能<strong>响应主设备</strong>发来的总线命令</p></blockquote><p><strong>②链式查询方式</strong></p><blockquote><p><strong>BR线</strong>：设备通过这条线发出<strong>总线占用请求</strong><br><strong>BS线</strong>：如果<strong>总线被占用</strong>，则通过这条线得知<br><strong>BG线</strong>：总线<strong>授权</strong>线，按照<strong>设备的优先级</strong>依次连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当总线空闲时，多个设备提出了总线占用请求，则通过BG线依次查询部件，优先给优先级高的部件提供总线，并设置总线忙</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对电路故障敏感，且靠后的设备很难申请到总线，速度较慢，通常用于简单的系统中</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_7.png" alt="链式查询方式"></p><p><strong>②计数器定时查询</strong></p><blockquote><p><strong>总线控制部件</strong>中有一个<strong>计数器</strong>，为某个数<code>n</code>（可以人为或者通过程序<strong>控制</strong>），当接收到总线请求后，总线控制部件<strong>根据计数器的值<code>n</code><strong>，通过</strong>设备地址线</strong>从<strong>第n个部件开始</strong>查找，直到找到发出总线请求的部件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 和链式类似，但是链式的值只能是0，定时器可以设置优先级</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_8.png" alt="计数器定时查询"></p><p><strong>③独立请求方式</strong></p><blockquote><p><strong>每个部件</strong>都有对应的<strong>BR线</strong>和<strong>BS线</strong>，总线控制部件中有一个<strong>排队器</strong>设置<strong>设备的优先级</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_9.png" alt="独立请求方式"></p><h4 id="2-4总线通信控制"><a href="#2-4总线通信控制" class="headerlink" title="2.4总线通信控制"></a>2.4总线通信控制</h4><p><strong>①总线传输周期</strong></p><blockquote><p><strong>申请分配阶段</strong>：主模块<strong>申请总线</strong></p></blockquote><blockquote><p><strong>寻址阶段</strong>：<strong>主模块</strong>给出<strong>地址</strong>和<strong>命令</strong>，通过地址<strong>找到从设备</strong>并<strong>传递命令</strong></p></blockquote><blockquote><p><strong>传数阶段</strong>：主模块和从模块<strong>交换数据</strong></p></blockquote><blockquote><p><strong>结束阶段</strong>：主模块和从模块<strong>撤销相关信息</strong></p></blockquote><p><strong>②同步通信</strong></p><blockquote><p><strong>统一时标</strong>控制通信过程，需要在<strong>对应的传输周期节点</strong>完成<strong>对应的操作</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主从模块是强制统一的，对于速度不一样的模块，选择速度最慢的模块对时标进行设计，即速度快的模块需要等速度慢的模块</div><blockquote><p><strong>以读数据为例</strong><br><strong>T1时钟上升时</strong>：<strong>主设备</strong>需要给出<strong>地址信号</strong><br><strong>T2时钟上升时</strong>：<strong>主设备</strong>给出<strong>读信号</strong><br><strong>T3时钟上升时</strong>：<strong>从设备</strong>给出<strong>数据信号</strong><br><strong>T4时钟上升时</strong>：从模块<strong>撤销数据</strong>，主模块<strong>撤销命令</strong></p></blockquote><p><strong>③异步通信</strong></p><blockquote><p><strong>不互锁</strong>：主设备发出请求，<strong>一定时间后撤销</strong>，从设备接收到请求后应答，<strong>一段时间后撤销</strong><br>不稳定</p></blockquote><blockquote><p><strong>半互锁</strong>：主设备发出请求，从设备接收到请求后应答，主设备只有<strong>接收到应答信号再撤销请求信号</strong>，从设备<strong>一段时间后撤销应答信号</strong></p></blockquote><blockquote><p><strong>全互锁</strong>：主设备发出请求，从设备接收到请求后应答，主设备<strong>只有接收到应答信号再撤销请求信号</strong>，从设备<strong>只有知道主设备撤销请求后再撤销应答信号</strong></p></blockquote><p><strong>④半同步通信</strong></p><blockquote><p>同步通信中<strong>插入等待周期</strong></p></blockquote><blockquote><p><strong>以读数据为例</strong><br>T1时钟上升时，主设备需要给出地址信号<br>T2时钟上升时，给出读信号<br>如果<strong>从设备不能在T3给出数据</strong>，则给出一个<strong>低电平的等待信号</strong><br>当<strong>等待信号为低电平</strong>时，<strong>等待一个周期T_w</strong><br>直到<strong>等待信号为高电平开始执行T3</strong><br>T3时钟上升时，从设备给出数据信号<br>T4时钟上升时，从模块撤销数据，主模块撤销命令</p></blockquote><p><strong>⑤分离式通信</strong></p><blockquote><p><strong>一个总线传输周期</strong>分为<strong>两个子周期</strong><br><strong>第一个子周期</strong>：<strong>主模块申请占用总线</strong>，使用完后<strong>放弃总线的使用权</strong><br><strong>第二个子周期</strong>：当主/从模块<strong>准备好数据</strong>，<strong>从模块在申请占用总线</strong>，将各种信息送至总线上</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个总线传输周期会有不使用总线的小周期，比如从设备准备数据，为了提高总线使用效率，可以在此期间将总线给其他设备使用</div><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><h4 id="3-1分类"><a href="#3-1分类" class="headerlink" title="3.1分类"></a>3.1分类</h4><p><strong>①按照存储介质分类</strong></p><blockquote><p><strong>半导体存储器</strong>：易失</p></blockquote><blockquote><p><strong>磁表面存储器</strong>：非易失</p></blockquote><blockquote><p><strong>磁芯存储器</strong>：非易失</p></blockquote><blockquote><p><strong>光盘存储器</strong>：非易失</p></blockquote><p><strong>②按存取方式分类</strong></p><blockquote><p><strong>存取时间与物理地址无关</strong>：<strong>随机存储器</strong></p></blockquote><blockquote><p><strong>存取时间与物理地址有关</strong>：<strong>顺序存取存储器</strong>（磁带）、<strong>直接存取存储器</strong>（磁盘）</p></blockquote><h4 id="3-2层次结构"><a href="#3-2层次结构" class="headerlink" title="3.2层次结构"></a>3.2层次结构</h4><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_10.png" alt="层次结构"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_11.png" alt="层次结构"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主存和辅存层次解决容量问题，若程序过大，则会将一部分放入主存，其余部分放入辅存</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缓存和主存层次解决CPU和主存速度差异问题，缓存中存放CPU经常使用的的主存信息</div><h4 id="3-3主存"><a href="#3-3主存" class="headerlink" title="3.3主存"></a>3.3主存</h4><p><strong>①基本构成</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_12.png" alt="主存基本构成"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同存储器的存储单元存储方式可能不同</div><blockquote><p><strong>大端大尾</strong>：<strong>高位字节地址</strong>为字地址，<strong>高位字节</strong>存储<strong>字的低位</strong></p></blockquote><blockquote><p><strong>小端小尾</strong>：<strong>低位字节地址</strong>为字地址。<strong>低位字节</strong>存储<strong>字的低位</strong></p></blockquote><p><strong>②主要技术指标</strong></p><blockquote><p><strong>存储容量</strong>：存放<strong>二进制代码</strong>的<strong>总位数</strong></p></blockquote><blockquote><p><strong>存取时间</strong>：存储器的<strong>访问时间</strong></p></blockquote><blockquote><p><strong>存储周期</strong>：<strong>连续两次独立</strong>的存储器操作所需的<strong>最小间隔时间</strong></p></blockquote><blockquote><p><strong>存储器带宽</strong>：<strong>单位时间存储读取的长度（位/秒）</strong></p></blockquote><h4 id="各种介质"><a href="#各种介质" class="headerlink" title="各种介质"></a>各种介质</h4><p>半导体存储芯片<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_21.png" alt="组成"><br>片选线表示哪片芯片被访问</p><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_22.png" alt="片选法"><br>地址译码器，四位，表示有16个单元<br>读写控制电路，8位，表示每个单元为8位</p><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_23.png" alt="重合法"><br>每次只选择一个位输出到I/O接口中</p><p>随机存取存储器<br>静态RAM<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_24.png" alt="静态RAM基本电路"><br>利用行列开关选择存储单元，触发器控制存储01，通过写/读放大器与读写信号控制读写<br>将每一行分为四组，每一组位16列，其中列地址只有16位，给出一个列地址，每一组对应列地址的单元会被选中，这样就可以同时选中四个单元<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_25.png" alt="RAM矩阵读写"></p><p>动态RAM<br>以三管为例<br>0/1内容保存在C_g中，如果读选择线有效，则T_2导通，如果写选择线有效，则T_3导通，<br>若预充电信号有效，则T_4导通，V_DD对读数据线充电，都数据线变为1，读选择线有效，T_2导通，若C_g保存信号是0（低电平），T_1不会导通，数据线不会放电，读数据线保持为1，反之T_1导通，读数据线放电，变为0<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_26.png" alt="动态RAM"><br>读出信息与原存信息相反<br>写入信息与输入信息相同<br>每个行地址都有读选择线和写选择线，然后通过列地址精确定位<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_27.png" alt="动态RAM芯片"><br>电容中信息容易丢失（容易漏电），刷新至于行地址有关（每次刷新一行的数据）<br>集中刷新：每隔一段时间对所有的行进行刷新，在此期间，动态RAM无法使用（死区）<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_28.png" alt="集中刷新"><br>分散刷新：每隔一段时间对某一行进行刷新，但是这样导致存取周期变长，因为刷新时间也算入到存取周期中了<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_29.png" alt="分散刷新"><br>异步刷新：每个一段时间刷新几行，只要将刷新时间安排在指令译码阶段，可以大大减小死区<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_30.png" alt="分散刷新"><br>动态RAM集成度较高，功耗小，价格低，速度慢，一般用于主存，静态RAM集成度较低，功耗大，一般用于做缓存</p><p>ROM只读存储器，用于保存系统程序和系统信息<br>MROM：只能读，不能进行擦写<br>PROM：只能进行一次擦写<br>EPROM：能进行多次擦写，紫外线<br>EEPROM：能进行多次擦写，电<br>闪存：能多次擦写，速度快，且类似于RAM</p><p>CPU和存储器的连接<br>位扩展：将多个芯片连接成一个芯片，其中片选线和控制线需要共用<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_31.png" alt="分散刷新"><br>字扩展：增加地址线，作为片选线，将两个芯片的地址空间分开<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_32.png" alt="分散刷新"><br>同时扩展<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_33.png" alt="分散刷新"><br>CPU和存储器的连接</p><blockquote><p>上面地址范围存储系统，下面存储用户程序，MREQ表示访问的是I/O端口<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_34.png" alt="分散刷新"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_35.png" alt="分散刷新"></p></blockquote><p>存储器的校验<br>电子元件可能发生故障，0/1错误<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_36.png" alt="分散刷新"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 《计算机组成原理》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake应用（一）</title>
      <link href="/2023/11/07/cmake-ying-yong-yi/"/>
      <url>/2023/11/07/cmake-ying-yong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><h2 id="Cmake应用（一）"><a href="#Cmake应用（一）" class="headerlink" title="Cmake应用（一）"></a>Cmake应用（一）</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1Cmke概述"><a href="#1-1Cmke概述" class="headerlink" title="1.1Cmke概述"></a>1.1<code>Cmke</code>概述</h4><blockquote><p>一个<strong>跨平台</strong>的<strong>项目构建工具</strong>，根据<code>CMakeLists.txt</code><strong>文件</strong>自动生成（<code>cmake</code>命令）<strong>本地化</strong>的<code>makefile</code>，最后只需要<code>make</code>命令即可获得<strong>目标文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用Cmke本质上就是在项目文件夹中编写CMakeLists.txt</div><h4 id="1-2基本指令"><a href="#1-2基本指令" class="headerlink" title="1.2基本指令"></a>1.2基本指令</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CMake支持大写、小写、混合大小写的命令</div><p><strong>①注释</strong></p><blockquote><p><strong>单行注释</strong>：以<code>#</code>开头，以<strong>换行符</strong>结束<br><strong>多行注释</strong>：以<code>#[[</code>开头，以<code>]]</code>结尾</p></blockquote><p><strong>②<code>cmake_minimum_required</code></strong></p><blockquote><p>指定<code>Cmake</code>的<strong>最低版本</strong><br><strong>格式</strong>：<code>cmake_minimum_required(VERSION 3.0.0)</code></p></blockquote><p><strong>③<code>project</code></strong></p><blockquote><p>指定<strong>工程信息</strong>，包括<strong>名字</strong>、<strong>版本</strong>、<strong>描述</strong>、<strong>web主页地址</strong>和<strong>支持的语言</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只有项目的名字是必须的，其余都可忽略，缺省情况下支持所有CMake支持的语言</div><blockquote><p><strong>格式</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none"># PROJECT 指令的语法是：project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])project(&lt;PROJECT-NAME&gt;       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]       [DESCRIPTION &lt;project-description-string&gt;]       [HOMEPAGE_URL &lt;url-string&gt;]       [LANGUAGES &lt;language-name&gt;...])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④<code>add_executable</code></strong></p><blockquote><p>生成<strong>可执行文件</strong>，需要指定<strong>可执行文件名</strong>和<strong>源文件</strong><br><strong>格式</strong>：<code>add_executable(可执行文件名 源文件名称)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 源文件名可以是一个也可以是多个，如有多个可用空格或;间隔</div><p><strong>⑤<code>message</code></strong></p><blockquote><p><strong>显示一条信息</strong><br><strong>格式</strong>：<code>message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] "message to display" ...)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CMake警告和错误消息的文本显示使用的是一种简单的标记语言，文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</div><blockquote><p><strong>状态</strong><br><code>(无)</code> ：<strong>重要</strong>消息<br><code>STATUS</code> ：<strong>非重要</strong>消息<br><code>WARNING</code>：<strong>警告</strong><br><code>AUTHOR_WARNING</code>：<strong>警告(dev)</strong><br><code>SEND_ERROR</code>：<strong>错误</strong>， <strong>继续执行</strong>，但是会<strong>跳过生成的步骤</strong><br><code>FATAL_ERROR</code>：<strong>错误</strong>， <strong>终止所有处理过程</strong></p></blockquote><p><strong>⑥<code>add_definitions</code></strong></p><blockquote><p>定义宏<br>格式：<code>add_definitions(-D宏名称)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在对应程序中定义宏，而不是在CMakeLists中定义宏</div><h4 id="1-3例子"><a href="#1-3例子" class="headerlink" title="1.3例子"></a>1.3例子</h4><p><strong>①概述</strong></p><blockquote><p>有四个<strong>源文件</strong><code>main.cc</code>、<code>a.cc</code>、<code>b.cc</code>、<code>c.cc</code>，以及一个<strong>头文件</strong><code>head.h</code>，其中<code>main.cc</code><strong>调用</strong>了另外三个源文件，<code>head.h</code>中包含了对应<strong>声明</strong></p></blockquote><p><strong>②CmakeLists文件编写</strong></p><pre class="line-numbers language-none"><code class="language-none">#CMake最低版本为3.15cmake_minimum_required(VERSION 3.15)#项目名称为exampleproject(example)#将main.cc a.cc b.cc c.cc编译为可执行文件mainadd_executable(main main.cc a.cc b.cc c.cc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③生成可执行文件</strong></p><blockquote><p>在<strong>终端</strong>执行<code>cmake CmakeLists所在路径</code>命令，会在<strong>当前路径</strong>生成<code>makefile</code>等文件，再执行<code>make</code>命令即可</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常在项目文件文件夹中建造一个build文件夹，在该路径下执行上述命令，将相关文件和源文件分开</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在使用Cmke指令时，需要保证其后接路径下不能有相关文件</div><hr><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><h4 id="2-1创建与使用"><a href="#2-1创建与使用" class="headerlink" title="2.1创建与使用"></a>2.1创建与使用</h4><p><strong>①<code>set</code></strong></p><blockquote><p><strong>定义/修改变量</strong>，参数分别为<strong>变量名</strong>、<strong>变量的值（可以是多个）</strong>以及一些<strong>自定义选项（非必须）</strong><br><strong>格式</strong>：<code>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省情况下，Cmake中的变量都是字符串（ITEM）或者字符串列表（LIST）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过set进行变量的拼接</div><blockquote><p><code>set(变量名1 ${变量名1} ${变量名2} ...)</code></p></blockquote><p><strong>②变量的使用</strong></p><blockquote><p><code>${变量名}</code>：将<strong>变量名</strong>转化为<strong>对应的值</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cc a.cc b.cc c.cc)add_executable(main  ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> Cmake中，给变量赋值时，空格会被当作分隔符，如果想要使得变量中包含空格，则需要用双引号包围</div><blockquote><p>以下程序输出<code>abc</code>和<code>a b c</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">set(WORD1 a b c)        #WORD1是一个字符串列表set(WORD2 "a b c")      #WORD2是一个字符串message(STATUS ${WORD1}) message(STATUS ${WORD2}) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2变量操作"><a href="#2-2变量操作" class="headerlink" title="2.2变量操作"></a>2.2变量操作</h4><p><strong>①<code>list</code></strong></p><blockquote><p>根据<strong>操作码</strong>对<strong>列表</strong>进行<strong>不同的操作</strong></p></blockquote><p><strong>②追加</strong></p><blockquote><p><strong>格式</strong>：<code>list (APPEND &lt;list&gt; [&lt;value&gt; ...])</code><br><code>&lt;list&gt;</code>：当前操作的<strong>列表</strong><br><code>&lt;element&gt;</code>：可以是<strong>字面值</strong>，也可以是<strong>变量的值</strong></p></blockquote><p><strong>③移除</strong></p><blockquote><p><strong>格式</strong>：<code>list (REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</code></p></blockquote><p><strong>④读取</strong></p><blockquote><p><strong>格式</strong>：<code>list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</code><br><code>&lt;element index&gt;</code>：列表元素的<strong>索引</strong>，从<code>0</code>开始，若为<strong>负数</strong>，则表示<strong>倒数</strong>第几个元素</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其他操作可查询官网</div><h4 id="2-3预定义宏"><a href="#2-3预定义宏" class="headerlink" title="2.3预定义宏"></a>2.3预定义宏</h4><p><strong>①<code>CMAKE_CXX_STANDARD</code></strong></p><blockquote><p><strong>C++标准</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#增加-std=c++11set(CMAKE_CXX_STANDARD 11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②<code>EXECUTABLE_OUTPUT_PATH</code></strong></p><blockquote><p><strong>可执行文件输出路径</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#定义一个变量用于存储一个绝对路径set(HOME /home/robin/Linux/Sort)#将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果路径不存在，则会自动创建</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 最好使用绝对路径，如果使用相对路径，则./代表的是makefile所在路径</div><p><strong>③<code>PROJECT_SOURCE_DIR</code></strong></p><blockquote><p><strong>Cmke指令后接的路径</strong></p></blockquote><p><strong>④<code>CMAKE_CURRENT_SOURCE_DIR</code></strong></p><blockquote><p><code>CmakeLists</code><strong>文件所在路径</strong></p></blockquote><h3 id="3-结构化"><a href="#3-结构化" class="headerlink" title="3.结构化"></a>3.结构化</h3><h4 id="3-1文件搜索"><a href="#3-1文件搜索" class="headerlink" title="3.1文件搜索"></a>3.1文件搜索</h4><p><strong>①<code>aux_source_directory</code></strong></p><blockquote><p>查找<strong>某个路径</strong>下的<strong>所有源文件</strong>，并将源文件列表<strong>存储到对应变量中</strong><br><strong>格式</strong>：<code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 搜索当前目录下的源文件aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR} SRC_LIST)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②<code>file</code></strong></p><blockquote><p>查找<strong>某个路径</strong>下的所有<strong>指定格式</strong>的文件<br><strong>格式</strong>：<code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> GLOB表示只搜索当前路径，GLOB_RECURSE还会递归搜索当前路径下的所有子目录</div><pre class="line-numbers language-none"><code class="language-none">#搜索对应路径下的源文件file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)#搜索对应路径下的头文件file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2头文件路径"><a href="#3-2头文件路径" class="headerlink" title="3.2头文件路径"></a>3.2头文件路径</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常，大型项目将源文件、头文件等分开放，如下所示</div><pre class="line-numbers language-none"><code class="language-none">$ tree.├── build├── CMakeLists.txt├── include│&nbsp;&nbsp; └── head.h└── src    ├── main.cc    ├── a.cc    ├── b.cc    └── c.cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②<code>include_directories</code></strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于#include " "指令只在当前目录下寻找头文件，以上情况需要添加头文件路径</div><blockquote><p><strong>格式</strong>：<code>include_directories (headpath)</code>，<code>headpath</code>为<strong>头文件路径</strong></p></blockquote><h4 id="2-3改进后的CmakeLists"><a href="#2-3改进后的CmakeLists" class="headerlink" title="2.3改进后的CmakeLists"></a>2.3改进后的CmakeLists</h4><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)#添加C++11标准set(CMAKE_CXX_STANDARD 11)#设置头文件路径include_directories(${PROJECT_SOURCE_DIR}/include)#搜索所有源文件file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)#生成可运行文件add_executable(main  ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-动态库和静态库"><a href="#4-动态库和静态库" class="headerlink" title="4.动态库和静态库"></a>4.动态库和静态库</h3><h4 id="4-1引言"><a href="#4-1引言" class="headerlink" title="4.1引言"></a>4.1引言</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 库文件本质上是源文件的二进制格式</div><p><strong>①静态库</strong></p><blockquote><p><strong>优点</strong>：<strong>打包到应用程序中</strong>，加载速度快，移植方便<br><strong>缺点</strong>：内存中可能出现<strong>多份静态库</strong>（多个链接该库的程序一起运行），且如果<strong>静态库更新</strong>，则项目需要<strong>重新编译</strong></p></blockquote><p><strong>②动态库</strong></p><blockquote><p><strong>优点</strong>：<strong>多个进程共享</strong>，只有<strong>在调用时才被载入内存</strong>，动态库更新<strong>无需重新编译程序</strong><br><strong>缺点</strong>：加载<strong>速度比静态库慢（可忽略）</strong>，发布程序需要<strong>提供依赖的动态库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 动态库有可执行权限，而静态库没有</div><p><strong>③文件架构</strong></p><pre class="line-numbers language-none"><code class="language-none">.├── build├── lib├── CMakeLists.txt├── include           # 头文件目录│&nbsp;&nbsp; └── head.h├── main.cc           # 用于测试的源文件└── src               # 源文件目录    ├── a.cc    ├── b.cc    └── c.cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2制作库"><a href="#4-2制作库" class="headerlink" title="4.2制作库"></a>4.2制作库</h4><p><strong>①<code>add_library</code></strong></p><blockquote><p>将对应<strong>源文件</strong>制作为<strong>静态库/动态库</strong><br><strong>格式</strong>：<code>add_library(库名称 STATIC/SHARED 源文件1 [源文件2] ...)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中计算机中的库名由三部分组成lib+库名+后缀，命令中只需要指定库名即可，其余计算机自动填充</div><p><strong>②指定输出路径</strong></p><blockquote><p>通过指定<strong>系统变量</strong><code>LIBRARY_OUTPUT_PATH</code><br><strong>例子</strong>：<code>set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不指定则生成到当前路径中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中，动态库的生成路径还可以通过改变EXECUTABLE_OUTPUT_PATH，因为动态库是一个可执行文件</div><p><strong>③对应CmakeLists文件</strong></p><blockquote><p>将<code>src</code><strong>文件夹</strong>中文件构建为<strong>库文件</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)include_directories(${PROJECT_SOURCE_DIR}/include)file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")# 设置动态库/静态库生成路径set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)# 生成动态库，将SHARED修改为STATIC即可生成静态库#add_library(abc SHARED ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3使用库文件"><a href="#4-3使用库文件" class="headerlink" title="4.3使用库文件"></a>4.3使用库文件</h4><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 库文件的生成和库文件的使用是两个项目</div><p><strong>①<code>link_libraries</code></strong></p><blockquote><p><strong>链接静态库</strong><br><strong>格式</strong>：<code>link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...])</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中static lib可以写全名，也可以只写中间部分</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 由于静态库是可执行文件的一部分，故需要在可执行文件生成前链接</div><p><strong>②<code>target_link_libraries</code></strong></p><blockquote><p><strong>链接动态库</strong><br><strong>格式</strong>：如下所示，<code>target</code>为<strong>链接动态库的文件</strong>，<code>PRIVATE|PUBLIC|INTERFACE</code>为动态库的<strong>访问权限</strong>，<strong>缺省</strong>为<code>PUBLIC</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> `target`可能是可执行文件、源文件或者动态库文件</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 由于动态库不是可执行文件的一部分，故需要在可执行文件生成后链接</div><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(    &lt;target&gt;     &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 动态库链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法（PUBLIC情况下）</div><blockquote><p><strong>访问权限</strong><br><code>PUBLIC</code>：在<code>PUBLIC</code>后面的库会被<strong>链接</strong>到前面的<code>target</code>中，并且里面的符号也会被导出<br><code>PRIVATE</code>：在<code>PRIVATE</code>后面的库<strong>仅被链接到前面的<code>target</code>中</strong>，<strong>不会传递</strong><br><code>INTERFACE</code>：在<code>INTERFACE</code>后面引入的库<strong>不会被链接到前面的target中</strong>，只会导出<strong>符号</strong>，并<strong>不知道库的信息</strong>，同样也<strong>不会传递</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 动态库和静态库也可以相互链接，相互之间不会影响各自特性</div><p><strong>③<code>link_directories</code></strong></p><blockquote><p><strong>指定库的路径</strong><br><strong>格式</strong>：<code>link_directories(lib_path)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果使用非系统提供的库文件，则需要指明库文件路径，便于编译器找到</div><h4 id="4-4例子"><a href="#4-4例子" class="headerlink" title="4.4例子"></a>4.4例子</h4><p><strong>①文件架构</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用库文件还需要包含相关头文件（包含库文件使用的函数声明）</div><pre class="line-numbers language-none"><code class="language-none">.├── build├── CMakeLists.txt├── include│&nbsp;&nbsp; └── head.h              #库文件对应的头文件├── lib│&nbsp;&nbsp; └── libabc.a（.so）     # 制作出的静态库（动态库）的名字└── src    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②静态库版本</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)# 搜索指定目录下源文件file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)# 包含头文件路径include_directories(${PROJECT_SOURCE_DIR}/include)# 包含静态库路径link_directories(${PROJECT_SOURCE_DIR}/lib)# 链接静态库link_libraries(abc)add_executable(main ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③动态库版本</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)# 指定源文件或者动态库对应的头文件路径include_directories(${PROJECT_SOURCE_DIR}/include)# 指定要链接的动态库的路径link_directories(${PROJECT_SOURCE_DIR}/lib)# 添加并生成一个可执行程序add_executable(main ${SRC_LIST})# 指定要链接的动态库，其中libpthread.so为系统提供的线程库target_link_libraries(main pthread abc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码工具 </tag>
            
            <tag> Cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake应用（二）</title>
      <link href="/2023/11/07/cmake-ying-yong-er/"/>
      <url>/2023/11/07/cmake-ying-yong-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><h2 id="Cmake应用（二）"><a href="#Cmake应用（二）" class="headerlink" title="Cmake应用（二）"></a>Cmake应用（二）</h2><h3 id="1-嵌套Cmake"><a href="#1-嵌套Cmake" class="headerlink" title="1.嵌套Cmake"></a>1.嵌套Cmake</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当项目有多个源代码目录时，给每个源码目录都添加一个CMakeLists.txt文件，便于管理</div><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><blockquote><p>进行<strong>模块化测试</strong>，将<code>calc</code>和<code>sort</code>中的源代码打包成<strong>库</strong>，并分别给<strong>对应测试文件</strong>调用</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$ tree.├── build├── calc              #计算库│&nbsp;&nbsp; ├── add.cpp│&nbsp;&nbsp; ├── CMakeLists.txt│&nbsp;&nbsp; ├── div.cpp│&nbsp;&nbsp; ├── mult.cpp│&nbsp;&nbsp; └── sub.cpp├── CMakeLists.txt├── include           #头文件目录│&nbsp;&nbsp; ├── calc.h│&nbsp;&nbsp; └── sort.h├── sort              #排序库│&nbsp;&nbsp; ├── CMakeLists.txt│&nbsp;&nbsp; ├── insert.cpp│&nbsp;&nbsp; └── select.cpp├── test1             #测试计算库│&nbsp;&nbsp; ├── calc.cpp│&nbsp;&nbsp; └── CMakeLists.txt└── test2             #测试排序    ├── CMakeLists.txt    └── sort.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2建立联系"><a href="#1-2建立联系" class="headerlink" title="1.2建立联系"></a>1.2建立联系</h4><p><strong>①节点关系</strong></p><blockquote><p><code>CMakeLists</code>文件关系是<strong>树状结构关系</strong>（因为<strong>文件/目录之间的关系</strong>也是树状结构关系）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 父节点定义的变量也可以在子节点中使用，子节点定义的变量只能在当前节点使用</div><p><strong>②<code>add_subdirectory</code></strong></p><blockquote><p><strong>建立父子节点关系</strong><br><strong>格式</strong>：<code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></p></blockquote><blockquote><p><code>source_dir</code>：指定<strong>子目录</strong><br><code>binary_dir</code>：指定了<strong>子目录输出文件的路径</strong>，一般<strong>不需要指定</strong><br><code>EXCLUDE_FROM_ALL</code>：当指定该参数时，父目录的<code>CMakeLists.txt</code>不会构建子目录的目标文件，必须在<strong>子目录下显式去构建</strong>，除非<strong>父目录的目标文件依赖于子目录的目标文件</strong></p></blockquote><h4 id="1-3CmakeLists文件"><a href="#1-3CmakeLists文件" class="headerlink" title="1.3CmakeLists文件"></a>1.3CmakeLists文件</h4><p><strong>①根目录</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根目录主要的功能是定义全局变量和添加子目录</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(test)# 定义变量# 静态库生成的路径set(LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)# 测试程序生成的路径set(EXEC_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)# 头文件目录set(HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/include)# 静态库的名字set(CALC_LIB calc)set(SORT_LIB sort)# 可执行程序的名字set(APP_NAME_1 test1)set(APP_NAME_2 test2)# 添加子目录add_subdirectory(calc)add_subdirectory(sort)add_subdirectory(test1)add_subdirectory(test2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②calc目录</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(CALCLIB)#搜索当前目录（calc目录）下的所有源文件aux_source_directory(./ SRC)#包含头文件路径，HEAD_PATH是在根节点文件中定义的include_directories(${HEAD_PATH})#设置库的生成的路径，LIB_PATH是在根节点文件中定义的set(LIBRARY_OUTPUT_PATH ${LIB_PATH})#生成静态库，静态库名字CALC_LIB是在根节点文件中定义的add_library(${CALC_LIB} STATIC ${SRC})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③sort目录</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(SORTLIB)aux_source_directory(./ SRC)include_directories(${HEAD_PATH})set(LIBRARY_OUTPUT_PATH ${LIB_PATH})#生成动态库，动态库名字SORT_LIB是在根节点文件中定义的add_library(${SORT_LIB} SHARED ${SRC})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④test1目录</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当程序某个模块中生成库且在对应CmakeLists文件中指定了库的输出路径，其他模块不需要指定其路径</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(CALCTEST)aux_source_directory(./ SRC)#指定头文件路径，HEAD_PATH变量是在根节点文件中定义的include_directories(${HEAD_PATH})link_directories(${LIB_PATH})#指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的link_libraries(${CALC_LIB})#指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})#生成可执行程序，APP_NAME_1变量是在根节点文件中定义的add_executable(${APP_NAME_1} ${SRC})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑤test2目录</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(SORTTEST)aux_source_directory(./ SRC)include_directories(${HEAD_PATH})set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})link_directories(${LIB_PATH})add_executable(${APP_NAME_2} ${SRC})target_link_libraries(${APP_NAME_2} ${SORT_LIB})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑥结果</strong></p><blockquote><p>进入到<strong>根节点目录</strong>的<code>build</code><strong>目录</strong>中，执行<code>cmake</code>和<code>make</code>命令，在项目<strong>根目录</strong>的<code>lib</code><strong>目录</strong>中生成了<strong>静态库</strong><code>libcalc.a</code>和<strong>动态库</strong><code>libsort.so</code>，并在项目<strong>根目录</strong>的<code>bin</code><strong>目录</strong>生成了<strong>可执行程序</strong><code>test1</code>和<code>test2</code></p></blockquote><h3 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2.流程控制"></a>2.流程控制</h3><h4 id="2-1条件判断"><a href="#2-1条件判断" class="headerlink" title="2.1条件判断"></a>2.1条件判断</h4><p><strong>①<code>if</code>语句</strong></p><pre class="line-numbers language-none"><code class="language-none">if(&lt;condition&gt;)  &lt;commands&gt;elseif(&lt;condition&gt;)  #可选块，可重复  &lt;commands&gt;else()               #可选块  &lt;commands&gt;endif()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②<code>condition</code></strong></p><blockquote><p><code>condition</code>的值为<code>1</code>, <code>ON</code>, <code>YES</code>, <code>TRUE</code>, <code>Y,</code> <strong>非零值</strong>，<strong>非空字符串</strong>时，条件判断返回<code>True</code><br><code>condition</code>的值为<code>0</code>，<code>OFF</code>，<code>NO</code>，<code>FALSE</code>，<code>N</code>，<code>IGNORE</code>，<code>NOTFOUND</code>，<strong>空字符串</strong>时，条件判断返回<code>False</code></p></blockquote><p><strong>③相关操作符</strong></p><blockquote><p><strong>逻辑操作</strong>：<code>NOT</code>（非）、<code>AND</code>（与）、<code>OR</code>（或）</p></blockquote><blockquote><p><strong>数值比较</strong>：<code>LESS</code>（小于）、<code>GREATER</code>（大于）、<code>EQUAL</code>（等于）、<code>LESS_EQUAL</code>（小于等于）、<code>GREATER_EQUAL</code>（大于等于）</p></blockquote><blockquote><p><strong>字符串比较</strong>：<strong>同上</strong>，但是需要加上<code>STR</code><strong>前缀</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> CMake还提供了其他判断语句，如if(EXISTS path-to-file-or-directory)则是判断文件或者目录是否存在</div><h4 id="2-2循环语句"><a href="#2-2循环语句" class="headerlink" title="2.2循环语句"></a>2.2循环语句</h4><p><strong>①while循环</strong></p><blockquote><p>当<code>condition</code>为<code>False</code>时结束</p></blockquote><pre class="line-numbers language-none"><code class="language-none">while(&lt;condition&gt;)    &lt;commands&gt;endwhile()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>②<code>foreach</code>循环1</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)</code><br><code>loop_var</code>：<strong>存储每次循环取出的值</strong><br><code>RANGE</code>：关键字，表示<strong>要遍历范围</strong><br><code>stop</code>：这是一个正整数，表示<strong>范围的结束值</strong>，即遍历范围为<code>[0,stop]</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.2)project(test)# 循环foreach(item RANGE 10)    message(STATUS "当前遍历的值为: ${item}" )endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③<code>foreach</code>循环2</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</code><br><code>start</code>：表示范围的<strong>起始值</strong><br><code>stop</code>：表示范围的<strong>结束值</strong><br><code>step</code>：循环的<strong>步长</strong>，<strong>默认为1</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.2)project(test)foreach(item RANGE 10 30 2)    message(STATUS "当前遍历的值为: ${item}" )endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④<code>foreach</code>循环3</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])</code><br><code>IN</code>：关键字，对应<code>RANGE</code><br><code>LISTS</code>：关键字，对应的是列表<br><code>ITEMS</code>：关键字，对应的也是列表，但是需要通过<code>${}</code><strong>将列表中的值取出</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> LISTS关键字和ITEMS至少要存在一个，也可以同时存在，每个后面可以接多个对象</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.2)project(test)# 创建 listset(WORD a b c d)set(NAME ace sabo luffy)# 遍历 listforeach(item IN LISTS WORD ITEMS ${NAME})    message(STATUS "当前遍历的值为: ${item}" )endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑤<code>foreach</code>循环4</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</code><br><code>ZIP_LISTS</code>：关键字</p></blockquote><blockquote><p><strong><code>&lt;loop_var&gt;...</code></strong><br>如果指定了<strong>多个变量名</strong>，则<strong>变量的数量</strong>应该和<strong>列表数</strong>相等<br>若<strong>只给出一个</strong><code>loop_var</code>，则他会<strong>自动创建出对应数量</strong>的<code>loop_var_0</code>到<code>loop_var_N</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该循环同时对所有列表进行循环，每次循环各个列表对应的值存储在这些变量中</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.17)project(test)# 通过list给列表添加数据list(APPEND WORD hello world "hello world")list(APPEND NAME ace sabo luffy zoro sanji)# 遍历列表foreach(item1 item2 IN ZIP_LISTS WORD NAME)    message(STATUS "当前遍历的值为: item1 = ${item1}, item2=${item2}" )endforeach()message("=============================")# 遍历列表foreach(item  IN ZIP_LISTS WORD NAME)    message(STATUS "当前遍历的值为: item1 = ${item_0}, item2=${item_1}" )endforeach()#[[输出结果如下-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji=============================-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码工具 </tag>
            
            <tag> Cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp学习笔记（一）</title>
      <link href="/2023/11/07/cpp-xue-xi-bi-ji-yi/"/>
      <url>/2023/11/07/cpp-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp学习笔记（一）"><a href="#Cpp学习笔记（一）" class="headerlink" title="Cpp学习笔记（一）"></a>Cpp学习笔记（一）</h1><h2 id="Cpp启蒙"><a href="#Cpp启蒙" class="headerlink" title="Cpp启蒙"></a>Cpp启蒙</h2><h3 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1.基本知识"></a>1.基本知识</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> Cpp基础部分和C++有很多类似，主要介绍不同的地方</div><h4 id="1-1输入输出"><a href="#1-1输入输出" class="headerlink" title="1.1输入输出"></a>1.1输入输出</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要包含iostream头文件</div><p><strong>①输出</strong>：<code>cout&lt;&lt;内容1&lt;&lt;内容2...&lt;&lt;endl;</code></p><blockquote><p><code>cout</code>：<code>iostream</code>类的一个实例，连接到<strong>标准输出设备</strong>，通常是<strong>显示屏</strong><br><code>&lt;&lt;</code>：<strong>输出流运算符</strong>，<strong>左侧</strong>必须是一个<code>ostream</code><strong>对象</strong>，<strong>右侧</strong>是<strong>输出的值</strong>，<strong>计算结果</strong>为<code>ostream</code><strong>对象</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 计算结果为ostream对象，这是可以连续输出的原因</div><p><code>endl</code>：<strong>换行符</strong></p><p><strong>②输入</strong>：<code>cin&gt;&gt;容器（变量）;</code></p><blockquote><p><code>cin</code>：同<code>cout</code>，连接到<strong>标准输入设备</strong>，通常是键盘<br><code>&gt;&gt;</code>：<strong>输入流运算符</strong>，和<code>&lt;&lt;</code>类似，将<strong>标准输入设备的数据</strong>保存到<strong>右边的容器</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还有一些其他的标准输入输出，如标准错误cerr</div><h4 id="1-2命名空间"><a href="#1-2命名空间" class="headerlink" title="1.2命名空间"></a>1.2命名空间</h4><blockquote><p>常见的语句是<code>using namespace std;</code><br><code>std</code>：<strong>标准库</strong>的命名空间<br><code>using</code>：让对应命名空间<strong>曝光</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 命名空间可以避免程序发生命名冲突，当命名冲突发生时，需要获得解析才能继续执行</div><blockquote><p><strong>解析</strong>：<code>命名空间::变量名</code></p></blockquote><h4 id="1-3算数类型"><a href="#1-3算数类型" class="headerlink" title="1.3算数类型"></a>1.3算数类型</h4><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 算数类型的尺寸在不同机器上有所差别，C++标准只规定了它们的最小尺寸，以下描述的都是它们的常见长度</div><p><strong>①布尔类型</strong></p><blockquote><p>只有<code>bool</code><strong>一种类型</strong>，只有<code>true</code>和<code>false</code>两种值，通常占<strong>8个字节</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> true转化为非布尔类型即为1，false为0，其他类型转化为布尔类型时，0为false，其余为true</div><p><strong>②字符</strong></p><blockquote><p>常见的为<code>char</code><strong>类型</strong>，通常占<strong>8个字节</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> C++还规定了扩展字符集，如wchar_t可以存放机器最大扩展字符集的任意一个字符（16位）</div><p><strong>③整型</strong></p><blockquote><p>除了<code>int</code>（<strong>16位</strong>）、<code>short</code>（<strong>16位</strong>）和<code>long</code>（<strong>32位</strong>），<strong>C++11新特性</strong>还规定了<code>long long</code>（<strong>64位</strong>）</p></blockquote><p><strong>④浮点型</strong></p><blockquote><p><code>float</code>（<strong>1个字</strong>）、<code>double</code>（<strong>2个字</strong>）和<code>long double</code>（<strong>3至4个字</strong>）</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 浮点型一般采用double，因为double和float运算速度相差不大，但是精度更高，long double消耗太大</div><h4 id="1-4引用"><a href="#1-4引用" class="headerlink" title="1.4引用"></a>1.4引用</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> C++独有的传址方式，被称为变量的别名，本质上其指向对象的指针常量</div><blockquote><p>如下所示，<code>b</code>为<code>a</code>的一个<strong>引用</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int a = 1024;int *p = &amp;a;int &amp;b = a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 引用变量在定义时就必须初始化（指向一个对象，不能是字面值），一旦指定就不可改变</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对引用变量的操作就是对其指向对象的操作，包括寻址操作等</div><h4 id="1-5空指针"><a href="#1-5空指针" class="headerlink" title="1.5空指针"></a>1.5空指针</h4><p>int *p = 0/nullptr<br>避免使用NULL</p><h4 id="1-4命名规范"><a href="#1-4命名规范" class="headerlink" title="1.4命名规范"></a>1.4命名规范</h4><blockquote><p>变量名一般使用小写字母，自定义类名一般以大写字母开头<br>用户自定义变量名不能连续出现两个下划线，也不能以下划线紧连大写字母开头，函数体外的标识符不能以下划线开头</p></blockquote><blockquote><p>全局作用域：声明在代码块之外<br>块作用域：声明在代码块内（声明还是定义？）<br>内层作用域可以访问外层的变量，也可以重新定义（新建局部变量覆盖全局变量）<br>作用域操作符::修饰变量表示使用对应的全局变量</p></blockquote><blockquote><p>声明使得名字为程序所知，一个文件如果想要使用在别处定义的名字必须包含对那个名字的声明<br>定义负责创建与名字相关联的实体<br>如果仅仅只需要声明一个变量。在变量名前添加关键字extern，如果对一个变量赋值，则就算其有extern修饰，也是一个定义<br>在函数体内部初始化一个由extern关键字修饰的变量将引发错误？<br>如果要在多个文件中使用一个变量，则需要在一个文件中定义，在其他文件中声明</p></blockquote><h4 id="1-4初始化"><a href="#1-4初始化" class="headerlink" title="1.4初始化"></a>1.4初始化</h4><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 初始化和赋值并不是同一个概念，初始化是在创建变量时赋予其初始值，赋值是将对象当前值替换为新值</div><blockquote><p><strong>列表初始化</strong>：当初始值存在丢失信息的风险（如使用浮点型初始化整型数据，会丢失精度），编译器将报错<br>内置类型初始化由位置决定，函数体内部，一个未被初始化的内置类型的变量的值是未定义的，访问会报错</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 显式初始化每一个内置类型变量</div>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《C++primer》 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（一）</title>
      <link href="/2023/11/07/c-yu-yan-xue-xi-bi-ji-yi/"/>
      <url>/2023/11/07/c-yu-yan-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（一）"><a href="#C语言学习笔记（一）" class="headerlink" title="C语言学习笔记（一）"></a>C语言学习笔记（一）</h1><h2 id="C语言启蒙"><a href="#C语言启蒙" class="headerlink" title="C语言启蒙"></a>C语言启蒙</h2><h3 id="1-C语言程序组成简介"><a href="#1-C语言程序组成简介" class="headerlink" title="1.C语言程序组成简介"></a>1.C语言程序组成简介</h3><h4 id="1-1空白"><a href="#1-1空白" class="headerlink" title="1.1空白"></a>1.1空白</h4><blockquote><p>换行、<code>tab</code>和空格键，使得程序更加美观</p></blockquote><h4 id="1-2注释"><a href="#1-2注释" class="headerlink" title="1.2注释"></a>1.2注释</h4><blockquote><p>解释程序，debug<br><strong>①单行注释</strong>：以<code>//</code>开始、以换行符结束<br><strong>②多行注释</strong>：以<code>/*</code>开始，以<code>*/</code>结束<br><strong>③预处理注释</strong>：用于注释<strong>包含注释</strong>的代码块</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#if 0  statement#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 多行注释不能嵌套，第一个/*到第一个*/之间都视为注释</div><h4 id="1-3预处理命令"><a href="#1-3预处理命令" class="headerlink" title="1.3预处理命令"></a>1.3预处理命令</h4><p><strong>①</strong><code>#include&lt;文件名&gt;</code>：将对应文件内容逐字写到对应位置<br><strong>②</strong><code>#define 变量名 值</code>：将变量名（<strong>大写</strong>）对应位置替换为对应值</p><h4 id="1-4函数原型（声明）"><a href="#1-4函数原型（声明）" class="headerlink" title="1.4函数原型（声明）"></a>1.4函数原型（声明）</h4><blockquote><p>告诉编译器调用函数的<strong>特征</strong>（参数和返回值的个数和类型）</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果有一些函数声明经常需要使用，可以将他们的函数声明写到一个头文件中，再调用#include宏将该头文件写入即可</div><h4 id="1-5main函数"><a href="#1-5main函数" class="headerlink" title="1.5main函数"></a>1.5main函数</h4><blockquote><p>程序执行的<strong>起点</strong>和<strong>终点</strong>（无异常）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">int main (void){  statement;  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-简单数据类型"><a href="#2-简单数据类型" class="headerlink" title="2.简单数据类型"></a>2.简单数据类型</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 基本数据类型有整型、浮点数、指针和聚合类型，这里只介绍整型和浮点型</div><h4 id="2-1整型"><a href="#2-1整型" class="headerlink" title="2.1整型"></a>2.1整型</h4><p><strong>①字符</strong>：<code>char</code></p><blockquote><p><code>char</code>本质上是一个小整型，占<strong>一个字节（8位）</strong></p></blockquote><p><strong>②整型</strong></p><blockquote><p><strong>短整型</strong>：<code>short int</code><br><strong>整型</strong>：<code>int</code><br><strong>长整型</strong>：<code>long int</code><br><code>short int</code>至少占<strong>16位</strong>，<code>long int</code>至少占<strong>32位</strong>，<code>int</code>位数<strong>由编译器决定</strong>，通常是这种机器<strong>最为高效的位数</strong>，32位系统最可能是32位，64位系统最可能是64位，一些嵌入式系统可能是16位或者更小</p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在长度上，长整型≥整型≥短整型，但是他们能表示的范围是不同的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在C11的标准中追加stdint.h避免了位数的不确定如：int32_t就是指4个字节的，int8_t就是一个字节</div><p><strong>③有符号数（signed）和无符号数（unsigned）</strong></p><blockquote><p>对于<code>int</code>、<code>short int</code>、<code>long int</code>来说，缺省情况下为<strong>有符号数</strong>，有符号数可表示正负数和0，无符号数<strong>只能表示正数</strong><br>对于<code>char</code>来说，分为<code>char</code>、<code>singed char</code>和<code>unsigned char</code>，其中<code>char</code>的带符号与否<strong>取决于编译器</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了提高程序的可移植性，需要将char限制在其余两者的交集（0~127）内，且只对显式声明为有符号数和无符号数再对其进行数值运算</div><h4 id="2-2浮点类型"><a href="#2-2浮点类型" class="headerlink" title="2.2浮点类型"></a>2.2浮点类型</h4><blockquote><p><strong><code>float</code>单精度浮点数</strong><br><strong><code>double</code>双精度浮点数</strong><br><strong><code>long double</code>扩展精度浮点数，只有某些机器支持扩展精度</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ANSI C没有规定浮点类型的长度，long double≥doubl≥float，字面量在缺省情况下一般为double，除非在后面添加l、f后缀</div><h4 id="2-3字面值"><a href="#2-3字面值" class="headerlink" title="2.3字面值"></a>2.3字面值</h4><blockquote><p><strong>整型字面值</strong>：在缺省情况下，字面值类型就是<strong>能表示</strong>该字面量的<strong>最短的类型</strong>，也可以通过<strong>添加后缀</strong>改变字面值的类型，一般采用<strong>十进制</strong>写法，也可采用其他进制（需要特殊前缀）<br><strong>字符型字面值</strong>：<code>‘内容’</code>，类型总是<code>int</code>，不能添加后缀改变<br><strong>字符串字面值</strong>：<code>“内容”</code>，以<code>NUL</code>字节结尾，所以内容中不能存在<code>NUL</code><br><strong>浮点数字面值</strong>：通常是<code>double</code>，可以通过后缀改变其类型</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 字面值被创建后就不能改变</div><h4 id="2-4枚举类型"><a href="#2-4枚举类型" class="headerlink" title="2.4枚举类型"></a>2.4枚举类型</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上还是int，相当于被命名的int集合</div><blockquote><p><strong>命名格式</strong>：<code>enum 枚举类型名{枚举1,枚举2,枚举3…} ；</code><br>如果不对枚举进行赋值，则枚举从0开始，依次增大1，如果对有的被赋值，有的没有，则没有被赋值的枚举<strong>比前者大1</strong></p></blockquote><hr><h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h3><h4 id="3-1声明与定义"><a href="#3-1声明与定义" class="headerlink" title="3.1声明与定义"></a>3.1声明与定义</h4><p><strong>①格式</strong>：<code>说明符 声明表达式列表</code></p><blockquote><p><strong>说明符</strong>：用于指明变量的<strong>基本类型</strong>、<strong>存储类型</strong>和<strong>作用域</strong>，可以有一个，也可以有多个<br><strong>声明表达式</strong>：命名变量、赋值</p></blockquote><p><strong>②声明和定义</strong></p><blockquote><p><strong>声明</strong>：用于向程序表明变量的<strong>类型和名字</strong><br><strong>定义</strong>：用于为变量<strong>分配存储空间</strong>，还可为变量<strong>指定初始值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于int a;，如果a是全局变量的话就是声明，是局部变量的话就是定义</div><blockquote><p>可以利用<code>extern</code>修饰<strong>局部变量</strong>表明是变量的<strong>声明</strong>，该关键词含义是此变量/函数是<strong>在别处定义</strong>的，要在此处引用</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明（extern）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 变量可以声明多次，而只能定义一次</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在声明变量时不要赋值，否则就是定义了</div><p><strong>③实例</strong></p><pre class="line-numbers language-none"><code class="language-none">include &lt;stdio.h&gt;int a;int a;int main(){return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该程序正常工作</p></blockquote><pre class="line-numbers language-none"><code class="language-none">include &lt;stdio.h&gt;int main(){int a;    int a;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该程序由于<strong>重复定义</strong>错误</p></blockquote><p><strong>④声明/定义的解释</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 变量的声明可以理解为，变量通过声明表达式的运算得到说明符，如int a[]可以理解为变量a通过下标运算得到一个整数，则a就是一个数组，本质上是一个指向整型的指针</div><h4 id="3-2typedef"><a href="#3-2typedef" class="headerlink" title="3.2typedef"></a>3.2typedef</h4><p><strong>①格式</strong>：只要在<strong>变量声明</strong>前面加上<code>typedef</code>，就成了<strong>类型定义</strong>，对应变量名即称为新的类型名</p><blockquote><p>如<code>typedef int (*function_t) (int param);</code>，在这里<code>function_t</code>则称为了对应的函数指针的类型名</p></blockquote><p><strong>②与define的区别</strong>：<code>define</code>只是简单的替换，如下，<code>a</code>被定义为一个指针，而<code>b</code>被定义为一个字符</p><pre class="line-numbers language-none"><code class="language-none">#define char* ptr_to_charptr_to_char a,b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在进行句法分析的时候，typedef和存储类型指示符是等价的，故该关键词不能和static等存储类型指示符一起用</div><h4 id="3-3const常量"><a href="#3-3const常量" class="headerlink" title="3.3const常量"></a>3.3const常量</h4><blockquote><p>使得变量被<strong>初始化后不得被更改</strong></p></blockquote><p><strong>①修饰对象</strong></p><blockquote><p><code>const</code>修饰指针时，需要注意<code>const</code>修饰的是<strong>指针</strong>还是<strong>指针指向的值</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int const *a：指针指向的值不能被修改int * const a：指针无法被修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②<code>const</code>与<code>define</code></strong></p><blockquote><p><code>const</code>只能用于允许使用变量的地方，比如数组的大小就最好使用<code>define</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数中被const修饰的形参获得对应的实参的值后无法被改变，当你不希望函数改变该值时，可以使用const修饰该形参</div><h4 id="3-4作用域"><a href="#3-4作用域" class="headerlink" title="3.4作用域"></a>3.4作用域</h4><blockquote><p>变量只能在一定的区域中才能被访问，即变量<strong>能被访问的区域</strong></p></blockquote><p><strong>①代码块作用域</strong></p><blockquote><p>代码块中变量的作用域<strong>于代码块开头开始，到代码块结尾结束</strong></p></blockquote><blockquote><p><strong>嵌套</strong>的代码块中，<strong>同名</strong>内层变量会<strong>覆盖</strong>外层变量，包括全局变量<br><strong>非嵌套</strong>的代码块，每个代码块的变量无法被另一个代码块访问，<strong>代码块之间变量隔离</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在ANSI C中，函数形参的作用域在函数最外层代码块内（动态变量）</div><p><strong>②文件作用域</strong></p><blockquote><p>在<strong>代码块外</strong>声明的变量都具有文件作用域（<code>extern</code>属性），从他们<strong>声明之处到所处源文件结尾</strong>都可以访问</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用include包含到该文件的变量属于文件作用域</div><p><strong>③原型作用域</strong></p><blockquote><p>只适用于<strong>函数原型（不是函数定义）</strong>中声明的参数名，只存在那个括号内</p></blockquote><p><strong>④函数作用域</strong></p><blockquote><p>只适用于语句标签，一个函数中所有<strong>语句标签必须唯一</strong></p></blockquote><h4 id="3-5链接属性（如果使用extern修饰局部变量的效果是什么？？？）"><a href="#3-5链接属性（如果使用extern修饰局部变量的效果是什么？？？）" class="headerlink" title="3.5链接属性（如果使用extern修饰局部变量的效果是什么？？？）"></a>3.5链接属性（如果使用extern修饰局部变量的效果是什么？？？）</h4><blockquote><p>变量的链接属性决定如何处理在<strong>不同文件中的同名变量</strong></p></blockquote><p><strong>①<code>none</code></strong></p><blockquote><p>只能在其<strong>所在代码块中</strong>被访问。</p></blockquote><p><strong>②<code>internal</code></strong></p><blockquote><p><strong>同一个源文件</strong>中的所有同名变量都是同一个实体，可以在<strong>该源文件</strong>中被访问</p></blockquote><p><strong>③<code>external</code></strong></p><blockquote><p><strong>所有源文件</strong>的所有同名变量是<strong>同一个实体</strong>，可以被所有源文件访问</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在缺省情况下，在代码块外的链接属性为external，其余none</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 拥有extern属性的变量在单个源文件中，从头到尾都可以访问，在有多个源文件时，其他源文件也可以访问</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意拥有extern属性的变量只是可以被其他文件访问，若要在其他源文件中使用，需要在使用的源文件中添加对应变量的声明（需要加上extern关键词）</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在多个文件中定义同名的全局变量会导致链接错误，因此建议在一个文件中定义一个全局变量，并通过extern关键字在其他文件中进行引用（可以声明在头文件中）</div><h4 id="3-6存储类型（静态变量和全局变量的区别？？？？）"><a href="#3-6存储类型（静态变量和全局变量的区别？？？？）" class="headerlink" title="3.6存储类型（静态变量和全局变量的区别？？？？）"></a>3.6存储类型（静态变量和全局变量的区别？？？？）</h4><p><strong>①静态内存</strong></p><blockquote><p>在<strong>代码块之外</strong>声明的变量被称为<strong>静态变量</strong>，无法改变其存储类型，在<strong>程序运行之前</strong>创建，在程序的<strong>整个执行期间</strong>始终存在</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 全局变量总是静态变量</div><p><strong>②堆栈</strong></p><blockquote><p>在<strong>代码块内</strong>声明的变量被称为<strong>动态变量</strong>，存储在<strong>堆栈</strong>中，当<strong>程序执行流到达该代码块时，才被创建，执行流离开该代码块时，该变量被销毁</strong>，当该代码块重复执行时（比如循环），<strong>内存位置不固定</strong></p></blockquote><p><strong>③硬件寄存器</strong></p><blockquote><p>称为<strong>寄存器变量</strong>，<strong>访问效率更高</strong>，可以把<strong>高频使用</strong>的变量声明为寄存器变量，寄存器变量的<strong>生命周期和动态变量</strong>相同</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 寄存器变量是一种请求，编译器可能忽略该请求，同时，当寄存器数量不足是，寄存器变量也可能转变为自动变量，且只要声明为寄存器变量，就不能对其取址</div><h4 id="3-7相关属性修改"><a href="#3-7相关属性修改" class="headerlink" title="3.7相关属性修改"></a>3.7相关属性修改</h4><p><strong>①<code>static</code></strong></p><blockquote><p>对<strong>缺省属性</strong>为<code>extern</code>属性的的变量，<code>static</code>将改变其<strong>链接属性</strong>，变为<code>internal</code><br>对<strong>缺省属性</strong>为<code>none</code>属性的的变量，<code>static</code>将改变其<strong>存储类型</strong>，由动态变量变为<strong>静态变量</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用static将动态变量转化为静态变量，其作用域不会改变，原先的值也不会改变</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> static不能修饰形参</div><p><strong>②<code>extern</code></strong><br>可以给标识符赋予<code>external</code>链接属性（只需要在声明处添加即可），则<strong>所有源文件都能访问该变量</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果标识符在第一次声明中已经指定了链接属性，那么extern在后面的第二次或以后的声明中，不会更改第一次声明所指定的链接属性</div><p><strong>③<code>register</code></strong></p><blockquote><p>将<strong>动态变量</strong>转化为<strong>寄存器变量</strong></p></blockquote><h4 id="3-8C程序内存分布"><a href="#3-8C程序内存分布" class="headerlink" title="3.8C程序内存分布"></a>3.8C程序内存分布</h4><p><strong>①代码段</strong></p><blockquote><p>存放<strong>程序执行代码</strong>的内存区域，在<strong>程序运行前</strong>就已经确定，同时其中也包括一些只读的常量</p></blockquote><p><strong>②初始化数据段</strong></p><blockquote><p>存放<strong>已初始化的全局变量</strong>，在进程运行时<strong>静态分配</strong></p></blockquote><p><strong>③未初始化数据段</strong></p><blockquote><p>存放程序中<strong>未初始化的全局变量</strong>和<strong>静态变量</strong>，默认为0，在进程运行时静态分配</p></blockquote><p><strong>④栈</strong></p><blockquote><p>按内存地址<strong>由高到低</strong>扩张，最大长度编译时确定，<strong>自动变量以及函数调用时所需的信息</strong>（如每次函数调用返回地址、寄存器的值）存放在此段。递归函数每次调用自身时，就会使用一个新的栈帧存放其数据</p></blockquote><p><strong>⑤堆</strong></p><blockquote><p>自由申请的空间，按内存地址<strong>由低到高</strong>方向扩张，其长度由系统内存/虚拟内存上限决定，通常在堆中进行<strong>动态存储分配</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个线程都会有自己的栈，但是堆空间是共用的。</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 自动变量因为其地址只有在其创建时确定，故其缺省情况下的初始值是垃圾</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_2.png" alt="C程序内存分布"></p><h3 id="4-语句"><a href="#4-语句" class="headerlink" title="4.语句"></a>4.语句</h3><h4 id="4-1空语句"><a href="#4-1空语句" class="headerlink" title="4.1空语句"></a>4.1空语句</h4><blockquote><p>本身<strong>只包含一个分号</strong>，用于<strong>不需要操作但是语法要求出现一条完整语句</strong>的场合</p></blockquote><h4 id="4-2表达式语句"><a href="#4-2表达式语句" class="headerlink" title="4.2表达式语句"></a>4.2表达式语句</h4><blockquote><p>每个表达式语句都有其<strong>对应返回值</strong>，但是没有其他操作的情况下，该返回值<strong>不被保存</strong></p></blockquote><h4 id="4-3代码块"><a href="#4-3代码块" class="headerlink" title="4.3代码块"></a>4.3代码块</h4><blockquote><p>被一对花括号囊括的多条语句，在语法上相当于<strong>一条语句</strong></p></blockquote><h4 id="4-4条件语句"><a href="#4-4条件语句" class="headerlink" title="4.4条件语句"></a>4.4条件语句</h4><pre class="line-numbers language-none"><code class="language-none">if （expression）{statement;}else if (expression){statement;}else {statement；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>出现<code>if</code>嵌套时，<code>else</code>从句属于<strong>最靠近</strong>他的<strong>不完整</strong>的<code>if</code>从句</p></blockquote><h4 id="4-5循环语句"><a href="#4-5循环语句" class="headerlink" title="4.5循环语句"></a>4.5循环语句</h4><p><strong>①<code>while</code>循环</strong></p><pre class="line-numbers language-none"><code class="language-none">while （expression）{statement;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②f<code>or</code>循环</strong></p><pre class="line-numbers language-none"><code class="language-none">for （初始化语句; 条件语句;调整语句）{statement;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>初始化语句在循环一开始执行，条件语句在每一次循环开始之前执行，调整语句在每一次循环后执行</strong></p></blockquote><p><strong>③<code>do while</code>循环</strong></p><pre class="line-numbers language-none"><code class="language-none">do{statement;}while(expression);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><code>while</code>语句相比，<code>do while</code>语句会先执行语句然后再判断条件是否成立</p></blockquote><p><strong>④<code>switch</code>循环</strong></p><pre class="line-numbers language-none"><code class="language-none">switch（expression）{    case expression_n：  statement；      break；    default：      statement；      break；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> expression的结果必须是整数，C语言中没有布尔类型，非零值为真，零值为假，缺省情况下，真值为1，假值为0</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在循环中可以使用break语句，用于永久终止循环，使用continue语句终止当前的循环</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若循环是嵌套的，则break和continue语句，只能终止其所在的循环</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 当执行到匹配到case语句后，执行流会一直往下直到switch语句结束(包括default子句)，所以要在每个case语句下添加break及时退出，同时这也是一种特性，可以加以利用</div><h4 id="4-6跳转语句"><a href="#4-6跳转语句" class="headerlink" title="4.6跳转语句"></a>4.6跳转语句</h4><pre class="line-numbers language-none"><code class="language-none">biaoqian:goto biaoqian;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>标签就是<strong>标识符后面加一个冒号</strong><br>可以通过goto语句<strong>跳出嵌套循环</strong></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 非必要不使用goto语句</div><h3 id="5-操作符"><a href="#5-操作符" class="headerlink" title="5.操作符"></a>5.操作符</h3><h4 id="5-1基本操作符"><a href="#5-1基本操作符" class="headerlink" title="5.1基本操作符"></a>5.1基本操作符</h4><p><strong>①算术操作符</strong></p><blockquote><p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>（取余）</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> /操作符只有当两个操作数都为整型时，才做整型运算，%只能接受两个整型</div><p><strong>②关系操作符</strong></p><blockquote><p><code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code>、<code>==</code></p></blockquote><p><strong>③逻辑操作符</strong></p><blockquote><p><code>&amp;&amp;</code>（与）、<code>||</code>（或）、<code>^</code>（异）、<code>！</code>（否）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 短路求值，通过第一个操作数能判断结果就不会判断后面的操作数，且要求操作数均为整数</div><p><strong>④赋值操作符</strong></p><blockquote><p><strong>基本赋值操作符</strong>：<code>=</code><br><strong>复合赋值符</strong>：比如<code>+=</code>，<code>a += （expression）</code>代表<code> a = a+（expression）</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 赋值表达式语句的返回值是左操作数的新值，所以可以连等a=b=10</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当a比较复杂或者其中有需要编译器实时计算的项，采用复合赋值符可以提高效率</div><p><strong>⑤逗号操作符</strong></p><blockquote><p><code>expression1,expression2,...,expressionN</code>,<code>expression</code>都会被求值，但是整个表达式的值是<strong>最后一个表达式</strong>的值</p></blockquote><p><strong>⑥条件操作符</strong></p><blockquote><p><code>expression1 ？ expression2 ： expression3</code>：如果<code>expression1</code>值为真，则该表达式结果为<code>expression2</code>，反之为<code>expression3</code></p></blockquote><p><strong>⑦单目操作符</strong></p><blockquote><p><code>&amp;</code>（取址）、<code>*</code>（引用）、<code>sizeof()</code>（判断类型长度）、<code>~</code>（求补，位取相反）、<code>++/--</code>（递增/递减）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ++/--为前缀时，先递加/减，再进行相关操作，为后缀时，先进行相关操作，再递加/减</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 强制类型转换的优先级非常高</div><h4 id="5-2位操作符"><a href="#5-2位操作符" class="headerlink" title="5.2位操作符"></a>5.2位操作符</h4><p><strong>①移位操作符</strong></p><blockquote><p><strong>左移<code>&lt;&lt;</code><strong>：最左边的几位被丢弃，右边多出来的几位</strong>由0补齐</strong><br><strong>右移<code>&gt;&gt;</code><strong>：可以选择两种移位方案，一种是</strong>逻辑移位</strong>，用<strong>0</strong>补充，一种是<strong>算数移位</strong>，补充的<strong>取决于符号数</strong>，对于<strong>无符号数</strong>，采用的都是<strong>逻辑移位</strong>，对于<strong>有符号数</strong>，采用逻辑移位还是算数移位<strong>取决于编译器</strong>，可能会影响程序的移植性</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 两边的操作数都必须是整型，需要移动的位数必须正数，且不能超过被操作数的位数</div><p><strong>②逻辑位操作符</strong></p><blockquote><p>对操作数的<strong>各个位</strong>执行逻辑运算（<code>&amp;</code>与，<code>|</code>或，异或<code>^</code>）<br><code>value = value | 1 &lt;&lt; bit_number;</code>即将<code>bit_number</code>对应位置转换为1</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 位操作符优先级比移位操作符高</div><h4 id="5-3左值和右值"><a href="#5-3左值和右值" class="headerlink" title="5.3左值和右值"></a>5.3左值和右值</h4><blockquote><p>左值相当于一个<strong>容器</strong>，可以储存结果的地方，一个内存位置，右值则是一个<strong>可以被储存的数据</strong><br>变量<code>a</code>可以表示一个容器，也可以表示一个数据，<code>a+1</code>只能是一个数据</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 左值是一个确切知道地址的容器</div><h4 id="5-4类型转换"><a href="#5-4类型转换" class="headerlink" title="5.4类型转换"></a>5.4类型转换</h4><p><strong>①隐式类型转换</strong></p><blockquote><p>在C中的整型算数运算总是以<strong>缺省整型类型精度</strong>进行的，所以操作数是<strong>字符型</strong>和<strong>短整型</strong>时，在使用之前会先被<strong>转化为普通整型</strong>再进行运算，如果要将结果存储到字符型和短整型中，则会将结果进行截短。</p></blockquote><p><strong>②算数转换</strong></p><blockquote><p>当多操作数进行运算时，且操作数属于不同的类型，则会<strong>将精度低的数据类型转化为精度高的数据类型进行运算</strong></p></blockquote><p><strong>③强制类型转换</strong></p><blockquote><p><code>(类型) [操作数/表达式]</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在16位机器上，第三个算式可能会产生溢出，可以在运算前将 a、b中的一个或者两个转化为long即可</div><pre class="line-numbers language-none"><code class="language-none">int a = 5000；int b = 25；long c = a*b；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 强制类型转换可能会导致精度的损失，因为位数不同</div><h4 id="5-4优先级和结合性"><a href="#5-4优先级和结合性" class="headerlink" title="5.4优先级和结合性"></a>5.4优先级和结合性</h4><p><strong>①优先级</strong></p><blockquote><p>标识运算符在表达式中的<strong>运算顺序</strong></p></blockquote><p><strong>②结合性</strong></p><blockquote><p>当一个运算对象两侧运算符的<strong>优先级别相同时</strong>, 运算对象与运算符的结合顺序<br>比如<code>*a++</code>，其中<code>*</code>和<code>++</code>为同一优先级，结合性为右到左，先进行<code>a++</code>，再进行<code>*(a++)</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 表达式的求值顺序不一定完全按照优先级和结合性求值，如c + --c，我们并不知道c是否是在执行了--c后再与其相加，结果取决于编译器，面对有副作用的操作符需要小心</div><h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h3><p><strong>6.1定义</strong>：一串以<code>'/0'</code>结尾的字符 </p><blockquote><p><code>'/0'</code>的位模式全为0，也叫<strong>NUL字节</strong>，是字符串的<strong>终止符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> NUL字节不是字符串的一部分，字符串长度不包括终止符的长度</div><p><strong>6.2基本操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含string.h头文件</div><p><strong>①</strong><code>strlen()</code>：<strong>测量字符串长度</strong>，即字符串包含的<strong>字符个数</strong></p><blockquote><p>该函数返回的长度的数据类型为<code>size_t</code>，是一个<strong>无符号数</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 两个无符号数a、b相互比较时，应该使用a&gt;b，而不是a-b&gt;0，因为无符号数运算结果为无符号数，无符号数永远大于0</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 大部分字符串相关函数都是根据终止符判断字符串长度，所以使用者要确保操作后字符串不会溢出，否则会缺少终止符</div><p><strong>②</strong><code>strcpy()</code>：<strong>复制字符串</strong>，但是如果复制的字符串长度<strong>超出了容器的限度</strong>，则会<strong>覆盖其后面的内存空间</strong></p><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 大部分字符串函数不允许两个数组参数重叠，否则函数的返回值是未定义的</div><p><strong>③</strong><code>strcat()</code>：<strong>连接字符串</strong>，将一个字符串添加到另一个字符串后面<br><strong>④</strong><code>strcmp()</code>：<strong>字符串比较</strong>，进行的是<strong>字典比较</strong></p><blockquote><p><strong>字典比较</strong>：对两个字符串的逐个字符从头进行比较，只要比较出一个字符大小即可判断结果，<code>'/0'</code>小于任何字符<br><strong>⑤长度受限的字符串函数</strong>：为了<strong>防止目标数组溢出</strong>，定义了对应函数的长度受限版本，接受一个长度参数，用于限制操作的字符个数，如<code>strncpy()</code></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 但是这些函数可能导致目标数组**不是以“/0”结尾**，可能会**导致程序崩溃**</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以在函数调用完后将字符数组的最后一个元素改为NUL</div><p><strong>6.3字符串查找</strong><br><strong>①字符查找</strong></p><blockquote><p><code>strchr()</code>：返回对应字符<strong>第一次</strong>出现的位置<br><code>strrchr()</code>：返回对应字符<strong>最后一次</strong>出现的位置<br><code>strpbrk()</code>：返回<strong>一组字符中任意一个字符</strong>第一次出现的位置</p></blockquote><p><strong>②字串查找</strong></p><blockquote><p><code>strstr()</code>：返回<strong>子串</strong>第一次出现的起始位置<br><code>strtok()</code>：删除字符串中的所有<strong>标记字符</strong>，其第二个参数是一个字符串，也就是<strong>标记字符的集合</strong><br><code>strspn()</code>：检索字符串str1（第一个参数）中<strong>第一个不在字符串str2（第二个参数）中出现的字符下标</strong><br><code>strcspn()</code>:检索字符串str1（第一个参数）中<strong>第一个出现在字符串str2（第二个参数）中出现的字符下标</strong></p></blockquote><p><strong>6.4字符操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含ctype.h头文件</div><p><strong>①字符分类</strong>：根据对应分类函数定义，判断该字符是否为该类型</p><blockquote><p><code>isspace()</code>：是否为空白字符<br><code>isdigit()</code>：是否为数字</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还有很多类似函数，可自行查询</div><p><strong>②字符转换</strong>：转换字符的大小写</p><blockquote><p><code>tolower()</code>：转换为小写形式<br><code>toupper()</code>：转化为大写形式</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 直接测试或者操纵字符可能会影响程序的移植性，比如if(ch&gt;='A' &amp;&amp; ch&lt;='Z')判断ch是否为大写字母，在使用EBCDIC字符集上的机器上将失败，但是使用isupper(ch)则无限制</div>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（三）</title>
      <link href="/2023/11/07/c-yu-yan-xue-xi-bi-ji-san/"/>
      <url>/2023/11/07/c-yu-yan-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（三）"><a href="#C语言学习笔记（三）" class="headerlink" title="C语言学习笔记（三）"></a>C语言学习笔记（三）</h1><h2 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h2><h3 id="1-预处理器"><a href="#1-预处理器" class="headerlink" title="1.预处理器"></a>1.预处理器</h3><h4 id="1-1预处理"><a href="#1-1预处理" class="headerlink" title="1.1预处理"></a>1.1预处理</h4><blockquote><p>在源代码<strong>编译前</strong>对其进行一些<strong>文本性质</strong>操作</p></blockquote><p><strong>①</strong>删除注释<br><strong>②</strong>插入<code>#include</code>指令包含的文件的内容<br><strong>③</strong>定义和替换由<code>#define</code>指令定义的符号<br><strong>④</strong>确定代码部分内容是否根据一些<strong>条件编译</strong>指令进行编译</p><h4 id="1-2预定义符号"><a href="#1-2预定义符号" class="headerlink" title="1.2预定义符号"></a>1.2预定义符号</h4><blockquote><p>预处理器定义的符号，都有各自对应的含义</p></blockquote><p><strong>①</strong><code>__FILE__</code>：进行编译的源文件名<br><strong>②</strong><code>__LINE__</code>：文件当前行的行号<br><strong>③</strong><code>__DATE__</code>：文件被编译的日期<br><strong>④</strong><code>__TIME__</code>：文件被编译的时间<br><strong>⑤</strong><code>__STDC__</code>：若编译器遵循ANSI C，返回1</p><h4 id="1-3-define"><a href="#1-3-define" class="headerlink" title="1.3#define"></a>1.3#define</h4><p><strong>①普通替换</strong>：<code>#define name stuff</code></p><blockquote><p>每当<code>name</code>出现在这条命令之后，都会被替换为<code>stuff</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若stuff非常长，可以将其分为好几行，每行除了最后一行都要加上反斜杠\</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在使用该命令时，最好不要在末尾添加分号，而是在程序正文中添加，否则可能会多出一条空语句，在一些只能使用一条语句的地方会出错，如不使用代码块的if语句</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏的name全部大写，用于区分宏</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用宏定义类型，只需要修改宏的值就可改变类型</div><p><strong>②带参数的宏</strong>：<code>#define name(parameter-list) stuff</code></p><blockquote><p><code>parameter-list</code>为参数列表，参数之间用逗号<code>,</code>相隔，类似于函数的形参，<code>stuff</code>为包含<strong>参数列表中参数</strong>的表达式<br><strong>运用实例</strong>：如果定义了一个宏<code>#define SQUARE(x) ((x) * (x))</code>，在代码块中输入<code>SQUARE(a)</code>，在预处理阶段会被替换为<code>((5) * (5))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> #name会被预处理器处理为"name"，a##b会被预处理器处理为ab</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏本质上还是简单的替换操作，所以要避免其与正文中的其他操作符发生预料之外的作用，可以像上述一样采用()对每个参数和整体进行隔离</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 宏中可以出现其他宏定义的符号，但是不能出现递归</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 其中name和(parameter-list)之间不能有空格</div><p><strong>③带副作用的宏参数</strong></p><blockquote><p>当宏参数在宏定义中出现不止一次时，若宏参数具有副作用，可能会带来无法预料的后果，副作用指<strong>永久性的效果</strong>，如<code>x+1</code>和<code>x++</code>，后者会永久改变x的值<br>以下程序运行后结果<code>x = 6,y = 10,z = 9</code>，这是因为<code>z = MAX(x++,y++)</code>被替换为<code>z = ((x++)&gt;(y++)?(x++):(y++))</code>，其中<code>y++</code><strong>执行了两次</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#define MAX(a,b) ((a)&gt;(b)?(a):(b))x=5;y=8;z = MAX(x++,y++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了避免这种情况，可以将宏需要使用的数据存储到临时变量中</div><p><strong>④宏定义的移除</strong>：<code>#undef name</code><br><strong>⑤命令行控制宏</strong>：在命令行编译时<strong>添加编译选项</strong>对宏进行定义和修改</p><blockquote><p>如<code>cc -DARRAY_SIZE=100 prog.c</code>，则就是将<code>ARRAY_SIZE</code>修改为100<br>其他的选项还有<code>-Uname</code>（忽略宏<code>name</code>）以及<code>-Dname</code>（定义宏<code>name</code>）</p></blockquote><p><strong>⑥宏的利与弊</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏比较适用于频繁使用的小型简单代码，因为函数的调用和返回也需要开支</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏是与类型无关的，有些参数无法传递给函数，比如说传递参数的类型</div><blockquote><p>如<code>#define MALLOC(n,type) ((type*)malloc((n)*sizeof(type)))</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 宏会使得代码变得更长，因为宏的本质就是插入代码副本</div><h4 id="1-4条件编译"><a href="#1-4条件编译" class="headerlink" title="1.4条件编译"></a>1.4条件编译</h4><p><strong>①定义</strong>：选择一部分代码在编译时是被<strong>正常编译</strong>还是被<strong>忽略</strong><br><strong>②格式</strong></p><pre class="line-numbers language-none"><code class="language-none">#if constant-expression  statement0#elif constant-expression  statement1#else  statement2#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>constant-expression</code>为常量表达式，常常为<strong>宏</strong>（和命令行控制宏一同使用），当其为<strong>非零值</strong>时，<code>statement</code>被<strong>正常编译</strong>，反之则被忽略<br><code>elif</code>、<code>else</code>子句出现的次数可以不限，只有当其前面<strong>所有常量表达式均为假</strong>时，且自身的常量表达式为真时，才被正常编译</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 记住要以#endif结束条件编译</div><p><strong>③定义判断</strong>：判断某个宏是否被定义</p><blockquote><p>若<code>symbol</code>被定义则为真<br><code>#if defined(symbol)</code><br><code>#ifdef symbol</code><br>若<code>symbol</code>没有被定义则为真<br><code>#if !defined(symbol)</code><br><code>#ifndef symbol</code></p></blockquote><h4 id="1-5文件包含"><a href="#1-5文件包含" class="headerlink" title="1.5文件包含"></a>1.5文件包含</h4><p><strong>①格式</strong>：<code>#include &lt;filename&gt;</code>/<code>#include "filename"</code></p><blockquote><p>前者表示在<strong>编译器定义的标准位置</strong>寻找相关文件，后者表示在<strong>源文件所在目录</strong>寻找相关文件（如果没找到还是再去标准位置）</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> include的实质就是将对应文件内容复制到对应位置</div><p><strong>②嵌套包含</strong>：有些头文件中还会包含其他的头文件，可能会导致<strong>某些头文件被包含多次</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用条件编译避免这种情况</div><blockquote><p>如下，<code>_TOUWENJIAN_H</code>为这个头文件的代号，当头文件被第一次包含时，其被定义为1，第二次被包含时，通过条件编译，他的所有内容<strong>被忽略</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#ifndef _TOUWENJIAN_H#define _TOUWENJIAN_H 1    All the stuff that you want in the header file#endif <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 应该避免多重包含，因为上述做法只能忽略重复读入内容，该文件还是会被多次读取</div><h4 id="1-6命令行参数"><a href="#1-6命令行参数" class="headerlink" title="1.6命令行参数"></a>1.6命令行参数</h4><blockquote><p>C语言<code>main</code>函数有两个形参用于接收命令行参数，<code>int main (int argc,char **argv)</code></p></blockquote><p><strong>①</strong><code>argc</code>：命令行参数的<strong>数目</strong><br><strong>②</strong><code>argv</code>：本质上是一个<strong>指向字符指针的指针</strong>，将命令行参数看作为一个<strong>字符指针数组(以空指针结尾)<strong>，该参数指向该数组的</strong>第一个参数</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 命令行第一个参数固定是程序的名称，不需要用户输入</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意命令行参数是字符数组，在C中，没有字符串</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_5.png" alt="命令行参数"></p><h4 id="1-7其他预处理指令"><a href="#1-7其他预处理指令" class="headerlink" title="1.7其他预处理指令"></a>1.7其他预处理指令</h4><p><strong>①</strong><code>#error</code>：允许生成<strong>错误信息</strong></p><blockquote><p><code>#error message</code>，其中<code>message</code>为错误提示信息</p></blockquote><p><strong>②</strong><code>#line</code>：定义下一行的<strong>行号</strong>，且可以修改<strong>文件名</strong></p><blockquote><p><code>#line number "strings"</code>，其中<code>number</code>为下一行行号，<code>"strings"</code>为文件名</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> "strings"为可选选项</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该命令会修改__LINE__和__FILE__</div><p><strong>③</strong><code>#progma</code>：用于支持<strong>因编译器而异</strong>的特性，如向一个函数插入<strong>内联的汇编代码</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 预处理器会忽略它不认识的#progma指令</div><hr><h3 id="2-I-x2F-O函数"><a href="#2-I-x2F-O函数" class="headerlink" title="2.I/O函数"></a>2.I/O函数</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 包含stdio.h头文件</div><h4 id="2-1基本概念"><a href="#2-1基本概念" class="headerlink" title="2.1基本概念"></a>2.1基本概念</h4><p><strong>①流</strong>：C语言的I/O操作就是从程序移进或移出字节，这个<strong>字节流</strong>称为流</p><blockquote><p><strong>标准流</strong>：标准输入<code>stdin</code>，标准输出<code>stdout</code>和标准错误<code>stderr</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常标准输入设备为键盘，标准输出/错误设备为终端或者屏幕</div><blockquote><p><strong>流的分类</strong><br><strong>文本流</strong>：零个或者多个字符，以<strong>换行符</strong>结束（UNIX系统）<br><strong>二进制流</strong>：完全根据<strong>程序编写它们的形式</strong>输入/出</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 流本质上是一个指向FILE数据结构的指针，每个流都有一个相应的FILE文件与它关联</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 文本流的结束形式在不同的系统上可能不同，但是库函数会将标准形式（换行符）转化为对应的形式</div><p><strong>②缓冲区</strong>：字节流并不是直接从输入端到输出端，而是要经过一块称为缓冲区的<strong>内存区域</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省情况下，I/O函数库为流动态分配一个缓冲区</div><blockquote><p><strong>输出缓冲区</strong>：在<strong>被写满</strong>的时候才会被<strong>写入（刷新）</strong>到设备或者文件中<br><strong>输入缓冲区</strong>：同理，输入缓冲区<strong>为空时</strong>才会从设备或文件中<strong>读取</strong>数据</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 上述的缓冲为完全缓冲，但是通常情况下，流的缓冲状态由编译器决定，通常是请求输入的同时刷新输出缓冲区</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用int fflush(FILE *stream)使输出缓冲区立即刷新</div><p><strong>③标准I/O常量</strong></p><blockquote><p><code>EOF</code>：提示到达了文件末尾，所选择的实际值比一个字符要多几位<br><code>FOPEN_MAX</code>：一个程序最多能打开文件的数量，至少是8（包括三个标准流）<br><code>FILENAME_MAX</code>：合法文件名的最大长度</p></blockquote><p><strong>④临时文件</strong>：使用一个文件<strong>临时保存数据</strong>，当程序结束时，该文件就被<strong>删除</strong></p><blockquote><p><code>FILE *tmpfile(void)</code>：创建了一个<strong>临时文件</strong>，以<code>"wb+"</code>模式打开，当<strong>文件被关闭或程序终止</strong>时，文件便被删除</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若该文件需要需以其他模式打开，或者需要由一个程序打开，由另一个程序读取，都不适用临时文件</div><blockquote><p><code>char *tmpnam(char *name)</code>：给临时文件命名，参数需是一个指向长度<strong>至少为<code>L_tmpnam</code><strong>的字符数组的指针。若参数为NULL，函数返回一个</strong>静态数组</strong>的指针，该数组包含了文件名。</p></blockquote><p><strong>⑤错误报告</strong></p><blockquote><p><code>void perror(char const *message)</code>：若<code>message</code>不为<code>NULL</code>，则该函数<strong>打印出这个字符串</strong>，后面跟一个分号和一个空格，并打印出一条用于解释当前<code>errno</code>当前<strong>错误代码的信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> errno定义在errno.h头文件中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有当库函数失败时才会刷新errno，故需要在一些可能出错的地方判断错误是否发生，再调用该函数提示错误信息</div><h4 id="2-2流的操控"><a href="#2-2流的操控" class="headerlink" title="2.2流的操控"></a>2.2流的操控</h4><p><strong>①创建流</strong>：调用<code>fopen</code>创建一个流，指定访问的文件/设备以及他们的<strong>访问方式</strong>，并<strong>初始化</strong><code>FILE</code>结构</p><blockquote><p><strong>函数原型</strong>：<code>FILE *fopen(char const *name,char const *mode);</code><br>其中<code>name</code>是希望打开的<strong>设备和文件的名字</strong>，<code>mode</code>提示流的<strong>操作模式</strong>以及<strong>分类</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 时刻检查fopen的返回值</div><blockquote><p><strong><code>mode</code>参数</strong><br><strong>文本流</strong>：<code>"r"</code>只读 、<code>"w"</code>只写、<code>"a"</code>添加<br><strong>二进制流</strong>：<code>"rb"</code>只读、<code>"wb"</code>只写、<code>"ab"</code>添加</p></blockquote><p><strong>②操作模式</strong></p><blockquote><p><strong>读</strong>：访问文件<strong>必须已经存在</strong><br><strong>写</strong>：访问文件存在，<strong>原来的内容就会被删除</strong>，若不存在，则会<strong>新创建一个</strong><br><strong>添加</strong>：类似于写，但是不会覆盖内容，而是在<strong>尾部</strong>写入新内容</p></blockquote><p><strong>③重新打开一个流</strong></p><blockquote><p><code>FILE *freopen(char const *filename,char const *mode,FILE *stream)</code><br>该函数试图关闭<code>stream</code>对应的流，并<strong>重新打开</strong>它</p></blockquote><p><strong>④流的位置控制</strong></p><blockquote><p><code>long ftell(FILE *stream)</code>：返回<strong>下一个读写将要开始位置</strong>距离<strong>文件起始位置</strong>的偏移量</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于二进制流，这个偏移量为字节数，对于文本流，这个值取决于系统（由于行末字符映射）</div><blockquote><p><code>int fseek(FILE *stream,long offset,int from)</code>：改变下一次读写的起始位置，由<code>from</code>和<code>offset</code>决定</p></blockquote><blockquote><p><code>from</code>参数有三种值<br><code>SEEK_SET</code>：从流的<strong>起始位置</strong>起<code>offset</code>个字节，<code>offset</code>必须是一个<strong>非负值</strong><br><code>SEEK_CUR</code>：从流的<strong>当前位置</strong>起<code>offset</code>个字节，<code>offset</code><strong>可正可负</strong><br><code>SEEK_END</code>：从流的<strong>尾部位置</strong>起<code>offset</code>个字节，<code>offset</code><strong>可正可负</strong>，当其为正数时，写入将扩展这个文件，读取将获得一条“到达文件尾的信息”</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 文本流为了其可移植性，当from为SEEK_END或者SEEK_CUR时，offset需为0，from为SEEK_SET，offset需为同一个流中之前调用ftell获得的返回值</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 二进制流中，SEEK_END定位可能不被支持</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 调用fseek之后，行末指示字符将会被清除</div><p><strong>⑤改变缓冲方式</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只有当指定流被打开但是还没有对其进行操作时，才能调用这些函数</div><blockquote><p><code>void setbuf(FILE *stream,char *buf)</code>：为流设置了<strong>一个数组</strong>作为其缓冲区，该数组长度必须为<code>BUFSIZ</code>（定义在stdio.h中）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若数组指针为空，则关闭流的所有缓冲方式，按照程序规定的方式读取写入（操作系统有自己的缓冲方式）</div><blockquote><p><code>int setvbuf(FILE *stream,char *buf,int mode,size_t size)</code>：其中，<code>mode</code>用于指定<strong>缓冲的类型</strong>，<code>buf</code>用于指向缓冲区，<code>size</code>用于指定缓冲区大小</p></blockquote><blockquote><p><code>mode</code>的参数类型<br><code>_IOFBF</code>：完全缓冲<br><code>_IONBF</code>：不缓冲<br><code>_IOLBF</code>：行缓冲，即每当换行符被写入缓冲区时，缓冲区便刷新</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 缓冲区的大小最好是BUFSIZ的整数倍（与磁盘簇大小相匹配），否则可能会需要一些额外的磁盘操作</div><p><strong>⑥状态判断</strong></p><blockquote><p><code>int feof(FILE *stream)</code>：若流处于<strong>文件尾</strong>，则返回真<br><code>int ferror(FILE *stream)</code>：若流出现<strong>读写错误</strong>，函数返回真<br><code>int clearerr(FILE *stream)</code>：<strong>重置</strong>流的错误状态</p></blockquote><p><strong>⑦关闭流</strong>：调用<code>fclose</code>关闭对应流（防止与其关联的设备文件被访问），并释放<code>FILE</code>文件</p><blockquote><p><code>int fclose(FILE *f);</code><br>如果执行成功，则返回零值，否则返回<code>EOF</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果关闭的是输出流，那么这个函数还会刷新缓冲区</div><h4 id="2-3I-x2F-O函数"><a href="#2-3I-x2F-O函数" class="headerlink" title="2.3I/O函数"></a>2.3I/O函数</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 依据处理数据的类型将其分为单个字符、文本行和二进制数据三种</div><p><strong>①字符I/O</strong></p><blockquote><p><strong>字符输入（读取）</strong><br><code>int getchar(void)</code><br><code>int getc(FILE *stream)</code><br><code>int fgetc(FILE *stream)</code><br>每次从流中读取<strong>下一个字符</strong>，如果不存在更多的字符，则返回<code>EOF</code>（整型）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中getchar从标准输入读取字符</div><blockquote><p><strong>字符输出（写入）</strong><br><code>int putchar(int character)</code><br><code>int putc(int character,FILE *stream)</code><br><code>int fputc(int character,FILE *stream)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同上，putchar写入到标准输出中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在打印前，这些函数会整型参数裁剪为一个无符号字符型</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中fgetc和fputc是函数，其余是宏</div><blockquote><p><strong>字符回退</strong><br><code>int ungetc(int character,FILE *stream)</code><br>将一个字符返回到流中，这样它可以<strong>被重新读入</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 注意退回到流和写入到流是不同的，前者类似于压栈，后者类似于队列的增长</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果流的位置之后被改变，则退回的字符会被丢弃</div><p><strong>②未格式化行I/O（字符串）</strong></p><blockquote><p><strong>字符串读取</strong><br><code>char *fgets(char *buffer,int buff_size,FILE *stream)</code><br><code>char *gets(char *buffer)</code></p></blockquote><blockquote><p>从<code>stream</code>流中读取字符并将他们<strong>复制到</strong><code>buffer</code>中，当读取到<strong>一个换行符</strong>或者字符数达到<code>buffer_size-1</code>个时就<strong>停止读取</strong>，并在<strong>缓冲区结尾</strong>添加一个<code>nul</code>字节，使其成为一个字符串</p></blockquote><blockquote><p>若没有读取到字符（<strong>到了文章尾</strong>），就返回<code>NULL</code>，否则返回<code>buffer</code>对应的指针</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> gets与fgets类似，是从标准输入中读取，但是gets不会存储换行符</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> gets函数没有缓冲区长度，所以很可能导致缓冲区溢出，只适用于玩具程序</div><blockquote><p><strong>字符串写入</strong><br><code>int fputs(char const *buffer,FILE *stream)</code><br><code>int puts(char const *buffer)</code></p></blockquote><blockquote><p>传递给<code>fputs</code>的缓冲区<strong>必须包含一个字符串</strong>，并将该字符串<strong>逐字符</strong>写入流中，如果写入时发生了错误，则返回<code>EOF</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> puts与fputs类似，写入到标注输入中，且puts在写入一个字符串后，会再输出一个换行符</div><p><strong>③二进制I/O</strong></p><blockquote><p><code>size_t fread(void *buffer,size_t size,size_t count,FILE *stream)</code><br><code>size_t fwrite(void *buffer,size_t size,size_t count,FILE *stream)</code></p></blockquote><blockquote><p>其中<code>buffer</code>指向用于<strong>保存数据的内存位置</strong>，<code>size</code>为缓冲区<strong>每个元素的字节数</strong>（使用sizeof计算即可），<code>count</code>为<strong>读取或者写入的元素数</strong>，<code>stream</code>为指定的流</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二进制I/O的效率非常高，省区了转换的开销</div><h4 id="2-4格式化读取"><a href="#2-4格式化读取" class="headerlink" title="2.4格式化读取"></a>2.4格式化读取</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 内容较多且重要，故单列出来</div><p><strong>①scanf家族</strong></p><blockquote><p><code>int fscanf(FILE *stream,char const *format,...)</code><br><code>int scanf(char const *format,...)</code><br><code>int sscanf(char const *string,char const *format,...)</code></p></blockquote><blockquote><p>当格式化字符串到达<strong>末尾</strong>或者读取的输入<strong>不再与格式匹配</strong>时，输入停止，返回<strong>转化的输入值的数目</strong>，若没有读取输入值，则返回<code>EOF</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这些函数都从一定的输入源读入数据，其中fscanf为stream指定的流，scanf为标准输入，sscanf为string指向的字符串</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中format为一个字符串，表示转换的格式代码</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中...表示一个可变长度的指针列表，从输入源读取的数据转化后就存储在这些指针指向的位置</div><p><strong>②format字符串</strong>：<code>format</code>字符串可能包含三种内容，即<strong>空白字符</strong>、<strong>格式代码</strong>和<strong>其他字符</strong></p><blockquote><p><strong>空白字符</strong>：<strong>丢弃</strong>输入中的<strong>所有</strong>空白字符</p></blockquote><blockquote><p><strong>格式代码</strong>：指定函数将<strong>如何解释</strong>接下来的<strong>输入字符</strong></p></blockquote><blockquote><p><strong>其他字符</strong>：当出现其他字符时，<strong>下一个输入字符</strong>必须与他匹配，若匹配，输入字符将被<strong>丢弃</strong>，若不匹配，则直接结束</p></blockquote><p><strong>③scanf格式代码</strong>：以<code>%</code>开头，后面接一个<strong>可选的星号（<code>*</code>）</strong>、<strong>可选的宽度</strong>、<strong>可选的限定符</strong>和<strong>格式代码</strong></p><blockquote><p><strong>星号（<code>*</code>）</strong>：使转换后的值被<strong>丢弃</strong>而不是被存储</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以用于跳过不需要的字符</div><blockquote><p><strong>宽度</strong>：用于<strong>限制</strong>读取的输入字符的<strong>个数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若没有限定宽度，则遇到空白字符停止</div><blockquote><p><strong>限定符</strong>：修改一些<strong>格式代码的含义</strong>，主要是指定<strong>参数的长度</strong>，有<code>h</code>、<code>l</code>、<code>L</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> h修饰整型和无符号数，表示short和unsigned short，l修饰整型、无符号数和浮点型表示long、unsigned long和double，L修饰浮点型表示long double</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在转换short、long和long double时，采用适当的限定符，提高程序可移植性</div><blockquote><p><strong>格式代码</strong>：一个<strong>单字符</strong>，表明如何解释输入字符</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> c表示char，d表示十进制int，u表示十进制无符号数，f表示浮点数等等</div><h4 id="2-5格式化写入"><a href="#2-5格式化写入" class="headerlink" title="2.5格式化写入"></a>2.5格式化写入</h4><p><strong>①printf家族</strong></p><blockquote><p><code>int fprintf(FILE *stream,char const *format,...)</code><br><code>int printf(char const *format,...)</code><br><code>int sprintf(char const *buffer,char const *format,...)</code></p></blockquote><blockquote><p>根据<code>format</code>字符串将参数列表的值<strong>格式化</strong>，并输出到一定的<strong>输出源</strong>中，返回值为实际输出的字符数</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中fprintf为stream指定的流，printf为标准输入，sprintf为buffer指向的缓冲区</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用sprintf要注意缓冲区的溢出问题</div><p><strong>②format格式代码</strong>：由<code>%</code>开头，后跟零个或多个<strong>标志字符</strong>、可选的<strong>最小字段宽度</strong>、可选的<strong>精度</strong>、可选的<strong>修改符</strong>以及<strong>转换类型</strong></p><blockquote><p><strong>标志字符</strong>：决定其表现形式，如<strong>对齐</strong>、<strong>填充格式</strong>等</p></blockquote><blockquote><p><strong>字段宽度</strong>：指定出现在结果中的<strong>最小字符数</strong>，如果值的字符数小于该值，则对其进行<strong>填充</strong></p></blockquote><blockquote><p><strong>精度</strong>：以<strong>一个句号开头</strong>，后跟一个可选的<strong>十进制整数</strong>，不同<strong>转换类型</strong>的格式也不尽相同，对于<code>f</code>是规定<strong>小数点后的位数</strong>，对于<code>s</code>则是指定被转换的<strong>最多字符</strong></p></blockquote><blockquote><p><strong>修改符</strong>：类似于<code>scanf</code>格式代码中的限定符，指定<strong>长短类型</strong></p></blockquote><blockquote><p><strong>转换类型</strong>：转化为那种<strong>数据类型</strong>、<strong>格式</strong>和<strong>进制</strong>等，常用的有整数<code>d</code>、字符串<code>s</code>和浮点数<code>f</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中字段宽度和精度可以用星号替代，由print的下一个参数指定</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当字符或短整数作为printf的参数时，会被先转化为整数，需要使用修改符，修改符在转换发生之前将其转换为对应类型，同样在长整型和int长度不同的环境中也需要对应的修改符指明其长度</div><hr><h3 id="3-标准函数库"><a href="#3-标准函数库" class="headerlink" title="3.标准函数库"></a>3.标准函数库</h3><p><strong>3.1整型函数</strong><br><strong>①算数</strong></p><blockquote><p><code>int abs(int value)</code>：返回<strong>绝对值</strong><br><code>div_t div(int x,int y)</code>：将第二个参数除以第一个参数，产生<strong>商</strong>和<strong>余数</strong>，其中商是<strong>最靠近精确解</strong>的整数，其中<code>div_t</code>是一个结构，其中<code>quot</code>是商。<code>rem</code>是余数</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 都有对应的处理长整型的版本</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> /操作符的除法运算结果并未精确定义，当其操作数任一为负数且不能整除时，商和精确解的舍入关系取决于编译器</div><p><strong>②随机数</strong></p><blockquote><p><code>int rand (void)</code>：返回一个0至RAND_MAX区间内的<strong>伪随机数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了得到特定范围的伪随机数，可以对其进行取模并添加偏移量</div><blockquote><p><code>void srand(unsigned int seed)</code>：利用<code>seed</code>对<code>rand</code>进行初始化</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> seed常常采用每天的时间，即srand((unsigned int)time(0))</div><p><strong>③字符串转化</strong></p><p><strong>3.2浮点型函数</strong><br><strong>①算数</strong></p><blockquote><p><code>double sqrt(double x)</code>：取平方根<br><code>double exp(double x)</code>：返回以e的x次幂<br><code>double floor(double x)</code>：返回不大于参数的最大整数<br><code>double ceil(double x)</code>：返回不小于参数的最小整数<br><code>double fabs(double x)</code>：返回参数的绝对值<br><code>double fmod(double x,double y)</code>：返回x除以y的余数</p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 参数需要在定义域内，结果需要在double所能表示的范围内</div><p><strong>②三角函数</strong>：<code>sin</code>、<code>cos</code>、<code>tan</code>、<code>asin</code>、<code>acos</code>、<code>atan</code></p><blockquote><p><code>double sin(double angle)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> sin、cos、tan的参数是弧度，asin、acos、atan的参数范围从-1至1</div><p><strong>③对数和指数函数</strong></p><blockquote><p><code>double exp(double x)</code>：e的x次幂<br><code>double pow(double x,double y)</code>：x的y次幂，其中x不能是负数，y必须是整数<br><code>double log(double x)</code>：以e为底的对数<br><code>double log10(double x)</code>：以10为底的对数</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以采用换底公式计算任意底数的对数</div><p><strong>④浮点数表示</strong></p><blockquote><p><code>double frexp(double value,int *exponent)</code>：该函数返回<code>fraction</code>，并将<code>exponent</code>存储到第二个参数指定位置，其中<code>fraction*2^exponent = value</code><br><code>double ldexp(double fraction,int exponent)</code>：配合以上函数，还原该浮点数</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 用于浮点格式不兼容的机器之间传递浮点数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 要记得包含math.h头文件，绝大部分参数和返回值都是double类型</div><p><strong>3.3时间与日期函数</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含time.h头文件</div><p><strong>①处理器时间</strong></p><blockquote><p><code>clock_t clock(void)</code>：返回从<strong>程序开始</strong>起处理器消耗的时间<br><code>clock_t</code>由编译器定义，通常是处理器时钟滴答的次数，可以将其除以<code>CLOCKS_PER_SEC</code>转化为秒</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果想要精确的执行时间，可以在程序（某段语句）开始处与结尾处，各放置一个clock()，将结果相减</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若操作系统不能追踪处理器时间，则返回已经流逝的实际时间数量</div><p><strong>②当天时间</strong></p><blockquote><p><code>time_t time(time_t *returned_value)</code>：返回当前的时期和时间，并存储到参数指向位置，当机器无法提供时间或者时间值太大，就返回-1</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的编译器有不同的格式，常见的形式是从某一特定时间开始流逝的秒数，在UNIX中，这个时间为1970年1月1日零点</div><p><strong>③日期和时间的转换</strong></p><blockquote><p><code>double difftime(time_t time1,time_t time2)</code>：计算<code>time1-time2</code>，并将其转化为秒</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不要直接调用两次time函数并相减</div><p><code>struct tm *gmtime(time_t const *time_value)</code>：将时间转换为<strong>世界协调时间</strong><br><code>struct tm *localtime(time_t const *time_value)</code>：将时间转换为<strong>当地时间</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> tm结构包含了很多与时间有关的成员</div><blockquote><p><code>char *ctime(time_t const *time_value)</code>：接收一个<code>time_t</code>的指针，返回一个对应时间的字符串<br><code>char *asctime(struct tm const *tm_ptr)</code>：将<code>tm</code>结构转化为与<code>ctime</code>结果一样的字符串</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 字符串格式是固定的，编译器通常将其保存在一个静态数组中，如果想要特定格式的字符串，可以调用strftime()</div><p><strong>3.4非本地跳转</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含setjmp.h头文件</div><p><strong>①含义</strong>：类似于<code>goto</code>语句，但是<strong>不局限于一个函数的作用域</strong>之内<br><strong>②相关函数</strong></p><blockquote><p><code>int setjmp(jmp_buf state)</code>：初始化一个<code>jmp_buf</code>变量，并将程序的状态信息保存到<strong>跳转缓冲区</strong>，调用<code>setjmp</code>的函数便称为<strong>顶层函数</strong><br><code>void longjmp(jump_buf state,int value)</code>：使得跳转缓冲区的状态被恢复，从而立即跳转到<strong>顶层函数</strong></p></blockquote><p><strong>3.5信号</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含signal.h头文件</div><p><strong>①含义</strong>：信号表示一种<strong>非程序本身</strong>引发的事件<br><strong>②标准定义的信号</strong></p><blockquote><p><code>SIGABRT</code>：程序请求异常终止，由<code>abort</code>函数引发，常见的错误是<strong>算数溢出</strong>以及<strong>除零错误</strong><br><code>SIGFPE</code>：发生一个算数错误<br><code>SIGILL</code>：检测到非法指令，比如<strong>指令版本不同</strong><br><code>SIGSEGV</code>：检测到对内存的非法访问，比如访问<strong>未分配给该程序的内存</strong>，或者出现<strong>边界对齐错误</strong><br><code>SIGINT</code>：受到一个交互性注意信号<br><code>SIGTERM</code>：受到一个终止程序的请求</p></blockquote><p><strong>③信号处理</strong></p><blockquote><p><code>int raise(int sig)</code>：显示地引发一个信号<br><code>void (*signal(int sig,void(*handler)(int))) (int)</code>：指定程序对信号的反应，简化后的原型为<code>void(*signal()) (int)</code>，则<code>signal</code>是一个返回类型为函数指针（对应信号以前的处理函数）的函数，其所接受参数<code>sig</code>为标准定义的信号，<code>handler</code>为希望信号发生时调用的函数，当函数调用失败时，返回<code>SIG_ERR</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还可以将signal函数第二个参数替换为SIG_DFL，恢复对该信号的缺省反应；或者替换为SIG_IGN，使该信号被忽略</div><p><strong>3.6执行环境</strong><br><strong>①终止程序</strong></p><blockquote><p><code>void abort(void)</code>：引发<code>SIGABRT</code>信号，若没有在程序中为其设置信号处理函数，则程序终止<br><code>void atexit(void(func)(void))</code>：把一些函数注册为<strong>退出函数</strong>，当程序<strong>正常终止（调用<code>exit()</code>函数）</strong>，退出函数将被调用</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意该退出函数的格式</div><blockquote><p><code>void exit(int status)</code>：当该函数被调用时，所有被<code>atexit()</code>注册的函数将按照他们注册的顺序被<strong>反序</strong>调用，随后刷新所有缓冲区，关闭所有文件，并删除所有临时文件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> main函数return语句相当将返回值传递给exit()并调用它</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 由atexit()注册的函数中不能包含exit()，其结果是未定义的</div><p><strong>②断言</strong></p><blockquote><p><code>void assert(int expression)</code>：当<code>expression</code>为假时，向<strong>标准错误</strong>打印一条诊断信息并<strong>终止程序</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上是一个宏，其诊断信息的格式由编译器定义</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过定义NDEBUG宏消除所有断言，可以将其定义为任意值</div><p><strong>③环境与系统</strong></p><blockquote><p><code>char *getenv(char const *name)</code>：在<strong>环境</strong>中查找一个特定的名字，如果找到则返回一个<strong>不能修改</strong>的字符指针，否则返回<code>NULL</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 环境：一个由编译器定义的名字/值对的列表</div><blockquote><p><code>void system(char const *command)</code>：将字符串传递给<strong>操作系统</strong>，将其作为一条命令，由<strong>系统的命令处理器</strong>运行</p></blockquote><p><strong>④排序与查找</strong></p><blockquote><p><code>qsort()</code>：以<strong>升序</strong>的方式对数组进行排序，与<strong>类型无关</strong>，其函数原型如下<br><code>void qsort(void *base,size_t n_elements,size_t el_size,int(*compare)(void const *,void const *))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中第一个参数指向需要排序的数组，第二个参数指定数组中元素的数目，第三个参数指定每个元素的长度，第四个参数时一个用于比较的函数指针</div><blockquote><p><code>bsearch()</code>：在一个已经<strong>排好序</strong>的数组中用<strong>二分法</strong>查找一个特定的元素，其函数原型如下<br><code>void *bsearch(void const *key,void const *base,size_t n_elements,size_t el_size,int(*compare)(void const *,void const *))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中第一个参数时需要查找的值，第二个参数指向查找的数组，第三个参数指定数组的数目，第四个参数是每个元素的长度，最后一个参数是用于比较的函数指针</div><p><strong>3.7本地化</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 详细见《C与指针》p347-349</div><p><strong>①</strong><code>locale</code>：一组<strong>特定的参数</strong>，每个国家和地区都不同<br><strong>②设置</strong><code>locale</code></p><blockquote><p><code>char *setlocale(int category,char const *locale)</code><br>其中，<code>category</code>用于指定<code>locale</code>的哪个部分需要被修改，<code>locale</code>指定新的<code>locale</code>，若该参数为<code>NULL</code>，则返回当前的<code>locale</code></p></blockquote><blockquote><p><code>setlocale</code><strong>参数列表</strong><br><code>LC_ALL</code>：整个<code>locale</code><br><code>LC_COLLATE</code>：<strong>字符集对照序列</strong>，将影响<code>strcoll</code>和<code>strxfrm</code>函数的行为<br><code>LC_CTYPE</code>：定义于<code>ctype.h</code>中的函数所使用的<strong>字符类型分类</strong>信息<br><code>LC_MONETARY</code>：<strong>格式化货币值</strong>使用的相关字符<br><code>LC_NUMERIC</code>：<strong>格式化非货币值</strong>使用的相关字符<br><code>LC_TIME</code>：<code>strftime</code>函数的行为</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核设计与实现（一）</title>
      <link href="/2023/11/07/linux-nei-he-she-ji-yu-shi-xian-yi/"/>
      <url>/2023/11/07/linux-nei-he-she-ji-yu-shi-xian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核设计与实现（一）"><a href="#Linux内核设计与实现（一）" class="headerlink" title="Linux内核设计与实现（一）"></a>Linux内核设计与实现（一）</h1><h2 id="Linux内核基础"><a href="#Linux内核基础" class="headerlink" title="Linux内核基础"></a>Linux内核基础</h2><h3 id="1-Unix和Linux"><a href="#1-Unix和Linux" class="headerlink" title="1.Unix和Linux"></a>1.Unix和Linux</h3><p><strong>1.1Unix系统特点</strong><br>①简洁：只有几百个系统调用且设计目的简单明确<br>②一切皆文件：对数据和设备的操作可以通过同一套接口完成<br>③C语言编写：移植能力强<br>④进程创建十分迅速，提供了一套十分简单稳定的进程间通信元语<br>#Linux是类Unix系统，没有直接使用Unix源码，但是<strong>设计理念一致</strong>且保证了<strong>应用程序编程接口的一致</strong><br><strong>1.2Linux和Unix的差异</strong><br>①Linux支持动态加载和卸载内核模块<br>②Linux支持对称多处理（SMP）机制<br>③linux内核可以抢占<br>④Linux不区分进程和线程<br>⑤Linux提供具有设备类的面向对象的设备模型、热插拔事件</p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p><strong>2.1内核空间</strong>：内核等相关程序运行的空间，拥有<strong>受保护的内存空间</strong>和访问硬件的<strong>所有权利</strong><br><strong>2.2用户空间</strong>：应用程序执行的空间，应用程序在用户空间只能看到系统允许他们使用的部分系统资源，只能使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划分给<strong>其他应用程序的内存空间</strong><br>#当内核运行时，系统以内核态进入内核空间，当用户程序运行时，系统以用户态进入用户空间<br><strong>2.3系统调用</strong>：应用程序通过系统调用陷入内核，应用程序调用库函数，库函数通过系统调用接口调用<strong>内核子系统/设备驱动程序</strong><br><strong>2.4单内核</strong>：内核以<strong>单个静态二进制文件</strong>的形式存放在磁盘中，运行在一个<strong>单独的地址空间</strong>上，内核之间的通信耗时可忽略不计<br><strong>2.5微内核</strong>：内核功能被划分为<strong>多个独立的过程</strong>，每个过程叫做一个<strong>服务器</strong>，每个服务器独立运行在<strong>各自的地址空间</strong>上，除了强烈要求特权服务的服务器运行在特权模式下，其他服务器运行在<strong>用户空间</strong>，每个服务器采用<strong>进程间通信机制</strong>沟通，可靠性更强，一个服务器出现问题不会祸及其他服务器，且服务器<strong>可以加载也可以卸载</strong><br>#Linux是<strong>单内核</strong>，但是汲取了微内核的精髓——模块化设计、抢占式内核、支持内核线程及动态装载内核模块</p><h3 id="3-Linux版本"><a href="#3-Linux版本" class="headerlink" title="3.Linux版本"></a>3.Linux版本</h3><p><strong>[主版本号].[从版本号].[修订版本号].[稳定版本号]</strong><br>#稳定版本号是偶数则是稳定版，反之为开发版</p><h3 id="4-简述编译内核"><a href="#4-简述编译内核" class="headerlink" title="4.简述编译内核"></a>4.简述编译内核</h3><p><strong>4.1获得内核源码</strong>：在<a href="http://www.kernel.org/">Linux内核官网</a>下载<br>①使用git clone和git pull获得内核源码<br>②自行下载安装，有bzip2和gzip两种形式，其中bzip2是默认和首选下载格式，采用tar命令解压，解压后的源码在linux-x.y.z.目录下（x.y.z.为Linux版本号）<br>③安装内核补丁进行版本的更迭<br><strong>4.2安装内核源码</strong>：系统本身的内核源码<strong>位于/usr/src/linux目录</strong>下，但是<strong>不能将该源码树用于开发</strong>，因为<strong>编译C库</strong>所用的内核版本链接到该棵树。应该建立<strong>自己的主目录</strong>，仅仅以<strong>root身份</strong>安装新内核到该目录，系统本身目录不进行任何更改<br><strong>4.3配置内核</strong>：将自己需要的<strong>特定功能和驱动程序</strong>编进内核（根目录下.config文件），常见内核配置工具如下<br>①make config<br>#遍历所有配置项，要求用户选择选项，耗时长，不推荐<br>②make menuconfig或者make gconfig<br>#图形界面，推荐<br>③make defconfig<br>#基于默认配置为你的体系结构创建一个配置<br>④make oldconfig<br>#根据.config文件生成/更新配置<br>#配置选项CONFIG_IKCONFIG_PROC将<strong>完整压缩</strong>的配置文件存放在/proc/config.gz下，可以采用zcat /proc/config.gz &gt; .config及make oldconfig克隆当前配置<br><strong>4.4编译内核</strong><br>①编译内核：make<br>②减少编译垃圾信息：make &gt; ../detritus或者make &gt; dev/null<br>#前者将编译信息重定向到该文件中，后者的/dev/null是个永无返回值的黑洞，但是警告和错误信息还是会打印出来<br>③将编译过程拆分为多个并行的作业：make -jn<br>#其中n为作业数，一般<strong>每个处理器上衍生出一两个作业</strong><br><strong>4.5安装新内核</strong>：根据启动引导工具的说明操作即可</p><h3 id="5-内核开发的特点"><a href="#5-内核开发的特点" class="headerlink" title="5.内核开发的特点"></a>5.内核开发的特点</h3><p><strong>5.1不能访问C库及标准C头文件</strong>:对于内核来说，C库<strong>太大且低效</strong>了<br>#不过大部分常用的C库函数在内核中已经得到了实现，比如string库对应&lt;linux/string.h&gt;<br>#基本的头文件位于内核源码树<strong>顶级目录的include目录</strong>下<br>#体系结构相关头文件位于arch/[architecture]/include/asm目录下,以asm为前缀，如&lt;asm/ioctl.h&gt;<br><strong>5.2必须使用GUN C</strong><br><strong>5.3没有内存保护机制</strong>：当内核自身发生了内存错误会导致oops<br>#内核中的内存<strong>不分页</strong><br><strong>5.4不要轻易使用浮点数</strong>：在内核中使用浮点数，不仅仅要人工保存和回复浮点寄存器，还需要一些繁琐的操作<br><strong>5.5容积小且固定的栈</strong>：内核栈大小随体系结构改变<br><strong>5.6同步和并发</strong>：内核的许多特性要求可以并发的访问共享数据，这就可能产生竞争<br><strong>5.7可移植性的重要性</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git及其应用</title>
      <link href="/2023/11/07/git-ji-qi-ying-yong/"/>
      <url>/2023/11/07/git-ji-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git应用"><a href="#Git应用" class="headerlink" title="Git应用"></a>Git应用</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1Git概述"><a href="#1-1Git概述" class="headerlink" title="1.1Git概述"></a>1.1Git概述</h4><blockquote><p>一个<strong>分布式版本控制系统</strong>，<strong>版本控制</strong>即记录文件<strong>修改历史</strong>，便于<strong>版本切换</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 很少通过拷贝历史版本进行版本控制，因为太占用存储空间</div><h4 id="1-2分布式与集中式"><a href="#1-2分布式与集中式" class="headerlink" title="1.2分布式与集中式"></a>1.2分布式与集中式</h4><blockquote><p><strong>集中式</strong>：有一个<strong>单一的集中管理的服务器</strong>，从中下载代码，修改后提交</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 便于管理，但是当中央服务器故障，则无法提交更新</div><blockquote><p><strong>分布式</strong>：分别有<strong>本地库（个人电脑）</strong>和<strong>远程库（大型代码托管中心）</strong>，从远程库上<strong>克隆</strong>代码进行修改</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在本地库和远程库上都可以进行版本控制</div><h4 id="1-3工作机制"><a href="#1-3工作机制" class="headerlink" title="1.3工作机制"></a>1.3工作机制</h4><blockquote><p><strong>代码托管中心</strong><br><strong>局域网</strong>：<code>GitLab</code><br><strong>互联网</strong>：<code>GitHub</code>、<code>Gitee</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 代码只有一份，通过保存修改历史保存版本</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 提交到本地库和远程库的代码无法单独删除</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/git_1.png" alt="git工作机制"></p><h3 id="2-Git基本操作"><a href="#2-Git基本操作" class="headerlink" title="2.Git基本操作"></a>2.Git基本操作</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在git bash中进行操作，可以使用linux命令和操作，如tab补全、ctrl+滚轮调整大小等</div><h4 id="2-1设置用户签名"><a href="#2-1设置用户签名" class="headerlink" title="2.1设置用户签名"></a>2.1设置用户签名</h4><blockquote><p><strong>签名</strong>的作用是<strong>区分操作者身份</strong>，<strong>首次安装必须设置</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以在.gitconfig文件中查看是否设置成功，windows系统下位于C/用户/asus目录下</div><pre class="line-numbers language-none"><code class="language-none">git config --global user.name [用户名]git config --global user.email [用户邮箱]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2工作流"><a href="#2-2工作流" class="headerlink" title="2.2工作流"></a>2.2工作流</h4><blockquote><p><code>git init</code>：使得<code>git</code>获得该文件夹的<strong>管理权</strong>，使得该文件夹变为<strong>工作区</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 会在该文件夹下创建一个.git文件夹</div><blockquote><p><code>git add [添加对象]</code>：将对象添加到<strong>暂存区</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用git add -A将所有改动添加</div><blockquote><p><code>git commit -m "[版本描述信息]" [提交对象]</code>：将对象提交到<strong>本地库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若不指定提交对象，则将暂存区所有改动提交</div><h4 id="2-3查看状态"><a href="#2-3查看状态" class="headerlink" title="2.3查看状态"></a>2.3查看状态</h4><blockquote><p><code>git status</code>：查看<strong>分支</strong>以及<strong>该分支下显示未添加、未提交文件</strong>等信息</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> git的修改是先删除修改的那一行，然后重写，所以提示信息是一行新增，一行删除</div><blockquote><p><code>git reflog</code>：查看<strong>本地库的提交信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次提交最前面的黄色字符串就是版本号</div><blockquote><p><code>git log</code>：在<code>git reflog</code>的基础上<strong>更加精细</strong>，有<strong>完整版的版本号</strong>以及<strong>提交者</strong>的等信息</p></blockquote><h4 id="2-4分支"><a href="#2-4分支" class="headerlink" title="2.4分支"></a>2.4分支</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 分支就是当时创建分支时对应对象的副本，不同的分支有不同的作用（程序员修改、运维测试和用户使用等）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以并行推进多个版本功能开发，分支之间不会互相影响</div><blockquote><p><code>git branch -v</code>：<strong>查看</strong>分支</p></blockquote><blockquote><p><code>git branch [分支名]</code>：<strong>创建</strong>分支</p></blockquote><blockquote><p><code>git checkout [分支名]</code>：<strong>切换</strong>分支</p></blockquote><blockquote><p><code>git merge [分支名]</code>：将<strong>指定分支</strong>合并到<strong>当前分支</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 合并分支只会影响当前分支，对指定分支无影响，即将指定分支的对应版本提交到当前分支</div><h4 id="2-5合并冲突"><a href="#2-5合并冲突" class="headerlink" title="2.5合并冲突"></a>2.5合并冲突</h4><blockquote><p>假设在<code>master</code><strong>分支</strong>下新建了<code>test</code><strong>分支</strong>，分别对<strong>同一个文件修改并提交</strong>后，将<code>test</code>合并到<code>master</code>，可能会导致<strong>合并冲突</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 合并冲突：合并分支时，当两个分支在同一个文件的同一个位置有两套完全不同的修改，需要人为指定新代码内容</div><blockquote><p>一开始<code>master</code><strong>分支</strong>下有一个<code>test.txt</code>文件，创建<code>fix</code><strong>分支</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">//创建分支时test.txt代码1234567812345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>分别在<strong>两个分支下修改并提交</strong><code>test.txt</code>，随后将<code>fix</code><strong>分支</strong>合并到<code>master</code><strong>分支</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">//合并时master分支下test.txt文件12345678 abc12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//合并时fix分支下的test12345678 12345678 ABC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>发生<strong>合并冲突</strong>，在<code>master</code><strong>分支</strong>下打开<code>test.txt</code>文件，如下所示</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> git在冲突处显示两份代码的冲突部分，上面的是当前分支的修改，下面的是传入分支的修改</div><pre class="line-numbers language-none"><code class="language-none">//合并发生冲突，在master分支下打开test.txt文件&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD12345678 abc12345678=======12345678 12345678 ABC&gt;&gt;&gt;&gt;&gt;&gt;&gt; test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>手动修改冲突</strong>，<strong>保存</strong>文件随后将文件<strong>添加</strong>、<strong>提交</strong>即可解决冲突</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 手动修改冲突的宗旨就是保持冲突部分代码的行数不变，可以只采用某一个的修改，也可以同时采用</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 解决冲突时，提交时不能带文件名git commit -m "merge test"</div><pre class="line-numbers language-none"><code class="language-none">//仅仅采用当前分支12345678 abc12345678//仅仅采用指定分支12345678 12345678 ABC//同时采用两个的修改12345678 abc12345678 ABC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-6版本控制"><a href="#2-6版本控制" class="headerlink" title="2.6版本控制"></a>2.6版本控制</h4><blockquote><p><code>git reset --hard [版本号]</code>：将<strong>工作区的文件</strong>变为<strong>对应版本</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 版本控制本质上是控制HEAD指针和对应分支指针的指向，通过分支切换将HEAD指向不同的分支，通过reset修改对应分支执行其下不同的版本</div><blockquote><p><code>.git</code>文件夹<code>HEAD</code>文件记录了<code>HEAD</code><strong>当前指向分支</strong>,<code>refs/heads</code><strong>目录</strong>下记载<strong>各个分支</strong>的当前指向，如<code>master</code>文件记载了<code>master</code>的<strong>当前指向的版本号</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/git_2.png" alt="版本控制机制"></p><h3 id="3-Github远程库"><a href="#3-Github远程库" class="headerlink" title="3.Github远程库"></a>3.Github远程库</h3><h4 id="3-1免密登陆"><a href="#3-1免密登陆" class="headerlink" title="3.1免密登陆"></a>3.1免密登陆</h4><p><strong>①SSH密钥登陆</strong></p><blockquote><p><strong>密钥生成</strong>：<code>C/用户/asus</code><strong>目录</strong>下，在<code>git bash</code>中输入<code>ssh-keygen -t rsa -C [github邮箱]</code>，<strong>敲击三次回车</strong>，会创建<code>.ssh</code>目录，其下有<strong>公钥</strong>和<strong>私钥</strong></p></blockquote><blockquote><p><strong>密钥设置</strong>：在<strong>Github设置</strong>中的<code>SSH and GPG keys</code>添加<code>SSH key</code>，将<strong>公钥</strong>内容粘贴到<strong>对应位置</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个远程库都对应的HTTPS/SSH链接，其中SSH链接只有设置了公钥之后才能使用</div><p><strong>②口令登陆</strong></p><blockquote><p><code>github settings-&gt;develop settings-&gt;personal access tokens</code>生成<strong>登陆口令</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当使用账号密码登陆较难时，可以考虑使用口令登陆</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 口令在生成后最好立刻复制保存，因为界面一刷新就消失了，只能重新生成</div><h4 id="3-2工作流"><a href="#3-2工作流" class="headerlink" title="3.2工作流"></a>3.2工作流</h4><blockquote><p><code>git remote add [name] [HTTPS/SSH]</code>：<strong>保存远程库并命名，便于本地库识别</strong></p></blockquote><blockquote><p><code>git remote -v</code>：<strong>查看保存的远程库</strong></p></blockquote><blockquote><p><code>git clone [HTTPS/SSH]</code>：<strong>将远程库复制到本地库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> clone实质上做了三件事，即拉取代码，初始化本地库，创建别名（初始化为origin）</div><blockquote><p><code>git pull [name/HTTPS/SSH] [本地库分支名]</code>：<strong>利用远程库更新本地库</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> pull拉取过程实质上就是一个合并的过程，可能产生合并冲突</div><blockquote><p><code>git push [name/HTTPS/SSH] [本地库分支名]</code>：<strong>将本地库分支推送到远程库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 向别人的远程库推送代码需要权限，需要对方邀请自己成为对应库的成员并同意，且每次成员的推送都需要被库的拥有者审核后才能被合并入库（pull request）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 想要push，必须保证本地库版本高于远程库，所以在修改代码前，最好先pull再进行修改</div><blockquote><p><code>git fork</code>：<strong>将一个远程库的代码复制到另一个远程库中</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/git_3.png" alt="github工作机制"></p><h3 id="4-IDEA集成Git"><a href="#4-IDEA集成Git" class="headerlink" title="4.IDEA集成Git"></a>4.IDEA集成Git</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以VScode为例</div><h4 id="4-1初始设置"><a href="#4-1初始设置" class="headerlink" title="4.1初始设置"></a>4.1初始设置</h4><p><strong>①忽略设置</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为一个IDEA可能会生成一些我们不需要入库的文件，如日志文件等</div><blockquote><p>创建<code>git.ignore</code>文件（最好是在<code>.gitconfig</code>文件所在目录下），在其中添加<strong>需要忽略的文件类型</strong>，随后在<code>.gitconfig</code>文件中添加<strong>设置</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#忽略设置[core]    excludesfile = [git.ignore完整路径]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://gist.github.com/Yousha/3830712334ac30a90eb6041b932b68d7">VScode下C++的git.ignore模板</a><br><strong>②IDEA设置</strong></p><blockquote><p><code>VScode</code>中内置了对<code>Git</code>的支持，<strong>其他IDEA</strong>可能还需要<strong>在相关设置中设置<code>git.exe</code>的路径</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核设计与实现（二）</title>
      <link href="/2023/11/07/linux-nei-he-she-ji-yu-shi-xian-er/"/>
      <url>/2023/11/07/linux-nei-he-she-ji-yu-shi-xian-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核设计与实现（二）"><a href="#Linux内核设计与实现（二）" class="headerlink" title="Linux内核设计与实现（二）"></a>Linux内核设计与实现（二）</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><p><strong>1.1进程</strong>：<strong>正在执行</strong>的程序的<strong>实时结果</strong><br>①进程不仅仅是一段可执行程序代码，还包含其他资源，如打开的文件、挂起的信号、内核内部数据、处理器状态、一个或多个具有内存映射的内存地址空间、执行线程和存放全局变量的数据段等<br>②进程和程序不是一对一关系，可能多个进程执行的是一个程序<br><strong>1.2线程</strong>：在<strong>进程中活动的对象</strong>，每个线程都拥有独立的程序计数器、进程栈和一组进程寄存器<br>①<strong>内核调度的对象</strong>是线程，不是进程<br>②在Linux中，线程被看作是<strong>特殊的进程</strong><br>③线程可以<strong>共享虚拟内存</strong>，但是有其<strong>各自的虚拟处理器</strong><br><strong>1.3内核线程</strong>：独立运行在<strong>内核空间</strong>的标准进程，但是没有独立的地址空间，只能<strong>由内核线程创建</strong><br><strong>1.4进程上下文</strong>：</p><h3 id="2-进程描述符（task-struct）"><a href="#2-进程描述符（task-struct）" class="headerlink" title="2.进程描述符（task_struct）"></a>2.进程描述符（task_struct）</h3><p><strong>2.1定义</strong>：内核将进程的列表存放在名为<strong>任务队列</strong>的<strong>双向循环链表</strong>中，链表的每一项就是进程描述符，包含了<strong>内核管理一个进程的所有信息</strong>，类型为<code>task_struct</code>，定义在&lt;linxu/sched.h&gt;中<br><strong>2.2分配</strong><br>①通过<strong>slab分配器</strong>分配进程描述符，能达到<strong>对象复用</strong>和<strong>缓存着色</strong>的目的<br>②slab分配器分配进程描述符后，在<strong>进程内核栈的尾端</strong>创建<code>thread_info</code>结构，其中<code>task</code>域存放指向<strong>其进程描述符的指针</strong><br><strong>2.3访问</strong>：内核通过访问进程描述符处理进程<br>①thread_info结构：采用<strong>硬件体系结构对应的current宏</strong>访问thread_info结构访问其task域<br>②特殊寄存器：有的硬件体系结构拿出<strong>一个专门寄存器</strong>存放指向当前进程task_struct的指针<br><strong>2.4PID</strong>：每个进程的标志，PID号的最大值表示系统中允许同时存在的进程的最大数目<br><strong>2.5进程状态</strong>：进程描述符中的<strong>state域</strong>描述了进程当前状态<br>①TASK_RUNNING（运行）：正在执行或者在运行队列中等待执行<br>②TASK_INTERRUPTIBLE（可中断）：进程被<strong>阻塞（睡眠）</strong>，<strong>等待某些条件的达成</strong>状态便改为运行，可能<strong>被某些信号提前唤醒</strong><br>③TASK_UNINTERRUPTIBLE（不可中断）：进程在等待时必须不受干扰，或者等待的事件很快就会发生，<strong>不对信号做出响应</strong><br>④_TASK_TRACED（被跟踪）：被一些进程监视<br>⑤_TASK_STOPPED（停止）：<strong>没有投入运行也不能投入运行</strong>，进程退出运行，在接收到某些信号或者在调试时接收到任何信号便会变为这种状态<br>#进程状态可以通过某些函数调整，如<code>set_task_state()</code>函数<br><strong>2.6父子进程</strong>：每个进程描述符中都包含一个<code>parent</code>指针指向其父进程，也有一个名为<code>children</code>的子进程列表<br>#所有进程都是<code>init</code>进程的子进程</p><h3 id="3-进程的创建"><a href="#3-进程的创建" class="headerlink" title="3.进程的创建"></a>3.进程的创建</h3><p><strong>3.1Unix进程创建概述</strong>：<code>fork()</code><strong>拷贝当前进程</strong>创建一个子进程，该子进程和父进程区别仅仅在于PID和PPID（父进程号）和某些资源，<code>exec()</code>读取<strong>进程对应可执行文件</strong>将其载入地址空间运行<br>#Linux的<code>fork()</code>系统调用采用的是<strong>写时拷贝</strong>，不复制整个父进程的进程地址空间（<strong>父进程占用的内存页</strong>），而是和父进程<strong>共享</strong>，只有当<strong>需要写入时</strong>才创建自己的内存页,<strong>在不写入的情况下，<code>fork()</code>函数只是复制了父进程的页表项和给子进程创建唯一的PID</strong><br><strong>3.2fork()</strong><br>①过程概述：<code>fork()</code>→<code>clone()</code>系统调用→<code>do_fork()</code>→调用<code>copy_process()</code><br>②copy_process过程</p><ul><li>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>结构，和父进程相同</li><li>检查是否超出了资源的限制</li><li>子进程<code>task_struct</code>的一些信息被清零或初始化，以便和父进程相区分，并将状态设置为“不可中断”，防止其投入运行</li><li>更新子进程<code>task_struct</code>中的<code>flag</code>标志，去掉子进程的<strong>超级用户权限</strong>，设置其“没有调用过<code>exec()</code>”对应的标志，并分配一个PID</li><li>根据<code>fork()</code>传递给<code>clone()</code>的标志判断其是否能<strong>共享公共资源</strong>，如果不能，则拷贝一份</li><li>扫尾工作，并返回一个指向子进程的指针，返回成功则<strong>先将子进程投入运行</strong>，因为子进程会运行<code>exec()</code>进行写时拷贝，防止父进程运行后写入改变地址空间</li></ul><p>#如果创建的是线程的话，每个线程都有<strong>各自的进程描述符</strong>，描述<strong>地址空间</strong>、<strong>文件资源系统</strong>等<strong>共享资源</strong>，<strong>线程本身</strong>再去描述其<strong>独占</strong>的资源，需要传递参数标志给clone()指明需要共享的资源（查阅相关表格）<br>#<br>③vfork():除了不拷贝父进程的页表项外，其余和<code>fork()</code>功能一致，可以通过向<code>clone()</code>传递特殊标志实现<code>vfork()</code></p><h3 id="4-进程的终结"><a href="#4-进程的终结" class="headerlink" title="4.进程的终结"></a>4.进程的终结</h3><p><strong>4.1终结的产生</strong>：进程调用exit()系统调用<br>①主动调用<br>②程序主函数返回：C语言会在函数的返回点后调用<br>③接收到不能处理与忽略的信号和异常<br><strong>4.2exit()</strong><br>①概述：调用exit（）后，只与该进程相关的所有资源全部被释放，成为僵死进程，只剩下内存栈、thread_info结构和task_struct结构，等待父进程调用wait（）将其释放，父进程退出后，需要给子进程在当前线程组或者找一个线程或者init作为父进程<br>②详细过程：LKD P31页<br>父进程退出后，需要给子进程在当前线程组或者找一个线程或者init作为父进程</p><h3 id="5-进程调度"><a href="#5-进程调度" class="headerlink" title="5.进程调度"></a>5.进程调度</h3>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（二）</title>
      <link href="/2023/11/07/c-yu-yan-xue-xi-bi-ji-er/"/>
      <url>/2023/11/07/c-yu-yan-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（二）"><a href="#C语言学习笔记（二）" class="headerlink" title="C语言学习笔记（二）"></a>C语言学习笔记（二）</h1><h2 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h2><h3 id="1-指针"><a href="#1-指针" class="headerlink" title="1.指针"></a>1.指针</h3><h4 id="1-1内存和地址"><a href="#1-1内存和地址" class="headerlink" title="1.1内存和地址"></a>1.1内存和地址</h4><p><strong>①比特/位</strong></p><blockquote><p>计算机的<strong>最小存储单位</strong>，可以存储1和0</p></blockquote><p><strong>②字节</strong></p><blockquote><p>一个字节包含<strong>8个比特</strong>，包含存储<strong>一个字符</strong>所需要的位数，是计算机的<strong>最小寻址单位</strong></p></blockquote><p><strong>③字</strong></p><blockquote><p>每个字由<strong>2（16位机器）或者4（32位机器）个字节</strong>组成，每个字的地址是其<strong>最左边或者最右边</strong>的字节的地址，每台机器规定不同</p></blockquote><p><strong>④寻址</strong></p><blockquote><p>高级语言一般通过<strong>变量名</strong>而不是地址访问内存位置，<strong>变量名和地址的关系由编译器提供</strong>，<strong>硬件还是通过地址</strong>访问内存位置</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 边界对齐：整型值存储的起始位置只能是某些特定的字节，通常是2和4的倍数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个内存位置中存储的时一连串1和0，被解释为什么数据类型取决于我们的使用方式和声明方式，有些时候值可能是一样的但是被解释为了不同的数据类型</div><h4 id="1-2指针变量"><a href="#1-2指针变量" class="headerlink" title="1.2指针变量"></a>1.2指针变量</h4><p><strong>①声明格式</strong></p><blockquote><p><code>[指向变量的数据类型] *[指针变量名] = &amp;[指向的变量]</code><br><code>*</code>为<strong>间接访问操作符</strong>，可以通过它<strong>访问指针指向的地址</strong><br><code>&amp;</code>为<strong>取址符</strong>，通过它可以<strong>获得变量的地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对*指针变量进行操作相当于对其指向的变量进行操作</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 指针数据类型取决于指向的变量的数据类型，比如假设整数a的地址是100，不能使用*100 = 10对a进行赋值，因为100是字面量，缺省情况下是整型而不是指针变量，应该写为*（int*）100 = 10，该技巧只有在需要访问特定地址时才使用</div><p><strong>②未初始化的指针</strong></p><pre class="line-numbers language-none"><code class="language-none">int *a;*a = 12;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 指针需要进行初始化，因为声明一个指针并不会创建一个存储空间，所以其指向也未知，可能指向非法地址（内存错误）或者导致储存地址处于错误的边界（总线错误），所以一定要对指针进行初始化*可以初始化为空指针，但是要进行空指针检查）</div><p><strong>③NULL指针</strong></p><blockquote><p>表示这个指针<strong>没有指向任何地方</strong></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意对NULL指针进行引用是错误的，所以在对指针解引用时需要检查其是否为空指针</div><p><strong>④指针的指针</strong></p><blockquote><p><code>int** a = &amp;b</code>：其中b是一个指向整型变量的指针，a表示一个指向指向整型变量指针的指针</p></blockquote><p><strong>1.3指针与左右值</strong></p><pre class="line-numbers language-none"><code class="language-none">int a = 10；int* b = &amp;a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>①</strong>其中当<code>a</code>、<code>*b</code>（变量名）作为右值时，代表的是“10”，即对应位置储存的数据，作为左值时代表对应位置的地址<br><strong>②</strong><code>&amp;a</code>作为右值代表a的地址，不能作为左值，因为<code>&amp;a</code><strong>不能代表内存中某一特定位置</strong><br><strong>③</strong><code>b</code>作为右值是表示的是<code>a</code>的地址，作为左值表示的是<code>b</code>的地址<br><strong>1.4指针表达式</strong><br><strong>①</strong><code>*b+1</code>：表示对<code>a</code>中的数据加1，只能作为右值，<code>*（b+1）</code>相当于<code>a</code>后面一个内存的标识符，作为左值代表对应的地址，作为右值代表对应位置存储的数据。<br><strong>②</strong><code>++b</code>：作为右值表示该指针指向位置的后一个位置的地址，作为左值是非法的<br><strong>③</strong><code>b++</code>：作为右值表示的该指针指向位置的地址，随后该指针加一，作为左值是非法的，因为他是一个数值而不是一个容器<br><strong>④</strong><code>*++b</code>：作为右值表示该指针指向位置后一个位置存放的数据，作为的左值表示的是该指针指向位置后一个位置<br><strong>⑤</strong><code>*b++</code>：作为右值表示的是该指针指向位置存放的数据，作为左值表示的是该指针指向变量，随后该指针变量加一<br><strong>⑥</strong><code>++*b</code>：作为右值表示的是b指向变量存放数据的值加一</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ++/--的优先级高于*</div><p><strong>1.5指针的运算</strong><br><strong>①与整数加减法</strong>：当对指针加减一个整数n时，该指针会<strong>根据其指向的数据的类型调整自身大小</strong>（也适用于malloc分配的内存）</p><blockquote><p>比如某台机器上<code>float</code>占4个字节，对一个指向<code>float</code>变量的指针+n，该指针的大小会增加4n</p></blockquote><p><strong>②<code>==</code>与<code>!=</code></strong></p><blockquote><p>可以用于任意两个指针，判断两个指针是否相同</p></blockquote><p><strong>③指针之间的减法</strong></p><blockquote><p>只有当两个指针都指向<strong>同一数组</strong>中的元素时，才允许用一个指针减去另一个指针，得到的数据类型是<strong>ptrdiff_t</strong>，这是一种有符号整数，表示两个指针指向位置的距离（以数组元素的长度为单位）</p></blockquote><p><strong>④关系运算（大于/小于）</strong>：只能用于<strong>同一个数组</strong>内的元素</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> ③④中同一数组的元素还包括数组末尾后一位元素，但是不包括数组开头前一位元素</div><p><strong>1.6函数指针</strong><br><strong>①格式</strong>：<code>返回类型 (*f)()</code></p><blockquote><p>可以解释为<code>f</code>被间接引用后是一个函数，该函数的返回值是一个整型，所以f为一个函数指针<br><code>()</code>为函数调用操作符，<code>f()</code>的结果是函数的返回值</p></blockquote><p><strong>②初始化：</strong><code>返回类型 (*f)(参数列表) = 函数名</code></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在函数指针初始化时，其参数列表需要与之对应</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中函数名在编译时会被转换为函数指针，故可以不用取址符号</div><p><strong>③函数指针数组</strong>：<code>返回类型 (*f[]) ();</code></p><blockquote><p><code>()</code>和<code>[]</code>均为第一优先级，结合性<strong>从左向右</strong>，优先级均高于<code>*</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">double  (*oper_func[])(double,double) = {a,b,c...};result = oper_func[1](i,j);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>④用途</strong>：构造泛型函数</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 泛型函数：可以处理不同数据类型的函数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数指针可以作为一个参数提供给另一个函数，使得该函数可以在另一个函数中使用，这些函数被称为回调函数</div><blockquote><p>将函数中与数据类型相关的操作替换为<strong>一系列等价的函数</strong>，需要使用哪一类数据类型的对应操作，传递对应的函数指针即可<br>将传递给<strong>函数以及回调函数</strong>的数据类型替换<code>*void</code>，<code>*void</code>用于接收不同数据类型的指针</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在使用这些数据的指针时，必须要强制转换为正确的数据类型</div><pre class="line-numbers language-none"><code class="language-none">/*比较函数的整数版本int compare_ints(void const *a,void const *b){if(*(int *)a = *(int *)b)return 0;elsereturn 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h3><p><strong>2.1源文件格式</strong></p><pre class="line-numbers language-none"><code class="language-none">返回类型 函数名（形参类型1 形参名1，...形参类型n 形参名n）{statement；    return expression；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>return</code>语句不一定出现在末尾，没有<code>return</code>语句的函数称为<strong>过程</strong><br><strong>类型、形参和statement</strong>都不是必须的，因此最简单的函数可以写为</p></blockquote><pre class="line-numbers language-none"><code class="language-none">void function （void）{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这种函数可以达到存根的目的,即为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数要考虑异常情况</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 函数中的形参是实参的一个副本，修改形参不能修改实参，如果想要修改实参，需要传递实参的地址</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 当本该有参数的地方没有参数时，必须要使用void占据位置</div><p><strong>2.2函数声明</strong><br><strong>①格式</strong>：<code>返回类型 函数名(形参类型n 形参名n);</code></p><blockquote><p>向编译器<strong>提供函数相关信息</strong>，如果没有对应的函数声明，函数会被调用，但是传递给函数的参数会进行<strong>缺省参数提升</strong>（<code>char</code>和<code>short</code>被转换为<code>int</code>，<code>float</code>被转化为<code>double</code>），且默认返回一个<strong>整型</strong><br>函数声明的结尾是有一个<strong>分号</strong>的，而函数定义没有</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 大部分时候将函数定义在单独的C文件中，然后将函数声明置于同一个头文件中，主函数文件使用include命令调用即可</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当调用函数时输入的变量类型不匹配，编译器会根据函数声明强制转换变量类型</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 函数原型不要写在代码块中，因为代码块中的函数原型有代码块作用域，可能会覆盖原来的函数声明</div><p><strong>2.3利用函数实现黑盒</strong>：利用<code>static</code>关键字修饰<strong>函数内置数据和函数</strong>，使其变为函数文件私有，外界不能访问<br><strong>2.4递归函数</strong>：直接或者间接<strong>调用自身</strong>的函数，当递归函数<strong>不再满足某个条件</strong>时，便停止调用自身<br>以下为递归函数的例子</p><pre class="line-numbers language-none"><code class="language-none">binary_to_ascii(unsigned int value){unsigned int a;a = value/10;if(a!=0)binary_to_ascii(a)putchar(value%10+‘0)’;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>递归的<strong>实现过程</strong>（假设一开始<code>value</code>的值为4267）<br>①当函数被调用时，变量创建在堆栈中，之前调用函数的变量依旧保持在堆栈之中，但是<strong>被新函数的变量掩盖所以不能被访问</strong>（堆栈的特性）<br>②所以当递归函数调用自身时，每次新的调用都会创建一批新的变量掩盖原来的变量<br>③函数刚调用时，堆栈中出现了<code>value[1] = 4267</code>和<code>a[1] = 426</code><br>④当函数判断条件符合，又对函数进行第二次调用，堆栈中<code>value[2] = 426</code>、<code>a[2] = 42</code>掩盖了原先的<code>value</code>和<code>a</code><br>⑤第三次调用，<code>value[3] = 42</code>，<code>a[3] = 4</code><br>⑥第四次调用，<code>value[4] = 4</code>，<code>a[4] = 0</code>，至此，停止递归，然后函数开始打印输出，并开始释放销毁堆栈中的对应变量，<strong>从顶端的变量开始释放</strong>（堆栈的特性），从<code>[4]</code>到<code>[3]</code>到<code>[2]</code>再到<code>[1]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 递归函数需要设置限制条件，且每次递归调用之后就越接近该限制条件</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 递归的计算代价非常大，如果可以使用循环等解决问题，不要使用递归</div><p><strong>2.5可变参数列表</strong><br><strong>①实现</strong>：通过宏实现，定义于<code>stdarg.h</code>头文件中，该头文件中声明了一个<code>va_list</code>类型和三个宏<code>va_start</code>、<code>va_arg</code>和<code>va_end</code><br><strong>②用法</strong>：</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdarg.h&gt;/*用于计算输入数字的平均数float average (int n_value,...){va_list number_n;int count;float sum = 0;va_start(number_n,n_value);for (count=0;count&lt;n_value;count+=1){sum = sum+va_arg(number_n,int);}va_end(number_n);return sum/n_value;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在函数体内部定义<code>va_list</code>类型参数，该参数代表可变参数列表<br>使用<code>va_statr</code>初始化<code>va_list</code>类型参数，该宏接收的第一个参数是<code>va_list</code>类型参数<code>number_n</code>，第二个参数是可变参数列表的前一个参数<code>n_value</code><br>使用<code>va_arg</code>代替可变参数进行计算，该宏接收的第一个参数是<code>va_list</code>类型参数<code>number_n</code>，第二个参数是可变参数列表的<strong>数据类型</strong><br>使用<code>va_end</code>注销可变参数列表</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要使用该宏，则函数必须要有一个已确定的参数（上例中的n_value）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意函数形参部分的写法，可变参数列表用...代替，在书写函数声明时，也需要注意</div><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><p><strong>3.1声明格式</strong>：<code>数据类型 数组名[数组大小]</code><br><strong>①数组名</strong>：数组名的值是一个<strong>指针常量</strong>（注意是常量，所以不能改变），指向数组的起始位置</p><blockquote><p>数组名不仅仅只是一个指针常量，还包含了<strong>数组长度</strong>等信息，在创建数组的时候编译器会根据其长度为<strong>数组</strong>划分对应的内存空间，随后为数组名划分内存；而创建指针的时候，<strong>只为指针本身划分内存</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只有数组名在表达式中被使用了，编译器才会创建对应的指针常量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 数组名在一些情况下不是一个指针，而是代表整个数组，比如sizeof（数组名）会返回整个数组的长度，&amp;数组名产生的是一个数组的指针，而不是一个指向指针的指针</div><p><strong>②下标引用</strong>：<code>a[b]</code>相当于<code>*(a+b)</code>，<strong>所以下标从0开始</strong></p><blockquote><p>在C语言中，下标引用可以应用于<strong>所有的指针</strong>，不仅仅局限于数组</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 指针间接访问的效率大于等于下标引用效率，详细见《C与指针》p145-p150</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意检查数组越界问题</div><p><strong>3.2数组与函数</strong>：数组做为<strong>形参</strong>，格式可以是<code>(数据类型 数组名[])</code>也可以是指针类型<code>(数据类型 *指针名)</code></p><blockquote><p>函数在声明数组参数时不需要指定他的长度，因为他只接受数组的地址，而不为其分配内存，所以如果需要知道数组的<strong>大小</strong>，还需要<strong>另一个形参</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数组名传给形参是以传值的形式传递的，所以在函数中，对应指针变量是可以被修改的，但是不会影响到原来的数组名的值</div><p><strong>3.3初始化</strong><br><strong>①格式</strong>：<code>数据类型 数组名[] = {值1,值2,…}</code></p><blockquote><p>当数组为<strong>静态变量</strong>时，在<strong>程序执行前</strong>便被初始化，缺省情况下为<strong>0</strong><br>数组为<strong>自动变量</strong>（存储在堆栈中），在缺省情况下<strong>无法被初始化</strong>（因为每次程序流经过堆栈，堆栈中变量的位置是不固定的）</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 被初始化后，每次执行流经过数组的作用域时，数组又会被初始化一次（因为之前在作用域结束后被销毁），所以，对于那些非常大的数组 ，可以考虑将其设为static，减少其初始化次数</div><p><strong>②不完整的初始化</strong></p><blockquote><p>缺少元素：<strong>优先填充前面的</strong>，缺少的被命名为0<br>缺少数组长度：编译器将其设置为刚好能够<strong>容纳所有初始值</strong>的大小</p></blockquote><p><strong>③字符数组的初始化</strong>:<code>char a[] = “b”</code>相当于<code>char a = {'b',0}</code></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有在初始化字符数组时“b”才代表一个初始化列表，其他场合都为字符串常量，如下，message1是一个字符数组，message2是一个指向字符串字面值的指针</div><pre class="line-numbers language-none"><code class="language-none">char message1[] = "hello";char *message2 = "hello";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3.4多维数组</strong><br><strong>①声明</strong>：<code>数据类型 数组名 [维度1][维度2]…[维度N]</code></p><blockquote><p><code>int a [3][6][9]</code>：可以解读为a数组有包含3个变量，这3个变量是个包含6个变量的数组，同时这6个变量又是包含9个变量的数组</p></blockquote><p><strong>②存储形式</strong>：按照<strong>最右边的下标</strong>率先变化，比如<code>int *b = &amp;a[1][3]</code>,<code>b++</code>为<code>a[2][0]</code><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_1.png" alt="a[3][4]"><br><strong>③数组名</strong>：类比一维数组，将n维数组看为一个<strong>元素是n-1维数组的一维数组</strong>，数组名即<strong>指向第一个n-1维数组的指针</strong></p><blockquote><p><code>int a[3][4]</code>，将其看成有三个包含四个元素的一维数组<br><code>a</code>：一个指向第一个包含<strong>四个整型元素的数组</strong>的指针<br><code>a+1</code>:指向的<strong>第二个四元素的一维数组</strong>的指针（指针的加减法法则是根据指针的类型决定的）<br><code>*(a+1)</code>：指向第二个包含四个元素数组的<strong>第一个整型元素的指针</strong>,注意这个还不是其中所包含的数据<br><code>*a+1</code>:指向第一个包含四个元素数组的第二个元素的指针<br><code>*(*a+1)</code>：为第一个包含四个元素数组的<strong>第二个元素</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一层一层解引用，n维数组要解引用n次，才能获得数据</div><p><strong>④多维数组的初始化</strong></p><blockquote><p>以二维数组为例<br><code>int a[][] = {元素1、元素2…};</code><br>定义后，通过<code>a[i][j] = 数值;</code>，一个一个赋值<br><code>int a[][] = {{数组1}，{数组2}…};</code> </p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 层层套娃</div><p><strong>3.5多维数组与指针</strong><br><strong>①指向数组的指针</strong>：<code>数组元素数据类型 (*指针名)[数组元素个数] = 二维数组名</code></p><blockquote><p><strong>下标引用的优先级比间接访问高</strong>，但是由于括号的存在，先执行的是间接访问，这样就将<code>p</code>定义为一个指针，<strong>它指向的对象进行下标引用得到的是一个整型</strong>，所以他是一个指向一维数组的指针，指向二维数组的第一行，该指针进行加法时，是<strong>以一个数组为单位移动</strong>的</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这里的数组元素个数与之对应，如int (*p)[4] = a;</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将数组传递给一个函数，本质上是传递一个对应的指针，对于多维数组，就是传递一个指向数组的指针，对应函数原型应写为`void func1(int (*a)[4])`或者`void func1(int a[][4])`</div><p><strong>②指向元素的指针</strong>：<code>数组元素数据类型 *p = &amp;数组名[0][0]</code>或者<code>数组元素数据类型 *p = 数组名[0]</code>（以二维数组为例）</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 注意后者是没有&amp;符号的，因为后者就是一个指向元素的指针！</div><p><strong>③指针数组</strong>：<code>数据类型* 数组名[个数]</code></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 与指向数组的指针仅仅只有一个括号之差</div><h3 id="4-结构"><a href="#4-结构" class="headerlink" title="4.结构"></a>4.结构</h3><p><strong>4.1格式</strong><br><strong>①定义</strong></p><pre class="line-numbers language-none"><code class="language-none">struct [结构类型名称]{结构成员表(每个成员的类型和名字);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 结构变量是标量类型，所以相同的结构变量可以相互赋值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将结构定义在一个头文件中，使用include包含即可</div><p><strong>②声明</strong>：<code>struct 结构类型名称 结构名</code></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用typedef关键字为结构定义新的名字</div><pre class="line-numbers language-none"><code class="language-none">typedef struct{结构成员表(每个成员的类型和名字);}[结构类型名称];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③初始化与赋值</strong>：<code>struct 结构名 变量名 = {成员1，成员2，成员3}</code></p><pre class="line-numbers language-none"><code class="language-none">struct X{int a;short b[3];simple c;};struct X x1 = {10,{1,2,3},{25,'x'}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④结构成员的访问</strong></p><blockquote><p><code>.</code>操作符：<code>结构名.成员名</code><br><code>-&gt;</code>操作符：<code>对应结构指针-&gt;成员名</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这两个操作符优先级相同，比*和[]高，结合性从左向右</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 假设px是结构x的指针，px指向的地址和结构第一个成员的地址是一样的，但是*px代表的是整个结构</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当结构需要作为函数参数时，可以传递该结构的指针，效率较高，可以用const关键词防止对结构体的修改</div><p><strong>4.2结构的引用</strong><br><strong>①结构的自引用</strong>：结构内部成员为自己本身是非法的，但是可以<strong>包含自己的指针类型</strong></p><pre class="line-numbers language-none"><code class="language-none">//非法，因为在声明next成员时，Node还有没被声明typedef struct{  ElemType data;  struct Node *next;}Node;//合法typedef struct Node{  ElemType data;  struct Node *next;}Node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为结构在定义时内存大小是不确定的，而结构指针的内存大小在结构创建前就已经确定</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意不能使用之前没有定义的结构标签</div><p><strong>②结构之间的引用</strong>：当需要定义几种之间<strong>存在联系</strong>的结构，可以采用不完整声明</p><pre class="line-numbers language-none"><code class="language-none">struct B; //B的不完整声明struct A{struct *B;};struct B{struct A;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意，A中不能以B为成员，只能以B的指针为成员，因为不完整声明导致B的大小不能确定</div><p><strong>4.3结构的存储分配</strong><br><strong>①</strong>正常情况下，编译器按照<strong>成员列表顺序</strong>一个一个给每个成员分配内存<br><strong>②</strong>当成员的存储需要满足正确的边界对齐条件，成员之间会出现未填充的内存空间</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 边界对齐：访问特定类型变量的时候经常在特定的内存地址访问</div><blockquote><p>假设一台机器的整型值长度为4字节，且要求其<strong>起始存储位置</strong>必须能被4整除，而结构的起始位置也必须满足<strong>成员中边界要求最严格</strong>的对齐条件，则以下结构在内存中的存储情况如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">struct X{char a;int b;char c;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_3.png" alt="内存分配情况"><br><strong>③对边界要求最严格的成员应该首先出现</strong>，这样可以<strong>节省内存</strong></p><pre class="line-numbers language-none"><code class="language-none">struct X{int b;char a;char c;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_4.png" alt="内存分配情况"><br><strong>④常用函数</strong>：<code>sizeof</code>可以得到一个结构的整体长度，<strong>包括因为边界对齐跳过的字节</strong>，<code>offsetof</code>可以确定结构中某个成员的位置（偏离结构存储起始位置的字节数）<br><strong>4.4位段</strong><br><strong>①声明格式</strong>：一种特殊的结构，成员必须是<code>int</code>、<code>signed</code>、<code>unsigned</code>类型，成员名后面是<strong>一个冒号和一个整数，该整数表示该成员占用的位的数目</strong></p><pre class="line-numbers language-none"><code class="language-none">struct WeiDuan{unsigned a : 7;unsigned b : 6;unsigned c : 19;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 位段可以将长度为奇数的数据包装在一起，并且可以访问一个整型值的部分内容（这些部分内容可能有特定的含义）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 显示的用signed和unsigned声明位段比较好，如果仅仅将位段声明为int类型，被解释为有符号数还是无符号数由编译器决定</div><p><strong>②位段的移植性问题</strong></p><blockquote><p>很多编译器将位段<strong>成员</strong>的长度限制在<strong>一个整型值</strong>之内，32位机器上可以使用的位段声明可能在16位机器上无法使用<br>位段的内存是<strong>从左向右</strong>分配还是<strong>从右向左</strong>分配由机器决定<br>当位段的<strong>总位数不是8的倍数时</strong>，其内存分配是否要“边界对齐”取决于编译器</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 任何使用位段实现的任务，都可以通过移位和屏蔽实现，但是会麻烦一些</div><p><strong>4.5联合</strong><br><strong>①声明格式</strong></p><pre class="line-numbers language-none"><code class="language-none">union{float f;int i;}fi;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>联合各个成员<strong>共用内存中的一个位置以及数据</strong>，当联合的某个成员被访问时，则将该联合所在位置的位以该成员类型解释被访问，换句话说，<strong>联合的各个成员决定了这些位是如何被解释的</strong></p></blockquote><p><strong>②联合的变体</strong>：联合各个成员的长度可以不同，比如说两个结构</p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当联合中各个成员具有不同的长度，联合的长度就是它最长成员的长度</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当成员之间大小相差太大时，可以将联合的成员修改为不同数据类型的指针，这样就不会造成空间浪费</div><p><strong>③联合的初始化</strong></p><pre class="line-numbers language-none"><code class="language-none">union{int a;float b;char c[4];}x = {5};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 联合变量的初始值只有一个，且必须是联合第一个成员类型的数据</div><h3 id="5-动态内存分配"><a href="#5-动态内存分配" class="headerlink" title="5.动态内存分配"></a>5.动态内存分配</h3><p><strong>5.1内存分配</strong><br><strong>①</strong><code>malloc()</code>:从<strong>内存池</strong>中提取一块<strong>连续</strong>的内存，并返回一个<strong>指向这块内存的指针</strong>，如果内存池没有合适的内存则返回<strong>NULL</strong>，这块内存<strong>没有被初始化</strong></p><blockquote><p>格式：<code>p = malloc（size）;</code><br><code>malloc()</code>返回值是<code>void *</code>，可以转化为任何类型的指针<br><code>size</code>为需要分配的<strong>字节数</strong>，其类型是<code>size_t</code>，一个<strong>无符号类型</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> malloc()返回内存的起始位置始终满足边界对齐条件</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将size替换为n*sizeof（数据类型），n为数量，还可以提高程序的可移植性</div><p><strong>②</strong><code>calloc()</code>：和<code>malloc</code>一样用于分配内存，但是<code>calloc</code>会将内存内所有元素初始化为0，会消耗一定的时间</p><blockquote><p>格式：<code>p = calloc(num,size);</code><br>其中<code>num</code>为元素的个数，<code>size</code>为每个元素的大小，类型均为size_t</p></blockquote><p><strong>③</strong><code>realloc()</code>：<strong>修改</strong>一个已经分配的内存块的大小，新增加的内存添加到原先内存块的<strong>尾部</strong>，没有被初始化，如果用于缩小原来的内存块，则将<strong>尾部</strong>的内存块拿掉</p><blockquote><p>格式：<code>p = realloc(ptr,size);</code><br>其中<code>ptr</code>是需要调整大小的指针，<code>size</code>是调整后内存的大小</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> C语言中，void*可以赋值给其他类型指针，但是在其他语言如C++中不行，故最好在前面加一个强制类型转换</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若原先的内存块大小无法改变，则realloc会重新划分一块内存，并释放原来的内存，所以要使用realloc返回的指针</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 动态分配得到的指针是变量，但是我们不希望他改变，因为最后还需要释放掉，故有需要可以构建该指针的副本对内存进行操作</div><p><strong>5.2内存释放</strong>：当分配的内存不再使用时，需要使用<code>free()</code>将其释放<br><strong>①函数原型</strong>：<code>void free (void *pointer)</code><br><strong>②使用格式</strong>：<code>free (p)</code><br><strong>5.3常见错误</strong><br><strong>①</strong>对NULL指针进行解引用<br><strong>②</strong>对分配的内存操作时越界<br><strong>③</strong>释放并为动态分配的内存<br><strong>④</strong>释放动态内存的一部分<br><strong>⑤</strong>访问一块已经被释放的内存，尤其是当内存分配指针被备份时<br><strong>⑥</strong>内存释放不及时，导致内存泄漏</p><p><strong>5.4内存操作函数</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 和字符串的一些操作函数很像，但是遇到NUL字节不会停止</div><p><strong>①</strong><code>memcpy()</code>：<strong>直接复制</strong>一块内存中数据到另一块内存中</p><blockquote><p>函数原型<code>void *memcpy(void *dst,void const *src,size_t length)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如上，内存操作函数接收和返回的参数都是void*，且会规定操作的内存长度</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> length是字节的个数，可以使用sizeof便捷计算</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 两块内存不能重叠</div><p><strong>②</strong><code>memmove()</code>：类似于<code>memcpy()</code>，但是<code>memmove()</code>在转移时会经过一块<strong>临时内存</strong><br><strong>③</strong><code>memcmp()</code>：比较两块内存的内容（按照无符号字符逐字节比较）</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不能用于比较非单字节数据</div><p><strong>④</strong><code>memchr()</code>：查找某块内存某个字符<strong>第一次出现</strong>的位置<br><strong>⑤</strong><code>memset()</code>：将一段内存<strong>都设置</strong>为某个字符</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工作流（一）</title>
      <link href="/2023/11/07/linux-gong-zuo-liu-yi/"/>
      <url>/2023/11/07/linux-gong-zuo-liu-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux工作流（一）"><a href="#Linux工作流（一）" class="headerlink" title="Linux工作流（一）"></a>Linux工作流（一）</h1><h2 id="Linux基础操作"><a href="#Linux基础操作" class="headerlink" title="Linux基础操作"></a>Linux基础操作</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1Linux基本介绍"><a href="#1-1Linux基本介绍" class="headerlink" title="1.1Linux基本介绍"></a>1.1Linux基本介绍</h4><blockquote><p>一款<strong>开源免费</strong>的操作系统，主要应用在<strong>服务器领域</strong>，借鉴了<strong>unix系统</strong>的思想，有<strong>ubuntu</strong>、<strong>debain</strong>等发行版</p></blockquote><h4 id="1-2Linux安装"><a href="#1-2Linux安装" class="headerlink" title="1.2Linux安装"></a>1.2Linux安装</h4><p><strong>①双系统安装</strong></p><p><strong>②虚拟机安装</strong></p><h4 id="1-3Linux目录结构"><a href="#1-3Linux目录结构" class="headerlink" title="1.3Linux目录结构"></a>1.3Linux目录结构</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> Linux下一切皆文件，包括硬件也会被映射为一个文件</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要介绍根目录下的各个目录，每个目录存放特定的文件</div><blockquote><p><code>bin</code>：存放<strong>经常使用的命令</strong>，如<code>cd</code>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> sbin存放只有管理员才能使用的命令</div><blockquote><p><code>home</code>：存放<strong>普通用户</strong>的<strong>主目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> root存放管理员的主目录</div><blockquote><p><code>lib</code>：存放<strong>系统</strong>使用的<strong>动态链接库</strong></p></blockquote><blockquote><p><code>ect</code>：存放<strong>系统管理</strong>所需要的<strong>配置文件</strong></p></blockquote><blockquote><p><code>usr</code>：存放<strong>系统自带文件</strong>，其中<code>usr/local</code>为<strong>用户使用系统安装</strong>的软件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> opt为用户手动安装软件的安装路径</div><blockquote><p><code>boot</code>：Linux<strong>启动</strong>时所需要的<strong>核心文件</strong></p></blockquote><blockquote><p><code>tmp</code>：存放<strong>临时文件</strong></p></blockquote><blockquote><p><code>dev</code>：存放<strong>系统硬件</strong>如CPU的<strong>映射</strong>，类似于windows的<strong>设备管理器</strong></p></blockquote><blockquote><p><code>media</code>：存放<strong>自动挂载</strong>，如<strong>U盘</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> mnt存放手动挂载</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> dev存放U盘的映射，media存放U盘的内容</div><blockquote><p><code>var</code>：存放<strong>经常被修改</strong>的东西，如<strong>日志文件</strong></p></blockquote><blockquote><p><code>proc</code>：存储的是Linux运行时的<strong>进程映射</strong></p></blockquote><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h3><p>没有反应一般就是成功</p><h4 id="2-1基础命令"><a href="#2-1基础命令" class="headerlink" title="2.1基础命令"></a>2.1基础命令</h4><blockquote><p><code>shutdown [选项] [时间]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -h选项是关机，-r选项是重启，时间以分钟为单位</div><blockquote><p><code>sync</code>：将<strong>内存数据</strong>同步到<strong>磁盘</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于保存，每次关机重启前要输入这条命令</div><blockquote><p><code>clear</code>：<strong>清除命令行</strong></p></blockquote><blockquote><p><code>man [命令或者配置文件]</code>：获得<strong>对应</strong>的<strong>帮助信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对应help只能获得shell内置命令的帮助</div><blockquote><p><code>ls</code>：列出<strong>当前路径</strong>的文件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -a显示隐藏文件，-l显示详细文件信息（单列输出）</div><blockquote><p><code>cd [目录路径]</code>：切换到<strong>目录下</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> .表示当前目录，..表示上一级目录，～表示家目录</div><blockquote><p><code>echo [输出内容]</code>：将<strong>对应内容</strong>输出到<strong>控制台</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用echo $PATH输出环境变量</div><blockquote><p><code>init [级别数字]</code>：指定<strong>运行级别</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 运行级别不同，关机等命令行、图形界面</div><blockquote><p><code>pwd</code>：显示<strong>当前目录</strong>的<strong>绝对路径</strong></p></blockquote><h4 id="2-2文件管理"><a href="#2-2文件管理" class="headerlink" title="2.2文件管理"></a>2.2文件管理</h4><p><strong>①创建</strong></p><blockquote><p><code>touch [文件路径]</code>：<strong>创建</strong>文件/<strong>更新</strong>文件<strong>修改时间</strong></p></blockquote><blockquote><p><code>mkdir [目录路径]</code>：<strong>创建</strong>对应<strong>目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-p选项创建多级目录，如mkdir -p a/b/c</div><p><strong>②删除</strong></p><blockquote><p><code>rmdir [目录路径]</code>：<strong>删除</strong>指定<strong>空目录</strong></p></blockquote><blockquote><p><code>rm [文件路径]</code>：<strong>删除</strong>指定<strong>文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-rf选项递归删除目录</div><p><strong>③移动</strong></p><blockquote><p><code>mv [源文件路径] [文件路径]</code>：将<strong>源文件</strong>复制到<strong>对应路径</strong>并对其<strong>重命名</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若两路径一致，则是重命名</div><blockquote><p><code>mv [源文件路径] [目录路径]</code>：将<strong>源文件</strong>移动到<strong>对应目录下</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该文件也可以是目录</div><p><strong>④复制</strong></p><blockquote><p><code>cp [源文件路径] [存放目录路径]</code>：将<strong>文件</strong>复制到<strong>对应目录下</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-r选项递归复制整个文件夹</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> \cp强制忽略覆盖信息</div><p><strong>⑤查看</strong></p><blockquote><p><code>less [文件路径]</code>：查看文件，查看<strong>大型文件</strong>友好</p></blockquote><blockquote><p><code>head [文件路径]</code>：查看文件<strong>头部信息</strong></p></blockquote><blockquote><p><code>tail [文件路径]</code>：查看文件<strong>尾部信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -f选项可以使用终端实时监控文件的修改</div><h4 id="2-3辅助命令"><a href="#2-3辅助命令" class="headerlink" title="2.3辅助命令"></a>2.3辅助命令</h4><blockquote><p><code>|</code>：<strong>管道</strong>命令，将<strong>前一个命令得到的输出</strong>作为<strong>下一个命令的输入</strong></p></blockquote><blockquote><p><code>&gt; [文件路径]</code>：将命令的输出<strong>重定向</strong>到对应<strong>文件</strong></p></blockquote><blockquote><p><code>&gt;&gt; [文件路径]</code>：将命令的输出<strong>追加</strong>到对应<strong>文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若对应文件不存在，则会创建该命令</div><blockquote><p><code>ln -s [源文件或者目录] [软连接路径]</code>：给<strong>对应文件/目录</strong>创建<strong>软链接</strong>，类似于<strong>快捷方式</strong><br><code>history [数字]</code>：查看<strong>历史命令</strong></p></blockquote><h3 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3.用户管理"></a>3.用户管理</h3><h4 id="3-1基本管理"><a href="#3-1基本管理" class="headerlink" title="3.1基本管理"></a>3.1基本管理</h4><blockquote><p><code>useradd [用户名]</code>：<strong>创建</strong>账户</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-d选项指定家目录路径</div><blockquote><p><code>passwd [用户名]</code>：设置/修改<strong>密码</strong></p></blockquote><blockquote><p><code>userdel [用户名]</code>：<strong>删除</strong>用户，但是<strong>保留</strong>了他的<strong>家目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-r选项删除其家目录</div><blockquote><p><code>id [用户名]</code>：查询<strong>用户信息</strong>（<code>uid</code>和<code>gid</code>）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> /etc/passwd中包含了每个用户的信息，/etc/shadow包含了用户口令的配置文件</div><blockquote><p><code>whoami</code>：查询<strong>当前用户</strong></p></blockquote><blockquote><p><code>su - [用户名]</code>：<strong>切换</strong>用户</p></blockquote><h4 id="3-2分组管理"><a href="#3-2分组管理" class="headerlink" title="3.2分组管理"></a>3.2分组管理</h4><blockquote><p><code>groupadd [组名]</code>：<strong>新建</strong>组</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> /etc/group包含了组的信息</div><blockquote><p><code>groupdel [组名]</code>：<strong>删除</strong>组</p></blockquote><blockquote><p><code>useradd -g [组名] [用户名]</code>：<strong>创建</strong>账户时给其<strong>指定组</strong>/<strong>修改</strong>用户所在组</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若创建用户时没有指定组，则会给起创建一个与其名字相同的组并将其放入</div><p>ubuntu如何找回用户密码？</p>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 工作流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT制作（基础篇）</title>
      <link href="/2023/11/07/ppt-zhi-zuo-ji-chu-pian/"/>
      <url>/2023/11/07/ppt-zhi-zuo-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="PPT制作（基础篇）"><a href="#PPT制作（基础篇）" class="headerlink" title="PPT制作（基础篇）"></a>PPT制作（基础篇）</h1><h2 id="PPT风格矩阵"><a href="#PPT风格矩阵" class="headerlink" title="PPT风格矩阵"></a>PPT风格矩阵</h2><h3 id="1-配色"><a href="#1-配色" class="headerlink" title="1.配色"></a>1.配色</h3><h4 id="1-1主色"><a href="#1-1主色" class="headerlink" title="1.1主色"></a>1.1主色</h4><p><strong>①根据logo选择</strong></p><blockquote><p>学校、企业<strong>logo</strong></p></blockquote><p><strong>②根据风格选择</strong></p><blockquote><p>比如说<strong>黑金风</strong>就是<strong>黑色</strong>和<strong>金色</strong>，<strong>科技风</strong>经常是<strong>蓝色</strong>和<strong>青色</strong>，<strong>党政风</strong>是<strong>红色</strong>和<strong>黄色</strong></p></blockquote><p><strong>③根据主题选择</strong>：</p><blockquote><p>比如说<strong>医疗行业</strong>对应的是<strong>蓝色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以在网上搜索对应关键字，提取配色</div><h4 id="1-2辅助色"><a href="#1-2辅助色" class="headerlink" title="1.2辅助色"></a>1.2辅助色</h4><p><strong>①邻近色</strong>：</p><blockquote><p><strong>基于主色</strong>调整<strong>色调</strong>，用于区分不同<strong>维度</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 右击色块→填充→其他颜色填充→颜色模式改为“HSL”→调整色调数值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 跨度最好在45以内，20较佳</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 色调数值的界限时0-255，所以-15相当于240，270相当于15</div><p><strong>②梯度色</strong></p><blockquote><p>调整<strong>亮度</strong>，用于区分不同<strong>层级</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 右击色块→填充→其他颜色填充→颜色模式改为“HSL”→调整亮度数值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 设计选项卡→变体选项卡→颜色→自定义颜色→着色1，输入主色的色值即可</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_40.png" alt="辅助色矩阵"><br><strong>③相关网站</strong></p><blockquote><p><a href="https://color.adobe.com/zh/">Adobe Color</a>、<a href="https://arco.design/palette/list">Palette</a>、<a href="https://colorsupplyyy.com/app">撞色</a>、<a href="https://webgradients.com/">渐变色</a></p></blockquote><hr><h3 id="2-修饰边框"><a href="#2-修饰边框" class="headerlink" title="2.修饰边框"></a>2.修饰边框</h3><h4 id="2-1形状"><a href="#2-1形状" class="headerlink" title="2.1形状"></a>2.1形状</h4><p><strong>①轮廓</strong></p><blockquote><p><strong>矩形</strong>：工业、商务和力量</p></blockquote><blockquote><p><strong>圆角矩形</strong>：卡通、儿童和女性</p></blockquote><blockquote><p><strong>去角矩形</strong>：文化、国风和传统</p></blockquote><blockquote><p><strong>平行四边形</strong>：运动、速度和竞赛</p></blockquote><blockquote><p><strong>折角</strong>：科技、未来</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 插入基础图形→右击→编辑顶点→每个顶点对应两个控点，拖动控点即可做出有弧度的图形</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 比较新颖的形状可以在素材网站上寻找，记得要下载矢量图（SVG）</div><p><strong>②填充</strong></p><blockquote><p><strong>色块填充</strong>：<strong>纯色</strong>和<strong>渐变色</strong></p></blockquote><blockquote><p><strong>纹理填充</strong>：找到<strong>纹理素材</strong>→在ppt中将<strong>纹理图片和形状重叠</strong>→<strong>先选形状，后选纹理</strong>→<strong>形状选项卡</strong>→<strong>合并形状</strong>→<strong>剪除</strong></p></blockquote><h4 id="2-2效果"><a href="#2-2效果" class="headerlink" title="2.2效果"></a>2.2效果</h4><p><strong>①立体</strong></p><blockquote><p><strong>设置渐变</strong>：两个<strong>颜色一致</strong>的光圈→<strong>第一个光圈</strong>亮度调整至<strong>70％</strong>→<strong>渐变类型</strong>调整为<strong>射线渐变</strong>，<strong>方向</strong>调整为<strong>从左上角</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 适当调整两个光圈位置调整效果，如两个光圈位置分别在15%和85%</div><blockquote><p><strong>添加映像效果</strong>：选择<strong>第一个预设</strong>，<strong>透明度</strong>85％，<strong>大小</strong>20％左右，适当添加<strong>模糊</strong>效果</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_41.png" alt="立体"><br><strong>②光泽</strong></p><blockquote><p><strong>设置渐变</strong>：选择<strong>线性渐变</strong>，<strong>方向</strong>调整为45°→<strong>左右两侧光圈</strong>设置为<strong>主色</strong>→<strong>中间</strong>添加<strong>一到两个光圈</strong>，颜色设置为<strong>背景色</strong>，<strong>透明度</strong>设置为100</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 适当调整两个光圈位置调整效果</div><blockquote><p>将<strong>轮廓</strong>设置为<strong>实线</strong>,并<strong>同上</strong>添加<strong>映像</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 轮廓线的亮度最好比主色高一些</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_42.png" alt="光泽"><br><strong>③新拟态</strong></p><blockquote><p><strong>凸起</strong>：<strong>形状颜色</strong>和<strong>背景色</strong>相同，<strong>去除轮廓</strong>，给<strong>两个相同的形状</strong>添加<strong>外阴影</strong>，<strong>方向对立</strong>（比如说右下45°和左上45°），一个阴影的<strong>色调</strong>比背景色<strong>暗</strong>，一个阴影的<strong>色调</strong>比背景<strong>亮</strong>，然后<strong>重叠这两个形状</strong></p></blockquote><blockquote><p><strong>凹陷</strong>：<strong>形状颜色</strong>和<strong>背景色</strong>相同，<strong>去除轮廓</strong>，给两个<strong>相同的形状</strong>添加<strong>内阴影</strong>，<strong>方向对立</strong>（比如说右下45°和左上45°），一个阴影的<strong>色调</strong>比背景色<strong>暗</strong>，<strong>复制</strong>其中一个，对另一个进行<strong>图片纹理填充</strong>（剪切板）即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 表现为凹凸不平的图形</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 适当调节阴影的距离和模糊使其更加柔和</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 背景不能是纯白纯黑，可以是灰色，淡蓝色等</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_43.png" alt="新拟态"><br><strong>④毛玻璃</strong></p><blockquote><p>对<strong>背景图</strong>做<strong>全屏虚化</strong>（100即可），再将<strong>正常背景图覆盖</strong>在上面，添加色块，将<strong>色块颜色</strong>改为<strong>幻灯片背景填充</strong>即可，这个<strong>色块</strong>就是<strong>一块毛玻璃</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 还可以添加白色描边、内阴影使其更加逼真</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_44.png" alt="毛玻璃"><br><strong>⑤发光</strong></p><blockquote><p><strong>内发光</strong>：<strong>射线渐变（圆形）/路径渐变（调整方向）</strong>，<strong>左光圈</strong>为<strong>背景色</strong>（<strong>透明度</strong>调节为100%），<strong>右光圈</strong>为<strong>发光色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 调整光圈位置调整发光效果</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 设置好渐变参数后，先点击纯色填充，再点击渐变填充可以使得发光效果更强</div><blockquote><p><strong>外发光</strong>：<strong>复制</strong>对应图形，<strong>柔化边缘</strong>，将其与<strong>原图形重叠</strong>，<strong>调整大小</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 柔化边缘的磅数可以适当大一些</div><blockquote><p><strong>发光平台</strong>：<strong>渐变透明</strong>的<strong>梯形</strong>，<strong>从上往下</strong>的渐变，一个光圈为<strong>背景色</strong>，一个光圈为<strong>主色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 梯形、矩形和平行四边形（侧面）组合可以成为三维平台，其中正面的透明度应该比上平面的透明度低</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 给边框添加光效素材，使其更漂亮</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_45.png" alt="发光"></p><h4 id="2-3参考网站"><a href="#2-3参考网站" class="headerlink" title="2.3参考网站"></a>2.3参考网站</h4><blockquote><p><a href="https://www.freepik.com/">freepik</a>、<a href="https://huaban.com/">花瓣网</a>、<a href="https://www.zcool.com/">zcool</a>、<a href="www.pinterest.com">pinterest</a></p></blockquote><hr><h3 id="3-修饰"><a href="#3-修饰" class="headerlink" title="3.修饰"></a>3.修饰</h3><h4 id="3-1背景"><a href="#3-1背景" class="headerlink" title="3.1背景"></a>3.1背景</h4><p><strong>①基调</strong></p><blockquote><p><strong>基于环境</strong>：当<strong>环境比较明亮</strong>时采用<strong>浅色</strong>，当<strong>环境比较暗</strong>时采用<strong>深色</strong></p></blockquote><blockquote><p><strong>基于主色</strong>：当<strong>主色</strong>为<strong>浅色</strong>时，采用<strong>深色背景</strong>，<strong>反之</strong>采用<strong>浅色背景</strong></p></blockquote><blockquote><p><strong>基于风格</strong>：比如<strong>科技风</strong>经常采用<strong>深色渐变背景</strong></p></blockquote><p><strong>②类型</strong></p><blockquote><p><strong>图片背景</strong>：常作为<strong>封面</strong>背景</p></blockquote><blockquote><p><strong>色块背景</strong>：常作为<strong>正文</strong>背景，可以是<strong>纯色</strong>，也可以是<strong>渐变色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 渐变背景：使用两个光圈，一个为主色，一个为白色，选择合适的渐变方向，提高主色光圈亮度即可（80%-90%）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以修改幻灯片母版修改每一张幻灯片，视图选项卡→幻灯片母版</div><h4 id="3-2字体"><a href="#3-2字体" class="headerlink" title="3.2字体"></a>3.2字体</h4><p><strong>①种类</strong></p><blockquote><p>字体种类最好<strong>不超过两种</strong>，一般<strong>正文</strong>采用<strong>黑体</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一般来说中文和西文的字体是不一样的，在调整两种字体都有的段落时，先整体设置中文，再设置英文</div><p><strong>②风格</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一般只有标题能使用风格字体，字体风格要和ppt整体风格相符合</div><blockquote><p><strong>黑体</strong>：力量、动感和科技</p></blockquote><blockquote><p><strong>宋体</strong>：文化、庄严和雅致</p></blockquote><blockquote><p><strong>书法</strong>：豪迈、奔放和大气</p></blockquote><p><strong>③粗细</strong></p><blockquote><p><code>light</code>、<code>regular</code>和<code>bold</code>为常见的三种<strong>字体字重</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用粗体，不要使用ppt自带的字体加粗，而是采用字体本身的bold类型</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> ppt主题字体设置：设计选项卡→变体分区→字体→自定义字体</div><h4 id="3-3素材"><a href="#3-3素材" class="headerlink" title="3.3素材"></a>3.3素材</h4><p><strong>①图标</strong></p><blockquote><p>填补/代替<strong>标题或小标题</strong>，使其更加<strong>生动饱满</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 图标主要有填充型和线条型，不要混用</div><p><strong>②图案</strong></p><blockquote><p><strong>不同风格</strong>使用<strong>不同的素材</strong>修饰，使其更加<strong>饱满</strong>，比如<strong>中国风</strong>有<strong>笔刷</strong>、<strong>祥云</strong>、<strong>卷轴</strong>等</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 也可以将ppt中的某些形状、边框等替换为类似的素材</div><p><strong>③素材网站</strong></p><blockquote><p><strong>图标</strong>：<a href="https://www.flaticon.com/">flaticon</a>、<a href="https://iconpark.oceanengine.com/official">iconpark</a></p></blockquote><blockquote><p><strong>图案</strong>：<a href="https://www.freepik.com/">freepik</a>、<a href="https://huaban.com/">花瓣网</a>、<a href="https://www.zcool.com/">zcool</a>、<a href="www.pinterest.com">pinterest</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT制作（进阶篇）</title>
      <link href="/2023/11/07/ppt-zhi-zuo-jin-jie-pian/"/>
      <url>/2023/11/07/ppt-zhi-zuo-jin-jie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="PPT制作（进阶篇）"><a href="#PPT制作（进阶篇）" class="headerlink" title="PPT制作（进阶篇）"></a>PPT制作（进阶篇）</h1><h2 id="一、封面页"><a href="#一、封面页" class="headerlink" title="一、封面页"></a>一、封面页</h2><h3 id="1-标题排版"><a href="#1-标题排版" class="headerlink" title="1.标题排版"></a>1.标题排版</h3><p><strong>1.1换行有节奏</strong>：当标题过长时，可以将标题分为多行，每一行要<strong>完整且相对独立</strong>，且<strong>长短交错</strong>，否则会很呆板<br><strong>1.2对比有重点</strong>：使标题有层次感，突出重点<br>①调粗细：粗体（Bold）用于标题，标准（Regular）用于副标题、正文（比如说汇报人什么什么<br>②变大小：一般来说标题为第一层级，副标题为第二层级，正文为第三层级，不同信息层级字体大小成<strong>倍数关系</strong>，如（60-20-15）<br>③换颜色：将标题字体颜色更换为<strong>PPT主色</strong>，可以采用渐进色进行修饰<br>④改间距：调整各个层级之间的间距使其不要太拥挤<br>⑤特殊效果：如倾斜、错位排版等<br>#倾斜：选中文本框→形状格式→文本效果→转换→正方形→拖动控点控制文字的倾斜角度</p><h3 id="2-背景图片"><a href="#2-背景图片" class="headerlink" title="2.背景图片"></a>2.背景图片</h3><p><strong>2.1图片网站</strong><br>①unsplash.com<br>②<a href="http://www.pexels.com/">www.pexels.com</a><br>③pixabay.com<br><strong>2.2图片选择</strong><br>①语意关联：根据<strong>关键词</strong>寻找配图<br>②留白空间：根据标题的排版，选择一张对应位置有留白的图片<br>③色调匹配：图片色调要和PPT主色相符合</p><h3 id="3-构图形式"><a href="#3-构图形式" class="headerlink" title="3.构图形式"></a>3.构图形式</h3><p><strong>3.1布局选择</strong><br>①居中构图：当图片为上下构图时，采用居中布局，图片主体占图片的1/3<br>②居左布局：图片为左右构图时，采用居左布局，图片主体占图片的1/2<br>③根据图片留白放置标题<br><strong>tips：可以通过裁剪，获得想要的留白空间</strong><br><strong>3.2图形凸显</strong>：降低图片对文字的干扰<br>①色块：使用<strong>一定颜色的形状</strong>作为图片的衬底，调整透明度使其更为自然<br>②蒙版：渐变透明的蒙版<br>#全屏蒙版：插入全屏矩形→选择<strong>线性渐变</strong>→渐变方向<strong>根据封面布局</strong>选择，比如居中布局采用自上而下，居左布局采用自左向右→光圈颜色选择背景图片的主色→将<strong>非文字区域</strong>的光圈透明度调整为100→调整光圈位置，使其更加自然<br>#局部蒙版：插入刚好能覆盖文案的形状（比较推荐椭圆）→设置为无轮廓→选择<strong>路径渐变</strong>→光圈颜色采用图片的主色→右侧光圈透明度调节为100→调整光圈位置，将<strong>图片置于底层</strong><br><strong>tips：如果觉得蒙版破坏了图片主体，可以将图片主体扣出来</strong><br><strong>等距缩放，为了让左右和上下的边距相等，可以创建一个小正方形，置于形状的左上角，按住ctrl键缩放即可</strong></p><h2 id="二、排版"><a href="#二、排版" class="headerlink" title="二、排版"></a>二、排版</h2><h3 id="1-文字排版"><a href="#1-文字排版" class="headerlink" title="1.文字排版"></a>1.文字排版</h3><p><strong>1.1对齐</strong>：不要使用首行缩进，这样会导致文本不够饱满，最好采用<strong>两端对齐</strong><br><strong>1.2调整间距</strong><br>①本身：标题字号较大，采用1.0倍行距，正文字号比较小，采用1.2-1.5倍行距<br>②相互：<strong>标题和正文间距＞段落间距＞行间距＞字间距</strong><br>#可以采用<strong>分隔线</strong>突出重点段落，比如副标题<br><strong>1.3控制行长</strong>：行长最好<strong>略小于页面的二分之一</strong>，可以采用多段左右、上下分布，<strong>避免出现独字</strong></p><h3 id="2-内容排版"><a href="#2-内容排版" class="headerlink" title="2.内容排版"></a>2.内容排版</h3><p><strong>2.1梳理文案信息</strong><br>①分段：将一段文字内容分为<strong>独立的几个维度</strong><br>②精简：删除<strong>连接词和重复词语</strong>，提炼核心内容<br>③凸显层级和重要内容：大小对比、颜色对比、粗细对比、距离对比、下划线、色块、字体对比<br><strong>2.2确定版式布局</strong><br>①统一版心，利用<strong>参考线</strong>确定标题区域和正文区域<br>#可以先创建一个全屏矩形，然后等比缩放，调节至合适大小，分布在ppt四角<strong>确定留白区域</strong>，随后在非留白区域确定标题位置和正文位置，标题位置和正文位置之间<strong>相隔一个标题高度</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_1.png" alt="统一版心"><br>②内容分块：利用<strong>色块、形状</strong>等根据文案信息对正文位置进行分块<br>#注意色块、形状等<strong>修饰内容可以占用留白区域</strong>，只要正文内容按照格式排版即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_2.png" alt="内容分块"><br><strong>2.3内容可视化</strong><br>①图标：给小标题增加合适的图标<br>#素材网站:<a href="https://www.flaticon.com/">https://www.flaticon.com/</a> <a href="https://iconpark.oceanengine.com/official">https://iconpark.oceanengine.com/official</a> <a href="http://www.iconfont.cn/">www.iconfont.cn</a><br>#可以将图标截图，并将<strong>位图转化为矢量图</strong>，这样就可以在ppt中修改格式了<br>②图片：给<strong>文本块</strong>增加对应的图片背景等<br>③逻辑图示：流程图、带有<strong>关系暗示</strong>的图形等等<br>#并列、包含、流程、循环和层级<br>#素材网站：<a href="https://www.freepik.com/">https://www.freepik.com/</a><br><strong>2.4实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_3.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_4.png" alt="实例二"></p><h3 id="3-多点排版"><a href="#3-多点排版" class="headerlink" title="3.多点排版"></a>3.多点排版</h3><p><strong>3.1中心环绕式布局</strong><br>①全圆式布局：段落数量为<strong>偶数</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_5.png" alt="全圆式布局"><br>②半圆式布局：段落数量为<strong>奇数</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_6.png" alt="半圆式布局"><br>#可以利用等比例缩放绘制圆辅助线，并<strong>利用对齐</strong>将段落点贴近辅助线<br><strong>3.2确定中心点样式</strong><br>①基本形状：并不一定要局限于圆形，还可以是其他多边形<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_7.png" alt="基本图形"><br>②图片素材：选取符合主题的图片<br><strong>3.3丰富层次</strong><br>①文本层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_9.png" alt="文本层次"><br>②图形层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_8.png" alt="图形层次"></p><h3 id="4-多图排版"><a href="#4-多图排版" class="headerlink" title="4.多图排版"></a>4.多图排版</h3><p><strong>4.1尺寸</strong>：图片格式→裁剪→纵横比，将图片裁剪为比例一致的图片，然后再调整大小<br><strong>4.2间距</strong>：利用<strong>对齐</strong>，注意<strong>图片之间</strong>的间距要小于<strong>图片和页面之间</strong>的间距<br><strong>4.3效果</strong><br>①形状：将图片裁剪为特定形状，图片格式→裁剪→形状<br>②轮廓：给图片加上边框<br>③阴影：ctrl拖动复制图片→图片格式→艺术效果→虚化→调整虚化半径（调整为90）→柔化边缘→将该图片拖动到原图片底部<br>④映像：ctrl拖动复制图片→图片格式→映像效果→选择第一个预设→调整映像大小→增加模糊度<br>#可以设置好一张图片效果，然后采用<strong>格式</strong>刷快速复制<br><strong>4.4创意排版</strong><br>①瀑布流<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_10.png" alt="瀑布流"><br>②三维旋转<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_11.png" alt="平行预设"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_12.png" alt="角度预设"><br><strong>#要将光源改为对比</strong>，防止过曝</p><p><strong>5.创意排版</strong><br><strong>5.1分栏排版</strong>：利用<strong>色块、图片等</strong>将不同维度内容分隔开<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_34.png" alt="分栏排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_35.png" alt="示例"><br><strong>5.2拦腰排版</strong>：用于需要突出重点内容的<strong>总分关系</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_36.png" alt="拦腰排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_37.png" alt="示例"><br><strong>5.3卡片排版</strong>：变种的分栏排版，注意卡片组合起来要是一个规整的矩形（可以有无内容色块），<strong>形状和间距相同</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_38.png" alt="拦腰排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_39.png" alt="示例"></p><p>#配色可以采用主色+<strong>黑白灰</strong>/主色的梯度色<br>#当内容不够饱满时，可以插入<strong>图片</strong></p><h2 id="三、特殊要素"><a href="#三、特殊要素" class="headerlink" title="三、特殊要素"></a>三、特殊要素</h2><h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1.表格"></a>1.表格</h3><p><strong>1.1大小</strong><br>①整体大小：要<strong>占满版心</strong><br>②单元格大小：全选表格→<strong>布局选项卡</strong>调整单元格高度→然后双击单元格的<strong>竖边</strong>，使得<strong>单元格宽度匹配文本宽度</strong><br><strong>1.2样式</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_13.png" alt="表格样式"><br>①选择<strong>无样式</strong>的表格样式，随后自己编辑<br>②线条型表格的<strong>内部框线不宜太粗</strong>，防止喧宾夺主，<strong>表头</strong>、<strong>表尾</strong>和<strong>分割表格</strong>的框线可以适当增粗<br>③色块型表格，可以在表格<strong>底部</strong>添加<strong>对应大小颜色</strong>的色块，也可以对表格进行颜色填充，但是后者是对<strong>每个单元格</strong>进行对应填充且<strong>不能改变形状</strong>，在使用渐变色时还是使用前者<br><strong>1.3对齐</strong>：文本左对齐，数据右对齐<br>①如果遇到小数，位数要统一<br>②文本内容过多，可以分点介绍<br><strong>1.4突出重点</strong>：粗细、颜色、衬底<br><strong>1.5可视化</strong><br>①文本可视化：利用图标、图片代替文字或者作为背景<br>②数据可视化：比如百分比可以利用对应的进度条和饼状图代替<br><strong>1.6实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_14.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_15.png" alt="实例二"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_16.png" alt="实例三"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_17.png" alt="实例四"></p><h3 id="2-时间轴"><a href="#2-时间轴" class="headerlink" title="2.时间轴"></a>2.时间轴</h3><p><strong>2.1时间轴线</strong><br>①直线：渐变、箭头<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_18.png" alt="直线"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_21.png" alt="示例"><br>②不规则线条：曲线、折线<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_19.png" alt="曲线绘制"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_20.png" alt="示例"><br>#注意其中的技巧三，可以在<strong>ppt画面之外</strong>使其形成一个封闭图形，并进行<strong>颜色填充</strong>，如示例所示<br>③实物元素<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_22.png" alt="实物元素"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_23.png" alt="示例"><br><strong>2.2节点</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_24.png" alt="节点"><br>①还可以使用图标<br>②节点<strong>外发光</strong>效果：去除线条→<strong>偏移为中</strong>的<strong>阴影</strong>预设→透明度将为0→调整<strong>大小</strong>从而调节发光范围<br>③节点<strong>内发光</strong>效果：<strong>射线</strong>渐变→方向改为<strong>从中心</strong>→<strong>左侧</strong>光圈改为<strong>背景色</strong>，调整为<strong>完全透明</strong>→调整光圈位置即可<br><strong>2.3文案排版</strong><br>①文本层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_9.png" alt="文本层次"><br>②文本修饰：在节点和文案之间添加<strong>直线</strong>等元素进行<strong>联系</strong></p><h3 id="3-架构图"><a href="#3-架构图" class="headerlink" title="3.架构图"></a>3.架构图</h3><p><strong>3.1确定走向</strong><br>①自上而下：适合分支较<strong>少</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_25.png" alt="示例"><br>②自左向右：适合分支较<strong>多</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_26.png" alt="示例"><br>③中心扩散：适合分支较<strong>多</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_27.png" alt="示例"><br><strong>3.2元素形状</strong><br>①衬底图形<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_28.png" alt="衬底图形"><br>#还可以将这些基本图形<strong>结合</strong>到一起形成新的衬底<br>②连接线条<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_29.png" alt="连接线条"><br>#其中曲线型连接可以采用<strong>花括号</strong>和箭头等组合而来<br>#可以在形状格式中修改箭头、花括号的<strong>末端形状</strong><br><strong>3.3区分层级</strong><br>①颜色对比：不同层级采用不同的颜色（最好<strong>梯度色</strong>），其中衬底颜色和文字颜色<strong>色调要相反</strong>，即衬底为深色，文字就要为浅色<br>②虚实对比：当层级过多，颜色对比不够用时，末端可以采用<strong>无填充、虚线框</strong>的形式<br>③形状对比<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_30.png" alt="示例"></p><h3 id="4-图表"><a href="#4-图表" class="headerlink" title="4.图表"></a>4.图表</h3><p><strong>4.1确定样式</strong><br>①柱形图：大小比较，项目名较短<br>②条形图：大小比较，项目名较长<br>③饼状图：占比关系<br>④环形图表：占比关系，可以使用弧形和圆组合而成，调<strong>粗</strong>其线宽，改变其<strong>线端类型</strong>，将弧形置于顶层即可<br>⑤折线图：变化趋势</p><p>#直接<strong>插入图表</strong>即可<br><strong>4.2图标优化</strong><br>①柱/条形图</p><ul><li>弱化或者删除<strong>网格</strong>、<strong>图例</strong>和<strong>坐标轴</strong>元素</li><li>间隙宽度<strong>50%-100%</strong></li><li>突出重点，利用<strong>颜色</strong>和<strong>色块衬底</strong>即可</li></ul><p>②饼状图</p><ul><li>扇面<strong>从大到小顺时针排序</strong></li><li>扇面配色避免花哨，使用<strong>梯度色</strong>即可</li></ul><p>③折线图</p><ul><li>弱化或者删除<strong>网格</strong>、<strong>图例</strong>和<strong>坐标轴</strong>元素</li><li>如果无需精确呈现数据时，可使用<strong>平滑线</strong>（右击→设计数据系列格式→填充与线条→勾选平滑线选项）</li><li>可以将其改变为<strong>面积图</strong>，对其进行<strong>渐变填充</strong>，但是如果要使用<strong>平滑线</strong>的话，不能将其改变为面积图，应该先将其改变为<strong>平滑线</strong>→新建一页，将图表<strong>选择性粘贴</strong>为<strong>图片（增强型图元文件）</strong>→取消组合，提取曲线→利用曲线和目标颜色色块进行<strong>组合拆分</strong>，将对应颜色色块裁剪为目标形状<strong>填充回原幻灯片</strong>即可</li></ul><p>#图表不仅仅局限于ppt图表自带的修饰，还可以自己利用<strong>线条、形状</strong>等素材对图表进行修饰，比如说用<strong>文本框</strong>代替图表原本的<strong>标题</strong>，用色块和文本框代替图例等<br>#可以使用<strong>数据标签</strong>代替纵轴</p><p><strong>4.3布局</strong><br>①单个图表：占满版心即可<br>②多个图表：利用<strong>色块</strong>对页面进行分区，将图表放在对应的色块中</p><p><strong>4.4实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_31.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_32.png" alt="实例二"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_33.png" alt="实例三"></p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
            <tag> 软技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客搭建</title>
      <link href="/2023/11/07/hexo-bo-ke-kuang-jia-da-jian-yi-ji-ge-xing-hua/"/>
      <url>/2023/11/07/hexo-bo-ke-kuang-jia-da-jian-yi-ji-ge-xing-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo个人博客搭建"><a href="#Hexo个人博客搭建" class="headerlink" title="Hexo个人博客搭建"></a>Hexo个人博客搭建</h2><h3 id="1-博客部署"><a href="#1-博客部署" class="headerlink" title="1.博客部署"></a>1.博客部署</h3><h4 id="1-1环境配置"><a href="#1-1环境配置" class="headerlink" title="1.1环境配置"></a>1.1环境配置</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 安装hexo的依赖</div><p><strong>①windows环境</strong></p><blockquote><p>安装<code>Node.js</code>和<code>Git</code>，并通过<code>xx -v</code>检测其是否在<strong>环境变量</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果不在，则需要手动将其bin文件夹路径添加到系统变量中的path变量中</div><blockquote><p>设置<code>npm</code>的<strong>镜像源</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 查看npm的配置npm config list# 默认源npm config set registry https://registry.npmjs.org# 临时改变镜像源npm --registry=https://registry.npm.taobao.org# 永久设置为淘宝镜像源npm config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②Linux环境</strong></p><blockquote><p>安装<code>Node.js</code>和<code>Git</code>，若使用<strong>源码安装</strong>，则需要添加<strong>软链接</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于windows的环境变量，Linux在指定位置找对应的命令</div><blockquote><p>设置<code>npm</code>的<strong>镜像源</strong>，<strong>同上</strong></p></blockquote><h4 id="1-2Hexo配置"><a href="#1-2Hexo配置" class="headerlink" title="1.2Hexo配置"></a>1.2Hexo配置</h4><p><strong>①Hexo安装</strong></p><blockquote><p>在<code>git bash/shell</code>中输入<code>npm install -g hexo-cli</code></p></blockquote><p><strong>②博客初始化</strong></p><blockquote><p>选择一个<strong>位置</strong>用于存放<strong>博客文件夹</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#新建文件夹mkdir &lt;新建文件夹的名称&gt; #初始化文件夹hexo init &lt;新建文件夹的名称&gt;#在该文件夹中安装博客所需要的依赖文件cd &lt;新建文件夹的名称&gt;npm install <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3GitHub设置"><a href="#1-3GitHub设置" class="headerlink" title="1.3GitHub设置"></a>1.3GitHub设置</h4><p><strong>①创建仓库</strong></p><blockquote><p><strong>名字</strong>必须是<code>&lt;用户名&gt;.github.io</code></p></blockquote><p><strong>②配置Git用户名和邮箱</strong></p><blockquote><p>如果<strong>之前配置过</strong>则<strong>不用配置</strong>，否则需要配置</p></blockquote><h4 id="1-4本地文件夹与GitHub建立连接"><a href="#1-4本地文件夹与GitHub建立连接" class="headerlink" title="1.4本地文件夹与GitHub建立连接"></a>1.4本地文件夹与GitHub建立连接</h4><p><strong>①插件安装</strong></p><blockquote><p>在<strong>博客目录</strong>下的<code>git bash/shell</code>中输入命令<code>npm install hexo-deployer-git --save</code></p></blockquote><p><strong>②SSH密钥设置</strong></p><blockquote><p>并在<code>git bash/shell</code>中输入<code>ssh -T git@github.com</code>测试是否连接成功</p></blockquote><p><strong>③修改Hexo配置文件</strong></p><blockquote><p>打开<code>_config.yml</code>，滑到<strong>文件最底部</strong>，填入<strong>如下代码</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">type: gitrepo: git@github.com:Github用户名/github用户名.github.io.git  //也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git            branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④上传博客</strong></p><blockquote><p>在<strong>博客目录</strong>下的<code>git bash/shell</code>中输入<strong>命令</strong><code>hexo d</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 上传成功后，在浏览器中打开https://&lt;用户名&gt;.github.io，即可查看上传的网页</div><hr><h3 id="2-博客个性化"><a href="#2-博客个性化" class="headerlink" title="2.博客个性化"></a>2.博客个性化</h3><h4 id="2-1主题设置"><a href="#2-1主题设置" class="headerlink" title="2.1主题设置"></a>2.1主题设置</h4><p><strong>①主题安装</strong></p><blockquote><p>在<strong>博客目录</strong>下的<code>git bash/shell</code>中输入如下<strong>命令</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里选择的是matery主题，有两个版本，稳定版本和最新版本 (不定期更新优化)，自主选择版本</div><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/blinkfox/hexo-theme-matery themes/matery     # 稳定版git clone -b develop https://github.com/blinkfox/hexo-theme-matery themes/matery   #最新版(不定期进行优化更新)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②修改博客主题</strong></p><blockquote><p>将<strong>博客配置文件</strong><code>_config</code>中的<code>theme</code>值修改为<strong>下载主题</strong>的<strong>文件夹名</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其他博客配置文件修改可见官网</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 修改博客配置文件后要运行执行hexo clean &amp;&amp; hexo g，重新生成博客文件</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意博客配置文件在博客根目录下，对应主题也有相应配置文件在主题文件夹中</div><h4 id="2-2插件配置"><a href="#2-2插件配置" class="headerlink" title="2.2插件配置"></a>2.2插件配置</h4><p><strong>①代码高亮</strong></p><blockquote><p><strong>安装</strong>：在<strong>博客文件夹</strong>下<code>git bash/shell</code>中运行<code>npm i -S hexo-prism-plugin</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 单行代码使用`包围，多行代码使用```包围</div><blockquote><p><strong>配置</strong>：修改<strong>博客配置文件</strong>下<code>_config.yml</code>文件中<code>highlight.enable</code>的值为<code>false</code>，并新增以下<strong>配置项</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">prism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②搜索</strong></p><blockquote><p><strong>下载</strong>：<code>npm install hexo-generator-search --save</code></p></blockquote><blockquote><p><strong>配置</strong>：在<strong>博客配置文件</strong>中，新增以下的<strong>配置项</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>③中文链接转拼音</strong></p><blockquote><p><strong>下载</strong>：<code>npm i hexo-permalink-pinyin --save</code></p></blockquote><blockquote><p><strong>配置</strong>：在<strong>博客配置文件</strong>中，新增以下的<strong>配置项</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">permalink_pinyin:  enable: true  separator: '-' # default: '-'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>④文章字数统计插件</strong></p><blockquote><p><strong>下载</strong>：<code>npm i --save hexo-wordcount</code></p></blockquote><blockquote><p><strong>配置</strong>：在<strong>博客配置文件</strong>中，新增以下的<strong>配置项</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3自定义标签设置"><a href="#2-3自定义标签设置" class="headerlink" title="2.3自定义标签设置"></a>2.3自定义标签设置</h4><p><strong>①步骤</strong></p><blockquote><p>在<strong>主题目录下</strong>新建<code>scripts</code>目录，并<strong>此目录下</strong>新建<code>block.js</code>文件，填入<strong>以下代码</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">hexo.extend.tag.register('wrong', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-danger"&gt;&lt;i class="fas fa-exclamation-triangle"&gt;&lt;/i&gt; ' + formattedContent + '&lt;/div&gt;';  }, {ends: true});    hexo.extend.tag.register('right', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-success"&gt;&lt;i class="fa fa-check-circle"&gt;&lt;/i&gt; ' + formattedContent + '&lt;/div&gt;';  }, {ends: true});    hexo.extend.tag.register('warning', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-warning"&gt;&lt;i class="fa fa-exclamation-circle"&gt;&lt;/i&gt; ' + formattedContent + '&lt;/div&gt;';  }, {ends: true});  hexo.extend.tag.register('list', function(args, content){    var className =  args.join(' ');    var formattedContent = content.replace(/\n/g, '&lt;br&gt;');  // 将换行符替换为 &lt;br&gt; 标签    return '&lt;div class="uk-alert uk-alert-list"&gt;&lt;i class="fas fa-list-ul"&gt;&lt;/i&gt; ' +'&lt;br&gt;'+formattedContent + '&lt;/div&gt;';  }, {ends: true});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在<code>head.ejs</code>文件<strong>添加</strong>以下<code>css</code>样式：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">   &lt;style type="text/css"&gt;       .uk-alert {           margin-bottom: 5px;           padding: 5px;           background: #ebf7fd;           color: #2d7091;           border: 0px solid #ffffff;           border-radius: 4px;           text-shadow: 0 1px 0 #ffffff;       }       .uk-alert-success {           background: rgba(120, 199, 9, 0.1);           color: rgba(120, 199, 9);           border-left: 6px solid rgba(120, 199, 9);           font-weight: 600;       }       .uk-alert-warning {           background: #FFF8E9;           color: #FFB91F;           border-left: 6px solid #FFB91F;           font-weight: 600;       }       .uk-alert-danger {           background: #FFE6E6;           color: #FF7979;           border-left: 6px solid#FF7979;           font-weight: 600;       }       .uk-alert-list {           background: #ECF7FE;           color: #3CACF4;           border-left: 6px solid#3CACF4;           font-weight: 600;       }&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②解析</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以warning部分作为例子</div><blockquote><p><strong><code>block.js</code>文件</strong>：其中<code>warning</code>决定了<strong>正文中的书写格式</strong>；<code>div class</code>决定了<strong>容器（背景）的名字</strong>；<code>i class</code>决定了<strong>图标的样式</strong></p></blockquote><blockquote><p><strong><code>head.ejs</code>文件</strong>：主要决定<strong>网页表现</strong>出的<strong>具体样式</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 详细可询问ChatGPT</div><p><strong>③示例</strong></p><pre class="line-numbers language-none"><code class="language-none">{%wrong%}错误{%endwrong%}{%right%}正确{%endright%}{%warning%}警告{%endwarning%}{%list%}列表项{%endlist%}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 错误</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 正确</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 警告</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 列表项</div><hr><h3 id="3-博客书写"><a href="#3-博客书写" class="headerlink" title="3.博客书写"></a>3.博客书写</h3><h4 id="3-1Front-matter"><a href="#3-1Front-matter" class="headerlink" title="3.1Front-matter"></a>3.1Front-matter</h4><blockquote><p>在<strong>博客根目录</strong>下<code>scaffolds</code>文件夹下新增/修改<code>post.md</code>文件，即可修改<strong>默认样式</strong>，<strong>详细样式</strong>如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">title: 文章名称seo_title: seo名称toc: true            # 是否生成目录indent: true         # 是否首行缩进comments: true       # 是否允许评论archive: true        # 是否显示在归档cover: false         # 是否显示封面mathjax: false       # 是否渲染公式pin: false           # 是否首页置顶top_meta: false      # 是否显示顶部信息bottom_meta: false   # 是否显示尾部信息sidebar: [toc]tag:  - 标签一  - 标签二categories: 分组keywords: 文章关键词date: 2021-13-13 00:00updated: 2021-13-13 00:00description: 文章摘要icons: [fas fa-fire red, fas fa-star green]references:  - title: 参考资料名称    url: https://参考资料地址headimg: https://文章头图thumbnail: https://右侧缩略图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2正文修饰"><a href="#3-2正文修饰" class="headerlink" title="3.2正文修饰"></a>3.2正文修饰</h4><p><strong>①标题</strong></p><blockquote><p><code>#</code>为<strong>一级标题</strong>，<code>##</code>为<strong>二级标题</strong>,以此类推</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最多六级，且#和文字之间要有空格</div><p><strong>②加粗与倾斜</strong></p><pre class="line-numbers language-none"><code class="language-none">*[文本]* #倾斜**[文本]** #加粗***[文本]*** #加粗倾斜<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>③引用</strong></p><blockquote><p><code>&gt;</code>后添加<strong>空格</strong>和<strong>引用内容</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的引用以及正文使用换行隔开</div><pre class="line-numbers language-none"><code class="language-none">&gt; 树1&gt; 树2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>树1</p></blockquote><blockquote><p>树2</p></blockquote><p><strong>④超链接</strong></p><blockquote><p><strong>格式</strong>：<code>[Link Text](link-address)</code></p></blockquote><p><a href="http://106.15.109.213/2020/07/25/markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/#6-%E5%BC%95%E7%94%A8%E6%AE%B5%E8%90%BD">参考文章</a></p><p><strong>⑤插入图片</strong></p><pre class="line-numbers language-none"><code class="language-none">#单张图片！[Figure](URL www.xxx.com)#figure此处的文字有时作为图片标题显示，有时不显示，optional，可留空#URL处也可以不填写url，也可以选择上传本地图片，此时只需填写相对路径即可，#相对路径指的是在与此markdown文档同路径下的相对路径，可在此md文档同路径下新建img文件夹，#在此处填/img/xx.png 具体情况具体分析，或许在主题配置文件中亦有提及*#多张图片{% gi total n1-n2-... %}  ![](url)  ![](url)  ![](url)  ![](url)  ![](url){% endgi %}#total为图片总的数量,n1为第一行的图片数量,n2为第二行的图片数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑥锚点</strong></p><blockquote><p><strong>格式</strong>：<code>[显示内容](#标题)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 锚点与链接基本相同，区别在于锚点是在文章内部相互传送，但只能传送到n级标题的位置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 注意此处#代表的是‘标题’这一性质，而非标题的级别，因此不必加n个#来体现标题等级</div>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 静态博客框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（三）</title>
      <link href="/2023/11/07/python-xue-xi-bi-ji-san/"/>
      <url>/2023/11/07/python-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（三）"><a href="#python学习笔记（三）" class="headerlink" title="python学习笔记（三）"></a>python学习笔记（三）</h1><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="1-文件路径"><a href="#1-文件路径" class="headerlink" title="1.文件路径"></a>1.文件路径</h3><p><strong>1.1定义：</strong>指明了文件在计算机上的<strong>位置</strong>，可分为<strong>绝对路径</strong>和<strong>相对路径</strong><br>①绝对路径：从<strong>根文件夹</strong>开始的完整路径<br>②相对路径：相对于程序的<strong>当前工作目录</strong>的路径</p><blockquote><p>windows上采用<code>\</code>作为文件夹之间的分隔符，Linux上和OS X上采用<code>/</code>作为文件夹之间的分隔符</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了程序的可移植性，采用python中os模块中的方法获取文件路径</div><p><strong>1.2获取</strong><br>①通过<code>os</code>模块获取</p><blockquote><p><code>os.path.join()</code>：将单个文件和路径上的文件夹名称的字符串传递给它，<code>os.path.join()</code>就会返回一个文件路径的字符串<br><code>os.getcwd()</code>：可以取得<strong>当前工作路径</strong>的<strong>字符串</strong>，并可以利用<code>os.chdir()</code>改变它<br><code>os.path.abspath(path)</code>：将返回参数（相对路径的<strong>字符串</strong>）的绝对路径的<strong>字符串</strong><br><code>os.path.dirname()</code>：获取文件绝对路径的目录部分</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果要获得路径的每一个文件夹的名称，可以使用'[路径]'.split(os.path.sep)</div><p>②使用<code>sys</code>模块</p><blockquote><p><code>sys.argv[0]</code>：获取当前脚本的路径（包括文件名）。<br><code>sys.path[0]</code>：获取当前脚本所在的目录路径。</p></blockquote><p>③使用<code>__file__</code>变量：包含了<strong>当前模块</strong>（脚本）的路径（包括文件名）</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该变量只在一个独立的模块（脚本）中才有定义</div><pre class="line-numbers language-none"><code class="language-none">import osimport sys# 获取当前工作目录current_directory = os.getcwd()print("当前工作目录:", current_directory)# 获取文件的绝对路径absolute_path = os.path.abspath('file.txt')print("文件的绝对路径:", absolute_path)# 拼接目录和文件名，返回完整路径full_path = os.path.join('dir', 'file.txt')print("完整路径:", full_path)# 获取当前脚本的路径script_path = sys.argv[0]print("当前脚本的路径:", script_path)# 获取当前脚本所在的目录路径script_directory = os.path.dirname(os.path.abspath(__file__))print("当前脚本所在的目录路径:", script_directory)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3有效性检查</strong></p><blockquote><p><code>os.path.exists(path)</code>：如果path参数所指的文件或文件夹存在，返回True<br><code>os.path.isfile(path)</code>：如果path参数存在，并且是一个文件，返回 True<br><code>os.path.isdir(path)</code>：如果path参数存在，并且是一个文件夹，返回Ture</p></blockquote><h3 id="2-文件处理"><a href="#2-文件处理" class="headerlink" title="2.文件处理"></a>2.文件处理</h3><p><strong>2.1打开文件</strong><br>①<code>open()</code>： 向它传递一个<strong>字符串</strong>路径，返回一个<code>File</code>对象，还可传入对应参数指定<strong>操作模式</strong>和<strong>编码方式</strong>，默认是<strong>读模式</strong>和<strong>操作系统默认的编码</strong><br>②操作模式：不同的操作模式有不同的规则</p><blockquote><p><code>'r'</code>：以只读模式打开文件（默认模式），文件指针位于文件的开头，如果文件不存在，则会引发FileNotFoundError。<br><code>'w'</code>：以写入模式打开文件，如果文件已存在，则会被清空。如果文件不存在，则会创建一个新文件。<br><code>'a'</code>：以追加模式打开文件，文件指针位于文件的末尾。如果文件不存在，则会创建一个新文件。<br><code>'x'</code>：以独占写入模式打开文件，如果文件已存在，则会引发FileExistsError。<br><code>'b'</code>：以二进制模式打开文件，可以与其他模式一起使用，例如’rb’或’wb’。<br><code>'t'</code>：以文本模式打开文件（默认模式），可以与其他模式一起使用，例如’rt’或’wt’。<br><code>'+'</code>：以读写模式打开文件，可以与其他模式一起使用，例如’r+’、’w+’或’a+’。</p></blockquote><p>③编码方式：通过<code>encoding</code>参数指定编码，常见的编码方式有<code>ASCII</code>、<code>UTF-8</code>等，选择编码方式时，应根据需求考虑文件中包含的<strong>字符范围、语言以及平台兼容性</strong>等因素</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果文件使用的编码方式与指定的编码方式不匹配，可能会导致读取或写入的数据出现错误</div><p>④如果<code>open</code>函数指定的文件并<strong>不存在或者无法打开</strong>，那么将引发异常状况导致程序崩溃，需要对其进行检查，此外，执行完业务逻辑后，需要<strong>及时对目标文件进行释放</strong>，可以使用python中的异常机制</p><blockquote><p>文件找不到会引发<code>FileNotFoundError</code>，指定了未知的编码会引发<code>LookupError</code>，而如果读取文件时无法按指定方式解码会引发<code>UnicodeDecodeError</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">def main():    f = None    try:        f = open('致橡树.txt', 'r', encoding='utf-8')        print(f.read())    except FileNotFoundError:        print('无法打开指定的文件!')    except LookupError:        print('指定了未知的编码!')    except UnicodeDecodeError:        print('读取文件时解码错误!')    finally:        if f:            f.close()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.2文件读写</strong><br>①文件读取</p><blockquote><p><code>read()</code>：将整个文件的内容读取为一个<strong>字符串值</strong><br><code>for-in</code>循环：还可以使用<code>for-in</code>循环逐行读取文件<br><code>readlines</code>：将文件按行读取到一个列表容器中</p></blockquote><pre class="line-numbers language-none"><code class="language-none">import timedef main():    # 一次性读取整个文件内容    with open('致橡树.txt', 'r', encoding='utf-8') as f:        print(f.read())    # 通过for-in循环逐行读取    with open('致橡树.txt', mode='r') as f:        for line in f:            print(line, end='')            time.sleep(0.5)    print()    # 读取文件按行读取到列表中    with open('致橡树.txt') as f:        lines = f.readlines()    print(lines)    if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②文件写入：采用<code>write()</code>方法，该方法接收<strong>字符串</strong>，并将其写入到文件对象中</p><pre class="line-numbers language-none"><code class="language-none">file = open("example.txt", "w")file.write("Hello, World!")file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.3文件信息查询</strong><br>①<code>os.path.getsize(path)</code>将返回path参数中文件的<strong>字节数</strong><br>②<code>os.listdir(path)</code>将返回<strong>文件名字符串的列表</strong>，包含path参数中的每个文件<br><strong>2.4文件管理器</strong><br>①定义</p><blockquote><p>上下文：任务本身会对其环境进行保存，做到哪里了，做了多少，各种状态都会标识记录，从而形成了上下文环境，在切换时根据每个任务的上下文环境，继续执行，从而达到多任务</p></blockquote><blockquote><p>上下文管理器对象：即任何实现了<code>__enter__()</code>和 <code>__exit__()</code> 方法的类的对象实例</p></blockquote><p>②使用：<code>with 上下文表达式 as 对象</code></p><blockquote><p>其中<strong>上下文表达式</strong>是一个返回上下文管理器对象的函数调用<br>在进入语句块之前，上下文管理器的<code>__enter__</code>方法会被调用，可以在这个方法中执行资源的获取操作<br>在离开语句块时，无论是正常的退出还是发生异常，上下文管理器的<code>__exit__</code>方法都会被调用，可以在这个方法中执行资源的释放操作</p></blockquote><pre class="line-numbers language-none"><code class="language-none">with open('example.txt', 'r') as file:    data = file.read()    print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③with关键字的实现原理</p><pre class="line-numbers language-none"><code class="language-none">class File(object):    def __init__(self, filename, mode):        self.filename = filename        self.mode = mode        self.file = None    def __enter__(self):        """        进入with as 语句的时候被with调用        返回值作为 as 后面的变量        """        print("__enter__ called")        self.file = open(self.filename, self.mode)        return self.file    def __exit__(self, exc_type, exc_value, exc_traceback):        """        离开with语句的时候被with调用        """        print("__exit__ called")        print("exc_type: ", exc_type)        print("exc_value: ", exc_value)        print("exc_traceback: ", exc_traceback)        self.file.close()        print("文件关闭操作")def main():    with File("test.txt", "w") as f:        print("with 代码块")        f.write("hello python1")        f.write("hello python2")        # a = 1 / 0        f.write("hello python3")    print("with 语句结束")if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>进入上下文管理器会自动调用<code>__enter__(self)</code>，该方法的返回值会被赋值给<code>as</code>子句后的对象，该方法可以返回多个值，因此在<code>as</code>子句后面也可以指定多个变量（括起来组成元组）<br>退出上下文管理器自动调用<code>__exit__(self, exc_type, exc_value, exc_traceback)</code>，前三个参数在调用<code>__exit__()</code>方法时由Python解释器自动传递，并提供与异常相关的信息</p></blockquote><p>④<code>with</code>关键字和<code>try-except</code>联合调用</p><pre class="line-numbers language-none"><code class="language-none">def main():    try:        with open('guido.jpg', 'rb') as fs1:            data = fs1.read()            print(type(data))  # &lt;class 'bytes'&gt;        with open('吉多.jpg', 'wb') as fs2:            fs2.write(data)    except FileNotFoundError as e:        print('指定的文件无法打开.')    except IOError as e:        print('读写文件时出现错误.')    print('程序执行结束.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>with</code>语句的主要目的是确保上下文管理器的资源<strong>被正确释放</strong>，即使在发生异常的情况下也能保证资源的释放，而<code>try-except</code>语句主要用于处理异常，提供错误处理和容错机制</p></blockquote><h3 id="3-变量保存"><a href="#3-变量保存" class="headerlink" title="3.变量保存"></a>3.变量保存</h3><p><strong>3.1json模块</strong><br>①简介：是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于<strong>跨平台跨语言</strong>的数据交换</p><blockquote><p>因为JSON是<strong>纯文本</strong>，任何系统任何编程语言处理纯文本都是没有问题的</p></blockquote><p>②JSON的数据类型和Python的数据类型对应关系</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>dict</td><td>object</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True/False</td><td>true/false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table><p>③实例</p><pre class="line-numbers language-none"><code class="language-none">import jsondef main():    mydict = {        'name': '骆昊',        'age': 38,        'qq': 957658,        'friends': ['王大锤', '白元芳'],        'cars': [            {'brand': 'BYD', 'max_speed': 180},            {'brand': 'Audi', 'max_speed': 280},            {'brand': 'Benz', 'max_speed': 320}        ]    }    try:        with open('data.json', 'w', encoding='utf-8') as fs:            json.dump(mydict, fs)    except IOError as e:        print(e)    print('保存数据完成!')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>json</code>模块常用方法<br><code>dump()</code>：将Python对象按照JSON格式序列化到文件中<br><code>dumps()</code>：将Python对象处理成JSON格式的字符串<br><code>load()</code>：将文件中的JSON数据反序列化成对象<br><code>loads()</code>：将字符串的内容反序列化成Python对象</p></blockquote><p><strong>3.2shelve模块：</strong>可以将Python程序中的变量保存到<strong>二进制的shelf文件</strong>中，这样，程序就可以从硬盘中恢复变量的数据</p><pre class="line-numbers language-none"><code class="language-none">#保存变量import shelveshelfFile = shelve.open('mydata') #初始化一个shelf变量，类似于file变量，其中mydata为保存变量的文件cats = ['Zophie', 'Pooka', 'Simon']shelfFile['cats'] = cats #变量以类似于字典的形式存储shelfFile.close() #结束#访问变量shelfFile = shelve.open('mydata')shelfFile['cats'] #访问cats变量shelfFile.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（二）</title>
      <link href="/2023/11/07/python-xue-xi-bi-ji-er/"/>
      <url>/2023/11/07/python-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（二）"><a href="#python学习笔记（二）" class="headerlink" title="python学习笔记（二）"></a>python学习笔记（二）</h1><h2 id="python进阶"><a href="#python进阶" class="headerlink" title="python进阶"></a>python进阶</h2><h3 id="1-正则表达式（Regex）"><a href="#1-正则表达式（Regex）" class="headerlink" title="1.正则表达式（Regex）"></a>1.正则表达式（Regex）</h3><p><strong>1.1定义</strong>：一种<strong>只描述文本特征</strong>文本描述方法</p><blockquote><p>与正则表达式有关的函数在<strong>re模块</strong>中</p></blockquote><p><strong>1.2字符分类</strong><br>①默认字符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_8.png" alt="默认字符"><br>②自定义:[ijk]</p><blockquote><p>可以使用<code>-</code>表示字母或数字的范围，如[0-57-8]表示[012345678]</p></blockquote><p><strong>一般的</strong>正则表达式符号不会被解释，不需要使用转义字符<br>在的左方括号后加上一个插入字符<code>^</code>，就可以得到<strong>非字符类</strong>，即匹配不在这个字符类中的所有字符<br><strong>1.3步骤</strong><br>①<code>import re</code>导入re模块<br>②用<code>re.compile()</code>函数创建一个<strong>Regex对象</strong>（记得使用<strong>原始字符串</strong>）<br>③向Regex对象的<code>search()</code>方法传入想查找的字符串，它返回一个<strong>Match对象</strong><br>④调用Match对象的<code>group()</code>方法，返回实际匹配文本的<strong>字符串</strong></p><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') #phoneNumRegex是一个Regex对象mo = phoneNumRegex.search('My number is 415-555-4242.') #mo是一个Match对象print('Phone number found: ' + mo.group())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>1.4修饰符号</strong>:在<strong>初始化Regex对象</strong>时使用，如果想要匹配这这些字符，需要使用对应的<strong>转义字符</strong><br>①<code>()</code>：对Regex对象进行<strong>分组</strong></p><blockquote><p>group()函数可以提取对象的<strong>某一组内容</strong>，默认是0，即不考虑分组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')mo = phoneNumRegex.search('My number is 415-555-4242.')mo.group(1) #得到的结果是'415'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果想要一次就获取<strong>所有的分组</strong>，使用<code>groups()</code>方法，返回多个组对应的<strong>字符串元组</strong></p></blockquote><p>②<code>|</code>：表示匹配许多表达式<strong>中的一个</strong>即可</p><pre class="line-numbers language-none"><code class="language-none">heroRegex = re.compile (r'Batman|Tina Fey')mo1 = heroRegex.search('Batman and Tina Fey.')mo1.group() #结果是'Batman'，即第一次匹配到的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>可以利用<code>()</code>和<code>|</code>实现某部分确定，某部分可选的正则表达式，如<code>batRegex = re.compile(r'Bat(man|mobile|copter|bat)')</code></p></blockquote><p>③<code>?</code>:表明它<strong>前面的分组</strong>在这个模式中是<strong>可选的</strong></p><blockquote><p><code>batRegex = re.compile(r'Bat(wo)?man')</code>既匹配’Batwoman’，又匹配’Batman’</p></blockquote><p>④<code>*</code>：意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现<strong>任意次</strong>，包括0次</p><blockquote><p><code>batRegex = re.compile(r'Bat(wo)*man')</code>可以匹配’Batwowowowoman’和’Batman’</p></blockquote><p>⑤<code>+</code>：类似于<code>*</code>，但是<strong>至少要一次</strong><br>⑥<code>{}</code>：类似于<code>*</code>，用于指定<strong>特定次数</strong>，<code>{n}</code>表示匹配n次，<code>{i，j}</code>代表i-j次</p><blockquote><p>贪心和非贪心匹配:Python 的正则表达式<strong>默认是“贪心”</strong>的，这表示在有二义的情况下，它们会<strong>尽可能匹配最长的字符串</strong>，花括号的“非贪心”版本匹配尽可能最短的字符串，即在<strong>结束的花括号后跟着一个问号</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">greedyHaRegex = re.compile(r'(Ha){3,5}')mo1 = greedyHaRegex.search('HaHaHaHaHa')mo1.group() #结果是'HaHaHaHaHa'nongreedyHaRegex = re.compile(r'(Ha){3,5}?')mo2 = nongreedyHaRegex.search('HaHaHaHaHa')mo2.group() #结果是'HaHaHa'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⑦<code>^</code>/<code>$</code>：被搜索字符串必须以正则表达式对应的字符串<strong>开始/结束</strong><br>⑧<code>.</code>：匹配一个<strong>除了换行之外</strong>的所有字符</p><blockquote><p>传入<code>re.DOTALL</code>作为<code>re.compile()</code>的第二个参数，可以让句点字符匹配<code>所有字符</code>，包括换行字符</p></blockquote><p><strong>1.5拓展方法</strong><br>①<code>findall()</code>：不同于<code>search()</code>返回的Match对象只包含<code>第一次出现的匹配文本</code>，<code>findall()</code>将返回一<strong>字符串列表</strong>，包含被查找字符串中的<strong>所有匹配</strong></p><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groupsphoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')['415-555-9999', '212-555-0000']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果在正则表达式中有分组，那么findall将返回<strong>元组的列表</strong>，每个元组表示一个找到的匹配，其中的项就是正则表达式中每个分组的匹配字符串</p></blockquote><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)') # has groupsphoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')[('415', '555', '1122'), ('212', '555', '0000')]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>②<code>sub()</code>：传入两个参数，第一个参数是一个字符串，用于取代发现和正则表达式匹配的部分，第二个参数是一个正则表达式，返回替换完成后的字符串</p><pre class="line-numbers language-none"><code class="language-none">namesRegex = re.compile(r'Agent \w+')namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')#返回'CENSORED gave the secret documents to CENSORED.'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果只想改变和对应正则表达式相匹配的<strong>一部分</strong>，可以给正则表达式参数<strong>分组</strong>，并在第一个参数开头加上<code>\n</code>，代表该字符串只替代第n组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">agentNamesRegex = re.compile(r'Agent (\w)\w*')agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.')#返回结果是'A**** told C**** that E**** knew B**** was a double agent.'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③复杂的正则表达式</p><blockquote><p>可以可以向<code>re.compile()</code>传入变量<code>re.VERBOSE</code>，作为第二个参数，忽略正则表达式字符串中的空白符和注释<br>使用三重引号，可以将正则表达式定义放在多行中</p></blockquote><p>详细可见<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">参考文章</a></p><h3 id="2-并发编程"><a href="#2-并发编程" class="headerlink" title="2.并发编程"></a>2.并发编程</h3><p><strong>2.1相关概念</strong><br>①并发编程：让程序同时执行多个任务<br>②进程：操作系统中<strong>正在执行</strong>的程序</p><blockquote><p>操作系统以进程为单位分配存储空间，每个进程都有自己的<strong>地址空间</strong>、<strong>数据栈</strong>以及其他用于跟踪进程执行的<strong>辅助数据</strong><br>不同进程通过<strong>进程间通信机制</strong>（IPC）来实现数据共享，具体的方式包括<strong>管道</strong>、<strong>信号</strong>、<strong>套接字</strong>、<strong>共享内存区</strong>等</p></blockquote><p>③线程：进程中可以获得CPU调度的执行单元</p><blockquote><p>某个时刻能够获得CPU的只有唯一的一个<strong>线程</strong></p></blockquote><p><strong>2.2多进程</strong><br><a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.md">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（一）</title>
      <link href="/2023/11/07/python-xue-xi-bi-ji-yi/"/>
      <url>/2023/11/07/python-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（一）"><a href="#python学习笔记（一）" class="headerlink" title="python学习笔记（一）"></a>python学习笔记（一）</h1><h2 id="python启蒙"><a href="#python启蒙" class="headerlink" title="python启蒙"></a>python启蒙</h2><h3 id="1-基本元素"><a href="#1-基本元素" class="headerlink" title="1.基本元素"></a>1.基本元素</h3><p><strong>1.1表达式</strong>：python中最基本的执行结构，由“<strong>对象</strong>”和<strong>操作符</strong>组成，并返回<strong>一个对象</strong><br><strong>1.2对象</strong>：即被存储的数据，类似于C语言中的字面值，如<code>1</code>、<code>"cat"</code>、<code>1.23456e2</code>等<br>①当一个对象被声明后，会给其分配对应的ID（地址）和内存，且数据类型不能更改<br>②基本数据类型：整型（int）、浮点型（float）、字符串（strs）、布尔类型（bool）、复数类型（a+bj）</p><blockquote><p>可以使用<code>type()</code>检查数据类型</p></blockquote><p>③可变类型与不可变类型</p><blockquote><p>不可变类型是指对象一旦创建，内容就<strong>不能被更改</strong>，常见的不可变类型包括整数、浮点数、布尔值、字符串和元组等，其对应的变量只能被<strong>覆盖</strong></p></blockquote><blockquote><p>可变类型是指变量的值可以被更改，常见的可变类型包括列表、集合和字典等</p></blockquote><p><strong>1.3变量</strong><br>①取名规则</p><blockquote><p>只能是一个词<br>只能包含<strong>字母、数字和下划线</strong><br>不能以数字开头<br>不能使用<strong>关键词</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一个好的变量名包含了数据对应的信息，常见的命名格式有my_cat和MyCat</div><p>②变量的本质</p><blockquote><p>变量是对象的一个<strong>引用</strong>，本身也占用一定的内存（存储对象的地址）<br><strong>没有变量</strong>指向的<strong>对象</strong>会被<strong>回收</strong>（垃圾回收机制）<br>变量名代表的内存地址是<strong>变化的</strong>，是<strong>上次赋值时</strong>新数据所在的内存的地址，而C语言<strong>变量名所代表的地址是不变的</strong>，<strong>变化的是该地址内存单元的数据</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 所以说如果两个变量指向是同一个可变类型对象，改变其中一个，另一个也随之改变</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_7.png" alt="变量的本质"></p><p><strong>1.4操作符</strong><br>①数字操作符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_1.png" alt="数字操作符"></p><blockquote><p><code>+</code>可以用于<strong>拼接字符串</strong>，比如<code>'a'+'b'</code>结果是<code>'ab'</code><br><code>*</code>可以用于<strong>字符串复制</strong>，比如<code>'a'*5</code>结果时<code>'aaaaa'</code></p></blockquote><p>②比较操作符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_3.png" alt="比较操作符"></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意<br>整型和浮点型之间是可以使用==正常比较的，但是整型、浮点型和字符串使用==只能得到False<br>&gt;、&lt;、≥、≤只能用于整型和浮点型</div><p>③增强的赋值操作符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_4.png" alt="赋值操作符"><br>④布尔操作符：<code>and</code>、<code>or</code>、<code>not</code></p><blockquote><p><code>not</code>优先级最高，随后是<code>and</code>，最后是<code>or</code></p></blockquote><p><strong>1.5注释</strong><br>①单行注释：以<code>#</code>开头<br>②多行注释：用三个单引号/双引号包围<br><strong>1.6类型转换</strong><br>①自动类型转换</p><blockquote><p>将一种类型的数据<strong>赋值</strong>给另外一种类型的变量时，<strong>表达式右边</strong>的类型<strong>转换为左边</strong>变量的类型<br>在不同类型的<strong>混合运算</strong>中，将参与运算的所有数据先转换为<strong>同一种类型</strong>，然后再进行计算</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_2.png" alt="混合运算下的类型转换"><br>②强制类型转换</p><blockquote><p><code>str()</code>：转化为字符串类型<br><code>int()</code>：转化为整数类型<br><code>float()</code>：转化为浮点数类型</p></blockquote><h3 id="2-控制流"><a href="#2-控制流" class="headerlink" title="2.控制流"></a>2.控制流</h3><p><strong>2.1基本格式</strong><br>①语句关键词后面的<strong>冒号</strong>，以及python使用<strong>换行符</strong>而不是分号作为语句终止符<br>②python的代码块不用花括号划分范围，而是<strong>根据代码的缩进</strong></p><blockquote><p>缩进<strong>增加</strong>时，代码块<strong>开始</strong><br>代码块可以包含其他代码块,缩进减少为零，或减<strong>少为外面包围代码块的缩进，代码块就结束了</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常以四个空格为一个缩进，不要使用制表键</div><p><strong>2.2条件语句</strong></p><pre class="line-numbers language-none"><code class="language-none">if(条件): #条件为结果为布尔值的表达式  statementelif(条件):  statementelse:  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一旦一个语句的条件为Ture，后面的语句会被忽略，所以要注意语句的顺序，或者说清晰化条件的范围，使其之间没有交集</div><p><strong>2.3循环语句</strong><br>①<code>while</code>循环语句</p><pre class="line-numbers language-none"><code class="language-none">while(条件):  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>②<code>for</code>循环语句</p><pre class="line-numbers language-none"><code class="language-none">for 控制变量 in range():   statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>缺省情况下，控制变量被初始化为0<br>在Python中，下划线<code>_</code>通常用作一个无用的变量名称，常用做控制变量的名称</p></blockquote><p><strong>2.4range函数</strong><br>①<code>range(a)</code>：0至<strong>a-1</strong>，取不到a<br>②<code>range(a,b)</code>：a至<strong>b-1</strong>，步长为1<br>③<code>range(a,b,i)</code>：a至<strong>b-1</strong>,步长为i</p><blockquote><p>range()的返回值是类似于<strong>列表</strong>的值（但是不是列表），所以也可以将循环中的<code>range()</code>换为一个列表，在每次迭代中，让变量<strong>依次</strong>设置为<strong>列表中的值</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一个常见的Python技巧，是在for循环中使用range(len(someList))，迭代列表的每一个下标</div><p><strong>2.5循环控制语句</strong><br>①break：遇到<code>break</code>语句，马上退出循环<br>②continue：遇到<code>continue</code>语句，马上跳回到循环开始处，重新对循环条件求值</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以结合条件语句对循环进行控制</div><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><p><strong>3.1格式</strong></p><pre class="line-numbers language-none"><code class="language-none">def 函数名(变元n):  statement  return expression #可以是变量，也可以是表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>①变元即形参<br>②<code>None</code>是<strong>NoneType数据类型</strong>的唯一值，代表没有值，相当于C中的<code>void</code><br>③关键字参数：某些函数有可选的关键字参数，在函数调用时可以指定，相当于修改函数的<strong>默认设置</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果需要传递多个同一位置的关键字参数，可以采用 | 管道命令将这些参数连接</div><p>④函数的参数可以有<strong>默认值</strong>，也支持使用<strong>可变参数</strong>（类型、个数均可变），所以Python并<strong>不需要</strong>像其他语言一样支持<strong>函数的重载</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 未知个数参数可以使用args关键字实现</div><pre class="line-numbers language-none"><code class="language-none"># 在参数名前面的*表示args是一个可变参数def add(*args):    total = 0    for val in args:        total += val    return total# 在调用add函数时可以传入0个或多个参数print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2作用域</strong><br>①局部作用域：在被调用<strong>函数内赋值</strong>（注意，如果在函数内没有对其进进行赋值，则为全局变量）的变量，局部作用域在<strong>函数被调用</strong>时创建，在<strong>函数返回时</strong>销毁<br>②全局作用域：在所有<strong>函数之外</strong>赋值的变量，属于<strong>全局作用域</strong>，全局作用域在<strong>程序开始时</strong>创建，在<strong>程序终止时</strong>销毁<br>③嵌套作用域：当一个函数1内部有另一个函数2时，对于函数1内部的函数2来说，函数1中的变量属于函数2的嵌套作用域<br>④内置作用域：Python内置的那些<strong>标识符</strong></p><blockquote><p><strong>联系</strong><br>内置作用域→全局作用域→嵌套作用域→局部作用域，从左往右依次内推，内部的作用域可以访问外部作用域中的变量，但是外部作用域不能访问内部作用域的变量，局部作用域不能访问<strong>其他局部作用域</strong>的变量<br>如果在不同的作用域中，你可以用相同的名字命名不同的变量<br>可以使用<code>global</code>关键字修饰变量使其变为<strong>全局变量</strong><br>可以使用<code>nonlocal</code>关键字修饰变量使其变为<strong>嵌套作用域变量</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收</div><p><strong>3.3异常处理</strong>：捕捉<strong>函数内部某些语句</strong>的错误<br>①<code>try</code>语句：将可<strong>能出错的语句</strong>放在<code>try</code>之后，当这些语句出错后，会立马跳到<code>except</code>语句</p><pre class="line-numbers language-none"><code class="language-none">try:  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>②<code>except</code>语句：后面常接一些错误提醒的<code>print</code>语句</p><pre class="line-numbers language-none"><code class="language-none">except 错误名:  print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>③<code>finally</code>语句：<code>finally</code>块的代码不论程序正常还是异常<strong>都</strong>会执行到</p><blockquote><p>该语句不是必须的，通常用于执行一些必要的<strong>清理操作</strong>，如关闭文件、释放资源、关闭数据库连接等</p></blockquote><p><strong>3.4模块</strong><br>①导入模块：<code>import 模块名,模块名n</code><br>②调用模块中函数/方法：模块名.函数名/方法名</p><blockquote><p>模块类似于C++中的命名空间，可以<strong>防止命名冲突</strong>，同时也封装了代码</p></blockquote><p>③模块的测试：写完自定义的模块之后，都会写一个测试代码，<strong>直接运行</strong>该模块，检验一些模块中各个功能是否能够成功运行</p><pre class="line-numbers language-none"><code class="language-none">def c2f(cel):    fah = cel * 1.8 + 32    return fahdef f2c(fah):    cel = (fah - 32) / 1.8    return celdef test():    print("测试数据：0 摄氏度 = %.2f 华氏度" % c2f(0))    print("测试数据：0 华氏度 = %.2f 摄氏度" % f2c(0))if __name__ == '__main__':test()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中<code>if __name__ == '__main__':</code>的作用是检测当前模块是否被直接运行（作为主程序），还是被导入到其他模块中作为一个模块使用<br><code>__name__</code>为python中的一个<strong>内置变量</strong>，当程序直接被执行时，其<code>__name__</code>的值为<code>'__main__'</code>，而当导入到其他模块中时，其<code>__name__ </code>值为自己的模块名。</p></blockquote><p><strong>3.5常用函数（待合并）</strong><br>①print()：将括号内的<strong>字符串</strong>显示在屏幕上<br>#所以要输出其他类型变量时，需要使用<code>str()</code>将其<strong>转换为字符串类型</strong><br>#占位符语法：</p><ul><li><code>print('%d + %d = %d' % (a, b, a + b))</code>,其中<code>%d</code>是整数的占位符，<code>%f</code>是小数的占位符，<code>%%</code>表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成<code>%%</code>），字符串之后的<code>%</code>后面跟的变量值会替换掉占位符然后输出到终端中。</li><li><code>print('{0} * {1} = {2}'.format(a, b, a * b))</code>，其中<code>{0}</code>等都是占位符，<code>0</code>为format方法的<strong>索引</strong>，<strong>可省略，即按照默认顺序插入</strong>，还可以使用更多的格式选项，用于指定值的<strong>格式</strong>，还可以利用语法糖简化写法，即<code>print(f'{a} * {b} = {a * b}')</code></li></ul><p>②input()：等待用户输入文本，并按下<strong>回车键</strong>，将其转化为一个<strong>字符串</strong></p><h3 id="4-面向对象编程"><a href="#4-面向对象编程" class="headerlink" title="4.面向对象编程"></a>4.面向对象编程</h3><p><strong>4.1类的定义</strong></p><pre class="line-numbers language-none"><code class="language-none">class Student(object):    # __init__是一个特殊方法用于在创建对象时进行初始化操作    # 通过这个方法我们可以为学生对象绑定name和age两个属性    def __init__(self, name, age):        self.name = name        self.age = age    def study(self, course_name):        print('%s正在学习%s.' % (self.name, course_name))    # PEP 8要求标识符的名字用全小写多个单词用下划线连接    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)    def watch_movie(self):        if self.age &lt; 18:            print('%s只能观看《熊出没》.' % self.name)        else:            print('%s正在观看岛国爱情大电影.' % self.name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①在Python中可以使用<code>class</code>关键字定义类，其中<code>object</code>是所有类的基类，即<strong>顶级父类</strong>，这意味着在Python中定义的任何类都可以调用<code>object</code>类的方法（如<code>__init__</code>方法），并继承<code>object</code>类的特性<br>②类中的函数被称为<strong>方法</strong>，以描述对象的动态特征，其中方法的<strong>第一个参数</strong>通常被命名为<code>self</code>，Python会自动将对象绑定到第一个参数上<br>③<code>__init__</code>方法定义了类的<strong>属性</strong>，这些属性是描述类的关键</p><p><strong>4.2对象的创建与使用</strong></p><pre class="line-numbers language-none"><code class="language-none">def main():    # 创建学生对象并指定姓名和年龄    stu1 = Student('骆昊', 38)    # 给对象发study消息    stu1.study('Python程序设计')    # 给对象发watch_av消息    stu1.watch_movie()    stu2 = Student('王大锤', 15)    stu2.study('思想品德')    stu2.watch_movie()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①可以通过<code>对象.方法名/属性名</code>访问类的方法和属性</p><blockquote><p>对象的创建不使用<code>__init__</code>方法，而是使用<strong>类名</strong>创建，使用类名创建对象实际上是通过<strong>调用构造函数</strong>来创建对象</p></blockquote><p>②属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用<strong>两个下划线</strong>作为开头</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> python程序员遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重</div><p><strong>4.3property装饰器</strong></p><pre class="line-numbers language-none"><code class="language-none">class Person(object):    def __init__(self, name, age):        self._name = name        self._age = age    # 访问器 - getter方法    @property    def name(self):        return self._name    # 访问器 - getter方法    @property    def age(self):        return self._age    # 修改器 - setter方法    @age.setter    def age(self, age):        self._age = age    def play(self):        if self._age &lt;= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)def main():    person = Person('王大锤', 12)    person.play()    person.age = 22    person.play()    # person.name = '白元芳'  # AttributeError: can't set attributeif __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①<code>@property</code>:将一个<strong>方法</strong>转换为相应的<strong>属性</strong>，将<strong>方法的调用方式</strong>变为<strong>属性的访问方式</strong></p><blockquote><p>具体而言，<code>@property</code>装饰器定义了一个<code>getter</code>方法，用于获取属性的值,如果没有<code>@property</code>的话，<code>person.age</code>应为<code>person.age()</code></p></blockquote><p>②在定义了<strong>访问器</strong>后,可以使用<code>age.setter</code>等装饰器定义对应的<code>setter</code>方法，记住要有<strong>对应的前缀</strong>，且方法名需要一致（即<code>age</code>）<br><strong>4.4静态方法和类方法：</strong>当类中需要一些方法，但是不是基于具体对象实例的，如在<strong>创建对象前</strong>验证其是否合理的方法<br>①静态方法：使用<code>@staticmethod</code>修饰器定义，直接通过<code>类名.方法名()</code>调用</p><blockquote><p>静态方法属于<strong>类本身</strong>，所以在定义时不需要<code>self</code>参数</p></blockquote><pre class="line-numbers language-none"><code class="language-none">from math import sqrtclass Triangle(object):    def __init__(self, a, b, c):        self._a = a        self._b = b        self._c = c    @staticmethod    def is_valid(a, b, c):        return a + b &gt; c and b + c &gt; a and a + c &gt; bdef main():    a, b, c = 3, 4, 5    # 静态方法和类方法都是通过给类发消息来调用的    if Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)    else:        print('无法构成三角形.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②类方法：使用<code>@classmethod</code>修饰器定义类方法，直接通过<code>类名.方法名()</code>调用</p><blockquote><p>方法的第一个参数约定名为<code>cls</code>，类似于<code>self</code>，但是<code>cls</code>代表是对应的类，允许在类方法内部访问<strong>类级别</strong>的属性和方法</p></blockquote><pre class="line-numbers language-none"><code class="language-none">from time import time, localtime, sleepclass Clock(object):    """数字时钟"""    def __init__(self, hour=0, minute=0, second=0):        self._hour = hour        self._minute = minute        self._second = second    @classmethod    def now(cls):        ctime = localtime(time())        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)def main():    # 通过类方法创建对象并获取系统时间    clock = Clock.now()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.5继承和继承</strong>：</p><pre class="line-numbers language-none"><code class="language-none">class Person(object):    """人"""    def __init__(self, name, age):        self._name = name        self._age = age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age = age    def play(self):        print('%s正在愉快的玩耍.' % self._name)    def watch_av(self):        if self._age &gt;= 18:            print('%s正在观看爱情动作片.' % self._name)        else:            print('%s只能观看《熊出没》.' % self._name)class Student(Person):    """学生"""    def __init__(self, name, age, grade):        super().__init__(name, age)        self._grade = grade    @property    def grade(self):        return self._grade    @grade.setter    def grade(self, grade):        self._grade = grade    def study(self, course):        print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person):    """老师"""    def __init__(self, name, age, title):        super().__init__(name, age)        self._title = title    @property    def title(self):        return self._title    @title.setter    def title(self, title):        self._title = title    def teach(self, course):        print('%s%s正在讲%s.' % (self._name, self._title, course))def main():    stu = Student('王大锤', 15, '初三')    stu.study('数学')    stu.watch_av()    t = Teacher('骆昊', 38, '砖家')    t.teach('Python程序设计')    t.watch_av()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①继承：子类除了继承父类提供的属性和方法，还可以定义自己<strong>特有</strong>的属性和方法，所以子类比父类拥有的更多的能力<br>②多态：子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，不同的子类表现不同</p><blockquote><p>抽象类是一种专门让其他类继承的类，<strong>不能创建对应的对象</strong>，子类可以重写其中的<strong>抽象方法</strong>从而实现多态</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果</div><pre class="line-numbers language-none"><code class="language-none">from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta):    """宠物"""    def __init__(self, nickname):        self._nickname = nickname    @abstractmethod    def make_voice(self):        """发出声音"""        passclass Dog(Pet):    """狗"""    def make_voice(self):        print('%s: 汪汪汪...' % self._nickname)class Cat(Pet):    """猫"""    def make_voice(self):        print('%s: 喵...喵...' % self._nickname)def main():    pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')]    for pet in pets:        pet.make_voice()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-列表"><a href="#5-列表" class="headerlink" title="5.列表"></a>5.列表</h3><p><strong>5.1声明</strong>：<code>列表名 = [表项1,...,表项n]</code></p><blockquote><p>表项的数据类型<strong>可以不是一致的</strong>，也可以是<strong>列表</strong>，如果全部都是大小相同列表的话，类似于C语言中的<strong>多维数组</strong></p></blockquote><p><strong>5.2访问</strong><br>①<code>列表名[i]</code>:访问列表中<strong>第i-1表项</strong></p><blockquote><p>python中<strong>有</strong>对应的<strong>下标检查</strong><br>当i前面有<strong>负号</strong>时，代表<strong>倒数</strong>第i个<br>当列表某个表项是列表时，如果想要访问其中元素，需要再次使用下标，即<code>列表名[i][j]</code></p></blockquote><p>②<code>列表名[i:j:n]</code>：访问列表的一部分（第i个下标到第j个下标,n为步长，默认为1），结果还是一个列表</p><blockquote><p>省略<strong>第一个下标</strong>相当于使用 0，或列表的<strong>开始</strong><br>省略<strong>第二个下标</strong>相当于使用列表的长度，意味着分片直至列表的<strong>末尾</strong><br>当n为<strong>负数</strong>时，表示从第j个下标到第i个下标，即<strong>反向切片</strong></p></blockquote><p><strong>5.3常用操作</strong><br>①操作符</p><blockquote><p><code>+</code>操作符可以<strong>连接</strong>两个列表，得到一个新列表，就像它将两个字符串合并成一个新字符串一样<br><code>*</code>操作符可以用于一个列表和一个整数，实现列表的<strong>复制</strong><br><code>del</code>语句将删除列表中下标处的值，表中被删除值后面的所有值，都将<strong>向前移动一个下标</strong><br><code>del spam[2]</code><br><code>in</code>和<code>not in</code>:连接两个值,一个要在列表中<strong>查找的值</strong>，以及待查找的<strong>列表</strong>。这些表达式将求值为<strong>布尔值</strong></p></blockquote><p>②常用方法</p><blockquote><p>index()：传入一个值，如果该值存在于列表中，就返回它<strong>第一次</strong>出现的下标<br>append()：将参数添加到列表<strong>末尾</strong><br>insert()：以在列表<strong>任意下标处</strong>插入一个值<br>remove()：将对应值从被调用的列表中删除<br>sort()：对于<code>数值</code>或<code>字符串</code>的列表，基于“ASCII字符顺序”排序</p></blockquote><p><strong>5.4元组和集合</strong><br>①元组：几乎与列表数据类型一样，但是元组输入时用<strong>圆括号()<strong>，而不是用方括号，且也是</strong>不可变数据类型</strong></p><blockquote><p>如果元组中只有<strong>一个值</strong>，你可以在括号内该值的后面跟上一个<strong>逗号</strong>，否则就是一个值，而不是包含一个值的元组<br>元组在创建<strong>时间</strong>和占用的<strong>空间</strong>上面都优于列表</p></blockquote><p>②集合：<code>set1 = {1, 2, 3, 3, 3, 2}</code>，是<strong>无序</strong>的可变数据类型</p><blockquote><p>不允许有重复元素，而且可以进行交集、并集、差集等运算</p></blockquote><p>③转换</p><blockquote></blockquote><p><code>list()</code>：返回传递给它们的值的列表版本<br><code>tuple()</code>：返回传递给它们的值的元组版本<br><code>set()</code>：返回集合版本</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在将可变数据类型传递给函数时，又不希望函数改变其值，可以在函数内部拷贝一份对应的值，这就需要使用copy模块的copy()函数（直接赋值传递的还是引用）</div><h3 id="6-字典"><a href="#6-字典" class="headerlink" title="6.字典"></a>6.字典</h3><p><strong>6.1声明：</strong><code>字典名 = {键1:值1,...,键n:值n};</code></p><blockquote><p>字典的键相当于相当于列表的<strong>下标</strong>，但是列表的下标只能时整数，而字典的键可以是<strong>其他数据类型</strong>，比如说字符串<br>字典是<strong>无序</strong>的，只要键名和对应的值完全相同，两个字典就是完全相同的<br>字典的<strong>键</strong>不能重复</p></blockquote><p><strong>6.2常用操作：</strong><br>①访问：<code>字典名[键名]</code><br>②添加/修改键值对：<code>字典名[键名]=值</code><br>③删除键值对：<code>del 字典名[键名]</code><br>④判断是否存在：<code>键名 in 字典名</code></p><p><strong>6.3常用方法：</strong><br>①<code>keys()</code>:返回<code>dict_keys</code>，类似于字典的键的列表<br>②<code>values()</code>：返回<code>dict_values</code>，类似于字典的值的列表<br>③<code>items()</code>：返回<code>dict_items</code>，类似于字典的键-值对的列表</p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 这些返回值不能改变，常用于for循环判定条件中如for v in spam.values()用于遍历字典</div><p>④<code>get()</code>：它有两个参数，要取得其值的<strong>键</strong>，以及如果该键不存在时，返回的<strong>备用值</strong><br>⑤<code>setdefault()</code>:为字典中某个键设置一个默认值，当该键没有任何值时使用它，传递给该方法的第一个参数，是要<strong>检查的键</strong>，第二个参数，是如果<strong>该键不存在时要设置的值</strong>，即<code>spam.setdefault('color', 'black')</code></p><pre class="line-numbers language-none"><code class="language-none">#计算一个字符串中每个字符出现的次数message = 'It was a bright cold day in April, and the clocks were striking thirteen.'count = {}#for循环语句，即将character依次设置为message列表中的值for character in message:  count.setdefault(character, 0)  count[character] = count[character] + 1print(count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h3><p><strong>7.1声明</strong><br>①以<strong>单引号</strong>开始和结束</p><blockquote><p>但是这样会导致字符串不能包含单引号，可以使用对应的<strong>转义字符</strong><code>\'</code></p></blockquote><p>②以<strong>双引号</strong>开始和结束</p><blockquote><p>同理，不能包含双引号，可以使用对应的转义字符<code>\"</code></p></blockquote><p>③以<strong>3个单引号或3个双引号</strong>开始和结束，“三重引号”之间的所有<strong>引号、制表符或换行</strong>，都被认为是字符串的一部分缩进规则在这种字符串中不适用<br>④原始字符串：在字符串开始的<strong>引号之前加上r</strong>，完全忽略所有的转义字符，打印出字符串中所有的<strong>倒斜杠</strong></p><blockquote><p>字符串是<strong>不可变类型</strong>，可以看作是<strong>单个文本字符的元组（空格也算）</strong>，<code>name = 'cat'</code>相当于<code>name = ('c','a','t')</code></p></blockquote><p><strong>7.2常用方法</strong></p><blockquote><p><code>islower()/islower()</code>:如果字符串至少有一个字母，并且所有字母<strong>都是</strong>大写/小写,就会相应地返回布尔值 True。否则，该方法返回 False。<br><code>isalpha()</code>：如果字符串只包含字母，并且非空，返回True<br><code>isalnum()</code>：如果字符串只包含字母和数字，并且非空，返回True<br><code>isdecimal()</code>：如果字符串只包含数字字符，并且非空，返回 True<br><code>isspace()</code>：如果字符串只包含空格、制表符和换行，并且非空,返回 True<br><code>istitle()</code>:如果字符串仅包含以大写字母开头、后面都是小写字母的单词,返回 True<br><code>startswith()/endswith()</code>:如果它们所调用的字符串以该方法传入的字符串开始或结束,返回 True</p></blockquote><blockquote><p><code>upper()/lower()</code>：将原字符串的所有字母都被相应地转换为大写/小写，非字母字符保持不变，返回一个<strong>新</strong>字符串，而不是将旧字符串修改<br>因为 upper()和 lower()字符串方法本身返回字符串，可以在返回的字符串上继续调用字符串方法,如<code>'Hello'.upper().lower()</code></p></blockquote><blockquote><p><code>join()</code>:在一个字符串上调用，参数是一个字符串列表，返回一个字符串,返回的字符串由传入的列表中每个字符串连接而成。<br> <code>' '.join(['My', 'name', 'is', 'Simon'])</code>,返回结果是’My name is Simon’</p></blockquote><blockquote><p><code>split()</code>：传入一个分割字符串，指定它按照不同的字符串分割<br><code>'MyABCnameABCisABCSimon'.split('ABC')返回值为['My', 'name', 'is', 'Simon']</code></p></blockquote><blockquote><p><code>rjust()/ljust()/center()</code>:该方法的第一个参数为<strong>填充后</strong>的字符串的长度，第二个参数为<strong>填充使用的字符</strong>，默认是空格，分别为<br><code>'Hello'.rjust(20, '*')'***************Hello'</code><br><code>'Hello'.center(20, '=')'=======Hello========'</code></p></blockquote><blockquote><p><code>strip()/lstrip()/rstrip()</code>:删除字符串左边、右边或两边的空白字符（空格、制表符和换行符）有一个可选的字符串参数，指定两边的哪些<strong>字符</strong>应该删除（注意，删除的不一定和参数完全符合，可能是他们的组合）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">spam = 'SpamSpamBaconSpamEggsSpamSpam'spam.strip('ampS')'BaconSpamEggs'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><code>pyperclip</code>模块有<code>copy()</code>和<code>paste()</code>函数，可以向计算机的剪贴板发送文本，或从它接收文本,如果你的程序之外的某个程序改变了剪贴板的内容，<code>paste()</code>函数就会返回它</p></blockquote><p>7.生成式和生成器语法<br><a href="https://www.cnblogs.com/yyds/p/6281453.html">https://www.cnblogs.com/yyds/p/6281453.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python（深度学习篇）</title>
      <link href="/2023/11/07/python-shen-du-xue-xi-pian/"/>
      <url>/2023/11/07/python-shen-du-xue-xi-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="python（深度学习篇）"><a href="#python（深度学习篇）" class="headerlink" title="python（深度学习篇）"></a>python（深度学习篇）</h1><h3 id="1-环境配置（Ubuntu22-04）"><a href="#1-环境配置（Ubuntu22-04）" class="headerlink" title="1.环境配置（Ubuntu22.04）"></a>1.环境配置（Ubuntu22.04）</h3><p><strong>1.1安装Anaconda</strong>：Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本；Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。<br>①到官网下载安装包：<code>wget https://repo.anaconda.com/archive/Anaconda3-2023.03-1-Linux-x86_64.sh</code><br>②到<strong>对应目录</strong>下安装：<code>bash Anaconda3-2023.03-1-Linux-x86_64.sh</code><br>③打开conda基础环境：<code>conda activate base</code><br>#<code>conda list</code>查看Anaconda环境情况<br><strong>1.2环境管理</strong></p><pre class="line-numbers language-none"><code class="language-none"># 1.查看conda的版本号conda --version# 2.查看虚拟环境列表conda info --envs# 3.创建虚拟环境并指定python的版本号为3.8conda create -n virtualname pip python=3.9# 4.激活虚拟环境conda activate virtualname# 5.退出虚拟环境conda deactivate# 6.删除虚拟环境conda remove --name virtualname --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3包管理</strong></p><pre class="line-numbers language-none"><code class="language-none"># 1.安装包conda install PackageName# 2.安装多个包conda install name1 name2 ...# 3.安装包并指定版本号conda install PackageName=版本号# 4.卸载包conda remove PackageName# 5.更新包conda update PackageName# 6.更新环境中的所有包conda update --all# 7.列出已安装的包conda list# 8.搜寻包conda search PackageName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.4在pycharm中使用Anaconda环境</strong><br>①创建新环境：<code>conda create --name env_name package_names</code><br>#env_name为环境名；package_names为环境下使用的包的名称，可以在后面加<code>=版本号</code>确定版本，也可以使用多个包（空格隔开）<br>#创建新环境后会进行安装<br>②激活虚拟环境：<code>conda activate pytorch</code><br>③设置pycharm：[Add new Interpreter]→[conda environment]→[Interpreter]→填写环境所在路径<br>#环境路径通常为：<code>/home/xxxx/anaconda3/env/bin/[环境名]</code></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）</title>
      <link href="/2023/11/07/cao-zuo-xi-tong-yi/"/>
      <url>/2023/11/07/cao-zuo-xi-tong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（一）"><a href="#操作系统（一）" class="headerlink" title="操作系统（一）"></a>操作系统（一）</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="1-操作系统的启动"><a href="#1-操作系统的启动" class="headerlink" title="1.操作系统的启动"></a>1.操作系统的启动</h3><h4 id="1-1引导扇区的读入"><a href="#1-1引导扇区的读入" class="headerlink" title="1.1引导扇区的读入"></a>1.1引导扇区的读入</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以X86 PC为例（使用16位寄存器）</div><blockquote><p>开机时，PC处于<strong>实模式</strong>，<code>CS:IP</code>被<strong>初始化</strong>为<code>FFFFH:0000H</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPU的工作模式影响CPU的寻址方式、寄存器大小等</div><blockquote><p>CPU寻址<code>FFFFH:0000H</code>，即<strong>ROM BIOS映射区</strong>，并<strong>检查硬件</strong></p></blockquote><blockquote><p>将磁盘<strong>0磁道0扇区</strong>读入<code>7C00H处</code>，并设置<code>CS:IP</code>为<code>07c0H:0000H</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 0磁道0扇区即操作系统的引导扇区（bootsect.s），一个扇区512个字节</div><h4 id="1-2bootsect-s概述"><a href="#1-2bootsect-s概述" class="headerlink" title="1.2bootsect.s概述"></a>1.2<code>bootsect.s</code>概述</h4><blockquote><p>将<code>07C0H:0000</code>处的引导程序<strong>移动</strong>到<code>9000H:0000H</code>处，并跳转到<strong>下一条指令移动后的位置（因为还要继续执行<code>bootsect.s</code>）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将07C0H:0000到9000H:0000H这段地址空间腾出来，给操作系统使用</div><blockquote><p>利用<strong>13号中断</strong>读取<code>setup.s</code><strong>所在扇区</strong>，以及<strong>操作系统所在扇区</strong>（都按顺序放在<code>bootsect.s</code>之后），并完成一些<strong>辅助工作（如显示开机画面）</strong>，最后跳转到<code>setup.s</code>地址入口</p></blockquote><h4 id="1-3setup-s程序概述"><a href="#1-3setup-s程序概述" class="headerlink" title="1.3setup.s程序概述"></a>1.3<code>setup.s</code>程序概述</h4><blockquote><p>获得相关<strong>硬件信息</strong>，如<strong>扩展内存大小、显卡参数</strong>等，并存放在<strong>某段地址中</strong>，以便之后<strong>操作系统的初始化</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 实模式下寻址大小只有1M，所以要扩展内存</div><blockquote><p>将<strong>操作系统</strong>读入到<strong>0地址处</strong>（之前在<code>setup.s</code>程序后），并完成一些<strong>准备工作</strong>，并进入<strong>保护模式（32位模式）</strong>，最后跳转到<strong>0地址处</strong>执行<strong>操作系统的第一个模 块</strong><code>head.s</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里的准备工作包括gdt表和idt表的初始化，进入保护模式后CS根据其值查询gdt表获得32位段地址，与32位IP进行相加，获得32位地址</div><h4 id="1-4head-s概述"><a href="#1-4head-s概述" class="headerlink" title="1.4head.s概述"></a>1.4<code>head.s</code>概述</h4><blockquote><p>完成一些<strong>准备工作</strong>（如<strong>重新建立gdt表</strong>和<strong>idt表</strong>），并进入操作系统的<strong>main函数（通过内嵌汇编）</strong>，进行内存等对象的<strong>初始化并开始工作</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> head.s变为32位汇编（GNU as汇编），内嵌汇编</div><hr><h3 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="2.系统调用"></a>2.系统调用</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><blockquote><p><strong>shell实现概述</strong><br><code>shell</code>读取<strong>用户输入</strong>并调用<code>fork()</code>和<code>exec()</code>这两个<strong>系统调用</strong>执行用户输入 </p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 系统调用即由系统提供的函数接口</div><blockquote><p><strong>POSIX标准</strong>：由<strong>IEEE</strong>制定，每个操作系统<strong>都应该提供</strong>类似功能的<strong>系统调用</strong>（如<code>fork()</code>和<code>open()</code>） </p></blockquote><h4 id="2-2内核态和用户态"><a href="#2-2内核态和用户态" class="headerlink" title="2.2内核态和用户态"></a>2.2内核态和用户态</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内核态和用户态本质上是内存的不同部分，拥有不同的权限，由硬件实现</div><blockquote><p><strong>CPL</strong>：<strong>当前执行指令的特权级</strong>，用<strong>CS的最低两位</strong>来表示</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 操作系统启动后即进入用户态，CPL被初始化为3，系统调用可以将其变为0</div><blockquote><p><strong>DPL</strong>：当前指令<strong>访问的目标段的特权级</strong>，放在<strong>GDT表</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> GDT表的每一个表项用于描述一个地址，机器启动时初始化</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 0是内核态，3是用户态，当CPL≤DPL时，可以访问</div><h4 id="2-3陷入内核态概述"><a href="#2-3陷入内核态概述" class="headerlink" title="2.3陷入内核态概述"></a>2.3陷入内核态概述</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通过特定中断进入内核，如Linux是int 80H</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以Linux系统下调用printf函数为例</div><blockquote><p><strong>用户程序</strong>调用<code>printf</code><strong>库函数</strong>，<code>printf</code><strong>库函数</strong>调用<code>write</code><strong>库函数</strong></p></blockquote><blockquote><p><code>write</code>通过<strong>宏</strong><code>_syscall3</code>调用了<code>int 80H</code><strong>中断</strong>，并根据<strong>宏的参数</strong>将<strong>系统调用号等信息</strong>传递给<code>int 80H</code><strong>中断</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 给int 80H传递数据本质上是给对应的寄存器赋值</div><blockquote><p>调用中断后，读取对应的<strong>idt表项</strong>，并获得<strong>对应中断处理函数</strong><code>system_call</code>的<strong>起始地址</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 80H中断idt表项的DPL为3，以便用户程序访问，system_call的CPL为0（对应CS为8），当调用system_call函数时，即已经陷入内核</div><blockquote><p><code>system_call</code>函数首先<strong>跳转到内核的数据段和代码段</strong>，并根据<strong>系统调用号</strong>在<code>_sys_call_table</code>表（<strong>一个函数指针数组</strong>）中查找<strong>对应系统调用处理函数入口</strong>，并调用该函数</p></blockquote><hr><h3 id="3-进程和线程"><a href="#3-进程和线程" class="headerlink" title="3.进程和线程"></a>3.进程和线程</h3><h4 id="3-1基本概念"><a href="#3-1基本概念" class="headerlink" title="3.1基本概念"></a>3.1基本概念</h4><p><strong>①并发</strong></p><blockquote><p>CPU是<strong>取指执行</strong>，但是有些指令，如<strong>I/O指令</strong>，执行<strong>非常慢</strong>，且执行过程<strong>不使用CPU</strong>，可以在<strong>等待时执行别的指令</strong>，这就是<strong>并发</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一条I/O指令执行时间为简单指令的10的六次方倍</div><p><strong>②进程和线程</strong></p><blockquote><p><strong>进程</strong>：<strong>运行中的程序</strong>，除了<strong>对应的程序</strong>之外，还有<strong>记录其信息（如各个寄存器的值、运行状态等）的结构（PCB）</strong>以及<strong>对应资源</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> PCB保留了进程运行时的信息，以便于进程之间的切换，当进程1切换到进程2时，更新并保存进程1的PCB，随后读取进程2的PCB，为进程2运行布置好环境</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 不同的进程解决不同的任务，可以通过管理PCB管理进程</div><blockquote><p><strong>线程</strong>：一个进程可能有<strong>多个指令执行序列</strong>，<strong>每个指令执行序列</strong>就是<strong>线程</strong>，每个线程也有对应的<strong>记录其信息的结构（TCB）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以一个网页为例，一个线程用于从服务器接收数据，一个线程用于显示文本，一个线程用于处理图片</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同一个进程的线程共享进程资源，故线程切换的代价较小，又保留了并发的优点</div><p><strong>③运行状态</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_1.png" alt="运行状态"></p><h4 id="3-2线程切换"><a href="#3-2线程切换" class="headerlink" title="3.2线程切换"></a>3.2线程切换</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 进程的切换和线程的切换类似，只是多了内存映射的切换而已</div><p><strong>①引言</strong></p><blockquote><p><strong>函数调用</strong>：C语言中，当<strong>一个函数调用另一个函数</strong><code>func(p1,p2,p3)</code>时，会先<strong>向栈内压入返回地址</strong>、<code>p1</code>、<code>p2</code>和<code>p3</code>，随后<strong>跳转到对应函数的入口</strong>，当函数<strong>结束时</strong>，<strong>将栈内参数弹出</strong>，返回到原来的函数继续执行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 函数以}结束，}相当于iret指令</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 线程和进程的切换也类似于函数的调用，需要一个栈保存相关信息</div><p><strong>②用户级线程</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用户级线程不需要陷入内核，没有用户级进程这一说法，因为进程必须访问计算机资源</div><blockquote><p><strong>线程栈</strong>：每个线程都有<strong>自己的线程栈</strong>，用于实现<strong>当前线程的函数调用</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 线程之间不能共用栈，因为iret只是简单的弹栈，可能会导致线程1调用的函数返回时返回到线程2中</div><blockquote><p><strong>切换概述</strong>：<strong>切换TCB</strong>，并<strong>根据TCB切换线程栈</strong></p></blockquote><blockquote><p><strong>创建概述</strong>：为线程<strong>申请内存</strong>，创建<strong>TCB和线程栈</strong>，建立<strong>线程栈和TCB的联系</strong></p></blockquote><p><strong>③核心级线程</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 有些线程需要调用计算机资源，则必须陷入内核</div><blockquote><p><strong>线程栈</strong>：核心级线程除了<strong>用户态有一个栈（用户栈）</strong>，<strong>内核态还有一个栈（内核栈）</strong>，因为其<strong>在内核态也需要调用函数</strong></p></blockquote><p><strong>④核心级线程切换概述</strong></p><blockquote><p>当<strong>线程1</strong>接收到中断，<strong>陷入内核</strong>，<strong>从用户栈转移到内核栈</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> system_call将相关信息压入内核栈，如用户栈的指针，返回地址和标志寄存器，以及一段包含iret的代码</div><blockquote><p>当<strong>线程1在内核中堵塞</strong>，切换到<strong>线程2的TCB和内核栈</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 线程2即陷入内核但是因为某种原因未执行完的线程</div><blockquote><p><strong>线程2</strong>在内核中完成一些<strong>收尾工作（当然也可能再次阻塞）</strong>，通过<strong>内核栈的iret指令返回用户栈</strong></p></blockquote><p><strong>④核心级线程创建概述</strong></p><blockquote><p>申请<strong>TCB、内核栈和用户栈</strong>的<strong>内存空间</strong></p></blockquote><blockquote><p><strong>关联TCB</strong>和<strong>内核栈</strong>以及<strong>用户栈</strong>，<strong>初始化内核栈</strong>和<strong>用户栈</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中内核栈需要包含用户栈的指针以及初始返回地址</div><h4 id="3-3子进程"><a href="#3-3子进程" class="headerlink" title="3.3子进程"></a>3.3子进程</h4><p><strong>①<code>fork()</code></strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 父进程调用该系统调用创建子进程</div><blockquote><p><code>fork()</code>调用<code>_copy_process</code>，为子进程<strong>申请内存空间</strong>，<strong>创建并初始化子进程的内核栈和TCB</strong>，<strong>和父进程共用用户栈</strong>，并将其<code>eax</code>值设置为<code>0</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> _copy_process的参数是父进程陷入内核时压入内核栈的参数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> fork()的返回值是eax值，为0表示其是子进程，用于和父进程区分</div><p><strong>②子进程的运行</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以shell为例，假设执行ls</div><blockquote><p><code>shell</code><strong>主体代码</strong>如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">int main(int argc,char* argv[]){  while(1)  {    scanf("%s",cmd);    if(!fork())    {      exec(cmd);    }    wait(0);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>shell</code>通过<strong>读取用户输入创建对应子进程</strong>，</p></blockquote><blockquote><p>通过<code>fork()</code>的<strong>返回值判断是子进程还是父进程</strong></p></blockquote><blockquote><p>如果是<strong>子进程</strong>，<code>exec()</code>通过中断<strong>进入内核</strong>，修改<strong>子进程的内核栈</strong>，<strong>中断返回后</strong>执行的就是<code>ls</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要是将对应pc指向ls代码初始地址，并创建子进程自己的用户栈并修改对应寄存器</div><h4 id="3-4进程调度"><a href="#3-4进程调度" class="headerlink" title="3.4进程调度"></a>3.4进程调度</h4><p><strong>①调度指标</strong></p><blockquote><p><strong>周转时间</strong>：任务<strong>开始</strong>到任务<strong>结束</strong></p></blockquote><blockquote><p><strong>响应时间</strong>：从<strong>给出操作</strong>到<strong>发出响应</strong></p></blockquote><blockquote><p><strong>吞吐量</strong>：<strong>任务时间占比</strong>，因为系统有<strong>内耗</strong>，如<strong>进程切换</strong>也需要时间</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 进程调度的目标就是使得每个程序的指标都尽可能高，也有矛盾，如要求响应时间则表示进程切换频繁，导致系统内耗增加</div><p><strong>②基本调度算法</strong></p><blockquote><p><strong>SJF</strong>：<strong>短作业优先</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以保证周转，但是无法保证响应时间</div><blockquote><p><strong>RR</strong>：<strong>按照时间片轮转调度</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以保证响应时间，但是无法保证周转时间</div><blockquote><p><strong>优先级算法</strong>：<strong>动态调整优先级</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 任务主要可分为I/O约束型（前台）和CPU约束型（后台），一般要求先满足前台的要求</div><p><strong>③例子</strong></p><blockquote><p><strong>linux0.11</strong>的<code>schedule()</code>函数<br>找到<strong>任务列表</strong>中，处于<strong>运行状态且时间片大于0的最大</strong>的任务，如果能找到则<strong>调度该任务</strong><br>如果所有处于<strong>运行状态的任务时间片都为0</strong>，则将<strong>所有任务</strong>的时间片变为<code>（当前时间片/2）+（时间片初值）</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这样保证正在阻塞的程序的时间片会变得更高，使得被阻塞的程序优先级更高</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 假设一个进程的初始时间片为p，且一开始就一直阻塞，他的时间片最长也不会超过2p（p+p/2+p/4...）</div><pre class="line-numbers language-none"><code class="language-none">woid Schedule(void){  while(1)  {    c = -1;    next = 0;    i = NR_TASKS;    p = &amp;task[NR_TASKS];    while(--i)    {      //找到任务列表中，处于运行状态且时间片最大的任务      if((*p-&gt;state == TASK_RUNNING)&amp;&amp;(*p)-&gt;COUNTER &gt; c)      {        C = (*p)-&gt;counter;        next = i;      }      //如果找到则调度该程序      if(c) break;    }    //如果所有处于运行状态的任务时间片都为0，则将所有任务的时间片变为（当前时间片/2）+（时间片初值）    for(p = &amp;LAST_TASK;p &gt; &amp;FIRST_TASK;--p)    (*p)-&gt;counter = ((*p)-&gt;counter&gt;&gt;1)+(*p)-&gt;priotity;  }  switch_to(next);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算机取指执行<br>系统调用也被称为程序的一个标准库<br>虚拟化CPU：将单个CPU转化为多个虚拟CPU<br>虚拟化内存：每个进程都有自己的虚拟地址空间，操作系统将其映射到物理内存上<br>时分共享技术：让一个进程只运行一个时间片，然后切换到其他进程<br>进程的重要组成部分：自己的内存即地址空间，寄存器状态<br>进程创建：将代码和静态数据（初始化变量）加载到进程的地址空间中（从磁盘中读入）只加载需要执行的部分，为程序的运行时栈（存放返局部变量、函数参数和返回地址）和堆（动态分配）分配内存，完成一些初始化任务，跳转到main函数，然后开始执行<br>每个进程都有对应的进程描述符</p><p>程序是一种状态机，执行一条语句就是从一个状态转移到下一个状态<br>gdb vim<br>C语言函数调用，每次调用会产生一个新的栈帧，每个栈中含有变量和pc指针等，返回就是弹栈，C程序的状态就是堆栈的状态</p><p>递归转化为非递归？汉诺塔</p><p>对于二进制程序，状态就是内存、寄存器等的值<br>计算机系统基础<br>程序本身只是计算，需要使用系统调用syscall请求操作系统调用硬件资源退出程序等</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 《操作系统导论》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法</title>
      <link href="/2023/11/07/sou-suo-suan-fa/"/>
      <url>/2023/11/07/sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）</title>
      <link href="/2023/11/07/cao-zuo-xi-tong-er/"/>
      <url>/2023/11/07/cao-zuo-xi-tong-er/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（二）"><a href="#操作系统（二）" class="headerlink" title="操作系统（二）"></a>操作系统（二）</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="1-进程同步"><a href="#1-进程同步" class="headerlink" title="1.进程同步"></a>1.进程同步</h3><h4 id="1-1信号量"><a href="#1-1信号量" class="headerlink" title="1.1信号量"></a>1.1信号量</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 进程之间需要合作，需要通过信号量来相互通信，从而合理推进进程</div><p><strong>①代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 信号量是内核中的全局变量</div><pre class="line-numbers language-none"><code class="language-none">struct sqmaphore{  int value; //记录资源个数  PCB *queue; //记录等待在该信号量上的进程}//进程通过函数p申请使用资源，如果资源不足，则沉睡p(sqmaphore s){  s.value--;  if(s.value &lt; 0)  {    sleep(s.queue);  }}//进程通过v生产资源，如果资源不足，则唤醒v(sqmaphore s){  s.value++;  if(s.value &lt;= 0)  {    wake(s.queue);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②实例</strong></p><blockquote><p>有两个<strong>进程</strong>，分别为<strong>生产者</strong>和<strong>消费者</strong>，<strong>生产者</strong>向缓存区<strong>写入字符</strong>，<strong>消费者</strong>从缓存区<strong>读出字符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的进程，对同一个信号量的使用是不相同的，对于生产者，只有缓存区有空位才能工作，对于消费者只有缓存区有数据才能工作</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中mutex为互斥信号量，防止生产者和消费者同时对缓存区进行操作</div><pre class="line-numbers language-none"><code class="language-none">//定义缓存区int buffer [BUFFER_SIZE];//定义信号量sqmaphore full = 0;sqmaphore empty = BUFFER_SIZE;sqmaphore mutex = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//生产者程序Producer(*item,in){  P(empty);  p(mutex); //互斥信号量  将item写入到in对应位置;  v(mutex);  v(full);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//消费者程序Consumer(*item,out){  P(full);  p(mutex); //互斥信号量  将out对应位置数据读出;  v(mutex);  v(empty);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2临界区"><a href="#1-2临界区" class="headerlink" title="1.2临界区"></a>1.2临界区</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 信号量由多个进程共用，但是进程调度可能导致一个进程还没有修改好信号量，就切到另一个相关进程</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当一个进程修改但没有修改完信号量时，禁止其他进程修改信号量，即将信号量操作放入临界区中</div><pre class="line-numbers language-none"><code class="language-none">P1.register = empty;P1.register = P1.register - 1;//发生进程调度，切到P2进程P2.register = empty;P2.register = P2.register - 1;////发生进程调度，切到P1进程empty = P1.register<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②基本原则</strong></p><blockquote><p><strong>互斥进入</strong>：只有<strong>一个进程</strong>可以访问</p></blockquote><blockquote><p><strong>有空让进</strong>：当临界区<strong>空闲</strong>时，尽快使得<strong>一个进程</strong>进入</p></blockquote><blockquote><p><strong>优先等待</strong>：进程从<strong>发出进入请求</strong>到<strong>允许进入</strong>的时间不能过长</p></blockquote><pre class="line-numbers language-none"><code class="language-none">剩余区进入区临界区退出区剩余区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③实现</strong></p><blockquote><p><strong>面包店算法</strong>：当进程<strong>想进入临界区</strong>，会获得一个<strong>序号</strong>，<strong>序号最小</strong>的可以<strong>进入临界区</strong>，<strong>退出时</strong>序号变为<code>0</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 过于复杂，效率较低</div><blockquote><p><strong>阻止调度</strong>：进入临界区时，<strong>禁止中断（<code>cli()</code>）</strong>，直到<strong>退出临界区才允许中断（<code>sti()</code>）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只适用于单CPU，因为cli和sti只能禁止当前CPU的中断，其他CPU可能还会进入临界区</div><blockquote><p><strong>硬件原子指令</strong>：<strong>临界区</strong>和<strong>互斥信号量</strong>使用非常相似，只要将<strong>互斥信号量的修改</strong>变为<strong>原子操作</strong>即可，即<strong>锁信号量</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">boolean TestAndSet(boolean &amp;x){  boolean rv = x;  x = true;  return rv;}剩余区while(TestAndSet(&amp;lock));临界区lock = false;剩余区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3死锁"><a href="#1-3死锁" class="headerlink" title="1.3死锁"></a>1.3死锁</h4><p><strong>①概述</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 多个进程互相等待对方持有资源时，谁都无法执行，这就是死锁</div><blockquote><p>如下，<strong>生产者</strong>使得<code>mutex</code>从<code>1</code>变为<code>0</code>，倘若其在<code>p(empty)</code>处<strong>阻塞</strong>，进程<strong>切换到消费者</strong>，<strong>消费者直接阻塞</strong>，无法清空缓冲区，从而导致<strong>生产者和消费者一起一直阻塞</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">//生产者程序Producer(*item,in){  P(mutex);  p(empty);   将item写入到in对应位置;  v(mutex);  v(full);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//消费者程序Consumer(*item,out){  P(mutex);  p(full);   将out对应位置数据读出;  v(mutex);  v(empty);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②出现条件</strong></p><blockquote><p><strong>互斥使用</strong>：资源只能被<strong>一个进程占有</strong></p></blockquote><blockquote><p><strong>不可抢占</strong>：只有对应进程<strong>自动放弃对应资源</strong>，才能被<strong>其他进程</strong>使用</p></blockquote><blockquote><p><strong>请求和保持</strong>：进程需要<strong>先占用一个资源</strong>，然后根据这个资源<strong>申请下一个资源</strong></p></blockquote><blockquote><p><strong>循环等待</strong>：资源分配中出现<strong>一个环路</strong></p></blockquote><p><strong>③处理方法</strong></p><blockquote><p><strong>预防</strong>：检测每个<strong>资源请求</strong>，如果<strong>造成死锁就自动拒绝</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 银行家算法：根据每个进程占有的资源、需要的资源和当前空余的资源决定进程执行序列</div><blockquote><p><strong>恢复</strong>：<strong>死锁出现时</strong>，使一些进程<strong>回滚</strong>，<strong>让出资源</strong></p></blockquote><blockquote><p><strong>忽略</strong>：<strong>忽略死锁</strong>，在<strong>运行一会就关机</strong>的机器上常用</p></blockquote><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h3><h4 id="2-1重定位"><a href="#2-1重定位" class="headerlink" title="2.1重定位"></a>2.1重定位</h4><p><strong>①引言</strong></p><blockquote><p><strong>逻辑地址</strong>：<strong>用户程序中直接给出</strong>的地址，如<code>call 40</code>中的<code>40</code><br><strong>物理地址</strong>：<strong>存储单元的编号</strong>，是<strong>真实且唯一</strong>的</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要通过逻辑地址找到对应的物理地址，即重定位</div><p><strong>②重定位时机</strong></p><blockquote><p><strong>编译时</strong>：程序只能放在<strong>内存固定位置</strong></p></blockquote><blockquote><p><strong>载入时</strong>:程序一旦<strong>载入内存就不能动了</strong></p></blockquote><blockquote><p><strong>运行时</strong>：<strong>动态</strong>记录<strong>逻辑地址</strong>和<strong>物理地址</strong>的关系</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一般采用运行时重定位，因为进程在内存中位置是动态变化的，只有卫星等一烧录就不改变的采用编译时重定位</div><h4 id="2-2内存分割"><a href="#2-2内存分割" class="headerlink" title="2.2内存分割"></a>2.2内存分割</h4><p><strong>①程序分段</strong></p><blockquote><p>程序由<strong>多个段</strong>组成，<strong>每个段</strong>有各自的<strong>特点和用途</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 程序段只读，数据段可写，栈段向下增长等</div><p><strong>②内存分区</strong></p><blockquote><p>将程序<strong>各个段</strong>放入<strong>内存分区</strong>中，<strong>分区大小根据段大小调整</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 程序内的逻辑地址由段号和段内偏移组成，每个段号和某块内存区域相对应（记录在进程的LDT表中）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 因为不可能每次一个程序段的大小刚好和空闲区域大小相当，内存分区会产生内存碎片，导致内存使用率低</div><blockquote><p>不能<strong>整理内存</strong>将<strong>内存碎片合并</strong>，因为<strong>得不偿失</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_2.png" alt="内存分区"><br><strong>③内存分页</strong></p><blockquote><p>将<strong>程序</strong>分为多个<strong>固定大小的部分</strong>，并将<strong>内存</strong>分为多个<strong>固定大小的页</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个进程也有一个固定的页表，其中记录了两者的对应关系，即用页地址取代段地址</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 内存分页能减少内存的浪费，顶多浪费1页</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 为了减少内存的浪费，页的大小尽量得小，但是会造成页表过大</div><blockquote><p><strong>页表</strong>需要<strong>连续记录整个内存</strong>，这样<strong>便于查找（O(1)）</strong>，<strong>不连续记录</strong>则需要使用<strong>查找算法</strong>，得不偿失</p></blockquote><p><strong>④多级页表和快表</strong></p><blockquote><p><strong>多级页表</strong>：类似于<strong>多级目录</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 多级页表可以只连续记录使用了那段内存空间，不用记录整个内存空间，可以有效减少页表大小</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是多级页表增加了访问的次数，速度会慢一些</div><blockquote><p><strong>快表（<code>TLB</code>）</strong>：一个<strong>寄存器</strong>，存放<strong>经常使用的页</strong>，可以有效<strong>减少访问时间</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 快表可以通过硬件设置，直接找到对应的页，速度非常快，且由于程序内存访问具有局部性，TLB命中率高</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_3.png" alt="多级页表"><br><strong>⑤段页结合</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 程序员希望使用段，物理内存希望使用页，为了同时满足上层和硬件，将段页结合使用</div><blockquote><p>如<code>call 300</code>，<code>300</code>为<strong>逻辑地址</strong>，根据<strong>LDT表</strong>找到对应<strong>虚拟地址</strong><code>00045300</code>，再根据<strong>页表</strong>找到对应<strong>物理地址</strong><code>0007300</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_4.png" alt="段页结合"></p><h4 id="2-3内存交换"><a href="#2-3内存交换" class="headerlink" title="2.3内存交换"></a>2.3内存交换</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 换入换出可以实现大内存，假设虚拟内存有4G，但是实际物理内存只有1G，将访问的部分映射到物理内存即可</div><p><strong>①内存换入</strong></p><blockquote><p>当<strong>MMU</strong>无法根据<strong>用户请求的虚拟地址</strong>找到对应<strong>物理地址</strong>，产生<strong>缺页中断</strong>，调用对应<strong>中断处理程序</strong>，申请<strong>空闲页</strong>，将<strong>磁盘数据读入</strong>，做好<strong>映射关系</strong>，随后<strong>继续执行</strong></p></blockquote><p><strong>②内存换出</strong></p><blockquote><p>选择<strong>一页</strong>换出到<strong>磁盘</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内存换出类似于进程调度，但是内存换出的频率更高，颗粒度更小</div><blockquote><p><strong>clock算法</strong>：<strong>每一页</strong>都有一个<strong>标志位</strong>，<strong>每次访问</strong>一个页时，<strong>硬件自动设置该位</strong>，为<code>1</code>置<code>0</code>，并<strong>继续扫描</strong>，为<code>0</code><strong>淘汰</strong>该页</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为LUR算法粗略实现，即淘汰最近最少使用的页，因为LUR的精细实现代价太大，得不偿失</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果缺页情况很少，到最后很可能大部分页标志位为1，退化为FIFO，所以需要再来一个更快的扫描指针定时清除R位</div><h3 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h3><h4 id="3-1文件树"><a href="#3-1文件树" class="headerlink" title="3.1文件树"></a>3.1文件树</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于用户来说，文件的位置就是它的路径，对于操作系统来说就是区块号，需要将两者相互转换</div><p><strong>①磁盘分区</strong></p><blockquote><p><strong>引导区</strong>：存放<strong>引导程序</strong></p></blockquote><blockquote><p><strong>超级块</strong>：记录磁盘<strong>整体信息</strong>，如<strong>各个区的起始位置</strong></p></blockquote><blockquote><p><strong>I节点位图</strong>：记录<strong>Inode指针区</strong>的<strong>统计信息</strong>，如有哪些<strong>空闲空间</strong></p></blockquote><blockquote><p><strong>盘块位图</strong>：记录<strong>数据区</strong>的<strong>统计信息</strong>，如有哪些<strong>空闲空间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> inode为linux中记录文件信息（如区块号）的结构</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_5.png" alt="磁盘分区"><br><strong>②路径到inode</strong></p><blockquote><p>如<code>/home/my</code>，首先从<strong>Inode指针区第一个位置</strong>找到<strong>根目录</strong>的<code>inode</code>指针，从而找到<strong>根目录</strong>的<code>inode</code><strong>结构</strong></p></blockquote><blockquote><p><strong>根目录</strong>的<code>inode</code><strong>结构</strong>中存放了<strong>各个目录项</strong>的<strong>名字字符串</strong>与其在<strong>Inode指针区的位置</strong></p></blockquote><blockquote><p><strong>匹配名字字符串</strong>即可找到<code>home</code><strong>目录</strong>的<code>inode</code><strong>结构</strong>，类似的<strong>一层一层寻找下去</strong></p></blockquote><p><strong>③inode到区块号</strong></p><blockquote><p><strong>每个文件</strong>对应的<strong>inode结构</strong>中有一个<strong>索引表</strong>，记录了文件<strong>各个部分对应的区块号</strong></p></blockquote><h4 id="3-2磁盘定位"><a href="#3-2磁盘定位" class="headerlink" title="3.2磁盘定位"></a>3.2磁盘定位</h4><p><strong>①原理</strong></p><blockquote><p><strong>柱面（C）</strong>：描述是<strong>磁头相对磁盘位置</strong></p></blockquote><blockquote><p><strong>磁头（H）</strong>：描述是使用<strong>哪一个磁头读</strong></p></blockquote><blockquote><p><strong>扇区（S）</strong>：磁盘的<strong>访问单位</strong>，长度为<strong>512字节</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 磁头移动到对应磁道，旋转磁盘找到对应的扇区，即根据CHS定位磁盘</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了提高计算机读取磁盘的效率，增大读写单位（每次读写扇区的个数），本质上是用空间换时间</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_6.png" alt="磁盘"><br><strong>②区块号到CHS</strong></p><blockquote><p>由<strong>磁盘驱动程序</strong>将<strong>区块号</strong>转化为<strong>CHS</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为了提升磁盘读写的效率（读取一个区块时，经量少切换磁头），区块在磁盘上是连续且有直接计算关系的：Block = CxHxS+HxS+S</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_7.png" alt="区块到CHS"></p><h4 id="3-3磁盘调度"><a href="#3-3磁盘调度" class="headerlink" title="3.3磁盘调度"></a>3.3磁盘调度</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当多个区块需要被访问时，一时间只有一个能被访问</div><p><strong>①磁盘访问时间</strong></p><blockquote><p>由<strong>写入控制器时间</strong>、<strong>寻道时间</strong>、<strong>旋转时间</strong>和<strong>传输时间</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中主要部分是寻道时间和旋转时间，即找到对应扇区的时间</div><p><strong>②调度算法</strong></p><blockquote><p><strong>电梯算法</strong>：选择<strong>区块号和当前磁头位置距离最小</strong>的区块申请</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 单向选择，只有当一个方向的区块全部选择完，再反方向申请</div><h3 id="4-设备驱动"><a href="#4-设备驱动" class="headerlink" title="4.设备驱动"></a>4.设备驱动</h3><h4 id="4-1引言"><a href="#4-1引言" class="headerlink" title="4.1引言"></a>4.1引言</h4><p><strong>①概述</strong></p><blockquote><p>计算机<strong>使用外设的本质</strong>就是<strong>修改外设控制卡的寄存器</strong>，外设工作完毕后，通过<strong>中断</strong>向计算机<strong>传递信息</strong></p></blockquote><p><strong>②文件视图</strong></p><blockquote><p><strong>设备</strong>在<strong>操作系统中</strong>视为一种<strong>特殊的文件</strong>，也是通过类似于<code>open()</code>，<code>read()</code>等<strong>文件操作函数</strong>操作</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 《操作系统导论》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（一）</title>
      <link href="/2023/11/07/shu-ju-jie-gou-yu-suan-fa-yin-yan/"/>
      <url>/2023/11/07/shu-ju-jie-gou-yu-suan-fa-yin-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同样的问题，不同的方法效率不同，对于计算机的处理方法，主要有以下三个影响因素</div><p><strong>①数据的组织方式</strong></p><blockquote><p>如<strong>书架</strong>上<strong>书</strong>可以<strong>随便放</strong>，也可以<strong>分类放</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 前者方便存放，后者方便查找</div><p><strong>②空间利用率</strong></p><blockquote><p>如<strong>循环</strong>和<strong>递归</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 递归需要保存结束前所有函数调用的上下文</div><p><strong>③算法的巧妙程度</strong></p><blockquote><p>详情见<strong>实例</strong></p></blockquote><h4 id="1-2算法"><a href="#1-2算法" class="headerlink" title="1.2算法"></a>1.2算法</h4><p><strong>①定义</strong></p><blockquote><p>一个<strong>有限指令集</strong>，在接受一些<strong>输入</strong>后（<strong>也可能不接受输入</strong>），经过<strong>有限的步骤</strong>后，得到一定的<strong>输出</strong>，且能<strong>处理不合理输入</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每条指令不能有歧义，且在计算机处理范围内，不依赖任何具体实现手段</div><p><strong>②指标</strong></p><blockquote><p><strong>空间复杂度</strong><code>S(n)</code>：执行时<strong>占用存储单元的长度</strong></p></blockquote><blockquote><p><strong>时间复杂度</strong><code>T(n)</code>：执行时<strong>耗费的时长</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> n为问题的规模，即需要处理的数据的个数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常时间复杂度和空间复杂度并不能兼得，需要做出取舍</div><h4 id="1-3数据结构"><a href="#1-3数据结构" class="headerlink" title="1.3数据结构"></a>1.3数据结构</h4><p><strong>①定义</strong></p><blockquote><p><strong>数据对象</strong>在计算机中的<strong>组织方式</strong></p></blockquote><p><strong>②逻辑结构</strong></p><blockquote><p><strong>对象之间</strong>的相互关系</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要有集合结构、线性结构、树形结构和图结构</div><p><strong>③物理存储结构</strong></p><blockquote><p>在<strong>计算机中的存储方式</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要有连续存储和链式存储（地址不连续）</div><h4 id="1-4递归"><a href="#1-4递归" class="headerlink" title="1.4递归"></a>1.4递归</h4><p><strong>①定义</strong></p><blockquote><p><strong>递</strong>：程序不断<strong>调用自身</strong>，并设置一个<strong>终止条件</strong>，<strong>每次调用</strong>都更加<strong>靠近这个终止条件</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常终止条件是传入的参数为某一值，然后每次调用都靠近这个值</div><blockquote><p><strong>归</strong>：当<strong>触发终止条件</strong>，便从<strong>根据终止条件对应的值</strong>开始<strong>逐层返回</strong>，计算最终结果</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 终止条件对应的结果是一个确切的结果，否则无法完成递归</div><p><strong>②举例</strong></p><blockquote><p>计算从<code>1</code>到<code>n</code>的<strong>总和</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 递归的本质就是将问题分解为更小的子问题，天然适合处理分分治问题</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每次调用函数，都需要向栈中压入返回地址、参数等信息，直到返回才被释放，且由一定时间开销。所以递归的复杂度都较高</div><pre class="line-numbers language-none"><code class="language-none">int sum(int n){  //终止条件  if (n==1)      return 1;  //递  int jmp = sum(n-1);  //归  return n+jmp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_0.png" alt="递归过程"></p><h3 id="2-复杂度分析"><a href="#2-复杂度分析" class="headerlink" title="2.复杂度分析"></a>2.复杂度分析</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①复杂度估算</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 复杂度计算的是其随问题规模增大时的变化趋势，即T(n)/S(n)的函数渐进上界</div><blockquote><p><strong>函数渐进上界</strong>：对于<strong>函数</strong><code>T(n)</code>，若存在<strong>正实数</strong><code>c</code>和<strong>实数</strong><code>n0</code>，当<code>n &gt; n0</code>时，均有<code>T(n) &lt;= cf(n)</code>，则<code>f(n)</code>为其<strong>渐进上界</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由定义可知，渐进上界通常为函数的最高阶</div><p><strong>②算法相关空间</strong></p><blockquote><p><strong>输入空间</strong>：存储算法的<strong>输入数据</strong></p></blockquote><blockquote><p><strong>暂存空间</strong>：存储算法在<strong>运行过程</strong>中的<strong>变量</strong>、<strong>函数上下文</strong>等数据</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还可分为存储变量等数据的数据空间，保存调用函数上下文的的栈帧数据，以及保存编译后程序指令的指令空间</div><blockquote><p><strong>输出空间</strong>：存储算法的<strong>输出数据</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 调用的函数 */int func() {    // 执行某些操作...    return 0;}int algorithm(int n) // 输入空间{     const int a = 0;   // 数据空间（常量）    int b = 0;         // 数据空间（变量）    int c = func();    // 栈帧空间（调用函数）    return a + b + c;  // 输出空间}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2时间复杂度"><a href="#2-2时间复杂度" class="headerlink" title="2.2时间复杂度"></a>2.2时间复杂度</h4><p><strong>①估算思路</strong></p><blockquote><p>所有<strong>与n无关</strong>的部分看作<code>1</code>，因为其最后为<code>T(n)</code>的<strong>常数部分</strong></p></blockquote><blockquote><p><strong>与n有关</strong>的部分，将其分为<strong>多个独立部分</strong>，<strong>分别计算</strong>其复杂度，取其中<strong>最大的</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每种部分的复杂度不尽相同，需要自己分析，本质上是算其中基本语句的执行次数，如单层循环的复杂度为n</div><blockquote><p>如果有<strong>嵌套类型</strong>，先从<strong>最里层嵌套</strong>计算，<strong>每一层嵌套的复杂度相乘</strong>得到<strong>嵌套部分的复杂度</strong></p></blockquote><p><strong>②常见类型</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 以最差时间复杂度为例</div><blockquote><p><code>O(n^2)</code>：<strong>两层嵌套循环</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int quadratic(int n){    int count = 0;    // 循环次数与数组长度成平方关系    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            count++;        }    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(2^n)</code>：以下<strong>递归次数为n</strong>，每次递归都将<strong>一分为二</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 指数阶（递归实现） */int expRecur(int n){    if (n == 1)        return 1;    return expRecur(n - 1) + expRecur(n - 1) + 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(logn)</code>：以下只需要<strong>迭代logn次</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int logarithmic(float n){    int count = 0;    while (n &gt; 1) {        n = n / 2;        count++;    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(n!)</code>：以下<strong>循环n次</strong>，<strong>第一次</strong>循环<strong>分裂出n个</strong>，<strong>第二次</strong>循环<strong>每个都分裂出n-1个</strong>，依次类推</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 阶乘阶（递归实现） */int factorialRecur(int n) {    if (n == 0)        return 1;    int count = 0;    for (int i = 0; i &lt; n; i++) {        count += factorialRecur(n - 1);    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3空间复杂度"><a href="#2-3空间复杂度" class="headerlink" title="2.3空间复杂度"></a>2.3空间复杂度</h4><p><strong>①估算思路</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常只关心最差空间复杂度，其中最差指最差输入数据和峰值内存占用</div><blockquote><p>分别计算<strong>各个空间</strong>的<strong>空间复杂度</strong>，取<strong>最大值</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 空间复杂度的计算主要计算占用的内存数量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 其中递归函数需要注意栈帧空间的大小</div><blockquote><p>如下，<strong>迭代</strong>过程<strong>每次调用</strong>完就<strong>释放了栈帧空间</strong>，空间复杂度为<code>O(1)</code>，<strong>递归</strong>过程每次调用<strong>没有释放栈帧空间</strong>，故空间复杂度为<code>O(n)</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int func() {    // 执行某些操作    return 0;}/* 循环 O(1) */void loop(int n) {    for (int i = 0; i &lt; n; i++) {        func();    }}/* 递归 O(n) */void recur(int n) {    if (n == 1) return;    return recur(n - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②常见类型</strong></p><blockquote><p><code>O(n^2)</code>：构建<code>n*n</code>的<strong>矩阵</strong></p></blockquote><blockquote><p><code>O(2^n)</code>：构建<code>n</code>层的<strong>二叉树</strong></p></blockquote><hr><h3 id="3-经典算法实例"><a href="#3-经典算法实例" class="headerlink" title="3.经典算法实例"></a>3.经典算法实例</h3><blockquote><p><strong>最大子列和问题</strong>：给定<strong>N个整数</strong>的序列，求出其中<strong>连续n个子列和</strong>的<strong>最大值</strong>，其中<code>n≤N</code></p></blockquote><h4 id="3-1-暴力穷举法"><a href="#3-1-暴力穷举法" class="headerlink" title="3.1.暴力穷举法"></a>3.1.暴力穷举法</h4><p><strong>①基本思想</strong></p><blockquote><p>求出<strong>所有连续子列和</strong>，从中找出<strong>最大</strong>的子列和，<strong>时间复杂度</strong>为<code>O(n^3)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum1(int A[],int N){  int ThisSum,MaxSum = 0;  int i,j,k;  for (i=0;i&lt;=N;i++) #确定起点  {    for(j=i;j&lt;=N;j++) #确定终点    {      ThisSum=0;      for(k=i;k&lt;=j,k++) #将第i到第j个叠加到一起      {        ThisSum=ThisSum+A[k];      }      if(ThisSum&gt;MaxSum)      MaxSum=ThisSum;    }  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2改进的暴力穷举法"><a href="#3-2改进的暴力穷举法" class="headerlink" title="3.2改进的暴力穷举法"></a>3.2改进的暴力穷举法</h4><p><strong>①思想</strong></p><blockquote><p>基于上述算法做出了一定<strong>改进</strong>。计算子列和是在<strong>已经计算完成</strong>的子列和<strong>加上最新项</strong>更新获得，可以<strong>省去k循环</strong>，<strong>时间复杂度</strong>为<code>O(n^2)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum2(int A[],int N){  int ThisSum,MaxSum = 0;  int i,j;  for (i=0;i&lt;=N;i++)/*i是子列左端*/  {    ThisSum=0;    for(j=i;j&lt;=N;j++)/*j是子列右端*/    {      ThisSum=ThisSum+A[j];/*对于相同的i和不同的j，只需要在j-1的基础上累加最新项即可*/      if(ThisSum&gt;MaxSum)      MaxSum=ThisSum;    }  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3分而治之"><a href="#3-3分而治之" class="headerlink" title="3.3分而治之"></a>3.3分而治之</h4><p><strong>①思想</strong>：？<br><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100000int MaxofThreeNum (int a, int b, int c)  \\ 求三个数中得最大值{   int maxSum;    maxSum = a &gt; b ? a : b;    maxSum = maxSum &gt; c ? maxSum : c;    return maxSum;}int DivideConquer(int data[], int left, int right){    int mid;    int leftMaxSum, rightMaxSum;    int leftBoardSum, rightBoardSum;    int leftMaxBoardSum, rightMaxBoardSum;   /* 退出条件 */    if (left == right)         return data[left];/* “分的过程” */    mid = (left + right) / 2; //找到中分点        /* 递归求两边的最大值 */    leftMaxSum = DivideConquer(data, left, mid);  // 左边最大值    rightMaxSum = DivideConquer(data, mid + 1, right);  // 右边最大值     /* 跨越边界的最大值 := leftMaxBoardSum + rightMaxBoardSum  */     leftMaxBoardSum = data[mid];     leftBoardSum = 0;     for (int i = mid; i &gt;= left; i--) {        leftBoardSum += data[i];        if (leftBoardSum &gt; leftMaxBoardSum)            leftMaxBoardSum = leftBoardSum;     }   //左边界扫描    rightMaxBoardSum = data[mid + 1];    rightBoardSum = 0;    for(int i = mid + 1; i &lt;= right; i++) {        rightBoardSum += data[i];        if(rightBoardSum &gt; rightMaxBoardSum)            rightMaxBoardSum = rightBoardSum;    }  //有边界扫描     /* 治的过程，最大值为左边的最大值、右边最大值，跨越边界最大值之中的最大值 */    return MaxofThreeNum(leftMaxSum, rightMaxSum, leftMaxBoardSum + rightMaxBoardSum);}int MaxSubSeqSum(int data[], int num)  // 改变函数接口{    return DivideConquer(data, 0, num - 1);}int main(){    int num;    int data[MAXN] = {0};    scanf("%d",&amp;num);    for (int i = 0; i &lt; num; i++) {        scanf("%d", &amp;data[i]);    }    printf("%d", MaxSubSeqSum(data, num));    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-在线处理"><a href="#5-在线处理" class="headerlink" title="5.在线处理"></a>5.在线处理</h4><p><strong>①思想</strong></p><blockquote><p>一开始<strong>子列左端为A[0]<strong>，逐个</strong>向右累加</strong>，若当前子列和<strong>为负数则舍去</strong>，因为一个<strong>负的子列和部分只会使得子列和变小</strong>,算法时间复杂度为<code>O(n)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">int MaxSubseqSum4(int A[],int N){  int ThisSum,MaxSum = 0;  int i;  for (i=0;i&lt;=N;i++)/*i是子列左端*/  {    ThisSum=ThisSum+A[i];    if(ThisSum&gt;=MaxSum)    MaxSum=ThisSum;    else    ThisSum=0;  }  return MaxSum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（三）</title>
      <link href="/2023/11/07/shu-ju-jie-gou-yu-suan-fa-san/"/>
      <url>/2023/11/07/shu-ju-jie-gou-yu-suan-fa-san/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法（三）"><a href="#数据结构与算法（三）" class="headerlink" title="数据结构与算法（三）"></a>数据结构与算法（三）</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h4><blockquote><p>建立<strong>键</strong><code>key</code>与<strong>值</strong><code>value</code>的<strong>映射</strong>，根据<strong>映射关系</strong>快速<strong>根据键找到值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 哈希表的增删查改操作的时间复杂度都是O(1)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 哈希表本质上是利用空间换时间</div><h4 id="1-2哈希算法"><a href="#1-2哈希算法" class="headerlink" title="1.2哈希算法"></a>1.2哈希算法</h4><p><strong>①定义</strong></p><blockquote><p>即<strong>键与值的映射关系</strong>，构造<strong>散列函数</strong><code>h</code>，通过<code>h(key)</code>找到<strong>对应值的位置</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是将一个较大的输入空间映射到一个较小的输出空间</div><p><strong>②构造</strong></p><blockquote><p>将<code>key</code>转化为<strong>哈希值</strong>，如将<code>key</code>的<strong>每个字符的ASCALL码相加</strong></p></blockquote><blockquote><p>对<strong>哈希值</strong>进行<strong>二次操作</strong>，如<strong>对容器大小取模</strong>，从而<strong>缩小范围</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 哈希算法的构造准则就是计算简单和减少冲突，有专业的哈希算法，如SHA系列，一些编程语言也有内置哈希算法</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用大质数作为模数时，可以最大化地保证哈希值的均匀分布，因为质数不会与其他数字存在公约数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有不可变对象是可哈希的</div><hr><h3 id="2-冲突处理"><a href="#2-冲突处理" class="headerlink" title="2.冲突处理"></a>2.冲突处理</h3><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 通常情况下，哈希表的输入空间远远大于输出空间，冲突无法避免，需要一定的方法处理冲突</div><h4 id="2-1开放定址"><a href="#2-1开放定址" class="headerlink" title="2.1开放定址"></a>2.1开放定址</h4><p><strong>①定义</strong></p><blockquote><p>若发生了<strong>第<code>i</code>次冲突</strong>，试探性地将<strong>其地址增加</strong><code>di</code>，即<code>hi(key)=h(key)+di</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里的冲突不是总计的冲突，而是当前元素发生冲突的次数，即对于每个元素，i都是从0开始计数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 查找元素时，倘若不匹配，试探性地假设其发生冲突，使用哈希函数向后遍历，直到找到该元素或者遇到空元素</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不能在开放寻址哈希表中直接删除元素，若删除了某个元素，与其发生冲突且存储时间晚于该元素的元素无法被查询</div><blockquote><p>通常采用<strong>懒删除</strong>，即<strong>不直接删除该元素</strong>，使用<strong>标记</strong>表示该元素被删除</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 查找元素时，可以记录遇到的首个标记元素，将查找到的元素与其交换位置，从而释放空间</div><p><strong>②分类</strong></p><blockquote><p><strong>线性探测法</strong>：<code>di=i</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 线性探测会产生聚集现象，即冲突数据集中在某一块，从而导致那里更容易发生冲突</div><blockquote><p><strong>平方探测法</strong>：<code>di</code>序列为<code>1、-1、4、-4....i^2、-i^2</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只要散列表的长度是某个4k+1形式的素数时，平方探测法可以探查到整个散列表空间</div><blockquote><p><strong>双散列探测法</strong>：<code>di=i*h2(key)</code>，其中<strong>h2为另一个非0散列函数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> h2应该保证尽量多的哈希存储单元能被探测到，如h2 = p-h1</div><h4 id="2-2分离链接"><a href="#2-2分离链接" class="headerlink" title="2.2分离链接"></a>2.2分离链接</h4><blockquote><p><strong>原始哈希表</strong>中，<strong>每个地址</strong>对应的只是<strong>一个值</strong>，<strong>分离链接法</strong>采用的是<strong>链表</strong>，先<strong>找到对应链表</strong>再<strong>遍历该链表</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 分离链接的本质是扩容，此处不采用数组，因为数组一开始就要有一定的长度，会造成空间浪费</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当链表很长时，可以将其转化为红黑树或者AVL树，优化查找时间</div><hr><h3 id="3-哈希表的实现"><a href="#3-哈希表的实现" class="headerlink" title="3.哈希表的实现"></a>3.哈希表的实现</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为哈希表的特性就是快速查找，所以其主体采用结构数组实现</div><h4 id="3-1分离链接哈希表"><a href="#3-1分离链接哈希表" class="headerlink" title="3.1分离链接哈希表"></a>3.1分离链接哈希表</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 链表节点 */typedef struct Node {    Pair *pair;    struct Node *next;} Node;/* 分离链接哈希表 */typedef struct {    int size;         // 键值对数量    int capacity;     // 哈希表容量    double loadThres; // 触发扩容的负载因子阈值    int extendRatio;  // 扩容倍数    Node **buckets;   // 桶数组} HashMapChaining;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造和析构</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 构造函数 */HashMapChaining *newHashMapChaining() {    HashMapChaining *hashMap = (HashMapChaining *)malloc(sizeof(HashMapChaining));    hashMap-&gt;size = 0;    hashMap-&gt;capacity = 4;    hashMap-&gt;loadThres = 2.0 / 3.0;    hashMap-&gt;extendRatio = 2;    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        hashMap-&gt;buckets[i] = NULL;    }    return hashMap;}/* 析构函数 */void delHashMapChaining(HashMapChaining *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Node *cur = hashMap-&gt;buckets[i];        while (cur) {            Node *tmp = cur;            cur = cur-&gt;next;            free(tmp-&gt;pair);            free(tmp);        }    }    free(hashMap-&gt;buckets);    free(hashMap);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③增删查改</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 查询操作 */char *get(HashMapChaining *hashMap, int key) {    int index = hashFunc(hashMap, key);    // 遍历桶，若找到 key 则返回对应 val    Node *cur = hashMap-&gt;buckets[index];    while (cur) {        if (cur-&gt;pair-&gt;key == key) {            return cur-&gt;pair-&gt;val;        }        cur = cur-&gt;next;    }    return ""; // 若未找到 key 则返回空字符串}/* 添加操作 */void put(HashMapChaining *hashMap, int key, const char *val) {    // 当负载因子超过阈值时，执行扩容    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {        extend(hashMap);    }    int index = hashFunc(hashMap, key);    // 遍历桶，若遇到指定 key ，则更新对应 val 并返回    Node *cur = hashMap-&gt;buckets[index];    while (cur) {        if (cur-&gt;pair-&gt;key == key) {            strcpy(cur-&gt;pair-&gt;val, val); // 若遇到指定 key ，则更新对应 val 并返回            return;        }        cur = cur-&gt;next;    }    // 若无该 key ，则将键值对添加至尾部    Pair *newPair = (Pair *)malloc(sizeof(Pair));    newPair-&gt;key = key;    strcpy(newPair-&gt;val, val);    Node *newNode = (Node *)malloc(sizeof(Node));    newNode-&gt;pair = newPair;    newNode-&gt;next = hashMap-&gt;buckets[index];    hashMap-&gt;buckets[index] = newNode;    hashMap-&gt;size++;}/* 扩容哈希表 */void extend(HashMapChaining *hashMap) {    // 暂存原哈希表    int oldCapacity = hashMap-&gt;capacity;    Node **oldBuckets = hashMap-&gt;buckets;    // 初始化扩容后的新哈希表    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        hashMap-&gt;buckets[i] = NULL;    }    hashMap-&gt;size = 0;    // 将键值对从原哈希表搬运至新哈希表    for (int i = 0; i &lt; oldCapacity; i++) {        Node *cur = oldBuckets[i];        while (cur) {            put(hashMap, cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);            Node *temp = cur;            cur = cur-&gt;next;            // 释放内存            free(temp-&gt;pair);            free(temp);        }    }    free(oldBuckets);}/* 删除操作 */void removeItem(HashMapChaining *hashMap, int key) {    int index = hashFunc(hashMap, key);    Node *cur = hashMap-&gt;buckets[index];    Node *pre = NULL;    while (cur) {        if (cur-&gt;pair-&gt;key == key) {            // 从中删除键值对            if (pre) {                pre-&gt;next = cur-&gt;next;            } else {                hashMap-&gt;buckets[index] = cur-&gt;next;            }            // 释放内存            free(cur-&gt;pair);            free(cur);            hashMap-&gt;size--;            return;        }        pre = cur;        cur = cur-&gt;next;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④其他</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 哈希函数 */int hashFunc(HashMapChaining *hashMap, int key) {    return key % hashMap-&gt;capacity;}/* 负载因子 */double loadFactor(HashMapChaining *hashMap) {    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;}/* 打印哈希表 */void print(HashMapChaining *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Node *cur = hashMap-&gt;buckets[i];        printf("[");        while (cur) {            printf("%d -&gt; %s, ", cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);            cur = cur-&gt;next;        }        printf("]\n");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2开放寻址哈希表"><a href="#3-2开放寻址哈希表" class="headerlink" title="3.2开放寻址哈希表"></a>3.2开放寻址哈希表</h4><p><strong>①结构</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 开放寻址哈希表 */typedef struct {    int size;         // 键值对数量    int capacity;     // 哈希表容量    double loadThres; // 触发扩容的负载因子阈值    int extendRatio;  // 扩容倍数    Pair **buckets;   // 桶数组    Pair *TOMBSTONE;  // 删除标记} HashMapOpenAddressing;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 构造函数 */HashMapOpenAddressing *newHashMapOpenAddressing() {    HashMapOpenAddressing *hashMap = (HashMapOpenAddressing *)malloc(sizeof(HashMapOpenAddressing));    hashMap-&gt;size = 0;    hashMap-&gt;capacity = 4;    hashMap-&gt;loadThres = 2.0 / 3.0;    hashMap-&gt;extendRatio = 2;    hashMap-&gt;buckets = (Pair **)malloc(sizeof(Pair *) * hashMap-&gt;capacity);    hashMap-&gt;TOMBSTONE = (Pair *)malloc(sizeof(Pair));    hashMap-&gt;TOMBSTONE-&gt;key = -1;    hashMap-&gt;TOMBSTONE-&gt;val = "-1";    return hashMap;}/* 析构函数 */void delHashMapOpenAddressing(HashMapOpenAddressing *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Pair *pair = hashMap-&gt;buckets[i];        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {            free(pair-&gt;val);            free(pair);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③增删查改</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 搜索 key 对应的桶索引 */int findBucket(HashMapOpenAddressing *hashMap, int key) {    int index = hashFunc(hashMap, key);    int firstTombstone = -1;    // 线性探测，当遇到空桶时跳出    while (hashMap-&gt;buckets[index] != NULL) {        // 若遇到 key ，返回对应桶索引        if (hashMap-&gt;buckets[index]-&gt;key == key) {            // 若之前遇到了删除标记，则将键值对移动至该索引            if (firstTombstone != -1) {                hashMap-&gt;buckets[firstTombstone] = hashMap-&gt;buckets[index];                hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;                return firstTombstone; // 返回移动后的桶索引            }            return index; // 返回桶索引        }        // 记录遇到的首个删除标记        if (firstTombstone == -1 &amp;&amp; hashMap-&gt;buckets[index] == hashMap-&gt;TOMBSTONE) {            firstTombstone = index;        }        // 计算桶索引，越过尾部返回头部        index = (index + 1) % hashMap-&gt;capacity;    }    // 若 key 不存在，则返回添加点的索引    return firstTombstone == -1 ? index : firstTombstone;}/* 查询操作 */char *get(HashMapOpenAddressing *hashMap, int key) {    // 搜索 key 对应的桶索引    int index = findBucket(hashMap, key);    // 若找到键值对，则返回对应 val    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {        return hashMap-&gt;buckets[index]-&gt;val;    }    // 若键值对不存在，则返回空字符串    return "";}/* 添加操作 */void put(HashMapOpenAddressing *hashMap, int key, char *val) {    // 当负载因子超过阈值时，执行扩容    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {        extend(hashMap);    }    // 搜索 key 对应的桶索引    int index = findBucket(hashMap, key);    // 若找到键值对，则覆盖 val 并返回    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {        free(hashMap-&gt;buckets[index]-&gt;val);        hashMap-&gt;buckets[index]-&gt;val = (char *)malloc(sizeof(strlen(val + 1)));        strcpy(hashMap-&gt;buckets[index]-&gt;val, val);        hashMap-&gt;buckets[index]-&gt;val[strlen(val)] = '\0';        return;    }    // 若键值对不存在，则添加该键值对    Pair *pair = (Pair *)malloc(sizeof(Pair));    pair-&gt;key = key;    pair-&gt;val = (char *)malloc(sizeof(strlen(val + 1)));    strcpy(pair-&gt;val, val);    pair-&gt;val[strlen(val)] = '\0';    hashMap-&gt;buckets[index] = pair;    hashMap-&gt;size++;}/* 删除操作 */void removeItem(HashMapOpenAddressing *hashMap, int key) {    // 搜索 key 对应的桶索引    int index = findBucket(hashMap, key);    // 若找到键值对，则用删除标记覆盖它    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {        Pair *pair = hashMap-&gt;buckets[index];        free(pair-&gt;val);        free(pair);        hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;        hashMap-&gt;size--;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④其他</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 哈希函数 */int hashFunc(HashMapOpenAddressing *hashMap, int key) {    return key % hashMap-&gt;capacity;}/* 负载因子 */double loadFactor(HashMapOpenAddressing *hashMap) {    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;}/* 扩容哈希表 */void extend(HashMapOpenAddressing *hashMap) {    // 暂存原哈希表    Pair **bucketsTmp = hashMap-&gt;buckets;    int oldCapacity = hashMap-&gt;capacity;    // 初始化扩容后的新哈希表    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;    hashMap-&gt;buckets = (Pair **)malloc(sizeof(Pair *) * hashMap-&gt;capacity);    hashMap-&gt;size = 0;    // 将键值对从原哈希表搬运至新哈希表    for (int i = 0; i &lt; oldCapacity; i++) {        Pair *pair = bucketsTmp[i];        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {            put(hashMap, pair-&gt;key, pair-&gt;val);            free(pair-&gt;val);            free(pair);        }    }    free(bucketsTmp);}/* 打印哈希表 */void print(HashMapOpenAddressing *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Pair *pair = hashMap-&gt;buckets[i];        if (pair == NULL) {            printf("NULL\n");        } else if (pair == hashMap-&gt;TOMBSTONE) {            printf("TOMBSTONE\n");        } else {            printf("%d -&gt; %s\n", pair-&gt;key, pair-&gt;val);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

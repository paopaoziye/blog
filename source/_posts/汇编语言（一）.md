---
title: 汇编语言（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 8086
  - 《汇编语言》
categories: 编程语言
keywords: 文章关键词
updated: ''
img: /medias/featureimages/27.webp
date:
summary: 汇编语言
---

# 汇编语言（一）
## 汇编语言启蒙
### 1.引言
#### 1.1汇编语言
**①机器语言**
>**概述**：**机器指令**的集合，**机器指令**是一串**二进制序列**
{%list%}
CPU将机器指令转化为一系列高低电平，以驱动电子器件
{%endlist%}
{%right%}
每一种微处理器都有其机器指令集，对应的机器语言和汇编语言可能是不同的，本文以16位的8086CPU为例
{%endright%}

**②汇编语言**
>**汇编指令**：**机器指令**便于记忆的格式，有对应的**机器码**

>**伪指令**：**没有**对应的**机器码**，由**编译器执行**，计算机并**不执行**

>**符号**：由**编译器识别**，**没有**对应的**机器码**
{%right%}
汇编语言可以看作是机器语言的抽象，同理高级语言可以看作是汇编语言的抽象
{%endright%}

#### 1.2指令与数据
{%list%}
两者本质上都是一串二进制数据，也并没有特殊的格式区别它们，取决于CPU如何解释它们
{%endlist%}
**①进制**
>**二进制**：以`B`**结尾**，或者以`0B`**开头**

>**八进制**：以`O`/`Q`**结尾**，或者以`0`**开头**

>**十进制**：**缺省情况**是十进制，以`D`**结尾**

>**十六进制**：以`H`**结尾**，或者以`0x`**开头**
{%wrong%}
十六进制的数据，在汇编源程序中不能以字母开头，需要在前面加0，如A000H需要改为0A000H
{%endwrong%}

**②ASCLL编码**
>用**单引号**`''`包围，表示其**按照字符**给出，**编译器**将其转化为对应的`ASCLL`**编码**
`'unIX'`等价于`75H,6EH,49H,58H`
{%list%}
小写字母的ASCLL码比对应大写字母的ASCLL码大20H
{%endlist%}


**③逻辑位操作**
>`and`：按位进行**与**运算

>`or`：按位进行**或**运算
{%list%}
可以通过该逻辑运算将对应的位设为1/0
{%endlist%}
```
and al,10111111 ;将第6位设为0
or al,01000000 ;将第6位设为1
```
{%right%}
可以通过改变位改变字母大小写，大写字母的ASCLL码第5位为0，小写字母对应位置为1，这样不需要判断大小写
{%endright%}
**③移位操作**
>`shl`：**左**移位

>`shr`：**右**移位
{%list%}
这条指令将移出的位存储在CF标志中，并用0填充缺失的位
{%endlist%}
{%warning%}
只能操作内存单元或者寄存器，不能操作字面量
{%endwarning%}

#### 1.3相关硬件概念
**①主板和接口卡**
>**主板**：一些**主要器件**的集成，如**CPU**、**存储器**、**外围芯片组**和**扩展插槽**等，通过**总线**相连

>**接口卡**：插在**扩展插槽**上，连接一些**外部设备**，CPU通过**控制接口卡**控制**外部设备**


**②CPU**
>**运算器**：信息**处理**

>**控制器**：**控制**各种器件工作

>**寄存器**：信息**存储**，**容量较小**，**数量有限**，主要都是**和CPU密切相关的信息**
{%list%}
8086的寄存器为16位，通用寄存器可以分为两个8位的寄存器，如ax可以分为ah和al
{%endlist%}
{%right%}
可以通过改变寄存器内容实现对CPU的控制
{%endright%}
{%warning%}
当指令操作al导致溢出时，溢出的位不会存储到ah中，因为它将al当作一个独立的寄存器
{%endwarning%}
**③总线**
>**概述**：CPU和**其他部件**交流的通道，物理上是一根根**导线的集合**，可分为以下三类

>**地址总线**：指定**存储单元**的**地址**
{%list%}
地址总线的宽度（根数）为N，则其能对2^N个单元寻址
{%endlist%}
>**数据总线**：传输**数据**
{%list%}
数据总线的宽度（根数）为N，则一次能传输N位的数据
{%endlist%}
>**控制总线**：传输**控制指令**
{%list%}
数据总线的宽度（根数）为N，则有N种控制指令
{%endlist%}

**④存储器**
{%right%}
依据读写属性分类
{%endright%}
>**随机存储器**：**可读可写**，但是必须**带电存储**，**关机**后存储**内容消失**，通常用于存放**程序和数据**

>**只读存储器**：只能**读取**，存储内容**不会丢失**，通常用于存放**系统软件**和**BIOS**
{%list%}
BIOS是主板和各类接口卡中的软件，可通过它对该硬件进行最基本的输入和输出
{%endlist%}

**⑤端口**
>**概述**：**外设**中可以由CPU读写的**寄存器**，每个端口都有一个**对应的地址**
{%list%}
端口只能用in和out指令进行读写，且需要用特定的寄存器访问端口
{%endlist%}

***

### 2.内存与地址
#### 2.1引言
**①基本概念**
>**16位结构**：**运算器**一次能处理**最长数据**、**寄存器**的**长度**以及**寄存器和运算器**的**通路**均为`16`位

>**存储单元**：存储器被划分为**若干个存储单元**，长度为**一个字节**

>**逻辑存储器**：CPU将**多个存储器**看作为一个**整体**，即**逻辑存储器**，每个存储器占**一段地址空间**
{%list%}
逻辑寄存器对应的地址称为逻辑地址
{%endlist%}
>**物理地址**：一个单元**真实唯一**的地址，也是CPU通过**地址总线**发出的地址
{%right%}
物理地址的详细计算方法和具体的CPU有关，其中最重要的就是它是多少位结构
{%endright%}
**②地址加法器**
>**概述**：计算**物理地址**，`物理地址 = 段地址*16+偏移地址`，也可以表示为`段地址:偏移地址`
{%list%}
地址加法器将地址分为了多个段，每个段的大小位2^16位，即64KB
{%endlist%}
{%right%}
若直接从8086CPU内部发出地址信号，只能达到16位（64KB）的寻址能力，地址加法器将其扩大到20位（4M）
{%endright%}
{%warning%}
同一个物理地址可以使用不同的段地址和偏移地址表示
{%endwarning%}

#### 2.2寻址
**①段地址**
>**概述**：**缺省**时，cpu会**根据情况**自动读取**段寄存器**中的值作为**段地址**，可以添加**段前缀**显式表明段地址

>**段前缀**：`段前缀:[偏移地址]`，段前缀通常是**段寄存器名**，如`mov ax,ds:[bx]`
{%list%}
8086有四个段寄存器，CS、DS、ES和SS，其中CS和SS有对应的特殊用途，其余可供自由使用
{%endlist%}
{%warning%}
8086不支持使用立即数直接修改段寄存器，需要使用通用寄存器作为中介
{%endwarning%}
```
mov DS,xxxxH ;错误 

mov ax，xxxxH
mov ds,ax
```

**②偏移地址**
>**概述**：通过`[]`给出，其中可以放置**立即数**和**寻址寄存器**，也可以**混合使用**

>**立即数**：直接**包含在机器指令中**的数据，执行前位于cpu的**指令缓冲器**中
{%list%}
如100、'a'等，类似于C中的字面值
{%endlist%}
>**寻址寄存器**：8086CPU提供了`bx`，`bp`，`si`，`di`四个寄存器
{%warning%}
其中bx和bp不能同时出现，si和di也不能同时出现
{%endwarning%}
>**混合使用**：如`[bx+si+8]`、`[bp+di]`、`[bx+9]`，也可以写成`[bx].8[si]`、`[bx].9`、`[bx]`
{%list%}
若含有bp，则段地址默认为ss段寄存器中的数据，其余默认为ds段寄存器
{%endlist%}
{%right%}
用段寄存器指定段，用偏移地址访问段
{%endright%}
{%wrong%}
汇编语言中偏移地址是以存储单元为单位计算的，并没有像C语言那么智能
{%endwrong%}

#### 2.3内存访问
**①`mov`指令**：
>`mov [container],[data]`：将**数据**送入一个**容器**中

>**容器**：类似于**C的左值**，可以是**寄存器名**，**内存单元地址**

>**数据**：类似于**C的右值**，可以是**字面量**、**寄存器名**以及**内存单元地址**
{%list%}
mov ax,bx类似于C中ax = bx
{%endlist%}
{%warning%}
mov ax,[0]指令在一些编译器中的意义等同于mov ax,0，为了防止歧义需要添加段前缀，或者同段寄存器使用中介
{%endwarning%}
{%wrong%}
在赋值的时候，需要保证两边的内存大小是一样的
{%endwrong%}
>若需要将**小内存**数据传入到**大内存**中（如累加，需要大内存作为容器**防止溢出**），可以用一个**大内存容器**作为**中介**
```
mov dx,bl ;错误

mov al,bl
mov ah,0
add dx,ax
```

**②数据长度信息**
{%list%}
访问内存不仅仅需要知道其起始地址，还需要知道操作的内存长度
{%endlist%}
>**寄存器名**：如`mov ax,xxx`或者`mov xxx,ax`则表示**处理的数据长度为一个字**，因为`ax`寄存器长度为**一个字**
{%list%}
同理mov al,xxx或者mov xxx,al表示进行字节操作
{%endlist%}


>**显示指明**：`word ptr`指明访问的内存为**字单元**，`byte ptr`则是**字节单元**
```
mov word ptr ds:[0],1 ;修改的是ds:[0]和ds:[1]
mov byte ptr ds:[0],1 ;修改的是ds;[0]
```

{%list%}
一个字需要两个内存单位，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中
{%endlist%}
{%right%}
push、pop只执行字操作
{%endright%}
{%warning%}
在没有寄存器参与的内存单元访问指令中，必须要显示指明操作内存长度
{%endwarning%}

#### 2.4指令的访问
**①相关寄存器**
>**`CS`段寄存器**：用于提供**当前要实施指令**的**段地址**

>**`IP`寄存器**：搭配`CS`**段寄存器**使用，8086CPU将`CS:IP`作为**当前执行**的指令的**物理地址**

**②过程概述**
>`CS`和`IP`寄存器的值送入**地址加法器**中，获得指令的**物理地址**

>**地址加法器**将物理地址送入**控制输入输出电路**

>**控制输入输出电路**将物理地址送入**地址总线**

>**数据总线**将对应物理地址**对应的指令**送入CPU
{%list%}
如图，一条指令占据多个内存单元，数据总线输入的是整条指令，而不仅仅是对应物理地址对应的内存单元的数据
{%endlist%}
>**控制输入输出电路**将对应指令送入**指令缓冲器**

>`IP`的值自动增加，指向**下一条指令**
{%list%}
若刚刚读入的指令长度为N个字节，则IP增加3
{%endlist%}
>**执行**指令缓冲器中的指令，并重复上述过程执行**下一条指令**
{%right%}
CS:IP对应内存位置的数据即为指令，CPU根据这个区分指令和数据
{%endright%}
{%list%}
可以修改CS和IP寄存器的值，指向我们的代码段，用于执行该段代码
{%endlist%}
{%warning%}
mov指令可以修改大部分寄存器的地址，但是不能修改CS和IP的地址，需要用跳转修改
{%endwarning%}
![初始状态](/image/HB_1.png)
***
### 3.汇编程序
#### 3.1汇编源程序
**①框架**
>**概述**：由**汇编指令**、**标号**和**伪指令**构成，其中**汇编指令**转换为**机器指令**执行，其余都变成了**描述信息**

>**程序返回**：结尾处`mov ax,4c00H`和`int 21H`将**CPU的控制权**还给使他运行的程序
{%list%}
汇编语言的源文件后缀为.asm
{%endlist%}

![指令和伪指令](/image/HB_5.png)

**②常用伪指令**
>`assume [段寄存器名]:[段名]`：将某个段和某个**段寄存器**联系到一起
{%right%}
段和段寄存器的关联将决定这个段的作用，如代码段和CS联系到一起，栈段和SS联系到一起
{%endright%}
>`[段名] segment`：说明一个段**开始**

>`[段名] ends`：说明一个段**结束**
{%list%}
一个汇编程序由多个段组成，段名最后会被处理为一个段地址
{%endlist%}
>`end`：一个汇编程序的**结束标记**
{%warning%}
不要搞混end和ends
{%endwarning%}

**③常用汇编指令**
>`add/sub` ：**加减法**，`sub ax,bx`类似于C中`ax = ax - bx`

>`inc/dec`：**递增/减**，`inc ax`类似于C中`ax = ax+1`

>`mul/div`：**乘除法**指令
{%list%}
乘除法可分为8位和16位，且被除数/被乘数需要实现放在特定寄存器中
{%endlist%}
{%right%}
根据被除数的范围选取除法的类别，16位寄存器能表示的值的上限为65535
{%endright%}
{%warning%}
使用内存单元时，需要使用word ptr和byte ptr指明内存单元的长度
{%endwarning%}

#### 3.2源文件的编译
**①运行编译器**
>本篇采用微软的`masm`编译器

![masm编译器](/image/HB_6.png)

**②导入源文件**
>如果源文件在**编译器工作路径下**，输入**文件名**即可，否则需要指明**完整路径**
{%list%}
编译后将在指定路径（在对应冒号后输入路径即可）生成可执行文件（.obj文件），缺省情况下当前路径
{%endlist%}
{%right%}
编译过程中还会提示你生成一些中间文件，如列表文件（.lst）和交叉引用文件（.crf），可忽略（直接enter）
{%endright%}
{%warning%}
如果源程序不是.asm文件，则需要输入全名
{%endwarning%}
![导入源文件](/image/HB_7.png)


#### 3.3链接目标文件
**①运行链接器**
>本篇采用微软的`Overlay Linker`

![Overlay Linker链接器](/image/HB_8.png)


**②导入目标文件**
>路径和文件名的规则**同编译器**
{%right%}
链接过程中还会提示你生成一些中间文件，如映像文件（.map），可忽略（直接enter）
{%endright%}
![导入目标文件](/image/HB_9.png)

**③链接库文件**
>如果程序中调用了**库文件中的子程序**，则需要链接对应的库

![链接库文件](/image/HB_10.png)


#### 3.4简化的编译和链接
>将跳过一些**非必要步骤**，即生成**中间文件**和**链接库**

![简化的编译](/image/HB_11.png)
![简化的链接](/image/HB_12.png)


#### 3.5跟踪程序执行过程
>本篇采用微软的`debug`程序

**①导入可执行文件**
![简化的链接](/image/HB_14.png)

**②可执行文件的加载过程**
>`DOS`系统中可执行文件的加载过程，其中`SA`存放在`ds`寄存器中，`DOS`系统使用`PSP`用来与程序通信

![可执行文件的内存情况](/image/HB_15.png)

**③查看寄存器状态**
>输入`-r`查看寄存器

![简化的链接](/image/HB_13.png)

**④查看程序内容**
>输入`-u`查看程序内容

![查看程序内容](/image/HB_16.png)

**⑤单步执行程序**
>输入`-t`单步执行指令
{%warning%}
当执行到int 21时，需要使用-p执行
{%endwarning%}
![单步执行程序](/image/HB_17.png)

**②对源程序进行编译链接**
>编译产生**目标文件**
链接源文件产生**可执行文件**
{%list%}
可执行文件包括两部分，一部分为程序和数据，另一部分为相关描述信息（程序有多大，占用多大内存）
{%endlist%}
{%right%}
其中伪指令在编译时均转化为相关描述信息
{%endright%}
**③执行程序**
>每个**操作系统**都有类似于**命令解释器**的程序用于执行程序，**命令解释器**会先找到对应程序并将其**载入内存**，随后设置`CS:IP`指向**程序的入口**，命令解释器**停止运行**，并运行对应程序，最后对应程序运行**结束**，**返回**到命令解解释程序




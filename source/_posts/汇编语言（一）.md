---
title: 汇编语言（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 汇编语言
  - 《汇编语言》
categories: 编程语言
keywords: 文章关键词
updated: ''
img: /medias/featureimages/27.webp
date:
summary: 汇编语言
---

# 汇编语言（一）
## 汇编语言启蒙
{%right%}
以下内容主要以8086CPU为例，该CPU是16位结构，注意这个大前提
{%endright%}
### 1.引言
#### 1.1汇编语言
**①机器语言**
>**机器指令**的集合，**机器指令**是一串**二进制数字**
{%list%}
CPU将机器指令转化为一系列高低电平，以驱动电子器件
{%endlist%}
{%right%}
每一种微处理器都有其机器指令集，对应的机器语言和汇编语言可能是不同的
{%endright%}

**②汇编语言**
>**汇编指令**：**机器指令**便于记忆的格式，有对应的**机器码**

>**伪指令**：**没有**对应的**机器码**，由**编译器执行**，计算机并**不执行**

>**符号**：由**编译器识别**，**没有**对应的**机器码**
{%right%}
汇编语言可以看作是机器语言的抽象，同理高级语言可以看作是汇编语言的抽象
{%endright%}


#### 1.2指令与数据
{%list%}
两者本质上都是一串二进制数据，也并没有特殊的格式区别它们，取决于CPU如何解释它们
{%endlist%}
**①进制**
>**二进制**：以字母`B`结尾

>**八进制**：以字母`O`或者`Q`结尾

>**十进制**：以字母`D`结尾，或者没有结尾字母

>**十六进制**：以字母`H`结尾
{%wrong%}
十六进制的数据，在汇编源程序中不能以字母开头，需要在前面加0，如A000H需要改为0A000H
{%endwrong%}

**②ASCLL编码**
>用**单引号**`''`包围，表示其**按照字符**给出，**编译器**将其转化为对应的`ASCLL`**编码**
`'unIX'`等价于`75H,6EH,49H,58H`
{%list%}
小写字母的ASCLL码比对应大写字母的ASCLL码大20H
{%endlist%}


**③逻辑位操作**
>`and`：按位进行**与**运算
`or`：按位进行**或**运算
{%list%}
可以通过该逻辑运算将对应的位设为1/0
{%endlist%}
```
and al,10111111 ;将第6位设为0
or al,01000000 ;将第6位设为1
```
{%right%}
可以通过改变位改变字母大小写，大写字母的ASCLL码第5位为0，小写字母对应位置为1，这样不需要判断大小写
{%endright%}
**③移位操作**
>`shl`：**左**移位
`shr`：**右**移位
{%list%}
这条指令将移出的位存储在CF标志中，并用0填充缺失的位
{%endlist%}
{%warning%}
只能操作内存单元或者寄存器，不能操作字面量
{%endwarning%}

#### 1.3相关硬件概念
**①主板和接口卡**
>**主板**：一些**主要器件**的集成，如**CPU**、**存储器**、**外围芯片组**和**扩展插槽**等，通过**总线**相连

>**接口卡**：插在**扩展插槽**上，连接一些**外部设备**，CPU通过**控制接口卡**控制**外部设备**


**②CPU**
>**运算器**：信息处理

>**寄存器**：信息存储，一般能存储的**位数不高**，主要都是**和CPU密切相关的信息**

>**控制器**：控制各种器件工作
{%list%}
出于兼容性的考虑，一个寄存器可分多个寄存器，通常最小单位8位（因为一个内存单元是8位），如一个16位寄存器ax可以看成两个8位寄存器al和ah
{%endlist%}
{%right%}
可以通过改变寄存器内容实现对CPU的控制
{%endright%}
{%warning%}
当指令操作al导致溢出时，溢出的位不会存储到ah中，因为它将al当作一个独立的寄存器
{%endwarning%}
**③总线**
>CPU和**其他部件**交流的通道，物理上是一根根**导线的集合**，可分为以下三类

>**地址总线**：指定存储单元
{%list%}
地址总线的宽度（根数）为N，则其能对2^N个单元寻址
{%endlist%}
>**数据总线**：传输数据
{%list%}
数据总线的宽度（根数）为N，则一次能传输N位的数据
{%endlist%}
>**控制总线**：传输控制指令
{%list%}
数据总线的宽度（根数）为N，则有N种控制指令（激活则为高电平）
{%endlist%}

**④存储器**
{%right%}
依据读写属性分类
{%endright%}
>**随机存储器**：**可读可写**，但是必须**带电存储**，关机后存储内容消失
**只读存储器**：只能读取，存储内容**不会丢失**
{%right%}
依据功能分类
{%endright%}
>**随机存储器**：存放CPU使用的**大部分数据和程序**
**装有BIOS的ROM**：BIOS是主板和各类接口卡中的软件，可通过它对该硬件进行**最基本的输入和输出**
**接口卡上的RAM**：某些接口卡需要**对大量输入输出数据进行暂时存储**，则会装有RAM，如显示卡的显存

**⑤端口**
>**PC系统**中，除了**存储器**，还有**其他芯片**通过**总线**和CPU相连，如**接口卡**和**主板**上的**接口芯片**等，这些芯片都有一组可以由CPU读写的**寄存器**，称之为**端口**，每个端口都有一个**对应的地址**
{%list%}
端口只能用in和out指令进行读写，且需要用特定的寄存器访问端口
{%endlist%}

***

### 2.内存与地址
#### 2.1内存地址空间
**①存储单元**
>每个存储器被划分为**若干个存储单元**，每个存储单元存储**一个字节**

**②逻辑存储器**
>CPU在操作**物理存储器**时，将他们**总的**看作为一个由若干存储单元组成的**逻辑存储器**，每个存储器占**一段地址空间**
{%list%}
内存地址空间的大小受到地址总线宽度的影响
{%endlist%}

#### 2.2物理地址
>一个单元**真实唯一**的地址，也是CPU通过**地址总线**发出的地址
{%right%}
物理地址的详细计算方法和具体的CPU有关，其中最重要的就是它是多少位结构
{%endright%}
**①十六位结构**
>**运算器一次处理**最多**16位**的数据
**寄存器最大长度**为**16位**
**寄存器和运算器的通路**为**16位**

**②地址加法器**：计算**物理地址**，`物理地址 = 段地址*16+偏移地址`，也可以表示为`段地址:偏移地址`
>易知每一段的起始地址为**16的倍数**，每一段的长度为**64KB**
{%list%}
8086CPU地址总线宽度为20，但是它本身一次性只能传输16位数据，如果直接从CPU内部发出地址信号，则只能达到64KB的寻址能力，故需要使用地址加法器扩大其寻址能力（16位乘以16则为20位）
{%endlist%}
{%warning%}
同一个物理地址可以使用不同的段地址和偏移地址表示
{%endwarning%}

#### 2.3寻址
**①段地址**：由**段寄存器**提供
>8086CPU有四个段寄存器，`CS`、`DS`、`ES`和`SS`，其中`CS`和`SS`有对应的**特殊用途**，其余可供自由使用
{%list%}
缺省时，cpu会根据情况自动读取段寄存器中的值作为默认段地址，可以添加段前缀显示表明段地址
{%endlist%}
{%warning%}
每个寄存器都有其特殊用途，如乘除法需要使用ax，bx，只是CS、SS等寄存器被占用频率非常高，故最好不要随便使用
{%endwarning%}
>**段前缀**：`段前缀:[偏移地址]`
段前缀通常是**段寄存器名**，如`mov ax,ds:[bx]`

**②偏移地址**：可以通过`[]`给出，其中可以放置**立即数**和**寻址寄存器**，也可以**混合使用**
>**立即数**：直接**包含在机器指令中**的数据，执行前位于cpu的**指令缓冲器**中
{%list%}
如100、'a'等，类似于C中的字面值
{%endlist%}
>**寻址寄存器**：8086CPU提供了`bx`，`bp`，`si`，`di`四个寄存器
{%list%}
si和di寄存器，不能分为两个八位寄存器
{%endlist%}
{%warning%}
其中bx和bp不能同时出现，si和di也不能同时出现
{%endwarning%}
>**混合使用**：如`[bx+si+8]`、`[bp+di]`、`[bx+9]`，也可以写成`[bx].8[si]`、`[bx].9`、`[bx]`
{%list%}
若含有bp，则段地址默认为ss段寄存器中的数据，其余默认为ds段寄存器
{%endlist%}
{%right%}
用段寄存器指定段，用偏移地址访问段
{%endright%}
{%wrong%}
汇编语言中偏移地址是以存储单元为单位计算的，并没有像C语言那么智能
{%endwrong%}

#### 2.4内存访问
**①`mov`指令**：
>`mov [container],[data]`
将**数据**送入一个**容器**中

>**容器**：类似于**C的左值**，可以是**寄存器名**，**内存单元地址**
**数据**：类似于**C的右值**，可以是**字面量**、**寄存器名**以及**内存单元地址**
{%list%}
mov ax,bx类似于C中ax = bx
{%endlist%}
{%right%}
8086CPU不支持通过立即数直接修改段寄存器的值（mov DS,xxxxH），需要先修改一个通用寄存器的值，然后将该寄存器的值送入DS（mov ds,ax）
{%endright%}
{%warning%}
与在debug中不同的是，mov ax,[0]指令在一些编译器中的意义等同于mov ax,0，为了防止歧义需要添加段前缀，或者将0存入bx中，采用mov ax,[bx]
{%endwarning%}
{%wrong%}
在赋值的时候，需要保证两边的内存大小是一样的
{%endwrong%}
>若需要将一个**小内存**的值**传入**到**大内存值**中（如累加，需要使用一个大内存作为容器**防止溢出**），可以用一个**大内存容器**作为**中介**
```
mov dx,bl ;错误

mov al,bl
mov ah,0
add dx,ax
```

**②数据长度信息**
{%list%}
访问内存不仅仅需要直到其起始地址，还需要知道操作的内存长度
{%endlist%}
>**寄存器名**：如`mov ax,xxx`或者`mov xxx,ax`则表示**处理的数据长度为一个字**，因为`ax`寄存器长度为**一个字**
同理`mov al,xxx`或者`mov xxx,al`表示进行**字节操作**

>**显示指明**：`word ptr`指明访问的内存为**字单元**，`byte ptr`指明是**字节单元**
如`mov word ptr ds:[0],1`和`mov byte ptr ds:[0],1`,两者修改的**内存长度**不一样，前者修改的是`ds:[0]`和`ds:[1]`，后者修改的是`ds;[0]`
{%list%}
一个字需要两个内存单位，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中
{%endlist%}
{%right%}
push、pop只执行字操作
{%endright%}
{%warning%}
在没有寄存器参与的内存单元访问指令中，必须要显示指明操作内存长度
{%endwarning%}

#### 2.5指令的访问
**①相关寄存器**
>**`CS`段寄存器**：用于提供**当前要实施指令**的**段地址**
**`IP`寄存器**：搭配`CS`**段寄存器**使用，8086CPU将`CS:IP`作为当前要实施的指令的**物理地址**

**②过程概述**
![初始状态](/image/HB_1.png)
>`CS`和`IP`寄存器的值送入**地址加法器**中，获得指令的**物理地址**
**地址加法器**将物理地址送入**控制输入输出电路**
**控制输入输出电路**将物理地址送入**地址总线**
**数据总线**将对应物理地址**对应的指令**送入CPU
{%list%}
如图，一条指令占据多个内存单元，数据总线输入的是整条指令，而不仅仅是对应物理地址对应的内存单元的数据
{%endlist%}
>**控制输入输出电路**将对应指令送入**指令缓冲器**
`IP`的值自动增加，指向**下一条指令**
{%list%}
若刚刚读入的指令长度为N个字节，则IP增加3
{%endlist%}
>**执行**指令缓冲器中的指令，并重复上述过程执行**下一条指令**
{%right%}
CS:IP对应内存位置的数据即为指令，CPU根据这个区分指令和数据
{%endright%}
{%list%}
可以修改CS和IP寄存器的值，指向我们的代码段，用于执行该段代码
{%endlist%}
{%warning%}
mov指令可以修改大部分寄存器的地址，但是不能修改CS和IP的地址，需要用跳转修改
{%endwarning%}

***
### 3.汇编程序概述
#### 3.1汇编程序执行概述
**①编写汇编源程序**
{%list%}
汇编语言的源文件后缀为.asm
{%endlist%}
**②对源程序进行编译链接**
>编译产生**目标文件**
链接源文件产生**可执行文件**
{%list%}
可执行文件包括两部分，一部分为程序和数据，另一部分为相关描述信息（程序有多大，占用多大内存）
{%endlist%}
{%right%}
其中伪指令在编译时均转化为相关描述信息
{%endright%}
**③执行程序**
>每个**操作系统**都有类似于**命令解释器**的程序用于执行程序，**命令解释器**会先找到对应程序并将其**载入内存**，随后设置`CS:IP`指向**程序的入口**，命令解释器**停止运行**，并运行对应程序，最后对应程序运行**结束**，**返回**到命令解解释程序
#### 3.2汇编源程序框架
**①框架**
>汇编指令才是**机器执行**的指令，其余都变成了**描述信息**

![指令和伪指令](/image/HB_5.png)
>**程序返回**：一个程序结束后，将**CPU的控制权**还给使他运行的程序
{%list%}
在汇编程序的最后一个段中结尾处添加以下两行指令即可
{%endlist%}
```
mov ax,4c00H
int 21H
```
**②常用伪指令**
>`assume 段寄存器名:段名`：将某个段和某个**段寄存器**联系到一起
{%right%}
段和段寄存器的关联将决定这个段的作用，如代码段和CS联系到一起，栈段和SS联系到一起
{%endright%}
>`段名 segment`：说明一个段**开始**
`段名 ends`：说明一个段**结束**
{%list%}
一个汇编程序由多个段组成，段名最后会被处理为一个段地址
{%endlist%}
>`end`：一个汇编程序的**结束标记**
{%warning%}
不要搞混end和ends
{%endwarning%}

**②常用汇编指令**
>`add`：加法指令
{%list%}
add ax,bx类似于C中ax = ax + bx
{%endlist%}
>`sub`：减法指令
{%list%}
sub ax,bx类似于C中ax = ax - bx
{%endlist%}
>`inc`：递增指令
{%list%}
inc ax类似于ax = ax+1
{%endlist%}
>`dec`：递减指令
{%list%}
dec ax类似于ax = ax-1
{%endlist%}
>`div`：除法指令
{%list%}
div 容器，容器（不能是ax，dx相关寄存器）中为除数，若除数为8位，则被除数为16位，放在ax中，结束后al存商，ah存余数，若除数为16位，则被除数为32位，高位放在dx中，低位放在ax中，结束后ax存商，dx存余数
{%endlist%}
{%right%}
根据被除数的范围选取除法的类别，16位寄存器能表示的值的上限为65535
{%endright%}
{%warning%}
使用内存单元时，需要使用word ptr和byte ptr指明内存单元的长度
{%endwarning%}
>`mul`：乘法法指令
{%list%}

{%endlist%}

#### 3.3源文件的编译
**①运行编译器**
![masm编译器](/image/HB_6.png)
>本篇采用微软的`masm`编译器

**②导入源文件**
![导入源文件](/image/HB_7.png)
>如果源文件在**编译器工作路径下**，输入**文件名**即可，否则需要指明**完整路径**
如果源程序不是`.asm`文件，则需要输入**全名**
{%list%}
编译后将在指定路径（在对应冒号后输入路径即可）生成可执行文件（.obj文件），缺省情况下当前路径
{%endlist%}
{%right%}
编译过程中还会提示你生成一些中间文件，如列表文件（.lst）和交叉引用文件（.crf），可忽略（直接enter）
{%endright%}

#### 3.4链接目标文件
**①运行链接器**
![Overlay Linker链接器](/image/HB_8.png)
>本篇采用微软的`Overlay Linker`

**②导入目标文件**
![导入目标文件](/image/HB_9.png)
>路径和文件名的规则**同编译器**
{%right%}
链接过程中还会提示你生成一些中间文件，如映像文件（.map），可忽略（直接enter）
{%endright%}
**③链接库文件**
![链接库文件](/image/HB_10.png)
>如果程序中调用了**库文件中的子程序**，则需要链接对应的库

#### 3.5简化的编译和链接
![简化的编译](/image/HB_11.png)
![简化的链接](/image/HB_12.png)
>将跳过一些**非必要步骤**，即生成中间文件和链接库

#### 3.6跟踪程序执行过程
>本篇采用微软的`debug`程序

**①导入可执行文件**
![简化的链接](/image/HB_14.png)

**②可执行文件的加载过程**
>`DOS`系统中可执行文件的加载过程，其中`SA`存放在`ds`寄存器中，`DOS`系统使用`PSP`用来与程序通信

![可执行文件的内存情况](/image/HB_15.png)

**③查看寄存器状态**
>输入`-r`查看寄存器

![简化的链接](/image/HB_13.png)

**④查看程序内容**
>输入`-u`查看程序内容

![查看程序内容](/image/HB_16.png)

**⑤单步执行程序**
>输入`-t`单步执行指令
{%warning%}
当执行到int 21时，需要使用-p执行
{%endwarning%}
![单步执行程序](/image/HB_17.png)





---
title: C语言学习笔记（二）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - C语言
  - 《C和指针》
categories: 编程语言
keywords: 文章关键词
updated: ''
date:
img: /medias/featureimages/0.webp
summary: 指针
---
# C语言学习笔记（二）
## C语言基础
### 1.指针
#### 1.1内存和地址
**①比特/位**
>计算机的**最小存储单位**，可以存储1和0

**②字节**
>一个字节包含**8个比特**，包含存储**一个字符**所需要的位数，是计算机的**最小寻址单位**

**③字**
>每个字由**2（16位机器）或者4（32位机器）个字节**组成，每个字的地址是其**最左边或者最右边**的字节的地址，每台机器规定不同

**④寻址**
>高级语言一般通过**变量名**而不是地址访问内存位置，**变量名和地址的关系由编译器提供**，**硬件还是通过地址**访问内存位置
{%list%}
边界对齐：整型值存储的起始位置只能是某些特定的字节，通常是2和4的倍数
{%endlist%}
{%warning%}
每个内存位置中存储的时一连串1和0，被解释为什么数据类型取决于我们的使用方式和声明方式，有些时候值可能是一样的但是被解释为了不同的数据类型
{%endwarning%}

#### 1.2指针变量
**①声明格式**
>`[指向变量的数据类型] *[指针变量名] = &[指向的变量]`
>`*`为**间接访问操作符**，可以通过它**访问指针指向的地址**
`&`为**取址符**，通过它可以**获得变量的地址**
{%list%}
对*指针变量进行操作相当于对其指向的变量进行操作
{%endlist%}
{%warning%}
指针数据类型取决于指向的变量的数据类型，比如假设整数a的地址是100，不能使用*100 = 10对a进行赋值，因为100是字面量，缺省情况下是整型而不是指针变量，应该写为*（int*）100 = 10，该技巧只有在需要访问特定地址时才使用
{%endwarning%}
**②未初始化的指针**
```
int *a;
*a = 12;
```
{%warning%}
指针需要进行初始化，因为声明一个指针并不会创建一个存储空间，所以其指向也未知，可能指向非法地址（内存错误）或者导致储存地址处于错误的边界（总线错误），所以一定要对指针进行初始化*可以初始化为空指针，但是要进行空指针检查）
{%endwarning%}
**③NULL指针**
>表示这个指针**没有指向任何地方**
{%wrong%}
注意对NULL指针进行引用是错误的，所以在对指针解引用时需要检查其是否为空指针
{%endwrong%}
**④指针的指针**
>`int** a = &b`：其中b是一个指向整型变量的指针，a表示一个指向指向整型变量指针的指针

**1.3指针与左右值**
```
int a = 10；
int* b = &a；
```
**①**其中当`a`、`*b`（变量名）作为右值时，代表的是“10”，即对应位置储存的数据，作为左值时代表对应位置的地址
**②**`&a`作为右值代表a的地址，不能作为左值，因为`&a`**不能代表内存中某一特定位置**
**③**`b`作为右值是表示的是`a`的地址，作为左值表示的是`b`的地址
**1.4指针表达式**
**①**`*b+1`：表示对`a`中的数据加1，只能作为右值，`*（b+1）`相当于`a`后面一个内存的标识符，作为左值代表对应的地址，作为右值代表对应位置存储的数据。
**②**`++b`：作为右值表示该指针指向位置的后一个位置的地址，作为左值是非法的
**③**`b++`：作为右值表示的该指针指向位置的地址，随后该指针加一，作为左值是非法的，因为他是一个数值而不是一个容器
**④**`*++b`：作为右值表示该指针指向位置后一个位置存放的数据，作为的左值表示的是该指针指向位置后一个位置
**⑤**`*b++`：作为右值表示的是该指针指向位置存放的数据，作为左值表示的是该指针指向变量，随后该指针变量加一
**⑥**`++*b`：作为右值表示的是b指向变量存放数据的值加一
{%list%}
++/--的优先级高于*
{%endlist%}
**1.5指针的运算**
**①与整数加减法**：当对指针加减一个整数n时，该指针会**根据其指向的数据的类型调整自身大小**（也适用于malloc分配的内存）
>比如某台机器上`float`占4个字节，对一个指向`float`变量的指针+n，该指针的大小会增加4n

**②`==`与`!=`**
>可以用于任意两个指针，判断两个指针是否相同

**③指针之间的减法**
>只有当两个指针都指向**同一数组**中的元素时，才允许用一个指针减去另一个指针，得到的数据类型是**ptrdiff_t**，这是一种有符号整数，表示两个指针指向位置的距离（以数组元素的长度为单位）

**④关系运算（大于/小于）**：只能用于**同一个数组**内的元素
{%warning%}
③④中同一数组的元素还包括数组末尾后一位元素，但是不包括数组开头前一位元素
{%endwarning%}

**1.6函数指针**
**①格式**：`返回类型 (*f)()`
>可以解释为`f`被间接引用后是一个函数，该函数的返回值是一个整型，所以f为一个函数指针
`()`为函数调用操作符，`f()`的结果是函数的返回值

**②初始化：**`返回类型 (*f)(参数列表) = 函数名`
{%warning%}
在函数指针初始化时，其参数列表需要与之对应
{%endwarning%}
{%list%}
其中函数名在编译时会被转换为函数指针，故可以不用取址符号
{%endlist%}

**③函数指针数组**：`返回类型 (*f[]) ();`
>`()`和`[]`均为第一优先级，结合性**从左向右**，优先级均高于`*`
```
double  (*oper_func[])(double,double) = {a,b,c...};
result = oper_func[1](i,j);

```

**④用途**：构造泛型函数
{%list%}
泛型函数：可以处理不同数据类型的函数
{%endlist%}
{%right%}
函数指针可以作为一个参数提供给另一个函数，使得该函数可以在另一个函数中使用，这些函数被称为回调函数
{%endright%}
>将函数中与数据类型相关的操作替换为**一系列等价的函数**，需要使用哪一类数据类型的对应操作，传递对应的函数指针即可
将传递给**函数以及回调函数**的数据类型替换`*void`，`*void`用于接收不同数据类型的指针
{%warning%}
在使用这些数据的指针时，必须要强制转换为正确的数据类型
{%endwarning%}
```
/*比较函数的整数版本
int compare_ints(void const *a,void const *b)
{
	if(*(int *)a = *(int *)b)
		return 0;
	else
		return 1;
}
```



### 2.函数
**2.1源文件格式**
```
返回类型 函数名（形参类型1 形参名1，...形参类型n 形参名n）
{
	statement；
    return expression；
}
```
>`return`语句不一定出现在末尾，没有`return`语句的函数称为**过程**
**类型、形参和statement**都不是必须的，因此最简单的函数可以写为

```
void function （void）
{

}
```
{%list%}
这种函数可以达到存根的目的,即为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分
{%endlist%}
{%right%}
函数要考虑异常情况
{%endright%}
{%warning%}
函数中的形参是实参的一个副本，修改形参不能修改实参，如果想要修改实参，需要传递实参的地址
{%endwarning%}
{%wrong%}
当本该有参数的地方没有参数时，必须要使用void占据位置
{%endwrong%}

**2.2函数声明**
**①格式**：`返回类型 函数名(形参类型n 形参名n);`
>向编译器**提供函数相关信息**，如果没有对应的函数声明，函数会被调用，但是传递给函数的参数会进行**缺省参数提升**（`char`和`short`被转换为`int`，`float`被转化为`double`），且默认返回一个**整型**
函数声明的结尾是有一个**分号**的，而函数定义没有

{%right%}
大部分时候将函数定义在单独的C文件中，然后将函数声明置于同一个头文件中，主函数文件使用include命令调用即可
{%endright%}
{%warning%}
当调用函数时输入的变量类型不匹配，编译器会根据函数声明强制转换变量类型
{%endwarning%}
{%wrong%}
函数原型不要写在代码块中，因为代码块中的函数原型有代码块作用域，可能会覆盖原来的函数声明
{%endwrong%}
**2.3利用函数实现黑盒**：利用`static`关键字修饰**函数内置数据和函数**，使其变为函数文件私有，外界不能访问
**2.4递归函数**：直接或者间接**调用自身**的函数，当递归函数**不再满足某个条件**时，便停止调用自身
以下为递归函数的例子
```
binary_to_ascii(unsigned int value)
{
	unsigned int a;
	a = value/10;
	if(a!=0)
		binary_to_ascii(a)
	putchar(value%10+‘0)’;
}
```

>递归的**实现过程**（假设一开始`value`的值为4267）
①当函数被调用时，变量创建在堆栈中，之前调用函数的变量依旧保持在堆栈之中，但是**被新函数的变量掩盖所以不能被访问**（堆栈的特性）
②所以当递归函数调用自身时，每次新的调用都会创建一批新的变量掩盖原来的变量
③函数刚调用时，堆栈中出现了`value[1] = 4267`和`a[1] = 426`
④当函数判断条件符合，又对函数进行第二次调用，堆栈中`value[2] = 426`、`a[2] = 42`掩盖了原先的`value`和`a`
⑤第三次调用，`value[3] = 42`，`a[3] = 4`
⑥第四次调用，`value[4] = 4`，`a[4] = 0`，至此，停止递归，然后函数开始打印输出，并开始释放销毁堆栈中的对应变量，**从顶端的变量开始释放**（堆栈的特性），从`[4]`到`[3]`到`[2]`再到`[1]`

{%list%}
递归函数需要设置限制条件，且每次递归调用之后就越接近该限制条件
{%endlist%}
{%wrong%}
递归的计算代价非常大，如果可以使用循环等解决问题，不要使用递归
{%endwrong%}
**2.5可变参数列表**
**①实现**：通过宏实现，定义于`stdarg.h`头文件中，该头文件中声明了一个`va_list`类型和三个宏`va_start`、`va_arg`和`va_end`
**②用法**：
```
#include<stdarg.h>

/*用于计算输入数字的平均数
float average (int n_value,...)
{
	va_list number_n;
	int count;
	float sum = 0;
	va_start(number_n,n_value);
	for (count=0;count<n_value;count+=1)
	{
		sum = sum+va_arg(number_n,int);
	}
	va_end(number_n);
	return sum/n_value;
}
```
>在函数体内部定义`va_list`类型参数，该参数代表可变参数列表
使用`va_statr`初始化`va_list`类型参数，该宏接收的第一个参数是`va_list`类型参数`number_n`，第二个参数是可变参数列表的前一个参数`n_value`
使用`va_arg`代替可变参数进行计算，该宏接收的第一个参数是`va_list`类型参数`number_n`，第二个参数是可变参数列表的**数据类型**
使用`va_end`注销可变参数列表

{%list%}
要使用该宏，则函数必须要有一个已确定的参数（上例中的n_value）
{%endlist%}
{%warning%}
注意函数形参部分的写法，可变参数列表用...代替，在书写函数声明时，也需要注意
{%endwarning%}

### 3.数组
**3.1声明格式**：`数据类型 数组名[数组大小]`
**①数组名**：数组名的值是一个**指针常量**（注意是常量，所以不能改变），指向数组的起始位置
>数组名不仅仅只是一个指针常量，还包含了**数组长度**等信息，在创建数组的时候编译器会根据其长度为**数组**划分对应的内存空间，随后为数组名划分内存；而创建指针的时候，**只为指针本身划分内存**

{%list%}
只有数组名在表达式中被使用了，编译器才会创建对应的指针常量
{%endlist%}
{%warning%}
数组名在一些情况下不是一个指针，而是代表整个数组，比如sizeof（数组名）会返回整个数组的长度，&数组名产生的是一个数组的指针，而不是一个指向指针的指针
{%endwarning%}
**②下标引用**：`a[b]`相当于`*(a+b)`，**所以下标从0开始**
>在C语言中，下标引用可以应用于**所有的指针**，不仅仅局限于数组

{%list%}
指针间接访问的效率大于等于下标引用效率，详细见《C与指针》p145-p150
{%endlist%}
{%wrong%}
注意检查数组越界问题
{%endwrong%}
**3.2数组与函数**：数组做为**形参**，格式可以是`(数据类型 数组名[])`也可以是指针类型`(数据类型 *指针名)`
>函数在声明数组参数时不需要指定他的长度，因为他只接受数组的地址，而不为其分配内存，所以如果需要知道数组的**大小**，还需要**另一个形参**

{%list%}
数组名传给形参是以传值的形式传递的，所以在函数中，对应指针变量是可以被修改的，但是不会影响到原来的数组名的值
{%endlist%}
**3.3初始化**
**①格式**：`数据类型 数组名[] = {值1,值2,…}`
>当数组为**静态变量**时，在**程序执行前**便被初始化，缺省情况下为**0**
数组为**自动变量**（存储在堆栈中），在缺省情况下**无法被初始化**（因为每次程序流经过堆栈，堆栈中变量的位置是不固定的）

{%right%}
被初始化后，每次执行流经过数组的作用域时，数组又会被初始化一次（因为之前在作用域结束后被销毁），所以，对于那些非常大的数组 ，可以考虑将其设为static，减少其初始化次数
{%endright%}
**②不完整的初始化**
>缺少元素：**优先填充前面的**，缺少的被命名为0
缺少数组长度：编译器将其设置为刚好能够**容纳所有初始值**的大小

**③字符数组的初始化**:`char a[] = “b”`相当于`char a = {'b',0}`
{%warning%}
只有在初始化字符数组时“b”才代表一个初始化列表，其他场合都为字符串常量，如下，message1是一个字符数组，message2是一个指向字符串字面值的指针
{%endwarning%}
```
char message1[] = "hello";
char *message2 = "hello";
```

**3.4多维数组**
**①声明**：`数据类型 数组名 [维度1][维度2]…[维度N]`
>`int a [3][6][9]`：可以解读为a数组有包含3个变量，这3个变量是个包含6个变量的数组，同时这6个变量又是包含9个变量的数组

**②存储形式**：按照**最右边的下标**率先变化，比如`int *b = &a[1][3]`,`b++`为`a[2][0]`
![a[3][4]](/image/C_1.png)
**③数组名**：类比一维数组，将n维数组看为一个**元素是n-1维数组的一维数组**，数组名即**指向第一个n-1维数组的指针**
>`int a[3][4]`，将其看成有三个包含四个元素的一维数组
`a`：一个指向第一个包含**四个整型元素的数组**的指针
`a+1`:指向的**第二个四元素的一维数组**的指针（指针的加减法法则是根据指针的类型决定的）
`*(a+1)`：指向第二个包含四个元素数组的**第一个整型元素的指针**,注意这个还不是其中所包含的数据
`*a+1`:指向第一个包含四个元素数组的第二个元素的指针
`*(*a+1)`：为第一个包含四个元素数组的**第二个元素**

{%right%}
一层一层解引用，n维数组要解引用n次，才能获得数据
{%endright%}
**④多维数组的初始化**
>以二维数组为例
`int a[][] = {元素1、元素2…};`
定义后，通过`a[i][j] = 数值;`，一个一个赋值
`int a[][] = {{数组1}，{数组2}…};` 
{%right%}
层层套娃
{%endright%}

**3.5多维数组与指针**
**①指向数组的指针**：`数组元素数据类型 (*指针名)[数组元素个数] = 二维数组名`
>**下标引用的优先级比间接访问高**，但是由于括号的存在，先执行的是间接访问，这样就将`p`定义为一个指针，**它指向的对象进行下标引用得到的是一个整型**，所以他是一个指向一维数组的指针，指向二维数组的第一行，该指针进行加法时，是**以一个数组为单位移动**的
{%warning%}
这里的数组元素个数与之对应，如int (*p)[4] = a;
{%endwarning%}
{%right%}
将数组传递给一个函数，本质上是传递一个对应的指针，对于多维数组，就是传递一个指向数组的指针，对应函数原型应写为`void func1(int (*a)[4])`或者`void func1(int a[][4])`
{%endright%}
**②指向元素的指针**：`数组元素数据类型 *p = &数组名[0][0]`或者`数组元素数据类型 *p = 数组名[0]`（以二维数组为例）
{%list%}
注意后者是没有&符号的，因为后者就是一个指向元素的指针！
{%endlist%}
**③指针数组**：`数据类型* 数组名[个数]`
{%warning%}
与指向数组的指针仅仅只有一个括号之差
{%endwarning%}


### 4.结构
**4.1格式**
**①定义**
```
struct [结构类型名称]
{
	结构成员表(每个成员的类型和名字);
};
```
{%list%}
结构变量是标量类型，所以相同的结构变量可以相互赋值
{%endlist%}
{%right%}
可以将结构定义在一个头文件中，使用include包含即可
{%endright%}

**②声明**：`struct 结构类型名称 结构名`
{%right%}
可以使用typedef关键字为结构定义新的名字
{%endright%}

```
typedef struct
{
	结构成员表(每个成员的类型和名字);
}[结构类型名称];
```
**③初始化与赋值**：`struct 结构名 变量名 = {成员1，成员2，成员3}`
```
struct X
{
	int a;
	short b[3];
	simple c;
};
struct X x1 = {10,{1,2,3},{25,'x'}};
```
**④结构成员的访问**
>`.`操作符：`结构名.成员名`
`->`操作符：`对应结构指针->成员名`
{%list%}
这两个操作符优先级相同，比*和[]高，结合性从左向右
{%endlist%}
{%warning%}
假设px是结构x的指针，px指向的地址和结构第一个成员的地址是一样的，但是*px代表的是整个结构
{%endwarning%}
{%right%}
当结构需要作为函数参数时，可以传递该结构的指针，效率较高，可以用const关键词防止对结构体的修改
{%endright%}
**4.2结构的引用**
**①结构的自引用**：结构内部成员为自己本身是非法的，但是可以**包含自己的指针类型**
```
//非法，因为在声明next成员时，Node还有没被声明
typedef struct
{
  ElemType data;
  struct Node *next;
}Node;
//合法
typedef struct Node
{
  ElemType data;
  struct Node *next;
}Node;
```
{%list%}
因为结构在定义时内存大小是不确定的，而结构指针的内存大小在结构创建前就已经确定
{%endlist%}
{%wrong%}
注意不能使用之前没有定义的结构标签
{%endwrong%}

**②结构之间的引用**：当需要定义几种之间**存在联系**的结构，可以采用不完整声明
```
struct B; //B的不完整声明
struct A
{
	struct *B;
};
struct B
{
	struct A;
};
```
{%wrong%}
注意，A中不能以B为成员，只能以B的指针为成员，因为不完整声明导致B的大小不能确定
{%endwrong%}


**4.3结构的存储分配**
**①**正常情况下，编译器按照**成员列表顺序**一个一个给每个成员分配内存
**②**当成员的存储需要满足正确的边界对齐条件，成员之间会出现未填充的内存空间
{%list%}
边界对齐：访问特定类型变量的时候经常在特定的内存地址访问
{%endlist%}
>假设一台机器的整型值长度为4字节，且要求其**起始存储位置**必须能被4整除，而结构的起始位置也必须满足**成员中边界要求最严格**的对齐条件，则以下结构在内存中的存储情况如下
```
struct X
{
	char a;
	int b;
	char c;
}
```
![内存分配情况](/image/C_3.png)
**③对边界要求最严格的成员应该首先出现**，这样可以**节省内存**
```
struct X
{

	int b;
	char a;
	char c;
}
```
![内存分配情况](/image/C_4.png)
**④常用函数**：`sizeof`可以得到一个结构的整体长度，**包括因为边界对齐跳过的字节**，`offsetof`可以确定结构中某个成员的位置（偏离结构存储起始位置的字节数）
**4.4位段**
**①声明格式**：一种特殊的结构，成员必须是`int`、`signed`、`unsigned`类型，成员名后面是**一个冒号和一个整数，该整数表示该成员占用的位的数目**
```
struct WeiDuan
{
	unsigned a : 7;
	unsigned b : 6;
	unsigned c : 19;
};
```
{%right%}
位段可以将长度为奇数的数据包装在一起，并且可以访问一个整型值的部分内容（这些部分内容可能有特定的含义）
{%endright%}
{%warning%}
显示的用signed和unsigned声明位段比较好，如果仅仅将位段声明为int类型，被解释为有符号数还是无符号数由编译器决定
{%endwarning%}
**②位段的移植性问题**
>很多编译器将位段**成员**的长度限制在**一个整型值**之内，32位机器上可以使用的位段声明可能在16位机器上无法使用
位段的内存是**从左向右**分配还是**从右向左**分配由机器决定
当位段的**总位数不是8的倍数时**，其内存分配是否要“边界对齐”取决于编译器
{%list%}
任何使用位段实现的任务，都可以通过移位和屏蔽实现，但是会麻烦一些
{%endlist%}

**4.5联合**
**①声明格式**
```
union
{
	float f;
	int i;
}fi;
```
>联合各个成员**共用内存中的一个位置以及数据**，当联合的某个成员被访问时，则将该联合所在位置的位以该成员类型解释被访问，换句话说，**联合的各个成员决定了这些位是如何被解释的**

**②联合的变体**：联合各个成员的长度可以不同，比如说两个结构
{%list%}
当联合中各个成员具有不同的长度，联合的长度就是它最长成员的长度
{%endlist%}
{%right%}
当成员之间大小相差太大时，可以将联合的成员修改为不同数据类型的指针，这样就不会造成空间浪费
{%endright%}
**③联合的初始化**
```
union
{
	int a;
	float b;
	char c[4];
}x = {5};
```
{%list%}
联合变量的初始值只有一个，且必须是联合第一个成员类型的数据
{%endlist%}
### 5.动态内存分配
**5.1内存分配**
**①**`malloc()`:从**内存池**中提取一块**连续**的内存，并返回一个**指向这块内存的指针**，如果内存池没有合适的内存则返回**NULL**，这块内存**没有被初始化**
>格式：`p = malloc（size）;`
`malloc()`返回值是`void *`，可以转化为任何类型的指针
`size`为需要分配的**字节数**，其类型是`size_t`，一个**无符号类型**
{%list%}
malloc()返回内存的起始位置始终满足边界对齐条件
{%endlist%}
{%right%}
可以将size替换为n*sizeof（数据类型），n为数量，还可以提高程序的可移植性
{%endright%}
**②**`calloc()`：和`malloc`一样用于分配内存，但是`calloc`会将内存内所有元素初始化为0，会消耗一定的时间
>格式：`p = calloc(num,size);`
其中`num`为元素的个数，`size`为每个元素的大小，类型均为size_t

**③**`realloc()`：**修改**一个已经分配的内存块的大小，新增加的内存添加到原先内存块的**尾部**，没有被初始化，如果用于缩小原来的内存块，则将**尾部**的内存块拿掉
>格式：`p = realloc(ptr,size);`
其中`ptr`是需要调整大小的指针，`size`是调整后内存的大小

{%list%}
C语言中，void*可以赋值给其他类型指针，但是在其他语言如C++中不行，故最好在前面加一个强制类型转换
{%endlist%}
{%warning%}
若原先的内存块大小无法改变，则realloc会重新划分一块内存，并释放原来的内存，所以要使用realloc返回的指针
{%endwarning%}
{%wrong%}
动态分配得到的指针是变量，但是我们不希望他改变，因为最后还需要释放掉，故有需要可以构建该指针的副本对内存进行操作
{%endwrong%}

**5.2内存释放**：当分配的内存不再使用时，需要使用`free()`将其释放
**①函数原型**：`void free (void *pointer)`
**②使用格式**：`free (p)`
**5.3常见错误**
**①**对NULL指针进行解引用
**②**对分配的内存操作时越界
**③**释放并为动态分配的内存
**④**释放动态内存的一部分
**⑤**访问一块已经被释放的内存，尤其是当内存分配指针被备份时
**⑥**内存释放不及时，导致内存泄漏

**5.4内存操作函数**
{%list%}
和字符串的一些操作函数很像，但是遇到NUL字节不会停止
{%endlist%}
**①**`memcpy()`：**直接复制**一块内存中数据到另一块内存中
>函数原型`void *memcpy(void *dst,void const *src,size_t length)`
{%list%}
如上，内存操作函数接收和返回的参数都是void*，且会规定操作的内存长度
{%endlist%}
{%right%}
length是字节的个数，可以使用sizeof便捷计算
{%endright%}
{%warning%}
两块内存不能重叠
{%endwarning%}
**②**`memmove()`：类似于`memcpy()`，但是`memmove()`在转移时会经过一块**临时内存**
**③**`memcmp()`：比较两块内存的内容（按照无符号字符逐字节比较）
{%warning%}
不能用于比较非单字节数据
{%endwarning%}
**④**`memchr()`：查找某块内存某个字符**第一次出现**的位置
**⑤**`memset()`：将一段内存**都设置**为某个字符


### 5.字符串
#### 5.1定义
>以`'/0'`**结尾**的**字符数组** 
{%list%}
'/0'的位模式全为0，也叫NUL字节，是字符串的终止符，字符串长度不包括终止符的长度
{%endlist%}

**6.2基本操作**
{%list%}
需要包含string.h头文件
{%endlist%}
**①**`strlen()`：**测量字符串长度**，即字符串包含的**字符个数**
>该函数返回的长度的数据类型为`size_t`，是一个**无符号数**
{%warning%}
两个无符号数a、b相互比较时，应该使用a>b，而不是a-b>0，因为无符号数运算结果为无符号数，无符号数永远大于0
{%endwarning%}
{%wrong%}
大部分字符串相关函数都是根据终止符判断字符串长度，所以使用者要确保操作后字符串不会溢出，否则会缺少终止符
{%endwrong%}
**②**`strcpy()`：**复制字符串**，但是如果复制的字符串长度**超出了容器的限度**，则会**覆盖其后面的内存空间**
{%wrong%}
大部分字符串函数不允许两个数组参数重叠，否则函数的返回值是未定义的
{%endwrong%}
**③**`strcat()`：**连接字符串**，将一个字符串添加到另一个字符串后面
**④**`strcmp()`：**字符串比较**，进行的是**字典比较**
>**字典比较**：对两个字符串的逐个字符从头进行比较，只要比较出一个字符大小即可判断结果，`'/0'`小于任何字符
**⑤长度受限的字符串函数**：为了**防止目标数组溢出**，定义了对应函数的长度受限版本，接受一个长度参数，用于限制操作的字符个数，如`strncpy()`
{%wrong%}
但是这些函数可能导致目标数组**不是以“/0”结尾**，可能会**导致程序崩溃**
{%endwrong%}
{%right%}
可以在函数调用完后将字符数组的最后一个元素改为NUL
{%endright%}


**6.3字符串查找**
**①字符查找**
>`strchr()`：返回对应字符**第一次**出现的位置
`strrchr()`：返回对应字符**最后一次**出现的位置
`strpbrk()`：返回**一组字符中任意一个字符**第一次出现的位置

**②字串查找**
>`strstr()`：返回**子串**第一次出现的起始位置
`strtok()`：删除字符串中的所有**标记字符**，其第二个参数是一个字符串，也就是**标记字符的集合**
`strspn()`：检索字符串str1（第一个参数）中**第一个不在字符串str2（第二个参数）中出现的字符下标**
`strcspn()`:检索字符串str1（第一个参数）中**第一个出现在字符串str2（第二个参数）中出现的字符下标**


**6.4字符操作**
{%list%}
需要包含ctype.h头文件
{%endlist%}
**①字符分类**：根据对应分类函数定义，判断该字符是否为该类型
>`isspace()`：是否为空白字符
`isdigit()`：是否为数字
{%list%}
还有很多类似函数，可自行查询
{%endlist%}
**②字符转换**：转换字符的大小写
>`tolower()`：转换为小写形式
`toupper()`：转化为大写形式
{%right%}
直接测试或者操纵字符可能会影响程序的移植性，比如if(ch>='A' && ch<='Z')判断ch是否为大写字母，在使用EBCDIC字符集上的机器上将失败，但是使用isupper(ch)则无限制
{%endright%}

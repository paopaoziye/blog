---
title: C语言学习笔记（二）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - C语言
  - 《C和指针》
categories: 编程语言
keywords: 文章关键词
updated: ''
date:
img: /medias/featureimages/0.webp
summary: 指针
---
# C语言学习笔记（二）
## C语言基础
### 1.指针
#### 1.1引言
>**比特/位**：计算机的**最小存储单位**，可以存储**1和0**
{%right%}
数据以比特流的形式存储，被解释为什么取决于我们的使用方式和声明方式
{%endright%}

>**字节**：**一个字节**包含**8个比特**，存储**一个字符**所需要的**位数**
{%list%}
字节是计算机的最小寻址单位
{%endlist%}
{%warning%}
一些数据类型（如整型）的存储的起始位置只能是某些特定的字节，通常是2和4的倍数
{%endwarning%}
>**字**：**一个字**由**2/4个字节**组成
{%list%}
每个字的地址是其最左边或者最右边的字节的地址，每台机器规定不同
{%endlist%}

>**寻址**：**高级语言**一般通过**变量名**访问**内存位置**
{%right%}
变量名和地址的关系由编译器提供，硬件还是通过地址访问内存位置
{%endright%}

#### 1.2指针变量
**①声明格式**：
>`[指向变量的数据类型] *[指针变量名] = &[指向的变量]`

>`*`为**间接访问操作符**，可以通过它**访问指针指向的地址**

>`&`为**取址符**，通过它可以**获得变量的地址**
{%list%}
对（*指针变量）进行操作相当于对其指向的变量进行操作
{%endlist%}
{%warning%}
指针不是一个整型，其数据类型取决于指向的变量的数据类型
{%endwarning%}
>假设**整数**`a`的**地址**是`100`，不能使用`*100 = 10`对`a`进行**赋值**，因为`100`是**字面量**，**缺省情况**下是**整型**而不是**指针变量**，应该写为`*（int*）100 = 10`
{%right%}
可以使用该技巧访问特定地址
{%endright%}

**②未初始化的指针**
>使用**未初始化的指针**会**引发错误**
```
int *a;
*a = 12;
```
{%list%}
若指针变量没有被初始化，则其值可能为一垃圾值（动态变量）或者0（静态变量）
{%endlist%}
{%warning%}
未初始化指针可能指向非法地址（内存错误）或者导致储存地址处于错误的边界（总线错误）
{%endwarning%}
{%right%}
可以先将指针初始化为空指针NULL，但是注意要进行空指针检查，因为对空指针引用也是错误的
{%endright%}

**③指针的指针**
>`int** a = &b`：其中`b`是一个**指向整型变量的指针**，`a`表示一**个指向指向整型变量指针的指针**
{%list%}
依此类推，也称为多重指针
{%endlist%}
{%warning%}
尽量少使用多重指针
{%endwarning%}
**④指针与左右值**
```
int a = 10；
int* b = &a；
```
>`*b`相当于`a`，作为**右值**代表的是`10`，作为**左值**时代表`a`的**内存位置**

>`&a`作为**右值**代表**a的地址**，**不能作为左值**，因为`&a`**不能代表内存中某一特定位置**

>`b`作为**右值**代表`a`的**地址**，作为**左值**表示的是`b`**自身的地址**

#### 1.3指针表达式
**①单操作符**
{%list%}
++/--的优先级高于*，*的优先级高于+/-
{%endlist%}
{%warning%}
注意++/--操作符和+/-1的不同，前者会改变变量，后者不会
{%endwarning%}
>`*b+1`：作为**左值**是**非法**的，作为**右值**表示对**变量**`a`中的**数据加1**

>`*（b+1）`：相当于`b`**后一个内存**的**标识符**，作为**左值**代表对应的**内存位置**，作为**右值**代表对应位置**存储的数据**。

>`++b`：作为**左值**是**非法**的，作为**右值**表示`b`后一个**内存位置**

>`b++`：作为**左值**是**非法**的，作为**右值**表示`b`对应的**内存位置**，随后**该指针变量指向后一个内存位置**

>`*++b`：作为的**左值**表示的是`b`**指向内存单元的后一个内存单元**，作为**右值**表示`b`**指向位置后一个位置存放的数据**

>`*b++`：作为**左值**表示的是该**指针指向的内存位置**，随后**该指针变量加一**，作为**右值**表示的是**该指针指向位置存放的数据**，随后**该数据加一**

>`++*b`：作为**左值**是**非法**的，作为**右值**表示的是**b指向变量存放数据**的值**加一**

**②加减法**
>**与整数加减法**：当对**指针**加减一个**整数**`n`时，该指针会**根据其指向的数据的类型调整自身大小**
{%list%}
如某台机器上float占4个字节，对一个float类型指针+n，该指针的大小会增加4n个字节
{%endlist%}
>**指针之间的减法**：只有当**两个指针**都指向**同一数组中的元素**时，才允许进行**减法**
{%list%}
得到的数据类型是ptrdiff_t，是一种有符号整数，表示两个指针指向位置的距离（以数组元素的长度为单位）
{%endlist%}
**③比较**
>**`==`与`!=`**：可以用于**任意两个指针**，判断两个指针**是否相同**

>**大小比较**：只能用于**同一个数组**内的元素
{%list%}
同一数组的元素还包括数组末尾后一位元素，但是不包括数组开头前一位元素
{%endlist%}

#### 1.4函数指针
**①格式**
>`返回类型 (*f)(参数列表)`
{%list%}
()为函数调用操作符，f()的结果是函数f的返回值
{%endlist%}
{%right%}
可以解释为f被间接引用后是一个函数，该函数的返回值是一个整型，所以f为一个函数指针
{%endright%}

**②初始化**
>`返回类型 (*f)(参数列表) = 函数名`
{%warning%}
在函数指针初始化时，其参数列表需要与之对应
{%endwarning%}
{%list%}
其中函数名在编译时会被转换为函数指针，故可以不用取址符号
{%endlist%}

**③函数指针数组**
>`返回类型 (*f[]) ();`
{%list%}
()和[]均为同一优先级，结合性从左向右，优先级均高于*
{%endlist%}
```
double  (*oper_func[])(double,double) = {a,b,c...};
result = oper_func[1](i,j);

```

**④用途**
>**函数指针**可以作为**参数**提供给**另一个函数**，以便在**另一个函数**中使用，也被称为**回调函数**
{%list%}
将函数中与数据类型相关的操作替换为一系列等价的函数，需要使用哪类数据类型的对应操作，传递对应的函数指针
{%endlist%}
{%right%}
将传递给函数以及回调函数的数据类型采用*void，用于接收不同数据类型的指针
{%endright%}
{%warning%}
在使用这些数据的指针时，必须要强制转换为正确的数据类型
{%endwarning%}
```
/*比较函数的整数版本
int compare_ints(void const *a,void const *b)
{
	if(*(int *)a = *(int *)b)
		return 0;
	else
		return 1;
}
```



### 2.函数
#### 2.1格式
**①源文件**
>`return`语句**不一定**出现在**末尾**，没有`return`语句的函数称为**过程**
{%list%}
函数中的形参是实参的一个副本，修改形参不能修改实参，如果想要修改实参，需要传递实参的地址
{%endlist%}
{%right%}
当本该有参数的地方没有参数时，可以使用void占据位置
{%endright%}
{%warning%}
函数要考虑异常情况，并进行异常处理
{%endwarning%}
```
返回类型 函数名（形参类型1 形参名1，...形参类型n 形参名n）
{
	statement；
    return expression；
}
```
>**类型**、**形参**和**statement**都**不是必须**的，因此**最简单的函数**如下
{%right%}
这种函数可以达到存根的目的,即为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性
{%endright%}
```
void function （void）
{

}
```

**②函数声明**
>**格式**：`返回类型 函数名(形参类型n 形参名n);`
{%list%}
向编译器提供函数相关信息，当调用函数时传入参数与形参的类型不匹配，编译器会根据函数声明强制转换变量类型
{%endlist%}
{%right%}
可以将函数定义在单独的C文件中，并将函数声明置于同一个头文件中，主函数文件使用include命令调用即可
{%endright%}
{%warning%}
若没有对应的函数声明，函数会被调用，但是传递给函数的参数会进行缺省参数提升
{%endwarning%}
>`char`和`short`被转换为`int`，`float`被转化为`double`，且默认返回一个**整型**
{%wrong%}
函数原型不要写在代码块中，因为代码块中的函数原型有代码块作用域，可能会覆盖原来的函数声明
{%endwrong%}


**③黑盒**
>利用`static`关键字修饰**函数内置数据和函数**，使其变为**函数文件私有**，**外界不能访问**

#### 2.递归函数
**①定义**
>直接或者间接**调用自身**的函数，当递归函数**不再满足某个条件**时，便**停止**调用自身
{%list%}
递归函数需要设置限制条件，且每次递归调用之后就越接近该限制条件
{%endlist%}
{%wrong%}
递归的计算代价非常大，如果可以使用循环等解决问题，不要使用递归
{%endwrong%}
**②例子**
>输入`value`为`4267`
```
binary_to_ascii(unsigned int value)
{
	unsigned int a;
	a = value/10;
	if(a!=0)
		binary_to_ascii(a)
	putchar(value%10+‘0)’;
}
```
**③实现过程**
{%list%}
每次函数调用，都会创建一个栈帧，存放临时变量和返回地址等，并压入程序栈中，直到函数调用结束才会弹出
{%endlist%}
>**第一次调用**，在**堆栈**中压入了`value1 = 4267`和`a1 = 426`

>`a!=0`，进行**第二次调用**，压入`value2 = 426`、`a2 = 42`

>`a!=0`，进行**第三次调用**，压入`value3 = 42`，`a3 = 4`

>`a!=0`，进行**第四次调用**，压入`value[4] = 4`，`a[4] = 0`

>`a=0`，**递归停止**，开始**从堆栈中弹出并打印**变量`a4`、`a3`、`a2`、`a1`

#### 2.3可变参数列表
**①实现**
{%list%}
需要引入stdarg.h头文件
{%endlist%}
>该**头文件**中声明了一个`va_list`**类型**和**三个宏**`va_start`、`va_arg`和`va_end`

**②用法**
{%warning%}
注意函数形参部分的写法，可变参数列表用...代替，在书写函数声明时，也需要注意
{%endwarning%}
>在**函数体内部**定义`va_list`类型参数，代表**可变参数列表**

>使用`va_statr`宏**初始化**`va_list`类型参数
{%list%}
该宏第一个参数是va_list类型参数number_n，第二个参数是可变参数列表的前一个参数n_value
{%endlist%}
{%warning%}
要使用该宏，则函数必须至少有一个已确定的参数，如下例中的value
{%endwarning%}
>使用`va_arg`**代替可变参数**进行计算
{%list%}
该宏接收的第一个参数是va_list类型参数number_n，第二个参数是可变参数列表的数据类型
{%endlist%}

>使用`va_end`**注销**可变参数列表

**③例子**
```
#include<stdarg.h>

/*用于计算输入数字的平均数
float average (int n_value,...)
{
	va_list number_n;
	int count;
	float sum = 0;
	va_start(number_n,n_value);
	for (count=0;count<n_value;count+=1)
	{
		sum = sum+va_arg(number_n,int);
	}
	va_end(number_n);
	return sum/n_value;
}
```
### 3.数组
#### 3.1引言
**①格式**
>`数据类型 数组名[数组大小]`
{%list%}
C语言中，数组的长度一开始就要确定
{%endlist%}
**②数组名**
>**本质**上是一个**指针常量**，指向**数组的起始位置**，同时还包含**数组长度等信息**
{%list%}
创建数组时编译器会根据其长度为数组划分对应的内存空间，随后为数组名划分内存
{%endlist%}
{%right%}
只有数组名在表达式中被使用了，编译器才会创建对应的指针常量
{%endright%}
{%warning%}
数组名大部分情况下可作为指针常量使用，但是有些情况下代表整个数组
{%endwarning%}
>比如`sizeof(数组名)`会返回**整个数组的长度**，`&数组名`产生的是一个**数组的指针**，而**不是**一个**指向指针的指针**

**③下标引用**
>`a[b]`相当于`*(a+b)`，**所以下标从0开始**
{%list%}
指针间接访问的效率大于等于下标引用效率，详细见《C与指针》p145-p150
{%endlist%}
{%right%}
C语言中，下标引用可以应用于所有的指针，不仅仅局限于数组名
{%endright%}
{%warning%}
注意检查数组越界问题
{%endwarning%}
**④作为形参传递**
>**格式**：`数据类型 数组名[]`或者`数据类型 *指针名`
{%list%}
函数在声明数组参数时，不需要指明他的长度，因为函数只接受数组的地址，而不为其分配内存
{%endlist%}
{%right%}
如果需要知道数组的大小，还需要传递另一个参数
{%endright%}

#### 3.2初始化
**②格式**
>`数据类型 数组名[] = {值1,值2,…}`

>当数组为**静态变量**时，在**程序执行前**便被初始化，**缺省情况**下**全部初始化**为**0**

>当数组为**动态变量**时，在**缺省情况**下各个元素的**值是随机的**
{%right%}
若程序执行流将多次经过一数组，可以将其设置为静态变量，减少其初始化次数
{%endright%}

**②不完整的初始化**
>**缺少元素**：**优先填充前面的**，**其余**的被**初始化**为`0`

>**缺少数组长度**：**编译器**将其**设置为**刚好能够**容纳所有初始值**的大小
{%warning%}
只有在显示初始化时才能缺少数组长度
{%endwarning%}

**③字符数组的初始化**
>`char a[] = “b”`相当于`char a = {'b',NUL}`
{%warning%}
只有在初始化字符数组时“b”才代表一个初始化列表，其他场合均为字符串常量
{%endwarning%}
>如下，`message1`是一个**字符数组**，`message2`是一个**指向字符串字面值的指针**
```
char message1[] = "hello";
char *message2 = "hello";
```
#### 3.3多维数组
**①定义**
>`数据类型 数组名 [维度1][维度2]…[维度N]`，如`int a [3][4]`
{%list%}
可以解读为a数组有三个元素，每个元素又是一个包含4个元素的数组
{%endlist%}
>**存储形式**：按照**最右边的下标**率先变化，比如`int *b = &a[1][3]`,`b++`为`a[2][0]`

![多维数组的存储](/image/C_1.png)

**②数组名**
{%list%}
类比一维数组，将n维数组看为一个元素是n-1维数组的一维数组，数组名即指向第一个n-1维数组的指针
{%endlist%}
>`a`：指向第一个包含**四个整型元素的数组**

>`a+1`:指向的**第二个四元素一维数组**
{%list%}
指针的加减法根据指针的类型决定
{%endlist%}

>`*(a+1)`：指向**第二个四个元素数组**的**第一个整型元素的指针**
{%warning%}
注意这还不是其中所包含的数据，而是一个指针常量
{%endwarning%}
>`*a+1`:指向**第一个四个元素数**组的**第二个元素**

>`*(*a+1)`：为**第一个四个元素数组**的**第二个元素**
{%right%}
一层一层解引用，n维数组要解引用n次，才能获得数据
{%endright%}
**③初始化**
{%list%}
以二维数组a为例
{%endlist%}
>`int a[][] = {元素1、元素2…};`，元素按照其**存储顺序**排列

>`int a[][] = {{数组1}，{数组2}…};`

>通过`a[i][j] = 值ij;`，**一个个赋值**

**④多维数组与指针**
{%list%}
以二维数组a为例
{%endlist%}
>**多维数组的指针**：`数组元素数据类型 (*p)[数组元素个数] = 二维数组名`
{%list%}
对*p进行下标引用，得到一个数据，所以*p是一个一维数组，故p为一个指向一维数组的指针，也就是二维数组名
{%endlist%}
{%warning%}
这里的数组元素个数与之对应，如int (*p)[4] = a;，且要记得加上括号，因为下标引用的优先级高于引用
{%endwarning%}
{%right%}
将数组传递给一个函数，本质上是传递其元素类型的指针，对于多维数组，就是传递一个指向数组的指针
{%endright%}
>**接收二维数组的形参**应写为`void func1(int (*a)[4])`或者`void func1(int a[][4])`

>**指向元素的指针**：`数组元素数据类型 *p = &数组名[0][0]`或者`数组元素数据类型 *p = 数组名[0]`
{%list%}
注意后者是没有&符号的，因为后者就是一个指向元素的指针！
{%endlist%}
>**指针数组**：`数据类型* 数组名[元素个数]`
{%warning%}
与指向数组的指针仅仅只有一个括号之差
{%endwarning%}

#### 3.4字符串
**①定义**
>以`'/0'`**结尾**的**字符数组** 
{%list%}
'/0'的位模式全为0，也叫NUL字节，是字符串的终止符，字符串长度不包括终止符的长度
{%endlist%}

**②基本操作**
{%list%}
需要包含string.h头文件
{%endlist%}
>`strlen()`：**测量字符串长度**，即字符串包含的**字符个数**
{%list%}
该函数返回的长度的数据类型为size_t，是一个无符号数
{%endlist%}
{%warning%}
大部分字符串相关函数都是根据终止符判断字符串长度，故要确保操作后字符串不会溢出，否则会缺少终止符
{%endwarning%}
>`strcpy()`：**复制字符串**，若其长度**超出了容器的限度**，则会**覆盖其后面的内存空间**
{%wrong%}
大部分字符串函数不允许两个字符数组参数重叠，否则函数的返回值是未定义的
{%endwrong%}
>`strcat()`：**连接字符串**，将**一个字符串**添加到**另一个字符串后面**

>`strcmp()`：**字符串比较**，进行的是**字典比较**
{%list%}
字典比较：对两个字符串的逐个字符从头进行比较，只要比较出一个字符大小即可判断结果，'/0'小于任何字符
{%endlist%}

>**长度受限的字符串函数**：为了**防止目标数组溢出**，定义了**对应函数**的**长度受限版本**，接受一个**长度参数**，用于**限制操作的字符个数**，如`strncpy()`
{%wrong%}
但是这些函数可能导致目标数组不是以'/0'结尾，可能会导致程序崩溃
{%endwrong%}
{%right%}
可以在函数调用完后将字符数组的最后一个元素改为NUL
{%endright%}

**③字符查找**
>`strchr()`：返回对应字符**第一次**出现的下标

>`strrchr()`：返回对应字符**最后一次**出现的下标

>`strpbrk()`：返回**一组字符中任意一个字符第一次**出现的下标

**④字串查找**
>`strstr()`：返回**子串**第一次出现的**起始位置**

>`strtok()`：**删除**字符串中的所有**标记字符**
{%list%}
通常以字符串形式传递多个标记字符
{%endlist%}

>`strcspn()`:检索**字符串中标记字符第一次出现**的下标

**⑤字符操作**
{%list%}
需要包含ctype.h头文件
{%endlist%}
>**字符分类**：根据对应**分类函数**定义，判断**字符**是否为**该类型**，如`isspace()`判断其是否为**空白字符**

>**字符转换**：转换**字符**的**大小写**等形式，如`tolower()`将**字符**转化为**小写形式**
{%warning%}
直接测试或者操纵字符可能会影响程序的移植性，推荐使用对应的字符操作函数
{%endwarning%}
>比如`if(ch>='A' && ch<='Z')`判断`ch`是否为**大写字母**，在使用**EBCDIC字符集**上的机器上将**失败**

### 4.结构
#### 4.1格式
**①定义**
>**声明格式**：`struct 结构类型名称 结构名`
{%list%}
结构变量是标量类型，所以相同的结构变量可以相互赋值
{%endlist%}
{%right%}
将结构定义在一个头文件中，使用include包含即可
{%endright%}
```
struct [结构类型名称]
{
	/*每个成员的类型和名字*/
	结构成员表;
};
```
{%right%}
可以使用typedef关键字为结构定义新的名字
{%endright%}
>**声明格式**：`结构类型名称 结构名`
```
typedef struct
{
	结构成员表(每个成员的类型和名字);
}[结构类型名称];
```
**②结构的访问**
>**`.`操作符**：`结构名.成员名`

>**`->`操作符**：`对应结构指针->成员名`
{%list%}
这两个操作符优先级相同，比*和[]高，结合性从左向右
{%endlist%}
{%right%}
当结构需要作为函数参数时，可以传递该结构的指针，并使用->访问成员，效率较高
{%endright%}
{%warning%}
假设px是结构x的指针，px指向的地址和结构第一个成员的地址是一样的，但是*px代表的是整个结构
{%endwarning%}
**③初始化**
{%list%}
结构体的初始化也分为静态变量和动态变量两种，各个成员按照对应的规则初始化
{%endlist%}
>**整体赋值**：`x1.a = {10,'x',1.0}`

>**成员赋值**：`x1.a = 10`
```
typedef struct 
{
	int a;
	char b;
	float c;
}X;
```
**④结构体的内存分配**
>**编译器**按照**成员列表顺序**给**每个成员**分配内存

>`sizeof()`可以得到一个结构的**整体长度**，`offsetof`可以确定**结构中某个成员**的**偏离结构存储起始位置的字节数**
{%list%}
当成员的存储需要满足正确的边界对齐条件，结构的起始位置必须满足成员中边界要求最严格的对齐条件
{%endlist%}
>假设**一台机器**的**整型值长度**为**4字节**，且要求其**起始存储位置**必须能**被4整除**，则**结构**`X`在**内存中**的**存储情况**如下
```
struct X1
{
	char a;
	int b;
	char c;
}
```
{%warning%}
成员之间会出现未填充的内存空间
{%endwarning%}
{%right%}
对边界要求最严格的成员应该首先出现，这样可以节省内存
{%endright%}
```
struct X2
{
	int b;
	char a;
	char c;
}
```
![结构的存储](/image/C_3.png)


#### 4.2结构的引用
**①结构的自引用**
>结构**内部成员为自己**本身是**非法**的，但是可以**包含自己的指针类型**
{%list%}
因为结构在定义时内存大小是不确定的，而结构指针的内存大小在结构创建前就已经确定
{%endlist%}
{%warning%}
不能使用之前没有定义的结构标签
{%endwarning%}
```
//非法，因为在声明next成员时，Node还有没被声明
typedef struct
{
  ElemType data;
  struct Node *next;
}Node;
//合法
typedef struct Node
{
  ElemType data;
  struct Node *next;
}Node;
```
**②结构之间的引用**
>当需要定义几种之间**存在联系**的结构，可以采用**不完整声明**
{%warning%}
如下，A中不能以B为成员，只能以B的指针为成员，因为不完整声明导致B的大小不能确定
{%endwarning%}
```
struct B; //B的不完整声明
struct A
{
	struct *B;
};
struct B
{
	struct A;
};
```

#### 4.3位段
**①定义**
>一种**特殊的结构**，**成员**必须是`int`、`signed`、`unsigned`类型，**成员名后面**是**一个冒号**和**一个整数**
{%list%}
整数表示该成员占用的位的数目
{%endlist%}
{%right%}
位段可以将长度为奇数的数据包装在一起，并且可以访问一个整型值的部分内容
{%endright%}
{%warning%}
signed和unsigned声明位段成员比较好，如果将位段声明为int类型，被解释为有符号数还是无符号数由编译器决定
{%endwarning%}
```
struct WeiDuan
{
	unsigned a : 7;
	unsigned b : 6;
	unsigned c : 19;
};
```
**②位段的移植性问题**
>很多**编译器**将**位段成员**的**长度**限制在**一个整型值**之内，**32位机器可以使用**的位段声明可能在**16位机器无法使用**

>**位段的内存**是**从左向右**分配还是**从右向左**分配**由机器决定**

>当位段的**总位数**不是**8的倍数**时，其**内存分配**是否要**边界对齐**取决于**编译器**

#### 4.4联合
**①定义**
>联合**各个成员共用**内存中的**位置以及数据**
{%list%}
当联合的某个成员被访问时，则将该联合所在位置的位以该成员类型解释被访问
{%endlist%}
{%list%}
当联合中各个成员具有不同的长度，联合的长度就是它最长成员的长度
{%endlist%}
{%right%}
当成员之间大小相差太大时，可以将联合的成员修改为不同数据类型的指针，这样就不会造成空间浪费
{%endright%}
```
union
{
	float f;
	int i;
}fi;
```
**②初始化**
{%list%}
联合变量的初始值只有一个，且必须是联合第一个成员类型的数据
{%endlist%}
```
union
{
	int a;
	float b;
	char c[4];
}x = {5};
```
### 5.内存操作
#### 5.1动态内存分配
**①`malloc()`**
>**概述**：从**堆**中提取一块**连续的内存**，并返回一个**指向这块内存的指针**，如果**没有合适的内存**则返回**NULL**
{%list%}
这块内存没有被初始化
{%endlist%}
{%right%}
malloc()返回内存的起始位置始终满足边界对齐条件
{%endright%}
>**格式**：`p = malloc（size）;`
{%list%}
malloc()返回值是void *，size为需要分配的字节数，其类型是size_t，一个无符号类型
{%endlist%}
{%right%}
可以将size替换为n*sizeof（数据类型），n为数量，还可以提高程序的可移植性
{%endright%}
{%warning%}
C语言中，void*可以赋值给其他类型指针，但是在其他语言如C++中不行，故最好在前面加一个强制类型转换
{%endwarning%}
**②`calloc()`**
>**概述**：和`malloc`一样用于**分配内存**，但是`calloc`会将内存内**所有元素初始化为0**

>**格式**：`p = calloc(num,size);`
{%list%}
其中num为元素的个数，size为每个元素的大小，类型均为size_t
{%endlist%}

**③`realloc()`**
>**概述**：**修改**一个**已经分配**的**内存块的大小**，**新增加的内存**添加到**原先内存块**的**尾部**，如果用于**缩小原来的内存块**，则将**尾部**的内存块**释放**
{%list%}
新增内存没有被初始化
{%endlist%}
>**格式**：`p = realloc(ptr,size);`
{%list%}
其中ptr是需要调整大小的指针，size是调整后内存的大小
{%endlist%}
{%warning%}
若原先的内存块大小无法改变，则realloc会重新划分一块内存，并释放原来的内存，所以要使用realloc返回的指针
{%endwarning%}

**④`free()`**
>**概述**：当**分配的内存不再使用**时，需要使用`free()`将其**释放**

>**格式**：`free (p)`
{%wrong%}
动态分配得到的指针是变量，但最好不要修改，因为最后还需要根据其释放掉对应内存块
{%endwrong%}
{%right%}
可以构建该指针的副本对内存进行操作
{%endright%}
**⑤常见错误**
>对`NULL`指针/**非动态分配**的指针使用`free()`进行**释放**

>对**分配的内存**操作时**越界**

>释放**动态内存的一部分**

>**访问**一块**已经被释放的内存**，如当**内存分配指针被备份**时

>内存释放**不及时**，导致**内存泄漏**

#### 5.2内存操作函数
{%list%}
内存操作函数接收和返回的参数都是void*，且会以字节规定操作的内存长度
{%endlist%}
>`memcpy()`：**直接复制一块内存中**数据到**另一块内存**中
{%warning%}
操作的两块内存不能重叠
{%endwarning%}
>`memmove()`：类似于`memcpy()`，但是`memmove()`在**转移时**会经过一块**临时内存**

>`memcmp()`：按照**无符号字符逐字节比较**两块内存的内容
{%warning%}
不能用于比较非单字节数据
{%endwarning%}
>`memchr()`：查找某块内存**某个字符第一次出现**的位置

>`memset()`：将一段内存**都设置**为**某个字符**






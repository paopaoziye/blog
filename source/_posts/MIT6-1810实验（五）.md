---
title: MIT6.1810实验（五）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 写时复制
---
# MIT6.1810实验（五）
## MIT6.1810 Lab5
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：实现**写时复制**版本的`fork`机制
{%list%}
做之前记得切换到对应分支git checkout cow
{%endlist%}
**②实验结果**
>**测试准备**：**主目录**添加`time.txt`，随后`make qemu`，退出`make grade`即可
{%list%}
time.txt填写实验花费的时间
{%endlist%}
![测试结果](/image/MIT.6.1810_Lab5.png)

#### 1.2Xv6虚拟内存机制
**①虚拟内存**
>**概述**：为**每个进程**提供了独立的地址空间，将其映射到**不同的物理内存**上
{%list%}
保证了进程之间以及用户空间和内核空间的隔离性，并提供了一层抽象，可以阻断对内存的访问
{%endlist%}
>**页错误**：**读**、**写**和**执行指令**都可能引发页错误，通过`trap`机制进入**内核空间**进行**页错误处理**
{%list%}
可以通过读取SCAUSE寄存器获取页错误原因，以上错误类型分别对应13、15和12位
{%endlist%}
{%right%}
为了处理页错误，需要知道出现页错误的虚拟地址、页错误的原因和触发页错误的指令地址
{%endright%}
>**出现页错误的虚拟地址**被保存在`STVAL`寄存器中，**触发指令地址**被保存在`SEPC`和`trapframe->epc`中

**②`Lazy Allocation`**
>`sbrk`：XV6提供的**系统调用**，使得用户应用程序能**扩大**自己的`heap`
{%list%}
sbrk的参数为整数，表示想要申请的page数量，内核会为进程分配一些物理内存，并将内存内容初始化为0
{%endlist%}
{%right%}
当一个应用程序启动时，sbrk指向的是heap的最底端，同时也是stack的最顶端，存储在proc的sz字段中
{%endright%}
>`Lazy Allocation`：`sbrk`只增大进程的`sz`字段，但**不分配内存**，**使用**对应新申请的内存时**再分配内存**
{%list%}
当使用的内存虚拟地址属于旧的p->sz至新的p->sz，会触发页错误
{%endlist%}
**③`Zero Fill On Demand`**
>**概述**：一个程序的地址空间**有一段为全0**，将这些页全部映射到**一个全0物理页**
{%list%}
进程地址空间text段为程序指令，data段存放被初始化全局变量，BSS段存放未被初始化或初始化为0的全局变量
{%endlist%}
{%right%}
在程序启动的时候能节省大量的物理内存分配，但是会带来一定的页错误负担
{%endright%}
{%warning%}
映射到该物理页的PTE都是只读的，因为必须保持一直全0
{%endwarning%}

**④`Copy On Write Fork`**
>**概述**：一开始子进程和父进程**共享物理内存**，直到**一方被修改**，给其分配**新的物理空间**并修改`PTE`的映射关系
{%list%}
父子进程共享物理内存时PTE都是可读，所以修改时会引发页错误，分配新物理内存PTE才被修改为可读可写
{%endlist%}
{%warning%}
对每个物理内存进行引用计数，每次释放虚拟内存时，将对应物理内存引用计数减一，当引用计数为0才能被释放
{%endwarning%}
**⑤`Demand Paging`**
>**概述**：为应用程序的`text`段和`data`段分配**虚拟地址**，但是直到**使用时**才分配对应的**物理内存**
{%list%}
对于没有映射物理内存的虚拟内存，将其PTE的valid bit位设置为0即可
{%endlist%}
{%right%}
执行没有映射物理内存的指令会引发页错误，对应处理函数读取数据加载到内存中，建立映射关系后重新执行指令
{%endright%}

>**撤回`page`**：当**物理内存耗尽**时，需要选择**撤回一些物理页**
{%list%}
常见的撤回page的算法为LUR算法，且优先撤回non-dirty page
{%endlist%}
>`dirty page`是**曾经被写过**的`page`，而`non-dirty page`是**只被读过**，但是**没有被写过**的`page`

>`PTE`的`RSW`位或`Access`位被设置了，该`page`即为`dirty page`

>定时的将`Access`位恢复成`0`，没有被`Access`过的`page`可以**直接撤回**
{%right%}
撤回non-dirty page，将内存page中的内容写到文件中，之后将相应的PTE标记为non-valid即可
{%endright%}

**⑥`Memory Mapped Files`**
>**概述**：将完整或者部分文件**加载到内存**中，通过**内存地址相关**的`load`或者`store`**指令**来操纵文件
{%list%}
以lazy的方式实现，先记录该PTE对应的文件描述符，并将对应信息存储在VMA结构体中
{%endlist%}
>`VMA`结构体会记录**文件描述符**，**偏移量**等，用来表示对应**内存虚拟地址的实际范围**
{%right%}
当对应虚拟地址范围出现页错误时，将对应文件内容加载到内存中
{%endright%}

### 2.具体实现
**①设置引用计数**
>**概述**：**回收物理内存时**需要检查其是否**被多个虚拟内存映射**，在`kernel/kalloc.c`中引入**对应数据结构**
{%list%}
由一个记录所有物理页引用计数的数组以及一个锁组成，这种全局数据都需要锁防止并发修改
{%endlist%}
{%right%}
可以参照kmem，并引入对应处理函数
{%endright%}
{%warning%}
需要在defs.h中声明这些处理函数
{%endwarning%}
```c
struct {
  struct spinlock lock;
  int ref[PHYSTOP/PGSIZE];
} pageref;

void
refcnt_inc(void *pa){
  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("refcnt_inc");
  acquire(&pageref.lock);
  PG_REFCNT(pa)++;
  release(&pageref.lock);
}

void
refcnt_init(void *pa){
  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("refcnt_init");
  acquire(&pageref.lock);
  PG_REFCNT(pa) = 1;
  release(&pageref.lock);
}

void
refcnt_dec(void *pa){
  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("refcnt_dec");
  acquire(&pageref.lock);
  PG_REFCNT(pa)--;
  release(&pageref.lock);
}

int
get_refcnt(void *pa){
  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("get_refcnt");
  acquire(&pageref.lock);
  int ret = PG_REFCNT(pa);
  release(&pageref.lock);
  return ret;
}

void
kinit()
{
  initlock(&kmem.lock, "kmem");
  initlock(&pageref.lock, "ref_cnt");
  memset(pageref.ref, 0, sizeof(pageref.ref));
  freerange(end, (void*)PHYSTOP);
}
```
```c
// kalloc.c
void*           kalloc(void);
void            kfree(void *);
void            kinit(void);
void            refcnt_inc(void *pa);
void            refcnt_dec(void *pa);
int             get_refcnt(void *pa);
```
**②修改`klloc`和`kfree`**
>**概述**：物理页**被分配时**，其**引用计数**被初始化为`1`，**释放时**需要**检查起引用计数**
{%list%}
修改kernel/kalloc.c下的klloc和kfree函数
{%endlist%}
{%right%}
减少引用的工作交给kfree而不是uvmummap，因为一个物理页被释放时一定有对应映射关系被取消
{%endright%}
{%warning%}
注意初始化所有物理页的freerange函数中就调用了kfree，在此之前就先设置引用计数为1抵消kfree的计数减少
{%endwarning%}
```c
// Free the page of physical memory pointed at by pa,
// which normally should have been returned by a
// call to kalloc().  (The exception is when
// initializing the allocator; see kinit above.)
void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("kfree");

  if(get_refcnt(pa) > 1){
    refcnt_dec(pa);
    return;
  }

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  r = (struct run*)pa;

  acquire(&kmem.lock);
  r->next = kmem.freelist;
  kmem.freelist = r;
  release(&kmem.lock);
}
// Allocate one 4096-byte page of physical memory.
// Returns a pointer that the kernel can use.
// Returns 0 if the memory cannot be allocated.
void *
kalloc(void)
{
  struct run *r;

  acquire(&kmem.lock);
  r = kmem.freelist;
  if(r) {
    kmem.freelist = r->next;
    refcnt_init((void*)r);
  }
  release(&kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
```
**③修改`uvmcopy`函数**
>**概述**：`fork`函数**调用该函数**进行**用户态页表**和**用户空间数据**的复制，为了进行**写时复制**，需要进行相关修改
{%list%}
该函数位于kernel/vm.c中，需要将复制行为修改为共享
{%endlist%}
{%right%}
在kernel/riscv.h添加COW标志位的定义，为高位时表示这是一个写时复制的内存页
{%endright%}
```c
//8，9位为PTE中的预留位
#define PTE_V (1L << 0) // valid
#define PTE_R (1L << 1)
#define PTE_W (1L << 2)
#define PTE_X (1L << 3)
#define PTE_U (1L << 4) // user can access
#define PTE_C (1L << 8) 
```
```c
// Given a parent process's page table, copy
// its memory into a child's page table.
// Copies both the page table and the
// physical memory.
// returns 0 on success, -1 on failure.
// frees any allocated pages on failure.
int
uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
{
  pte_t *pte;
  uint64 pa, i;
  int flags;

  for(i = 0; i < sz; i += PGSIZE){
    if((pte = walk(old, i, 0)) == 0)
      panic("uvmcopy: pte should exist");
    if((*pte & PTE_V) == 0)
      panic("uvmcopy: page not present");
    if((pa = PTE2PA(*pte)) == 0)
      panic("uvmcopy: address should exist");

    if(*pte & PTE_W){ // 如果可以写变成COW页
      *pte |= PTE_C;
      *pte &= ~PTE_W;
    }

    flags = PTE_FLAGS(*pte);
    if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){
      printf("uvmcopy: mappages\n");
      goto err;
    }
    refcnt_inc((void *) pa);  // 增加引用计数。
  }
  return 0;

 err:
  uvmunmap(new, 0, i / PGSIZE, 1);
  return -1;
}
```
**④缺页中断处理**
>**概述**：在`kernel/trap.c`的`usertrap`中添加**缺页中断**的逻辑分支，并在`kernel/vm.c`中添加**中断处理函数**
{%list%}
当产生缺页中断时，对应的scause为13或者15
{%endlist%}
{%warning%}
处理函数需要在kernel/defs.h中声明
{%endwarning%}

```c
int
cowalloc(pagetable_t pagetable, uint64 va)
{
  if(va >= MAXVA)
    return -1;

  uint64 pa, new_pa, va_rounded;
  int flags;

  pte_t *pte = walk(pagetable, va, 0);

  if( pte == 0 || (*pte & PTE_V) == 0 || (*pte & PTE_U) == 0)
    return -1;

  flags = PTE_FLAGS(*pte);
  pa = PTE2PA(*pte);
  va_rounded = PGROUNDDOWN(va);
  // 不是 cow 页，且没有写权限，非法写入。
  if(!(*pte & PTE_C) && !(*pte & PTE_W))
    return -1;
  // 有写权限 or COW 位是0，该页不是COWpage
  if( (*pte & PTE_W) || !(*pte & PTE_C))
    return 0;
  // 大于1个进程引用该页，需要复制。
  if(get_refcnt((void *) pa) > 1){
    if((new_pa = (uint64) kalloc()) == 0) // 申请一个物理页。
      panic("cowalloc: kalloc");
    memmove((void *)new_pa, (const void *) pa, PGSIZE);  // 将原物理页中的内容复制到新物理页中。
    uvmunmap(pagetable, va_rounded, 1, 1);  // 解除虚拟页和物理页的映射关系。
    flags &= ~PTE_C;  // 清除页表项中的 COW 位。
    flags |= PTE_W;  // 设置页表项中的 W 位。
    if(mappages(pagetable, va_rounded, PGSIZE, new_pa, flags) != 0){// 建立新的虚拟页和物理页的映射关系。
      kfree((void *)new_pa);
      return -1;
    }
    return 0;
  } else if(get_refcnt((void *) pa) == 1){
    *pte |= PTE_W;
    *pte &= ~PTE_C;
    return 0;
  }

  return -1;
}
```
```c
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(killed(p))
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sepc, scause, and sstatus,
    // so enable only now that we're done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else if(r_scause() == 15 ){
    // Synchronous page fault from kernel.
    // This is most likely caused by a kernel
    // access to a user space address, for example
    // if the kernel tries to read a user page
    // or if a user page is paged out and the kernel
    // needs to bring it back in.
    uint64 addr = r_stval();
    if(cowalloc(p->pagetable, addr) < 0){
      printf("alloc user page fault addr=%p\n", addr);
      setkilled(p);
    }
  }else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    setkilled(p);
  }

  if(killed(p))
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```
**⑤修改`copyout`函数**
>**概述**：`kernel/vm.c`下的`copyout`负责将**内核态数据**复制到**用户态**，但是其并**不能判断内存是否只读**
```c
// Copy from kernel to user.
// Copy len bytes from src to virtual address dstva in a given page table.
// Return 0 on success, -1 on error.
int
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
{
  uint64 n, va0, pa0;

  while(len > 0){
    va0 = PGROUNDDOWN(dstva);
    if(cowalloc(pagetable, va0) < 0)
      return -1;
    pa0 = walkaddr(pagetable, va0);
    if(pa0 == 0)
      return -1;
    n = PGSIZE - (dstva - va0);
    if(n > len)
      n = len;
    memmove((void *)(pa0 + (dstva - va0)), src, n);

    len -= n;
    src += n;
    dstva = va0 + PGSIZE;
  }
  return 0;
}
```
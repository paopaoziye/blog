---
title: 算法思想
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机基础
  - 数据结构与算法
  - 《hello 算法》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/10.webp
date:
summary: 分治、回溯、贪心和动态规划
---
# 数据结构与算法
## 算法思想
### 1.分治
#### 1.1概述
>**分**：**递归**地将**原问题**分解为**两个或多个子问题**，达到**最小问题**时终止
{%warning%}
分解得到的子问题需要是独立的
{%endwarning%}
>**治**：从**易知解**的**最小问题**从底至顶地**合并各个子问题**，从而构建出**原问题的解**
{%list%}
分治通常基于递归实现
{%endlist%}
{%right%}
递归不仅能优化时间复杂度，还有利于并行计算
{%endright%}

#### 1.2二分查找
**①递归实现思路**
>由于是**基于搜索区间**进行分治，所以函数的**主要参数**为**区间开始索引**和**区间结束索引**，**每次递归**根据**中点值和`target`关系**修改这**两个值**即可

**②代码实现**
```
/* 二分查找：问题 f(i, j) */
int dfs(int nums[], int target, int i, int j) {
    // 若区间为空，代表无目标元素，则返回 -1
    if (i > j) {
        return -1;
    }
    // 计算中点索引 m
    int m = (i + j) / 2;
    if (nums[m] < target) {
        // 递归子问题 f(m+1, j)
        return dfs(nums, target, m + 1, j);
    } else if (nums[m] > target) {
        // 递归子问题 f(i, m-1)
        return dfs(nums, target, i, m - 1);
    } else {
        // 找到目标元素，返回其索引
        return m;
    }
}

/* 二分查找 */
int binarySearch(int nums[], int target, int numsSize) {
    int n = numsSize;
    // 求解问题 f(0, n-1)
    return dfs(nums, target, 0, n - 1);
}

```

#### 1.3构建树问题
**①概述**
>根据一个树的**前序遍历**`preorder`和**中序遍历**`inorder`构建**二叉树**，假设二叉树中**没有重复节点**
{%list%}
树的前序遍历和中序遍历都可以被划分为对应的三部分，且对应的子树同样也可以被同样划分
{%endlist%}
>**前序遍历**：可**按序**分为`根节点:左子树:右子树`

>**中序遍历**：可**按序**分为`左子树:根节点:右子树`
{%right%}
根据前序遍历得到的根节点划分中序遍历，总而得到左子树和右子树
{%endright%}
**②思路**
>根据**前序遍历的根节点**划分**中序遍历**得到**左子树**和**右子树**，连接**根节点**、**左子树根节点**和**右子树根节点**，随后再**同样操作左子树和右子树**
{%list%}
主要分治参数为根节点索引、左子树根节点索引和右子树根节点索引
{%endlist%}
**②代码实现**
```
/* 构建二叉树：分治 */
TreeNode *dfs(int *preorder, int *inorderMap, int i, int l, int r, int size) {
    // 子树区间为空时终止
    if (r - l < 0)
        return NULL;
    // 初始化根节点
    TreeNode *root = (TreeNode *)malloc(sizeof(TreeNode));
    root->val = preorder[i];
    root->left = NULL;
    root->right = NULL;
    // 查询 m ，从而划分左右子树
    int m = inorderMap[preorder[i]];
    // 子问题：构建左子树
    root->left = dfs(preorder, inorderMap, i + 1, l, m - 1, size);
    // 子问题：构建右子树
    root->right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r, size);
    // 返回根节点
    return root;
}

/* 构建二叉树 */
TreeNode *buildTree(int *preorder, int preorderSize, int *inorder, int inorderSize) {
    // 初始化哈希表，存储 inorder 元素到索引的映射
    int *inorderMap = (int *)malloc(sizeof(int) * MAX_SIZE);
    for (int i = 0; i < inorderSize; i++) {
        inorderMap[inorder[i]] = i;
    }
    TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorderSize - 1, inorderSize);
    free(inorderMap);
    return root;
}
```
#### 1.4汉诺塔问题
**①概述**
>**问题**：给定**三根柱子`A`、`B`、`C`**，其中`A`上套有**n个圆盘**，**从上到下**按照**从小到大**的顺序排列，将这**n个圆盘**移动到`C`上

>**规则**
**圆盘**只能从**一个柱子顶部**拿出，从另**一个柱子顶部**放入
**每次**只能移动**一个**圆盘
**小圆盘**必须时刻**位于大圆盘之上**

**②思路**
>**单圆盘**：**直接**将其从`A`**移动**到`C`即可

>**两圆盘**：将**小圆盘**从`A`移动到`B`，将**大圆盘**从`A`**移动**到`C`，再将**小圆盘**从`B`移动到`C`即可
{%list%}
这里B为缓冲柱，C为目标柱
{%endlist%}
{%right%}
本质上是将其转化为两个单圆盘问题
{%endright%}
>**三圆盘**：先**只**考虑**上面两个圆盘**，将`B`作为**目标柱**，`C`作为**缓冲柱**，将**上面两个圆盘**移到`B`上，将**最大圆盘**从`A`移到`C`，随后令`C`为**目标柱**、`A`为**缓冲柱**，将**两个圆盘**从`B`移动至`C`
{%right%}
本质上是将其转化为一个两圆盘问题和一个单圆盘问题
{%endright%}
>**n个圆盘**：将**n-1个圆盘**借助`C`移动到`B`，将**剩余一个圆盘**移动到`C`，将剩余**n-1个圆盘**借助`A`从`B`移动到`C`
{%right%}
本质上是将其转化为一个n-1圆盘问题和一个单圆盘问题
{%endright%}
**③代码实现**
{%list%}
时间复杂度为O(2^n)，空间复杂度为O(n)
{%endlist%}
```
/* 移动一个圆盘 */
void move(int *src, int *srcSize, int *tar, int *tarSize) {
    // 从 src 顶部拿出一个圆盘
    int pan = src[*srcSize - 1];
    src[*srcSize - 1] = 0;
    (*srcSize)--;
    // 将圆盘放入 tar 顶部
    tar[*tarSize] = pan;
    (*tarSize)++;
}

/* 求解汉诺塔：问题 f(i) */
void dfs(int i, int *src, int *srcSize, int *buf, int *bufSize, int *tar, int *tarSize) {
    // 若 src 只剩下一个圆盘，则直接将其移到 tar
    if (i == 1) {
        move(src, srcSize, tar, tarSize);
        return;
    }
    // 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf
    dfs(i - 1, src, srcSize, tar, tarSize, buf, bufSize);
    // 子问题 f(1) ：将 src 剩余一个圆盘移到 tar
    move(src, srcSize, tar, tarSize);
    // 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar
    dfs(i - 1, buf, bufSize, src, srcSize, tar, tarSize);
}

/* 求解汉诺塔 */
void solveHanota(int *A, int *ASize, int *B, int *BSize, int *C, int *CSize) {
    // 将 A 顶部 n 个圆盘借助 B 移到 C
    dfs(*ASize, A, ASize, B, BSize, C, CSize);
}
```

### 2.贪心
#### 2.1引言
**①概述**
>在问题的**每个决策阶段**，都选择**当前**看起来**最优的选择**
{%list%}
通常用来寻找最优解和近似最优解
{%endlist%}

### 3.回溯
#### 3.1引言
**①概述**
>从**某一状态**出发，根据**选择**不断**向前推进**搜索所有可能的**解决方案**，遇到**正确的解**则**记录**，直到**找到解**或者**尝试了所有可能**
{%list%}
状态表示问题在某一时刻的情况，包括已经做出的选择
{%endlist%}
{%right%}
本质上还是穷举法，只是向前推进的方式可能不同
{%endright%}

**②回退**
>遍历到**某个状态**，**无法前进**或者**无法得到满足条件的解**时，**撤销**上一个选择，回到**之前的状态**，并尝试**其他可能**
{%list%}
回退相当于推进的逆操作，不仅仅需要函数返回，还需要恢复状态
{%endlist%}

**③剪枝**
>当遍历到**某个状态**，不满足**约束条件**，则**直接回退**
{%list%}
去除了不满足约束条件的搜索分治，提高了搜索效率
{%endlist%}
**④代码框架**
```
/* 回溯算法框架 */
void backtrack(State *state, Choice *choices, int numChoices, State *res, int numRes) {
    // 判断是否为解
    if (isSolution(state)) {
        // 记录解
        recordSolution(state, res, numRes);
        // 停止继续搜索
        return;
    }
    // 遍历所有选择
    for (int i = 0; i < numChoices; i++) {
        // 剪枝：判断选择是否合法
        if (isValid(state, &choices[i])) {
            // 尝试：做出选择，更新状态
            makeChoice(state, &choices[i]);
            backtrack(state, choices, numChoices, res, numRes);
            // 回退：撤销选择，恢复到之前的状态
            undoChoice(state, &choices[i]);
        }
    }
}
```
#### 3.2全排列问题
**①概述**
>输入一个**整数数组**`nums[1A,1B,2]`，其中**可能包含重复元素**，返回**所有不重复的排列**

**②思路**
>**选择**：每次**添加的元素**

>**状态**：目前**已经选择了哪些元素**

>**剪枝**：每个元素**只能被选择一次**，且**相等元素是等价的**，**每个选择**中，**相同元素**只能**被选择一次**
{%list%}
每个初始分支引入一数组selected，其中selected[i]表示该元素是否被选择，选择时先遍历该数组，跳过已选择元素
{%endlist%}
{%list%}
每一轮选择引入一哈希表duplicated，记录该轮中已经尝试过的元素，并将重复元素剪枝
{%endlist%}
{%warning%}
注意duplicated和selected剪枝的生效范围，duplicated是每次选择，selected是从每个初始子分支开始到结束
{%endwarning%}
![全排列问题](/image/SF_22.png)
**③代码实现**
{%list%}
时间复杂度为O(nn!)，空间复杂度为O(n^2)
{%endlist%}
```
/* 回溯算法：全排列 II */
void backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) {
    // 当状态长度等于元素数量时，记录解
    if (stateSize == choicesSize) {
        res[*resSize] = (int *)malloc(choicesSize * sizeof(int));
        for (int i = 0; i < choicesSize; i++) {
            res[*resSize][i] = state[i];
        }
        (*resSize)++;
        return;
    }
    // 遍历所有选择
    bool duplicated[MAX_SIZE] = {false};
    for (int i = 0; i < choicesSize; i++) {
        int choice = choices[i];
        // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素
        if (!selected[i] && !duplicated[choice]) {
            // 尝试：做出选择，更新状态
            duplicated[choice] = true; // 记录选择过的元素值
            selected[i] = true;
            state[stateSize] = choice;
            // 进行下一轮选择
            backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize);
            // 回退：撤销选择，恢复到之前的状态
            selected[i] = false;
        }
    }
}

/* 全排列 II */
int **permutationsII(int *nums, int numsSize, int *returnSize) {
    int *state = (int *)malloc(numsSize * sizeof(int));
    bool *selected = (bool *)malloc(numsSize * sizeof(bool));
    for (int i = 0; i < numsSize; i++) {
        selected[i] = false;
    }
    int **res = (int **)malloc(MAX_SIZE * sizeof(int *));
    *returnSize = 0;

    backtrack(state, 0, nums, numsSize, selected, res, returnSize);

    free(state);
    free(selected);

    return res;
}

```
#### 3.3子集和问题
**①概述**
>给定一个**正整数集合**`nums`和一个**目标正整数**`target`，从`nums`找到**所有可能的集合**，使得**组合中元素的和**为`target`，**每个元素**可以被**多次选择**，但是**集合不能重复**
{%warning%}
集合是不区分顺序的
{%endwarning%}

**②思路**
>**选择**：每次**添加的元素**

>**状态**：集合中已经**包含了哪些元素**

>**剪枝**：**相等元素是等价的**；**相同元素的集合**也是**等价**的；当**元素总和**大于`target`时，**剪枝**
{%list%}
在全排列的基础上，不使用selected并去除相同集合即可
{%endlist%}
{%right%}
当做出选择xi后，设定下一轮选择从索引开始，就可以保证子集唯一，因为其一定与其他分支不相交
{%endright%}
![子集和问题](/image/SF_24.png)
**②代码实现**
```
/* 回溯算法：子集和 II */
void backtrack(int target, int *choices, int choicesSize, int start) {
    // 子集和等于 target 时，记录解
    if (target == 0) {
        for (int i = 0; i < stateSize; i++) {
            res[resSize][i] = state[i];
        }
        resColSizes[resSize++] = stateSize;
        return;
    }
    // 遍历所有选择
    // 剪枝二：从 start 开始遍历，避免生成重复子集
    // 剪枝三：从 start 开始遍历，避免重复选择同一元素
    for (int i = start; i < choicesSize; i++) {
        // 剪枝一：若子集和超过 target ，则直接跳过
        if (target - choices[i] < 0) {
            continue;
        }
        // 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过
        if (i > start && choices[i] == choices[i - 1]) {
            continue;
        }
        // 尝试：做出选择，更新 target, start
        state[stateSize] = choices[i];
        stateSize++;
        // 进行下一轮选择
        backtrack(target - choices[i], choices, choicesSize, i + 1);
        // 回退：撤销选择，恢复到之前的状态
        stateSize--;
    }
}

/* 求解子集和 II */
void subsetSumII(int *nums, int numsSize, int target) {
    // 对 nums 进行排序
    qsort(nums, numsSize, sizeof(int), cmp);
    // 开始回溯
    backtrack(target, nums, numsSize, 0);
}

```
#### 3.4N皇后问题
**①概述**
>**皇后棋子**可以攻击**同一行**、**同一列**以及**同一对角线**的棋子，给定`n`个**皇后**以及`nxn`的**棋盘**，寻找**所有**可以使得**皇后之间无法攻击**的摆放方案

**②思路**
>**选择**：**皇后**的**摆放位置**

>**状态**：棋盘上**皇后个数**以及**各自摆放位置**

>**剪枝**：**逐行放置**皇后**避免出现在同一行**，**在此基础上**避免皇后出现在**同一行**和**同一对角线**
{%list%}
每个初始分支，使用长度为n的数组cols以及长度为2n-2长度的数组diag1和diag2记录每一列以及对角线是否有皇后
{%endlist%}
{%right%}
对角线分为主对角线和从对角线，分别对应diag1和diag2
{%endright%}
>位于**同一主对角线**的元素，其**横坐标减纵坐标的值**相同，位于**同一从对角线**的元素，其**横坐标加纵坐标的值**相同，其中**横纵坐标取值范围**为`0~n-1`，所以**横纵坐标之差/和**的**取值范围**为`0~2n-2`**，每个值**对应**一条对角线**

![N皇后问题](/image/SF_23.png)
**③代码实现**
```
/* 回溯算法：N 皇后 */
void backtrack(int row, int n, char state[MAX_SIZE][MAX_SIZE], char ***res, int *resSize, bool cols[MAX_SIZE],
               bool diags1[2 * MAX_SIZE - 1], bool diags2[2 * MAX_SIZE - 1]) {
    // 当放置完所有行时，记录解
    if (row == n) {
        res[*resSize] = (char **)malloc(sizeof(char *) * n);
        for (int i = 0; i < n; ++i) {
            res[*resSize][i] = (char *)malloc(sizeof(char) * (n + 1));
            strcpy(res[*resSize][i], state[i]);
        }
        (*resSize)++;
        return;
    }
    // 遍历所有列
    for (int col = 0; col < n; col++) {
        // 计算该格子对应的主对角线和副对角线
        int diag1 = row - col + n - 1;
        int diag2 = row + col;
        // 剪枝：不允许该格子所在列、主对角线、副对角线存在皇后
        if (!cols[col] && !diags1[diag1] && !diags2[diag2]) {
            // 尝试：将皇后放置在该格子
            state[row][col] = 'Q';
            cols[col] = diags1[diag1] = diags2[diag2] = true;
            // 放置下一行
            backtrack(row + 1, n, state, res, resSize, cols, diags1, diags2);
            // 回退：将该格子恢复为空位
            state[row][col] = '#';
            cols[col] = diags1[diag1] = diags2[diag2] = false;
        }
    }
}

/* 求解 N 皇后 */
char ***nQueens(int n, int *returnSize) {
    char state[MAX_SIZE][MAX_SIZE];
    // 初始化 n*n 大小的棋盘，其中 'Q' 代表皇后，'#' 代表空位
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            state[i][j] = '#';
        }
        state[i][n] = '\0';
    }
    bool cols[MAX_SIZE] = {false};           // 记录列是否有皇后
    bool diags1[2 * MAX_SIZE - 1] = {false}; // 记录主对角线是否有皇后
    bool diags2[2 * MAX_SIZE - 1] = {false}; // 记录副对角线是否有皇后

    char ***res = (char ***)malloc(sizeof(char **) * MAX_SIZE);
    *returnSize = 0;
    backtrack(0, n, state, res, returnSize, cols, diags1, diags2);
    return res;
}

```
### 4.动态规划
#### 4.1引言
**①概述**




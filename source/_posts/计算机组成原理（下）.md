---
title: 计算机组成原理（下）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机组成原理
  - 《计算机组成原理》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/39.webp
date:
summary: 输入输出
---
# 计算机组成原理
## 计算机组成原理（下）
### 1.I/O系统
#### 1.1组成
**①软件部分**
>**I/O指令**：**CPU指令集**的一部分，格式为`操作码:命令码:设备码`
{%list%}
操作码指明该指令是I/O指令，命令码指明操作，设备码指定I/O设备或者其端口的地址
{%endlist%}

>**通道指令**：**通道自身**的指令，用于控制**通道的工作**
{%list%}
通道是一种小型的DMA处理机，实现I/O设备和主机直接进行信息传输
{%endlist%}
**②硬件部分**
>**I/O设备**：由**设备控制器**和**其他部分**组成

>**接口**：**I/O设备**通过**设备控制器**和**接口**相连，从而和**主机总线**连接
{%list%}
如果设备使用通道，设备通过设备控制器和子通道连接
{%endlist%}

**③接口组成**
>**设备选择电路**：**一个接口**可能连接**多个设备**，**一个设备**也有**多个端口**，需要通过**设备地址/端口号**进行选择
{%list%}
I/O设备可能被看作内存的一部分进行统一编址，也可能单独设置一个地址空间，后者需要专门的I/O指令
{%endlist%}
>**数据缓冲寄存器**：用于作为**数据缓冲区**，平衡**处理器**和**外设**之间的**速度差异**

>**命令寄存器和译码器**：用于**存储**以及**解释I/O指令**

>**状态标记**：用于告知**控制逻辑电路**外设和处理器状态，如是否**准备完成**，是否**空闲**、是否**允许中断**等

>**控制逻辑电路**：接口中的**控制单元**
{%list%}
除此之外，接口还需要协调外设和处理器，如进行数据串—并格式转换，并记录数据传输信息，如
{%endlist%}
![接口组成](/image/JZ_12.png)

**④程序查询方式**
{%list%}
一种CPU和外设通信的方式，其余还有程序中断方式和DMA方式
{%endlist%}
>**CPU**发出**I/O指令**后，根据**设备优先级**依次检查设备，若该设备**准备好**，则进行**对应操作**，否则一直**轮询**
{%warning%}
I/O处理过程中，CPU一直被占用，效率很低
{%endwarning%}

#### 1.2程序中断方式
**①工作原理**
>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，向CPU发送**中断信号**，CPU执行完**当前指令**后，如果**可以处理该中断**，转去执行**中断处理程序**
{%warning%}
CPU可以只有其中断允许触发器EINT为01时才能响应中断，且中断是有优先级的，会优先响应优先级高的设备
{%endwarning%}
**②中断流程**
>**提出中断**：**每个中断源**都有一个**INTR触发器**用于提出**中断请求**

>**触发中断**：CPU使用**中断请求标记寄存器**记录**各个**中断源**是否发出请求**，每次**执行完指令**后**查询该寄存器**
{%list%}
中断请求标记寄存器的每一位按照优先级对应一个中断源，1表示发出中断请求，0表示没有发出中断请求或者被屏蔽
{%endlist%}

>**响应中断**：选择**优先级最高的中断**，随后执行**中断隐指令**，并跳转到**对应中断服务程序**
{%right%}
中断隐指令会保存程序断点PC，随后将中断程序入口地址置给C，并将中断允许触发器EINT置为0，全部由硬件完成
{%endright%}

>**中断服务程序**：保存**CPU各个寄存器内容**，并根据**I/O指令**做出**对应操作**，跳转到**返回地址**，并恢复**寄存器内容**

**③中断屏蔽字**
>**概述**：**每个中断源**都有一个**中断屏蔽字**，**各个位**对应**各个中断源的中断屏蔽触发器**，为`1`使其**无法发出中断请求**
{%list%}
中断屏蔽字通常在该中断被响应且执行中断隐指令后，开中断前设置
{%endlist%}
{%right%}
中断屏蔽字可以人为设置，使该中断执行过程中，不会被某些中断打断
{%endright%}

**④单重/多重中断**
>**单重中断**：**不允许**中断**现行的中断服务程序**
{%list%}
执行中断服务程序之前关中断，直到恢复现场后才开中断
{%endlist%}

>**多重中断**：**允许级别更高的中断源**中断**现行的中断服务程序**
{%list%}
保护现场之后就开中断
{%endlist%}


#### 1.3DMA方式
**①工作原理**

>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，**DMA控制器**发出**DMA请求**，占用**总线**和**内存**，进行**I/O设备**和**内存**的**数据交换**
{%list%}
MA方式中，主存和I/O设备之间有一条直接的数据通道，不需要通过CPU寄存器进行数据交互
{%endlist%}
{%right%}
DMA工作期间，CPU虽然不能使用总线以及访问内存，但是可以进行其他工作，如执行缓存中的指令
{%endright%}

**②占用方式**
>**直接占用**：当**发出DMA请求**时，使得CPU**放弃总线和主存控制权**，直到**DMA**工作**全部完成**
{%warning%}
若DMA工作时间过长，会影响CPU工作，因为CPU还要去主存取出指令和数据
{%endwarning%}
>**交替访问**：CPU**工作周期**中，有**一段时间**专门提供给**DMA**
{%warning%}
不够灵活
{%endwarning%}
>**周期挪用**：当**发出DMA请求**时，若CPU**正在访问**主存，则**DMA等待**，若**CPU没有访问主存**，DMA挪**用一个或者固定几个存取周期**，两者**同时请求**，**DMA优先**
{%right%}
DMA分批次传送数据，若数据没有被传输完，则再发送DMA请求，直到数据传输完成
{%endright%}

**③传送过程**
>**预处理**：将一定的**控制信息**存入**DMA接口的寄存器**中，随后**启动设备**
{%list%}
控制信息主要有传输方向、设备地址、主存地址和传送字数
{%endlist%}
>**数据传送**：**CPU**继续**执行主程序**，由**DMA**完成**数据输送**，**传输完成**后，向CPU发出**中断请求**告知
{%list%}
每次传输完数据后，还需要修改控制信息，以便于下一次的传输
{%endlist%}

>**后处理**：执行**中断服务程序**，以**检查**这次传输过程**是否出现错误**

**④DMA接口分类**
{%list%}
同样，一个DMA接口可能连接多个设备，有请求线和响应线，连接方式类似于总线的链式请求和独立请求
{%endlist%}
{%right%}
设备的传输速度越快，优先级较高
{%endright%}
>**选择型**：各个寄存器**只有一套**，只能给**一个设备**使用，直到**数据全部传输结束**，才**释放接口**

>**多路型**：各个寄存器有**多套**，每一套也称为**子通道**，每次有一个**新的设备的I/O请求**，就给其**分配一个空闲子通道**，供其进行**为数据传输进行准备**
{%list%}
两者都只能是一个设备传输数据，但是多路型可以在多个设备间交替传输，即使一个设备的任务还没有完成
{%endlist%}
***
### 2.计算机数字
#### 2.1表示形式
**①真值与机器数**
>**概述**：称**真实世界**的数字为**真值**，如`+0.1101111B`，**存储在机器中**的**01序列**为**机器数**，如`01101111B`
{%list%}
数字中的小数点规定在特定位置，并不显示出现在机器数中
{%endlist%}
{%right%}
本质上就是用有限个数值表示对应范围，机器数的位数越多，范围/精度越大
{%endright%}
>**进制**：**计算机**采用**二进制**保存数据，同时辅以**其他进制**，如**八进制**、**十进制**、**十六进制**等
{%list%}
两个稳定态的物理实现简单，且二进制便于计算以及逻辑运算
{%endlist%}
{%right%}
同样的信息，二进制表示较长，可以将其转化为八进制以及十六进制减少其长度
{%endright%}
**②有符号/无符号数**
>**有符号数**：**最高位**为**符号位**，**其余位**用于**表示数值大小**，即`符号位:数值位`，**范围**为`-2^n-1`至`2^(n-1)-1`
{%list%}
符号位为0表示正，符号位为1表示负
{%endlist%}
>**无符号数**：**所有位**都用于**表示数值**，**范围**为`0`至`2^n-1`
{%warning%}
同一二进制序列，被解释为有符号数和无符号数差别是很大的
{%endwarning%}
>若**有符号负数**被解释为**无符号数**，相当于**真值加**`2^n`，若若**无符号数**被解释为**有符号数**，相当于**真值减**`2^n`

**③定点/浮点数**
>**定点数**：**小数点**规定在**特定位置**，常见的有在**符号位后**或者在**数值位后**
{%list%}
小数点在符号位后，则只能表示整数，小数点在数值位后，则只能表示绝对值小于等于1的小数
{%endlist%}
{%warning%}
机器数位相同的情况下，定点数能表示的范围太小
{%endwarning%}
>**浮点数**：根据`IEEE 754`标准，**机器位**分为`数符位S:阶码位E:尾数位N`，**数值**为`(-1)^Sx(1+N)x2^(E-127)`
{%list%}
阶码位为定点整数，尾数位为定点小数，浮点数的表示范围为最小负数—最大负数和最小正数—最大正数
{%endlist%}
>当**阶码**为`0`，**尾数**为`0`时，浮点数表示`+/-0`

>当**阶码**为**全一**，**尾数**为`0`时，表示`+/-∞`，**尾数**不为`0`，表示`NaN`
{%right%}
为了充分利用数值位，规定尾数形式为1.xxx，其中小数点前的1省略不写，在计算时自动加上即可
{%endright%}
{%warning%}
当输入数据是一个不可表示数时，转化为最邻近的可表示数
{%endwarning%}


#### 2.2编码方案
{%list%}
主要讨论8位有符号定点数，假设小数点在数值位后，浮点数将其中各个部分按照定点数规则变换即可
{%endlist%}
{%right%}
常用字符编码方案为UTF-8,为一种可变长度的编码，根据字符的复杂性使用1到4字节来表示一个字符，不多介绍
{%endright%}
**①原码**
>**概述**：**符号位**表示其**正负**，**数值位**表示**其绝对值**，如`01101111B`为`+1101111B`

{%warning%}
使用原码进行加减运算，无法统一，不利于硬件实现，如一个正数加上一个负数，还需要考虑符号位转化为减法
{%endwarning%}
{%right%}
通常使用使用原码表示浮点数尾数
{%endright%}
**②反码**
>**概述**：对于**正数**，反码为**原码**，对于**负数**保持原码**符号位不变**，**数值位依次取反**
{%right%}
通常使用补码表示有符号整数
{%endright%}

**③补码**
>**概述**：本质上是其**补数的原码**，对于**正数**，补码为其**原码**，对于**负数**，在其**反码的基础**上加`1`
{%list%}
补码10000000的原码为00000000，与00000000相矛盾，故规定10000000为-128
{%endlist%}
>**补数**：一个数**加上模数**即为补数，**加一个数的补数减去模数**，相当于**减去该数**，此处**模数**为`2^n`
{%list%}
如将时钟6点调整到3点，可以顺时针拨动9格，也可以逆时针拨动3格
{%endlist%}
{%right%}
计算机会自动帮机器数减去模数，所以使用补码可以很简单的统一正负数的加减法，有利于硬件实现
{%endright%}
>由于**补码**可以**将减法转化为加法**，故计算机内部的**硬件电路**主要是**基于加法运算**设计的
{%warning%}
使用补码无法通过机器直接判断两个数的大小
{%endwarning%}
>如`+21`的**补码**为`00010101` `-21`的**补码**为`10010101`，判断大小会判断**后者大于前者**

**④移码**
>**概述**：无论是**正数还是负数**，移码为**补码**的**符号位取反**
{%list%}
移码的就是给其加上2^n-1，只有整数形式的定义
{%endlist%}
{%right%}
移码便于比较大小，常用于表示浮点数阶码
{%endright%}
**⑤机器零**
>**机器零**：可分为`+0`和`-0`，两者**补码**和**移码**相同，**源码**和**反码**不同
{%list%}
所以8位机器数的补码和移码表示范围为-128-127，源码和反码只能表示-127-127
{%endlist%}
>对于**浮点数**，当其**尾数**为`0`、**阶码为最小负值**或者处于**最大负数**和**最小正数**之间，都可**判断**其为`0`

#### 2.3定点运算
{%list%}
浮点数的运算最后还是会转化为定点运算，其中加减运算，需要同时调整阶码和尾数使其阶码一致且大小不变
{%endlist%}
**①移位运算**
>**概述**：**数据位**相对于**小数点**进行**左/右移**，**绝对值**进行**扩大/缩小**，对于**二进制**，移动**一位**，数值变化**2倍**
{%list%}
移位运算可分为算数移位和逻辑移位，前者面对有符号数，后者面对无符号数
{%endlist%}
{%right%}
移位操作还可以将移出部分记录到寄存器中
{%endright%}
{%warning%}
注意移位操作移动的是数值位，不会影响符号位
{%endwarning%}
>**算数移位**：对于**正数**，**任何情况**都填`0`，对于**负数**，**原码**填`0`，**反码**填`1`，**补码左移**填`0`，**右移**填`1`
{%warning%}
移动时，右移丢1会导致精度丢失，可能向上或者向下进位，左移丢1可能会导致结果错误，实际上就是溢出
{%endwarning%}
{%right%}
能选择时，最好进行右移，因为右移顶多精度丢失，如调整浮点数阶码一致，小阶阶码右移向大阶看齐
{%endright%}
>**逻辑移位**：**所有的位**都会参加移位，**左移右移**均填`0`
{%right%}
通常采用对无符号数进行逻辑移位，移植性更强
{%endright%}
**②加减法运算**
>**概述**：通过**补码**进行**运算**，`A+B`的**补码**等于`A`的**补码**加上`B`的**补码**，`A-B`的**补码**等于`A`的**补码**加上`-B`的**补码**
{%list%}
符号位一起相加，符号位产生的进位自然丢掉
{%endlist%}
{%right%}
将正负数的加减法都统一为补码的加法
{%endright%}
{%warning%}
进行加减操作时，需要考虑结果是否超出存储单元长度，即发生了溢出
{%endwarning%}
>**溢出**：当参加操作的两个数**符号相同**，其**结果符号**与**原操作数符号不同**，则发生**溢出**
{%list%}
因为只有两个正数/负数相加才可能发生溢出
{%endlist%}
{%right%}
若数值位最高位发生的进位与符号位产生的进位结果不相同（异或结果为1），则发生了溢出
{%endright%}
**③乘法运算**
>**概述**：将**乘数数值位拆分**为多个**乘法因子**相加，**与乘法因子相乘**相当于进行**移位操作**，最后将**各个结果相加**即可
{%list%}
结果的符号位有乘数和被乘数的符号位异或得到
{%endlist%}
{%right%}
第i个乘法因子即第i位为原值，其余位为0，如11拆为10+01
{%endright%}
{%warning%}
被乘数和乘数的位应该相同，结果保存到长度为其两倍的寄存器中
{%endwarning%}
**④除法运算**
>**概述**：比较**被除数**和**除数**的**绝对值**，根据两者大小做出**不同的操作**，随后**除数右移**，循环操作

>若**被除数大于除数**，被除数**减少除数**，**末位**添`0`，**商**上`1`

>若**被除数大于除数**，被除数**不变**，**末位**添`0`，**商**上`1`
{%list%}
除法进行过程中，除数和被除数的长度不断增加，对于N位除法，需要使用2N位的加法器
{%endlist%}
>当**商的位数**等于其**存储器长度**时，**被除数减去除数**的值为**余数**
{%list%}
结果的符号位有除数和被除数的符号位异或得到
{%endlist%}
{%warning%}
对于小数除法，除数应该大于被除数，对于整数除法，除数应该小于被除数，否则会发生溢出
{%endwarning%}
{%wrong%}
除数不能为0
{%endwrong%}
***
### 3.CPU
#### 3.1机器指令
**①格式**
>将指令分为**多个字段**`字段1:字段2...字段N`，分别**按需分配**给**操作码**和**地址码**
{%list%}
操作码指出操作类型及操作数类型，地址码指出操作数地址，操作码位数影响指令种类，地址码位数影响寻址范围
{%endlist%}
{%right%}
采用硬件资源替代指令字中的地址码字段，以节省字段分配给其他部分，以提升指令种类/寻址范围上限
{%endright%}
>如8086的**乘法指令**，将**操作数**以及**结果**存入**指定寄存器**
{%warning%}
短操作码不能是长操作码前缀，通常将短操作码中的全1序列作为特殊序列，表示其后一个字段也是操作码部分
{%endwarning%}
>如`1110:1010:1010:1010`的**第一个字段**为**操作码**，`1111:1010:1010:1010`的**前两个字段**为**操作码**，以此类推

**②寻址方式**
{%list%}
指令中的地址码为形式地址，需要根据指令中的寻址方式找到真实地址
{%endlist%}
>**立即寻址**：形式地址就是**操作数**

>**直接寻址**：形式地址就是**存储单元的真实地址**

>**隐含寻址**：操作数地址**隐含在操作码中**，如8086的**乘法指令**

>**间接寻址**：形式地址为一**内存单元地址**，其中**保存数据真实地址**

>**寄存器寻址**：形式地址为一**寄存器编号**，其中**保存数据**

>**寄存器间接寻址**：形式地址为一**寄存器编号**，其中**保存数据真实地址**

>**基址寻址**：**基址寄存器数值**经过**一定变换**加上**形式地址**得到**真实地址**

>**变址寻址**：**变址寄存器数值**直接加上**形式地址**得到**真实地址**

>**堆栈寻址** ：**真实地址**为**栈顶地址**

**③指令集**
>**精简指令集计算机RISC**：指令**数量少**，每条指令的**功能简单**，**复杂指令**由**简单指令组合**实现
{%list%}
RISC便于设计，成本低，运算速度快，但是不易兼容
{%endlist%}
>**复杂指令集计算机CISC**：指令**数量多**，每条指令**功能强大**，使用的**频度相差较大**


#### 3.2CPU功能
**①结构概述**
>**控制器**：**取指令**，**分析指令**并给出对应**控制信号**，还需要处理**异常**和**特殊请求**

>**运算器**：实现**算数运算**和**逻辑运算**

>**中断系统**：

>**寄存器**：可分为**通用寄存器**、**数据寄存器**、**地址寄存器**、**条件码寄存器**、**控制寄存器**和**状态寄存器**
{%list%}
寄存器存放CPU工作需要的信息，如操作数、地址、段地址、条件码、程序状态等
{%endlist%}
>还有一些**用户不可见**的寄存器，如`IR`、`MAR`和`MDR`

**②周期**
>**指令周期**：**取出并执行**指令所需的**全部时间**，按**时间顺序**可分为**取址周期**、**间址周期**、**执行周期**和**中断周期**
{%list%}
每条指令一定有取址周期和执行周期，不一定有间址周期和中断周期，当然也有其他的分割方法
{%endlist%}
>**机器周期**：指令执行的一个**基准时间**，**每个指令周期**可以分为**多个机器周期**
{%list%}
机器周期的长度可以相等也可以不相等，即包含的节拍数可以不同
{%endlist%}
>**时钟周期**：控制计算机操作的**最小时间单位**，**每个机器周期**可以分为**多个相等的时钟周期**


**③指令流水**
>**概述**：**一条指令的执行**可以分为**不同阶段**，在**进行一条指令的某个阶段**的同时进行**其他指令的其他阶段**
{%right%}
指令流水本质就是指令级的并行，由硬件实现，可以显著提升指令执行效率
{%endright%}
{%list%}
并行可分为并发和同时，前者表示多个时间在同一段时间内发生，后者表示多个事件在同一时刻发生
{%endlist%}
{%warning%}
实际执行会遇到很多非理想情况，如各个阶段时间不同、跳转指令的影响、资源的冲突、指令必要的先后顺序等
{%endwarning%}
>可以利用**缓冲部件**、**分支预测**、**指令停顿**、**后推法**等分别解决上述问题

>**指标**：吞吐率、加速比等
{%list%}
吞吐率指单位时间内流水线完成指令的数量，加速比指采用流水线的速度和不采用流水线速度之比
{%endlist%}
{%right%}
在流水线基础上，还可以采用流水线的多发、超流水和超长指令字等技术提升效率
{%endright%}
![指令流水](/image/JZ_13.png)

#### 3.3控制器设计
**①引言**
>**微操作**：在**指令解释过程**中由**控制单元**发出的**控制信号**
{%list%}
微操作可采用同步控制、异步控制，类似于总线的同步通信和异步通信
{%endlist%}
>还可采用**联合控制**，对于**大部分微操作**采用**同步控制**，对于**很难确定完成时间**的微操作采用**异步操作**
{%right%}
将可以并行的微操作安排在同一个时钟周期中，在一个时钟周期先后执行两个较短的微操作以提升效率
{%endright%}
{%warning%}
微操作之间有先后顺序，不能随意更改
{%endwarning%}
>**时钟信号**：由**时序电路**产生，每个**时钟脉冲**对应一个**时钟周期**
{%list%}
一个时钟周期可以产生一个或一组可以并行的微操作命令
{%endlist%}

>**标志信息**：表明**CPU的状态**

**②组合逻辑设计**
>**设计思路**：根据**每个控制信号**的**产生条件**，写出其**逻辑表达式**，载转化为对应**逻辑电路**即可
{%list%}
控制信号的产生条件指收到的指令操作码、时钟信号和标志信息等，在对应时间收到对应信息便发出对应控制信号
{%endlist%}
{%right%}
组合逻辑设计全部由硬件实现，速度非常快
{%endright%}
{%warning%}
较为复杂，且兼容性较差，新增加一个指令，需要修改与之相关的所有微操作的逻辑电路
{%endwarning%}




**③微程序设计**
>**设计思路**：使用**一串0/1序列**记录**一个时钟周期中执行的微操作**，即**微指令**，按**时间周期顺序**排列构成**微程序**
{%list%}
一条机器指令对应一个微程序，调用微程序，即可在每个是时钟周期发出对应控制信号
{%endlist%}
{%right%}
根据IR中的操作码形成微程序的首地址，每条微指令还会记录下一条微指令定址
{%endright%}

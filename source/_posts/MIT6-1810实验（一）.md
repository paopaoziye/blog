---
title: MIT6.1810实验（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 操作系统调用
---
# 项目实战
## MIT6.1810实验（一）
### 1.引言
#### 1.1工具链安装
>**概述**：在**命令行**输入**以下代码**，详细见[课程官网](https://pdos.csail.mit.edu/6.828/2023/tools.html)，使用的环境是**Ubuntu 20.04.1**
```shell
sudo apt-get update  //更新软件包来源
sudo apt-get upgrade //更新所有能更新的软件
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```

#### 1.2课程源码编译
>**概述**：在**命令行**输入**以下代码**启动xv6，`ctrl-a x`，即**先同时**按住`ctrl`和`a`,**随后**按下`x`即可**退出**
{%list%}
第一次需要输入以下三行代码，以后只需要在对应目录下输入make qemu即可
{%endlist%}
```shell
git clone git://g.csail.mit.edu/xv6-labs-2023
cd xv6-labs-2023
make qemu
```

#### 1.3实验注意事项
>**分支切换**：每次做**某个`lab`**时，都要切换到**对应分支**，如`git checkout util`

>**添加文件**：在`makefile`文件对应位置添加对应**编译选项**，以`sleep`实验为例，随后`make qemu`**重新编译**即可

```makefile
//添加sleep项
UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\
```

>**评分**：`./grade-lab-[lab名] [作业名]`对某个作业进行**评分**，**总体评分**可以使用`make grade`

### 2.操作系统接口
#### 2.1进程相关
**①创建**
>`int fork()`：创建一个**内存内容**与其**完全相同**的**子进程**，即**指令**、**数据**和**堆栈**
{%list%}
在父进程中，返回值为子进程的PID，在子进程中，返回值为0
{%endlist%}
{%right%}
创建的是进程，子进程被创建后不久就执行了，通常使用fork的返回值以及if语句区别父子进程
{%endright%}
{%warning%}
子进程运行时有自己独立的内存空间的，父子进程相互不影响
{%endwarning%}
**②销毁**
>`void exit(int status)`：**销毁**当前进程并**释放资源**，`status`表示进程**结束状态**
{%list%}
主动结束进程，当status为0时，表示正常结束，1表示发生错误并结束
{%endlist%}
{%right%}
主动结束进程并给出提示信息，即是正常结束还是非正常结束
{%endright%}
**③等待**
>`int wait(int *)`：进程**立刻阻塞**，若其有**子进程主动退出或者被杀死**，返回**子进程PID**，如果**没有子进程**，返回`-1`，反之则**一直等待**
{%list%}
传入参数为一返回地址，用于接受子进程退出状态，如果不关心该信息，传入一个0地址（int*）0
{%endlist%}
{%right%}
对于父子进程共享的信息，可以先让父进程wait，让子进程先访问
{%endright%}
**④调用**
>`void exec(char* filename，char* argv)`：在**进程内部**执行一个**可执行文件**
{%list%}
filename用于提供文件路径，对应文件必须有特定的格式，argv用于提供字符串参数数组，第一个参数为程序名
{%endlist%}

#### 2.2I/O操作
**①文件描述符**
>**概述**：本质上是一个**小整型**，一个**可以读写**的由**内核管理**的对象，将**文件**、**目录**和**设备**等抽象为**字节流**
{%list%}
各个进程的文件描述符是相互隔离的，每个进程都至少有一个标准输入0，标准输出1和标准错误2
{%endlist%}
**②读取与写入**
>`int read(int fd,char* buf,int n)`：从`fd`处**最多读取n字节**，并复制到**缓冲区**`buf`中，返回**读取的字节数**
{%list%}
每个文件描述符都会记录其字节流所在位置信息，且随着读写等操作向前/后推移
{%endlist%}
{%warning%}
读取字节数为0表示到达文件末尾
{%endwarning%}
>`write(fd，buf，n)`：将**缓冲区**`buf`中的**n个字节**写入`fd`处，返回**写入的字节数**
{%warning%}
若写入字节小于n，则表示发生了错误
{%endwarning%}
**③打开与关闭**
>`close(int fd)`：**释放**文件描述符，使其可以被**重新分配**

>`int open(char* filename,MACRO)`：为文件**分配文件描述符**，并指定**字节流特性**
{%list%}
新分配的文件描述符号，总是当前进程最小的
{%endlist%}
{%right%}
常用的宏有O_RDONLY只读、O_WRONLY	只写、O_RDWR可读可写
{%endright%}
>还有`O_CREAT`若文件**不存在**则**创建该文件**、`O_TRUNC`将文件**截断为零长度**

>`int dup(int fd)`:接受一个**文件描述符**，返回一个**新文件描述符**，**一同**指向**对应文件**
{%list%}
父进程和子进程，以及dup得到的文件描述符和原文件描述符的字节流位置偏移一开始是一样的
{%endlist%}
#### 2.3管道
**①定义**
>**概述**：本质上是**一对文件描述符**，指向**全局的内核缓冲区**，用于在**两个进程**之间**传递数据**
{%right%}
两个文件描述符分别传递给两个进程，一个用于一个进程写数据，另一个用于另一个进程读书据
{%endright%}
**②使用**
>`void pipe(int* p)`：创建一个**管道**，`p`为一个**长度为2**的**文件描述符数组**，`pipe`会**在其中记录**管道所需的**读写文件描述符**
{%list%}
若一直没有写入数据，管道的读取操作会进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭
{%endlist%}
{%warning%}
及时关闭指向管道写入端的文件描述符，因为对于管道来说所有的写入端都被关闭才是结束，否则会一直等待
{%endwarning%}
>如下例，**子进程**必须在**调用wc之前**关闭**管道写入端的文件描述符**
{%right%}
对于cat|echo，shell对|的左端和右端，均调用fork和runcmd，并创建一个管道连接两者传递信息即可
{%endright%}
>还可通过**临时文件**在**进程间**传递信息，但管道会**自动清理自己**，且允许**两程序并行**，且管道的**阻塞式读写**更高效
```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
//创建管道所需要的文件描述符
pipe(p);
//创建子进程，这样父子进程都有指向同一个管道的文件描述符了
if (fork() == 0) {
    //子进程关闭标准读取，并将其指向管道的读取端
    close(0);
    dup(p[0]);
    //关闭所有指向管道的文件描述符
    close(p[0]);
    close(p[1]);
    //exec调用wc，wc从标准读取，也就是管道读取端读入数据
    exec("/bin/wc", argv);
} else {
    //关闭管道读取端
    close(p[0]);
    //将"hello world\n"写入管道
    write(p[1], "hello world\n", 12);
    //关闭管道写入端
    close(p[1]);
}
```

### 3.Lab1
#### 3.1`sleep`
**①引言**
>**题目概述**：利用`sleep`**系统调用**实现**用户级**`sleep`，暂停**用户指定**的`trick`，详细见[实验官网](https://pdos.csail.mit.edu/6.828/2023/labs/util.html)
{%list%}
trick为两次时钟中断的间隔
{%endlist%}
{%right%}
user/user.h可以看见所有的系统调用和少量的标准C库函数声明，其中就有sleep的声明int sleep(int);
{%endright%}
>`sleep`用户代码**跳转到内核**的汇编代码位于`user/usys.s`，当调用`sleep`时就会**执行以下代码**
```nasm
.global sleep
sleep:
 #将系统调用号SYS_sleep加载到专门的寄存器a7中
 li a7, SYS_sleep 
 #触发一个系统调用，具体操作由寄存器a7的值确定
 ecall
 ret
 ```
>`sys_sleep`代码位于`kernel/sysproc.c`中，具体如下
```c
uint64
sys_sleep(void)
{
  int n;
  uint ticks0;

  argint(0, &n);
  if(n < 0)
    n = 0;
  acquire(&tickslock);
  ticks0 = ticks;
  while(ticks - ticks0 < n){
    if(killed(myproc())){
      release(&tickslock);
      return -1;
    }
    sleep(&ticks, &tickslock);
  }
  release(&tickslock);
  return 0;
}

```
**②实现**
>**概述**：将**传入参数**作为`sleep`参数即可
```c
#include "kernel/types.h"
#include "kernel/stat.h"
//包含了系统调用
#include "user/user.h"

int main(int argc,char **argv){
  //如果参数数量不对
  if(argc != 2){
    fprintf(2,"Usage:sleep [tricks]\n");
    exit(1);
  }
  //将参数转化为整数
  int tricks = atoi(argv[1]);

  sleep(tricks);
  exit(0);
}
```
#### 3.2`pingpong`
**①引言**
>**题目概述**：通过**一对管道**在**两个进程之间**传递一个**字节**，**管道具体内容**见上

**②实现**
>**概述**：创建一个**缓冲区**保存需要**传递的字节**，父子进程分别使用**对应管道的对应端**进行读写
{%list%}
两个管道应该在生成子进程之前创建，因为父子进程想要通信必须有相同的管道
{%endlist%}
{%warning%}
不使用的管道端一开始就关闭，管道端使用完之后也要及时关闭
{%endwarning%}
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc,char **argv){
    
    //创建一个字节大小的缓冲区，其中包含需要传递的字节
    char buf[1] = {'P'};
    
    //创建两个管道用于通信
    //创建管道也有可能失败
    int pipe_parent_to_child[2];
    int pipe_child_to_parent[2];

    if(pipe(pipe_parent_to_child)==-1){
        fprintf(2,"Fail to create pipe_parent_to_child\n");
        exit(1);
    }

    if(pipe(pipe_child_to_parent)==-1){
        fprintf(2,"Fail to create pipe_child_to_parent\n");
        exit(1);        
    }

    int pid = fork();

    if(pid == -1){
        fprintf(2,"Fail to create child process!\n");
        exit(1);

    }
    else if(pid == 0){

        //子进程需要从pipe_parent_to_child读取，并写入到pipe_child_to_parent
        //所以使用pipe_parent_to_child[0]和pipe_child_to_parent[1]
        //并关闭pipe_parent_to_child[1]和pipe_child_to_parent[0]
        close(pipe_child_to_parent[0]);
        close(pipe_parent_to_child[1]);

        //读取数据
        if(read(pipe_parent_to_child[0],buf,1) != 1){
            fprintf(2,"Child: Fail to read from pipe_parent_to_child\n");
            exit(1);
        }
        //表示接收到数据
        printf("%d: received ping\n",getpid());

        //写数据
        if(write(pipe_child_to_parent[1],buf,1) != 1){
            fprintf(2,"Child: Fail to write to pipe_child_to_parent\n");
            exit(1);            
        }

        exit(0);
    }
    else{

        //同理，关闭不使用的管道端口
        close(pipe_child_to_parent[1]);
        close(pipe_parent_to_child[0]);

        if(write(pipe_parent_to_child[1],buf,1) != 1){
            fprintf(2,"Parent: Fail to write to pipe_parent_to_child\n");
            exit(1);            
        }

        if(read(pipe_child_to_parent[0],buf,1) != 1){
            fprintf(2,"Parent: Fail to read from pipe_child_to_parent\n");
            exit(1);            
        }

        printf("%d: received pong\n",getpid());

        exit(0);

    }
}
```


#### 3.3`primes`
**①引言**
>**题目概述**：利用**多个进程**和**管道**实现[素数筛](https://zhuanlan.zhihu.com/p/100051075)，从`2～35`筛选出**所有的素数**
{%list%}
第一个进程接收初始数据，将筛选一次的数据传递给第二个进程，依次类推
{%endlist%}

**②实现**
>**概述**：对于**最初的进程**，其只有**一个管道**`read_pipe`，用于**向子进程写入数据**

>对于**后续的子进程**，有一个**从父进程继承**而来的`read_pipe`，用于**读取父进程数据**

>还有一个**自己创建**的`write_pipe`，用于**向其子进程写入数据**
{%list%}
该实验主要基于递归实现，注意递归结束条件的设置
{%endlist%}
{%right%}
由于每次只需要读写一个int，所以这里采用&i作为缓冲区
{%endright%}
{%warning%}
注意，这里的宏定义prime_num后不能加上分号，否则会产生编译错误
{%endwarning%}
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#define prime_num 35
//注意这里的宏定义不能加上分号

void prime_select(int *read_pipe);
int main(int argc,char **argv){
    //创建管道，父进程只需要一个管道向子进程传递数据
    int read_pipe[2];
    if(pipe(read_pipe) == -1){
        fprintf(2,"Fail to create prime_pipe!\n");
        exit(1);
    }
    //创建子进程
    int pid = fork();
    if(pid<0){
        fprintf(2,"Fail to create child process!\n");
        exit(1);
    }
    else if(pid == 0){
        //子进程执行素数筛相关函数，将read_pipe传递给函数
        //用于子进程读取数据
        prime_select(read_pipe);
    }
    else{
        //父进程只需要写数据，及时关闭读取端
        close(read_pipe[0]);
        //传递数据
        for(int i = 2;i <= prime_num ; ++i){
            //注意这里使用&i取代缓冲区，因为每次读写一个整数
            if(write(read_pipe[1],&i,sizeof(int)) == -1){
                fprintf(2,"Parent: Fail to write to prime_pipe!\n");
                exit(1);
            }
        }
        //及时释放资源
        close(read_pipe[1]);
        wait((int*)0);
    }
    exit(0);
}
```
```c
void prime_select(int *read_pipe){
    //子进程只需要读取数据，关闭写入端
    close(read_pipe[1]);
    int status;
    int buf;

    //通过read_pipe从父进程中读取第一个数据buf
    //如果父进程没有数据传递过来，则表示到达了递归结束条件
    if((status = read(read_pipe[0],&buf,sizeof(int))) == 0){
        close(read_pipe[0]);
        exit(0);
    }
    else if(status == -1){
        fprintf(2,"Parent: Fail to read from read_pipe!\n");
        exit(1);
    }

    //打印读取到的第一个数字
    printf("prime %d\n",buf);

    //创建一个管道向子进程写数据
    int write_pipe[2];
    if(pipe(write_pipe) == -1){
        fprintf(2,"Fail to create write_pipe!\n");
        exit(1);
    }

    int pid = fork();

    if(pid<0){
        fprintf(2,"Fail to create child process!\n");
        exit(1);
    }
    else if(pid == 0){
        //对于子进程，父进程的write_pipe变为了它的read_pipe
        //这里子进程还需要关闭read_pipe的读取端
        close(read_pipe[0]);
        prime_select(write_pipe);
    }
    else{
        //关闭给子进程传递数据的读取端
        close(write_pipe[0]);
        //创建一个缓冲区，读取父进程传递的数据
        int num;
        while((status = read(read_pipe[0],&num,sizeof(int)))>0){
            //只要符合素数筛的要求，就将其传递给子进程
            if(num%buf != 0){
                if(write(write_pipe[1],&num,sizeof(int)) == -1){
                    fprintf(2,"Parent: Fail to write to write_pipe!\n");
                    exit(1);
                }
            }
        }
        if(status == -1){
            fprintf(2,"Parent: Fail to read form read_pipe!\n");
            exit(1);
        }
        close(write_pipe[1]);
        wait((int*)0);
    }

}
```
#### 3.4`find`
**①引言**
>**题目概述**：实现一个可以查找**目录树**下给定**具体名字**的**所有文件**
{%list%}
由于文件系统发生改变，编译时需要先执行make clean再执行make qemu
{%endlist%}
{%right%}
参考user/ls.c程序，查看如何读取文件夹
{%endright%}
>有**两个重要的结构体**`dirent`和`stat`，**前者**保存了**目录项**的信息，**后者**保存了**文件的元信息**

>其中函数`fstat`和`stat`，打开对应的**文件描述符/文件路径**，读取其`stat`结构信息
```c
//dirent定义
// Directory is a file containing a sequence of dirent structures.
#define DIRSIZ 14

struct dirent {
  ushort inum;
  char name[DIRSIZ];
};
```
```c
//stat定义
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
```
```c
int fstat(int fd, struct stat*);
int stat(const char*, struct stat*);
```
**②实现**
>**概述**：根据`dic`的**类型**进行**不同的操作**，这里始终将`file`当作**文件名**看待

>如果`dic`为**设备/普通文件**，则比较其**文件名**是否和`file`相同

>如果`dic`为**目录**，遍历其**目录项**，对**每个目录项递归调用**`find`

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"
#include "kernel/fcntl.h"

char *
fmtname(char *path) {
    char *p;
    // Find first character after last slash.
    for (p = path + strlen(path); p >= path && *p != '/'; p--)
        ;
    p++;
    return p; //返回末尾的文件名
}

void
find(char *dic,char *file){

    //创建一个缓冲区用于存放目录项的名称，一个用于读取文件名的指针以及一个文件描述符
    //创建一个dirent和stat存储目录项的信息
    char buf[512];
    char *p;
    int fd;
    struct dirent de;
    struct stat st;

    //打开dic
    if((fd = open(dic,0)) < 0){
        fprintf(2,"find: Fail to open%s!\n",dic);
        return;
    }

    //读取dic的信息
    if(fstat(fd,&st) < 0){
        fprintf(2,"find: cannot stat%s!\n",dic);
        //注意要及时归还资源
        close(fd);
        return;
    }
    
    switch(st.type){
        //如果是设备文件/普通文件，则比较dic的名字是否和查找的file相等
        case T_DEVICE:
        case T_FILE:
            if(strcmp(fmtname(dic),file) == 0){
            printf("%s\n",dic);
            }
            break;

        //如果是目录
        case T_DIR:
            //这里需要将dic+'/'+de.name+0合成为目录项的绝对路径并存放在buf中
            //所以需要检查起长度
            if(strlen(dic)+1+DIRSIZ+1 > sizeof(buf)){
                printf("find: dic path is too long!\n");
                break;
            }
            strcpy(buf,dic);
            p = buf+strlen(buf);
            *p++ = '/';
            //遍历目录的目录项目
            while(read(fd,&de,sizeof(de)) == sizeof(de)){
                //如果该目录项未使用或者为.、..则忽略
                //注意这里的判断条件应该是strcmp(".",de.name)==0而不是strcmp(".",de.name)
                if(de.inum == 0 || strcmp(".",de.name)==0 || strcmp("..",de.name)==0){
                    continue;
                }
                memmove(p,de.name,DIRSIZ);
                p[DIRSIZ] = 0;
                if(stat(buf,&st)<0){
                    printf("find: cannot stat %s!\n",buf);
                    continue;
                }
                //递归查找
                find(buf,file);
            }
            break;
    }
    //记得释放资源
    close(fd);
}

int main(int argc,char **argv){
    if(argc != 3){
        fprintf(2,"Usage: find dic file");
        exit(1);
    }
    find(argv[1],argv[2]);
    exit(0);
}
```
#### 3.5`xargs`
**①引言**
>**题目概述**：实现一个**简化**的`xargs`，将从**标准输入**读入一行行命令，并将**其结果**作为`xargs`后跟的**命令的参数**
{%list%}
可以指定MAXARG，即exec最多使用的参数数量
{%endlist%}
**②实现**
>**概述**：读取`xargs`后的**命令参数**保存到`_argv[]`中，不断从**标准输入**中**读取参数**添加到其后，调用`exec`即可
{%list%}
外层while循环的终止条件为内层while的exit(0)
{%endlist%}
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/param.h"

int main(int argc,char **argv){

    char *_argv[MAXARG];//用于存储最终需要执行的命令
    char buf[1024];//缓冲区
    char ch;
    int stat;

    //检验参数
    if(argc < 2){
        fprintf(2,"Usage: xargs command\n");
        exit(1);
    }

    //首先先将xargs本身的参数提取出来
    for(int i = 1;i < argc; ++i){
        _argv[i-1] = argv[i];
    }
    //开始从标准输入中读取参数
    while(1){

        int index = 0;//缓冲区指针
        int arg_begin = 0;//存储缓冲区每个参数的首地址
        int arg_cnt = argc-1;//存储_argv当前下标，用于将buf中的参数添加到_argv中
        //读取标准输入中的一行
        while(1){
            stat = read(0,&ch,1);
            if(stat == 0)
            exit(0);
            //遇到空格和换行符说明一个到了参数之间的间隔
            if(ch == ' ' || ch == '\n'){
                buf[index++] = '\0';//参数字符串之间使用'\0'隔开
                _argv[arg_cnt++] = &buf[arg_begin];//将参数的首地址传递给参数列表
                arg_begin = index;
                if(ch == '\n')
                break;
            }
            else{
                buf[index++] = ch;
            }
        }
        //添加结束符号
        _argv[arg_cnt] = (char*)0;

        if(fork() == 0){
            exec(_argv[0],_argv);
        }
        else{
            wait((int*)0);
        }
    }

    exit(0);
}
```
**③总体测试**
>**概述**：在**主目录**下添加`time.txt`，填写**花费的小时数**，随后运行`make grade`即可

![测试结果](/image/MIT.6.1810_Lab1.png)


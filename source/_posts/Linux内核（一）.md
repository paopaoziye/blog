---
title: Linux内核（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - Linux内核
categories: Linux
keywords: 文章关键词
updated: ''
img: /medias/featureimages/29.webp
date:
summary: 进程管理
---
# Linux内核
## Linux内核（一）
### 1.简介
#### 1.1引言
**①特点**
>**概述**：系统调用**简洁**，一切皆**文件**，基于**C语言**开发，进程创建**迅速**，可**动态加载**内核模块，支持**内核抢占**等
{%list%}
基于C语言开发使得Linux在各种硬件体系架构之间具有良好的移植能力
{%endlist%}
{%right%}
一切皆文件，使得Linux对于数据和硬件的系统调用接口是一致的
{%endright%}
**②宏/微内核**
>**宏内核**：一个不可分割的**静态可执行库**，在一个**单独的地址空间**中运行，**Linux内核**为宏内核

>**微内核**：被划分为多个**独立的过程**，每个过程被称为**服务器**，在**各自的地址空间**中运行
{%list%}
宏内核各个部分通信开销小于微内核，前者只需要进行函数调用，后者还涉及到内核空间和用户空间的切换
{%endlist%}
{%warning%}
宏内核虽然性能高，但是一个模块的故障会影响到其他模块
{%endwarning%}

**③源码获取**
>**概述**：可在[官网](https://kernel.org/)获取**源代码**，其中版本号各位分别为**主版本号**、**从版本号**、**修订版本号**
{%list%}
本身系统的源码位于/usr/src/linux下
{%endlist%}
{%right%}
从版本号为偶数表示该版本为稳定版本，奇数为测试版本
{%endright%}
#### 1.2内核开发特点
**①内核库**
>**概述**：不能使用**C标准库**，但是大部分都有其**对应实现**，如`<linux/string.h>`对应C库中的`string.h`文件
{%list%}
基本的头文件位于顶级目录下include文件夹中，体系结构相关的头文件位于arch目录下对应架构include文件夹中
{%endlist%}
>**普通头文件**前缀为`linux/`，如`<linux/string.h>`，**体系架构对应头文件**的前缀为`asm/`，如`<asm/ioctl.h>`

**②`GUNC`**
>**概述**：内核开发并不按照`ANSI C`标准，而是`ISO C99`标准和`GUNC`扩展特性
{%list%}
常用GUNC特性包括内联函数和内联汇编等
{%endlist%}
>**内联函数**：`static inline`修饰函数，一般在**头文件中定义**内联函数

>**内联汇编**：可以在C语言中**嵌入汇编指令**，格式为`asm volatile([内联汇编指令])`
{%right%}
内联函数会在调用位置上展开，可以消除函数调用和返回的开销，但代码会变长，占用更多的内存空间/指令缓存
{%endright%}

**③注意事项**
>**内存访问**：内核没有**内存保护机制**，**非法访问内存**不会有提示，且需要对**共享内存**进行保护

>**可移植**：为了维护内核的**可移植性**，**保持字节序**、**64位对齐**、**不假定字长以及页面长度**等

>**内核栈**：容量**非常小**，随**体系结构**变化，通常是**两页**

>**浮点数**：在内核中使用**浮点数**需要**人工保存和恢复**对应**寄存器**，以及一系列**繁琐操作**，所以**避免使用**
{%list%}
用户进程使用浮点操作时，会陷入内核并从整数模式转换为浮点模式，而内核不能陷入
{%endlist%}
#### 1.3内核数据结构
**①链表**
>**概述**：常用链表有**单向链表**、**双向链表**和**环形链表**，详细可查看`<linux/list.h>`头文件

**②队列**
>

**③映射**
>

**④二叉树**
>

***
### 2.进程和线程
#### 2.1引言
**①定义**
>**进程**：**执行期**的程序代码，除此之外还包含了**相关资源**，如**打开的文件**、**内存地址空间**等

>**线程**：进程中**执行单元**，有独立的**程序计数器**、**进程栈**和一组**进程寄存器**，Linux中线程被视为**特殊的进程**
{%list%}
同一个进程内的线程共享内存地址空间等资源
{%endlist%}
{%right%}
内核调度的对象是线程而不是进程
{%endright%}
{%warning%}
线程之间可以共享虚拟地址空间，但是必须有各自的处理器
{%endwarning%}
**②进程描述符**
>**`task_struct`**：包含一个**进程所有信息**的结构体，定义在`linux/sched.h`中
{%list%}
进程的描述符都存放在任务队列中，任务队列为一双向循环链表
{%endlist%}
>**`struct_thread_info`**：**X86架构**下，该结构`task`成员存放指向**对应进程描述符**的指针
{%list%}
该结构一般存放在进程的内核栈的栈底（向下增长的栈）或者栈顶（向上增长的栈），便于查找
{%endlist%}
>可通过`current_thread_info()`获取**当前进程**的`struct_thread_info`结构指针
{%right%}
有些硬件架构会拿出一个寄存器专门用来存放当前进程task_struct结构的指针
{%endright%}
**③进程状态**
{%list%}
进程描述符的state域记录了进程的状态，主要有以下几种状态
{%endlist%}
>**运行**：正在执行或者在**运行队列**等待执行

>**停止**：终止运行也**不能被投入运行**
{%list%}
进程在接收到SIGSTOP、SIGTSTP等信号时或者在调试期间接收到信号会变成停止状态
{%endlist%}

>**可中断**：等待**某些条件**的达成而睡眠，当**条件达成**或者**接收到对应信号**会被唤醒，**重新投入运行**

>**不可中断**：类似于可中断，但是**对信号不做反应**

>**被跟踪**：被其他进程**跟踪**，例如通过`ptrace`对程序进行跟踪

#### 2.2进程创建
**①引言**
>**概述**：先调用`fork()`拷贝**当前进程**，随后调用`exec()`读取**可执行文件**并将其**载入地址空间**中
{%list%}
父子进程的区别仅仅在于PID、PPID以及某些资源
{%endlist%}
{%right%}
Linux的fork()采用写时复制，进程创建后马上就会运行一个可执行文件，可以避免拷贝大量不会使用的数据
{%endright%}
>**写时复制**：让父子进程**共享同一个拷贝**，只有在**需要写入**的时候，数据才会被复制，从而拥有**各自的拷贝**
{%warning%}
共享拷贝时，对应页是只读的
{%endwarning%}
**②`fork()`**
>**概述**：`fork()`会调用`clone()`，随后`clone()`调用`do_fork()`，`do_fork()`调用`copy_process()`
{%list%}
创建线程和创建进程类似，只是需要向clone()传递标志指明哪些资源需要与父进程共享
{%endlist%}
>通常情况下，线程之间共享**地址空间**、**文件系统资源**、**文件描述符**和**信号处理程序**
{%right%}
fork()的主要工作是copy_process()完成的，其主要流程如下
{%endright%}
>创建**内核栈**、`thread_info`结和`task_struct`，**与父进程相同**

>子进程将自己的**进程描述符**一些成员修改为**初始值或清零**，并将状态设置为**不可中断**，防止其投入运行

>分配`PID`，并根据传递给`clone()`的标志**拷贝/共享**资源，最后返回**子进程进程描述符的指针**

>**`do_fork()`收尾**：`copy_process()`成功返回后，`do_fork()`会**唤醒子进程**，并让子进程**优先投入运行**
{%list%}
子进程一般会马上调用exec()载入新程序，从而避免了写时复制的开销，父进程先运行可能会向共享地址空间写入
{%endlist%}
**③内核线程**
>**定义**：独立运行在**内核空间**的进程，只是**没有独立的地址空间**
{%list%}
内核线程只能由内核线程（kthreadd内核线程）创建，即kthread_create()，本质上还是调用clone()
{%endlist%}
{%warning%}
内核线程被创建之后不会投入运行，需要wake_up_process()主动唤醒
{%endwarning%}

#### 2.3进程终结
**①引言**
>**概述**：进程**主动调用**`exit()`，或者接收到**不能处理也不能忽略**的**信号和异常**时，进程会终结
{%right%}
exit()的主要工作由do_exit()完成，其主要流程如下
{%endright%}
>将**进程描述符**的`flag`成员设置为`PF_EXITING`，并尝试删除对应**内核定时器**
{%list%}
确保没有定时器在排队，也没有定时器处理程序在运行
{%endlist%}
>减少**地址空间**、**文件描述符**和**文件系统数据**等资源的引用计数，当这些资源**引用计数**降为`0`时，释放这些资源

>将**进程描述符**中的`exit_code`设置为`exit()`提供的**退出代码**供父进程检索

>向**父进程**发送信号，给**子进程**重新找**养父进程**，并将**进程状态**修改为`EXIT_ZOMBIE`，最后切换到**新的进程**

**②僵死进程**
>**概述**：处于`EXIT_ZOMBIE`状态的进程依旧占据着一定的**内存空间**，从而**为父进程提供信息**
{%list%}
此时进程还拥有内核栈、task_struct和thread_info结构，只有当其父进程接收到相关信息才会将其释放
{%endlist%}
>**父进程**会调用`wait`系列函数，`wait`系列调用`wait4()`，`wait4()`调用`release_task()`释放剩余资源
{%warning%}
进程终结时必须为其子进程找到新的父进程，否则孤儿进程就会在退出时永远处于僵死状态
{%endwarning%}
{%right%}
通常是在当前线程组内找一个线程或者让init进程作为其父进程，init进程会定时调用wait()清除僵死进程
{%endright%}

### 3.进程调度
#### 3.1引言
**①抢占和时间片**
>**抢占**：**调度程序**决定什么时候**停止运行**一个进程，将一个进程**强制挂起**的动作叫做**抢占**
{%list%}
若没有抢占机制，则除非进程自己主动停止运行，否则会一直执行
{%endlist%}
>**时间片**：表明进程在**被抢占前**能持续运行的时间
{%warning%}
时间片过长会导致系统对交互响应变慢，过短会明显增大进程切换带来的处理器耗时
{%endwarning%}
**②进程分类**
>**I/O消耗型**：通常**只运行一会**，大部分时间用于**等待或者发出I/O请求**，如**用户图形界面GUI**

>**处理器消耗型**：大部分时间在运行，没有太多I/O需求，如**视频编码程序**
{%list%}
为了提高系统响应速度，I/O消耗型进程的优先级通常高于处理器消耗型进程，前者被唤醒后会抢占后者
{%endlist%}
{%right%}
运行一段时间后，I/0消耗型进程的剩余时间片通常高于处理器消耗型进程，从而优先级高于后者
{%endright%}
**③进程优先级**
>**nice值**：用于描述**普通进程**的优先级，nice值**越大**进程优先级**越高**

>**实时优先级**：用于描述**实时进程**的优先级,实时优先级**越大**进程优先级**越高**
{%list%}
实时优先级和nice优先级属于两个互不相交的范畴，任何实时进程的优先级高于普通的进程
{%endlist%}

**④调度器**
>**概述**：Linux以**模块方式**提供**调度算法**，这种模块化结构称为**调度器**
{%list%}
每个调度器都有一个优先级，基础调度器会按照优先级顺序遍历调度器类，找到拥有进程且优先级最高的调度器
{%endlist%}
>随后从**该调度器**的**运行队列**中选择一个**进程**投入运行
{%right%}
调度器可使不同类型进程选择不同的调度算法
{%endright%}
#### 3.2抢占
**①`need_resched`标志**
>**概述**：每个进程的`thread_info`结构中都有`need_resched`标志，当该标志**被设置时**，说明进程**需要被抢占**
{%list%}
内核会定时检查该标志，若该标志被设置，会调用schedule()切换到新进程
{%endlist%}
{%right%}
每个进程都有该标志，而不是作为一个全局变量，因为访问current宏速度很快且进程描述符都在高速缓存中
{%endright%}
**②抢占模式**
>**用户抢占**：从内核空间**返回用户空间**时，内核会检查`need_resched`标志，若被设置则**切换进程**

>**内核抢占**：从中断**返回内核空间**时，会检查`need_resched`标志，若被设置则**切换进程**
{%list%}
当内核中进程被阻塞或者显式调用schedule也会发生内核抢占
{%endlist%}
{%warning%}
只有没有持有锁的内核线程能被抢占
{%endwarning%}
{%right%}
每个进程的thread_info有preempt_count成员，每当进程获取锁该数值加一，释放锁则减一
{%endright%}
**③睡眠唤醒**
>**睡眠**：进程为了**等待某一事件**，如**硬件事件**、**尝试获取信号量**等，会从**运行队列**移动到**等待队列**，并**切换进程**
{%list%}
进程睡眠需要将状态改为可中断/不可中断，且在此之前需要检查条件是否达成，是则退出循环，防止错误睡眠
{%endlist%}
{%warning%}
若为进程被设置为可中断，在其信号唤醒时需要检查条件是否达成，防止伪唤醒
{%endwarning%}
>**唤醒**：当**对应事件发生**时，会唤醒**对应进程**，将其从**等待队列**移动到**运行队列**
{%list%}
如果唤醒进程优先级高于当前进程，会设置当前进程的need_resched标志
{%endlist%}
**④实时调度**
>**概述**：由**实时调度器**管理，有两种实时调度策略`SCHED_FIFO`和`SCHED_RR`，其优先级是**静态**的
{%list%}
当一个SCHED_FIFO级进程处于可执行状态，就会一直执行，直到其受阻塞、显式地释放处理器或被抢占
{%endlist%}
{%warning%}
只有优先级更高的SCHED_FIFO/SCHED_RR任务能对其进行抢占，高优先级实时进程立马抢占低优先级实时进程
{%endwarning%}
{%right%}
SCHED_RR类似于有时间片的SCHED_FIFO
{%endright%}

#### 3.3完全公平调度CFS
**①引言**
>**概述**：允许**每个进程**运行一段时间，**循环轮转**并选择**时间片最多**的进程作为**下一个运行进程**
{%list%}
CFS为Liunx中一个针对普通进程的调度器
{%endlist%}
{%right%}
CFS调度器将处理器的使用比例分配给进程，获得的时间片与系统负载密切相关，且受到nice值影响
{%endright%}
>**nice值越高**的进程获得**越低的处理器使用权重**，且每个进程获得的**时间片有最小值**，保证**切换开销**占比不多

**②时间记账**
>**概述**：进程会记录其**时间片**，**系统时钟节拍**发生时，会**减少一个节拍周期**，当其减少到`0`时进程会被**抢占**
{%list%}
进程描述符的se成员为进程对应的调度器结构，其中存放了进程的时间片
{%endlist%}
{%right%}
系统定时器会定时调用对应函数更新进程的时间片
{%endright%}
**③进程选择**
>**概述**：通过`schedule()`进行**进程切换**，先找到**优先级最高的调度器**，并从其**运行队列**找到**优先级最高的进程**
{%list%}
对于CFS，会挑选运行时间最短的进程投入运行
{%endlist%}
{%right%}
使用红黑树组织运行队列，从而迅速找到运行时间最短的进程
{%endright%}
**④进程切换**
>**概述**：`schedule()在`选择好一个进程后，会调用`context_swith()`进行**进程切换**
{%list%}
context_swith()分别调用switch_mm()和switch_to()切换内存映射和处理器状态
{%endlist%}
{%right%}
进程切换也称为上下文切换
{%endright%}

    int n;
    while(cin>>n){
    int val;
    auto *dummy = new struct Listnode;
    auto cur = dummy,fast = dummy,slow = dummy;
    dummy->val = 0;
    dummy->next = nullptr;
    while(n){
        cin>>val;
        auto tmp = new struct Listnode;
        tmp->val = val;
        tmp->next = nullptr;
        cur->next = tmp;
        cur = cur->next;
        --n;
    }
    cin>>n;
    while(n){
        fast = fast->next;
        --n;
    }
    while(fast!=nullptr){
        fast = fast->next;
        slow = slow->next;
    }

    cout<<slow->val<<endl;
    return 0;
    }

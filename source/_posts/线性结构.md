---
title: 线性结构
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机基础
  - 数据结构与算法
categories: 计算机基础
keywords: 文章关键词
updated: ''
date:
img: /medias/featureimages/10.webp
summary: 线性结构
---
# 数据结构与算法
## 线性结构
### 1.引言
#### 1.1数组和链表
**①数组**
>一段**连续的内存空间**，其**数组名**记录了其**起始位置**，可以通过**索引**访问**对应位置**的内存单元
{%list%}
数组的大小通常是一开始就确定的，但也可以通过一些手段构成动态数组，如C语言的malloc()
{%endlist%}
{%right%}
数组的元素访问非常块，元素地址=起始地址+元素长度x元素索引
{%endright%}
{%warning%}
由于数组是一段连续的内存空间，所以是有限的，可能会出现扩容问题，且移动一个元素会影响其后所有元素
{%endwarning%}
**②链表**
>多个**零星的内存空间**通过**指针**链接在一起，每个链表有一个**头节点**，记录链表**起始位置**，并通过**各个节点存储的指针**访问**对应节点**
{%list%}
根据各个节点的链接关系，链表可分为单链表、双向链表和环形链表
{%endlist%}
{%right%}
链表分散于内存各处，更加灵活，内存允许的情况下可以无限增长，且移动一个节点只会影响与其相连的节点
{%endright%}
{%warning%}
链表需要存储指针信息，需要占用更多的内存，且查询节点需要使用指针，速度较慢
{%endwarning%}
![数组与链表](/image/SF_1.png)

#### 1.2抽象
**①概述**
>只关心**是什么**，而不关心**如何做到**
{%list%}
数据结构的抽象就是描述其定义及其操作集
{%endlist%}
**②定义**
>**线性表**：**零个或多个**数据元素的**有限序列**，**每个元素**只有**一个直接前驱元素**，**一个直接后继元素**
{%list%}
线性表的元素可以是任何结构，如线性表，但是线性表存储的元素必须统一
{%endlist%}
>**栈**：受到**一定约束**的**线性表**，只能在**一端插入和弹出**数据，**后入先出**

>**队列**：受到**一定约束**的**线性表**，只能在**一端插入**，在**另一端删除**，**先进先出**

**③操作集**
>每个**数据结构**的**操作集**都只需要包含一些**基本且独立**的操作
{%right%}
任何复杂操作，都可以转化为操作集的组合
{%endright%}
{%warning%}
每个操作的实现都要考虑不合理情况并抛出异常，以及操作带来的副作用
{%endwarning%}
![线性结构](/image/SF_2.png)
***
### 2.线性表
#### 2.1数组实现
**①结构代码**
```
#define MAXSIZE 30
typedef int ElemType; //如果要修改线性表的数据类型，直接修改这里即可
typedef struct
{
  ElemType data[MAXSIZE];
  int length; //线性表目前的长度
}SqList;
```
**②操作集实现**
>**查找**：获取**对应位置**的**数据**
{%warning%}
需要判断查找的位置是否合理
{%endwarning%}
```
#define OK 1
#define ERROR 0
typedef int Status;

Status  GetElem(SqList L,int i,ElemType *e)
{
  if(L.length==0||i<1||i>L.length) //首先进行异常判断
    return ERROR;
  *e = L.data[i-1];

  return OK;
}
```
>**插入**：将**指定数据**添加到**指定位置**
{%warning%}
需要判断插入位置是否合理，以及该操作带来的副作用
{%endwarning%}
```
Status ListInsert(SqList *L,int i,ElemType e) //注意这里传入的是结构的指针，因为要改变结构
{
  //首先进行异常检查
  int k;
  if(L->lenth==MAXSIZE)
    return ERROR;
  if(i<1||i>L->lenth+1) //注意i的含义对代码的影响
    return ERROR;
  //考虑插入位置对操作的影响
  if(i<=L->length)
  {
    for(k=L->length;k>=i-1;k--) //后移元素
      L->data[k+1]=L->data[k];
  }
  L->data[i-1]=e;
  L->length++; //注意操作带来的额外影响
  
  return OK;
}
```
>**删除**：删除**指定位置**数据并**整理**线性表
```
Status ListDelete(SqList *L,int i)
{
  int k;
  //异常检查
  if(L->length==0)
    return ERROR;
  if(i<1||i>L->length)
    return ERROR;

  //当删除位置不在线性表末尾时
  if(i<L->length)
  {
    for(k=i-1,k<L-length,k++)
      L->data[k]=L->data[k+1];
  }
  L->length--; //函数操作带来的额外影响

  return OK;
}
```
#### 2.2链表实现
**①结构代码**
{%list%}
链表由节点组成，且链接关系也存储在节点中，所以指明了节点的结构就是指明了链表的结构
{%endlist%}
```
//单链表节点结构
typedef struct Node
{
  ElemType data;
  struct Node *next;
}Node;
typedef struct Node *LinkList
```
**②操作集实现**
>**创建**：链表是一种**动态结构**，指明其**头节点**即可

>**查找**
```
Status GetElem(LinkList L,int i,ElemType *e) //传入L为链表的头节点的指针
{
  int j;
  LinkList p;
  p=L->next; //使p指向链表的第一个节点
  j = 1;
  //其中p作为判别条件是防止其超过链表范围，因为当p为空指针时，说明已经到达最后一个节点了
  while(p && j<i) 
  {
    p = p->next;
    ++j;
  }
  if(!p || j>i) //当p为空指针或者i小于1时，第i个元素不存在
    return ERROR;
  return OK;
}
```
>**插入**
{%warning%}
注意节点插入时，先将新节点插入，再将旧的链接断开
{%endwarning%}
```
/*在已存在链表的第i个位置插入元素e
Status ListInsert(LinkList *L,int i,ElemType *e)
{
  int j;
  LinkList p,s;
  p = *L;
  j = 1；
  while(p && j<i ) /*寻找第i个结点,循环结束时j = i-1；
  {
    p = p->next;
    ++j;
  }
  if (!p || j>i) /*当i为0或者第i个结点不存在时
    return ERROR；
  s = (LinkList)malloc(sizeof(Node));
  s->data = e;
  /*注意结点断开和相连的顺序
  s->next = p->next;/*先将新节点添加进链表
  p->next = s;/*再将旧链接断开并添加新链接
}
```
>**删除**
{%warning%}
对于没有回收机制的语言，需要注意释放动态分配获得的内存
{%endwarning%}
```
Status LinkDelete(LinkList *L,int i,ElemType *e)
{
  int j;
  LinkList p,q;
  p = *L;
  j = 1;
  while(p->next && j<i)
  {
    p = p->next;
    ++j;
  }
  if (!p || j>i) /*当i为0或者第i个结点不存在时
    return ERROR；
  q = p->next;
  p->next = q->next;
  *e = q->data;
  free(q); /*记得要释放对应的空间
  return OK;
}
```
>**销毁**
```
Status LinkClear(LinkList *L)
{
  LinkList p,q;
  p = (*L)->next;
  while (p)
  {
    q = p->next;
    free(p)
    p=q
  }
  (*L)->next = NULL;
  return OK;
}
```
***
### 3.栈
#### 3.1数组实现
**①结构代码**
>由一个**记录元素的一维数组**和一个**记录栈顶元素位置**的**变量**组成
```
#define MaxSize
typedef struct SNode* Stack
struct SNode
{
  ElementType Data[MaxSize];
  int Top = -1;
}
```
**②操作集实现**
>**压入元素**：将**指定元素**放在**栈顶上面**
```
void Push(Stack PtrS,ElementType item)
{
  if (PtrS->Top==Maxsize-1)
  {
    printf("栈已满")；
    return；
  }
  else
  {
    PtrS->Data[++(PtrS->Top)]==item;
  }
}
```
>**弹出元素**：将**栈顶元素**删除
```
ElementType Pop(Stack PtrS)
{
  if(PtrS->Top==-1)
  {
    printf("栈空")；
    return ；
  }
  else
  return(PtrS->Data[(PtrS->Top)--]); /*注意--符号是后缀
}
```
#### 3.2链表实现
**①结构代码**
{%list%}
以链表的头节点作为TOP，方便查找
{%endlist%}
```
typedef struct SNode* Stack
struct SNode
{
  ElementType Data;
  struct SNode* Next;
}
```
**②操作集实现**
>**压入元素**
```
void Push(ElementType item,Stack S) 
{
  struct SNode *TmpCell;
  TmpCell=(struct SNode *)malloc(sizeof(struct SNode));
  TmpCell->Element = item;
  TmpCell->Next = S->Next;
  S->Next = TmpCell;
}
```
>**弹出元素**
```
ElementType Pop(Stack S)
{
  struct SNode *FirstCell;
  ElementType TopElem;
  if(IsEmpty(S))
  {
    printf("栈空")；
    return NULL；
  }
  else
  {
    FirstCell = S->Next; /*指向头节点
    S->Next = FirstCell = S->Next;
    TopElem = FirtCell->Element;
    free(FirstCell);
    return TopElem;
  }
}
```
***
### 4.队列
#### 4.1数组实现
**①结构代码**
>`rear`是指向**队尾的“指针”**，`front`是指向**队头的“指针”**，**插入**一个元素时，`rear`**加一**，**删除**一个元素时，`front`**加一**，
{%list%}
当“指针”可以在超过MaxSize且列表未满时，对MaxSize取余再次从0开始，需要一个状态标签判断队列是否已满
{%endlist%}
{%right%}
山不转水转！
{%endright%}

```
#define MaxSize
struct QNode
{
  ElementType Data [MaxSize]；
  int rear = -1; 
  int front = -1;
};
typedef struct QNode *Queue;
```
**②操作集实现**
>**入队列**：将**指定元素**添加到**队尾**
```
void AddQ(Queue PtrQ,ElementType item)
{
  if((PtrQ->rear+1)%MaxSize==PtrQ->front)
  {
    printf("队列已满")；
    return ；
  }
  PtrQ->rear=(PtrQ->rear+1)%MaxSize;
  PtrQ->Data[PtrQ->rear]=item;
}
```
>**出队列**：删除**队头元素**
```
ElementType DeleteQ(Queue PtrQ)
{
  if(PtrQ->front==PtrQ->rear)
  {
    printf("队列空")；
    return ERROR；
  }
  else
  {
    PtrQ->front=(PtrQ->front+1)%MaxSize;
    return PtrQ->Data[PtrQ->front];
  }
}
```
#### 4.2链表实现
**①结构代码**
```
struct Node
{
  ElementType Data;
  struct Node *Next;
};
struct QNode
{
  struct Node *rear; /*指向队尾
  struct Node *front; /*指向队头，列表的头节点，出队的一端
};
typedef struct QNode *Queue;
Queue PtrQ;
```
**②操作集实现**
>**出队列**
```
ElementType DeleteQ(Queue PtrQ)
{
  struct Node *FrontCell; /*作为中间变量保存要删除的节点
  ElementType FrontElem;

  if(PtrQ->front==NULL)
  {
    print("队列空")；
    return ERROR；
  }
  FrontCell = PtrQ->front;
  if(PtrQ->front == PtrQ->rear)
    PtrQ->front=PtrQ->rear=NULL;
  else
    PtrQ->front=PtrQ->front->Next;
  FrontElem = FrontCell->data;
  free(FrontCell);
  return FrontElem;
}
```
>**入队列**
```
Status AddQ(Queue PtrQ,ElementType Elem)
{
  struct Node *FrontCell; /*作为中间变量保存要删除的节点
  FrontCell = (struct Node *)malloc(sizeof(Node));
  if(!FrontCell)
    exit(OVERFLOW);
  FrontCell->Data = Elem;
  PtrQ->rear->next = FrontCell;
  PtrQ->rear = FrontCell;
  return OK;
}
```

---
title: MIT6.1810实验（九）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 文件系统
---
# MIT6.1810实验（九）
## MIT6.1810 Lab9
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：修改Xv6文件系统，使其支持**更大的文件**，并实现**符号链接**功能
{%list%}
做之前记得切换到对应分支git checkout fs
{%endlist%}

**②大文件**
>**概述**：通过**二级间接区块索引**提高Xv6所能支持的**最大文件大小**，需要从`268`块提升到`65803`块
{%list%}
Xv6有12块直接索引和1块一级间接索引，一级简介索引可以指向256块，所以最大文件大小为256+12块
{%endlist%}
{%right%}
65803即256x256+256+11，只需要将一块直接索引修改为二级索引块即可
{%endright%}

**③符号链接**
>**概述**：实现**系统调用**`symlink`，在**指定路径**创建一个新的**符号链接**指向**目标文件**
{%list%}
符号链接类似于硬链接，但是硬链接只仅限于指向同一磁盘的文件，而符号链接可以跨越磁盘
{%endlist%}
**④实验结果**
>**测试准备**：**主目录**添加`time.txt`，随后`make qemu`，退出`make grade`即可
{%list%}
time.txt填写实验花费的时间
{%endlist%}
![测试结果](/image/MIT.6.1810_Lab8.png)
#### 1.2Xv6文件系统
**①硬件抽象**
>**概述**：文件系统将**存储设备**看作是一个巨大的`block`数组，`block`大小通常为**扇区大小整数倍**
{%list%}
扇区为磁盘的读写最小单元，通常为512字节，Xv6的一个block为两个扇区，也就是1024字节
{%endlist%}
{%right%}
文件系统对磁盘做了一定的规划，Xv6中有启动区、超级区、log区、inode区、bitmap区和数据区
{%endright%}
>**启动区**：`block0`，通常存放足以**启动操作系统**的代码

>**超级区**：`block1`，存放**文件系统的描述信息**，如磁盘的`block`**分布**等

>**`log`区**：`block2`至`block31`

>**`inode`区**：`block32`至`block44`，用于存放**所有目录和文件**的`inode`结构
{%list%}
Xv6中inode大小为64字节，所以一个block中包含16个inode
{%endlist%}
>**`bitmap`区**：`block45`，用于描述各个`block`是否**空闲**

>**数据区**：其余`block`，**真正存放数据**的地方

**②`inode`**
>**概述**：每个`inode`代表**一个文件**，文件系统通过**其编号**找到对应`inode`，其结构代码位于`kernel/file.c`
{%list%}
每个inode包含一个block编号，指向了文件所在block，分为直接索引和间接索引
{%endlist%}
>`direct block number`：指向`block`即为**文件所在处**

>`indirect block number`：指向`block`包含**256个**`direct block number`，其中**有效**的`block`为**文件所在处**

```c
// in-memory copy of an inode
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // 标识是否被使用/是否是目录
  short major;
  short minor;
  short nlink;        //link 计数器
  uint size;          //描述文件大小
  uint addrs[NDIRECT+1];
};
```
```c
#define NDIRECT 12
#define NINDIRECT (BSIZE / sizeof(uint))
#define MAXFILE (NDIRECT + NINDIRECT)

// On-disk inode structure
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+1];   // Data block addresses
};
```
**③目录**
>**概述**：大部分`Unix`文件系统中，目录的本质是**文件**，包含多条`directory entry`，即**包含的文件的信息**
{%list%}
Xv6下entry为16字节，前2个字节包含了文件/子目录的inode编号，后14个字节包含了文件/子目录名
{%endlist%}
>查找文件通常从**根目录**的`inode`开始，随后扫描其`directory entry`找到**下一级目录**，直到找到**底层文件**
{%right%}
根目录的inode编号通常是固定的，在Xv6中其编号为1
{%endright%}
**④`sleeplock`**
>**概述**：Xv6中每个`block`都有一个`sleeplock`，当其**被持有时**，就进入`sleep`状态
{%list%}
sleeplock基于spinlock实现，但是不同于自旋锁，其被获取时不会关闭中断，从而允许该COU进行I/O操作
{%endlist%}
```c
void
initsleeplock(struct sleeplock *lk, char *name)
{
  initlock(&lk->lk, "sleep lock");
  lk->name = name;
  lk->locked = 0;
  lk->pid = 0;
}

void
acquiresleep(struct sleeplock *lk)
{
  acquire(&lk->lk);
  while (lk->locked) {
    sleep(lk, &lk->lk);
  }
  lk->locked = 1;
  lk->pid = myproc()->pid;
  release(&lk->lk);
}
```
#### 1.3logging
**①引言**
>**概述**：先将对文件系统的**更新行为**写入`log`，随后执行`log`**记录的操作**，最后**清除**`log`即可
{%list%}
一个文件系统的操作通常包含多个步骤，如果在期间出现故障，会损坏文件系统，所以需要保证其是原子的
{%endlist%}
>将**对文件系统的操作**称为事务，每个**相关系统调用**使用`begin_op`和`end_op`分别表示事务的**开始和结束**
{%right%}
事务中所有写block操作具备原子性，且只会调用log_write进行写操作
{%endright%}
>`log_write`：会先获取`log header`的锁，**记录该区块号**若其没被记录，并将该区块**添加到缓存**中

>**Xv6的log**：`log`区域有`header block`和`log block`，会先更新`log block`，再更新**对应的**`block`
{%list%}
header block包含一数字n和每个log block与其对应的block的映射
{%endlist%}
```c
// Caller has modified b->data and is done with the buffer.
// Record the block number and pin in the cache by increasing refcnt.
// commit()/write_log() will do the disk write.
//
// log_write() replaces bwrite(); a typical use is:
//   bp = bread(...)
//   modify bp->data[]
//   log_write(bp)
//   brelse(bp)
void
log_write(struct buf *b)
{
  int i;

  acquire(&log.lock);
  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
    panic("too big a transaction");
  if (log.outstanding < 1)
    panic("log_write outside of trans");

  for (i = 0; i < log.lh.n; i++) {
    if (log.lh.block[i] == b->blockno)   // log absorption
      break;
  }
  log.lh.block[i] = b->blockno;
  if (i == log.lh.n) {  // Add new block to log?
    bpin(b);
    log.lh.n++;
  }
  release(&log.lock);
}
```
**②数据写入**
>**`end_op()`**：调用`commit()`将对文件系统`log`区域的修改**从缓存写回磁盘**，再调用`install_trans`落实修改
{%list%}
只有将缓存中的log header和log blocks全部写回磁盘，才能完成正确的修改
{%endlist%}
{%right%}
commit中先将log blocks写回，否则先将log header写回而log blocks未写回会导致错误修改
{%endright%}
```c
// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void
end_op(void)
{
  int do_commit = 0;

  acquire(&log.lock);
  log.outstanding -= 1;
  if(log.committing)
    panic("log.committing");
  if(log.outstanding == 0){
    do_commit = 1;
    log.committing = 1;
  } else {
    // begin_op() may be waiting for log space,
    // and decrementing log.outstanding has decreased
    // the amount of reserved space.
    wakeup(&log);
  }
  release(&log.lock);

  if(do_commit){
    // call commit w/o holding locks, since not allowed
    // to sleep with locks.
    commit();
    acquire(&log.lock);
    log.committing = 0;
    wakeup(&log);
    release(&log.lock);
  }
}
```
```c
static void
commit()
{
  if (log.lh.n > 0) {
    write_log();     // Write modified blocks from cache to log
    write_head();    // Write header to disk -- the real commit
    install_trans(0); // Now install writes to home locations
    log.lh.n = 0;
    write_head();    // Erase the transaction from the log
  }
}
```
```c
// Copy committed blocks from log to their home location
static void
install_trans(int recovering)
{
  int tail;

  for (tail = 0; tail < log.lh.n; tail++) {
    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
    bwrite(dbuf);  // write dst to disk
    if(recovering == 0)
      bunpin(dbuf);
    brelse(lbuf);
    brelse(dbuf);
  }
}
```
**③数据恢复**
>**`recover_from_log()`**：读取`log header`，随后调用`install_trans`落实修改，最后**清空**
{%right%}
Xv6启动过程中会调用initlog()，该函数会调用recover_from_log()，以修复文件系统
{%endright%}
```c
static void
recover_from_log(void)
{
  read_head();
  install_trans(1); // if committed, copy from log to disk
  log.lh.n = 0;
  write_head(); // clear the log
}
```
### 2.具体实现
#### 2.1大文件
**①相关定义修改**
>**概述**：对`kernel/fs.h`和`kernel/file.h`中的`dinode`和`inode`结构进行对应的修改
{%list%}
本质上就是将一个直接块修改为二级间接块
{%endlist%}
```c
//将直接块的数目从12修改为11，因为要一个直接块修改为二级间接块
#define NDIRECT 11 
#define NINDIRECT (BSIZE / sizeof(uint))
//修改MAXFILE，将其从NDIRECT + NINDIRECT修改为NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT
#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)

// On-disk inode structure
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  //相应的，NDIRECT减少了1，需要给其加上1
  uint addrs[NDIRECT+2];   // Data block addresses
};
```
```c
// in-memory copy of an inode
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  //相应的，NDIRECT减少了1，需要给其加上1
  uint addrs[NDIRECT+2];
};
```
**②`bmap`**
>**概述**：`kernel/fs.c`中的`bmp()`会根据需要**分配新的块**来保存文件
{%list%}
该函数会先尝试使用直接块满足需求，如果不能满足需求则使用间接块，在此基础上添加二级块的逻辑即可
{%endlist%}
{%right%}
给文件分配数据块，主要是填充其addrs数组以及其中索引块的内容
{%endright%}
{%warning%}
对于每个文件块，在 bread()之后不要忘记进行brelse()
{%endwarning%}
```c
// Inode content
//
// The content (data) associated with each inode is stored
// in blocks on the disk. The first NDIRECT block numbers
// are listed in ip->addrs[].  The next NINDIRECT blocks are
// listed in block ip->addrs[NDIRECT].

// Return the disk block address of the nth block in inode ip.
// If there is no such block, bmap allocates one.
// returns 0 if out of disk space.
static uint
bmap(struct inode *ip, uint bn)
{
  uint addr, *a;
  struct buf *bp;

  if(bn < NDIRECT){
    if((addr = ip->addrs[bn]) == 0){
      addr = balloc(ip->dev);
      if(addr == 0)
        return 0;
      ip->addrs[bn] = addr;
    }
    return addr;
  }
  bn -= NDIRECT;

  if(bn < NINDIRECT){
    // Load indirect block, allocating if necessary.
    if((addr = ip->addrs[NDIRECT]) == 0){
      addr = balloc(ip->dev);
      if(addr == 0)
        return 0;
      ip->addrs[NDIRECT] = addr;
    }
    bp = bread(ip->dev, addr);
    a = (uint*)bp->data;
    if((addr = a[bn]) == 0){
      addr = balloc(ip->dev);
      if(addr){
        a[bn] = addr;
        log_write(bp);
      }
    }
    brelse(bp);
    return addr;
  }
  //二级块逻辑，减去分配的一级逻辑块，剩余的为二级逻辑块所需要的
  bn -= NINDIRECT;

  if(bn < NINDIRECT*NINDIRECT){
    //计算对应逻辑块在二级块逻辑下哪一个一级块中
    int index = bn/NINDIRECT;
    //进一步计算其在对应一级块逻辑下哪一个直接快
    int offset = bn%NINDIRECT;
    //查看其是否有二级块
    //如果不存在则分配
    if((addr = ip->addrs[NDIRECT+1])==0){
      addr = balloc(ip->dev);
      if(addr == 0)
      return 0;
      ip->addrs[NDIRECT+1] = addr;
    }
    //从磁盘中读取二级块以及其数据
    //其中二级块以缓存的形式返回
    bp = bread(ip->dev,addr);
    a = (uint*)bp->data;
    //查看其
    if((addr = a[index])==0){
      addr = balloc(ip->dev);
      if(addr){
        a[index] = addr;
        //将缓存写回磁盘
        log_write(bp);
      }
    }
    //释放缓存块
    brelse(bp);
    //通上读取一级块
    bp = bread(ip->dev, addr);
    a = (uint*)bp->data;
    if((addr = a[offset]) == 0){
      addr = balloc(ip->dev);
      if(addr){
        a[offset] = addr;
        log_write(bp);
      }

    }
    brelse(bp);
    return addr;
  }
  panic("bmap: out of range");
}
```
**③`itruc`**
>**概述**：`kernel/fs.c`中的`itruc()`会**释放**文件**占据的块**
{%list%}
类似地添加释放二级索引的逻辑即可，注意释放的顺序，从底至上释放
{%endlist%}
```c
// Truncate inode (discard contents).
// Caller must hold ip->lock.
void
itrunc(struct inode *ip)
{
  int i, j ,k;
  struct buf *bp, *ibp;
  uint *a, *b;

  for(i = 0; i < NDIRECT; i++){
    if(ip->addrs[i]){
      bfree(ip->dev, ip->addrs[i]);
      ip->addrs[i] = 0;
    }
  }
  if(ip->addrs[NDIRECT]){
    bp = bread(ip->dev, ip->addrs[NDIRECT]);
    a = (uint*)bp->data;
    for(j = 0; j < NINDIRECT; j++){
      if(a[j])
        bfree(ip->dev, a[j]);
    }
    brelse(bp);
    bfree(ip->dev, ip->addrs[NDIRECT]);
    ip->addrs[NDIRECT] = 0;
  }

  // 如果其有二级索引块，需要对其进行释放
  if(ip->addrs[NDIRECT + 1]){
    //读取对应索引块
    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
    a = (uint*)bp->data;
    // 释放其下一级索引块
    for(j = 0; j < NINDIRECT; j++){
      if(a[j]){
        //读取一级索引块
        ibp = bread(ip->dev, a[j]);
        b = (uint*)ibp->data;
        // 同上释放直接索引块
        for(k = 0; k < NINDIRECT; k++){
          if(b[k])
            bfree(ip->dev, b[k]);
        }
        brelse(ibp);
        bfree(ip->dev, a[j]);
      }
    }
    brelse(bp);
    bfree(ip->dev, ip->addrs[NDIRECT + 1]);
    //清空二级索引块的地址
    ip->addrs[NDIRECT + 1] = 0;
  }

  ip->size = 0;
  iupdate(ip);
}

```
#### 2.2符号链接
**①准备工作**
>**概述**：在`kernel/stat.h`中添加一个新的文件类型`T_SYMLINK`，并在`makefile`中添加`symlinktest`
```c
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device
#define T_SYMLINK 4   //符号链接
```
```makefile
UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_symlinktest\

```
**②系统调用添加**
>**概述**：添加`symlink`的**声明**、**编号**、**入口**和**映射关系**
{%list%}
详细可查看lab2
{%endlist%}
```c
// user/user.h
// system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(const char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);
int symlink(char*, char*);
```
```c
// kernel/syscall.h
// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_symlink 22
```
```perl
#user/usys.pl
entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("symlink");
```
```c
// kernel/syscall.c
// Prototypes for the functions that handle system calls.
extern uint64 sys_fork(void);
extern uint64 sys_exit(void);
extern uint64 sys_wait(void);
extern uint64 sys_pipe(void);
extern uint64 sys_read(void);
extern uint64 sys_kill(void);
extern uint64 sys_exec(void);
extern uint64 sys_fstat(void);
extern uint64 sys_chdir(void);
extern uint64 sys_dup(void);
extern uint64 sys_getpid(void);
extern uint64 sys_sbrk(void);
extern uint64 sys_sleep(void);
extern uint64 sys_uptime(void);
extern uint64 sys_open(void);
extern uint64 sys_write(void);
extern uint64 sys_mknod(void);
extern uint64 sys_unlink(void);
extern uint64 sys_link(void);
extern uint64 sys_mkdir(void);
extern uint64 sys_close(void);
extern uint64 sys_symlink(void);
// An array mapping syscall numbers from syscall.h
// to the function that handles the system call.
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_symlink] sys_symlink,
};
```
**③`sys_symlink`**
>**概述**：在`kernel/sysfile.c`下创建核心函数`sys_symlink`
{%list%}
writei的作用是向inode写入数据
{%endlist%}
{%right%}
代码可参考sys_unlink
{%endright%}
{%warning%}
sys_symlink需要写在create函数之后，否则会报错
{%endwarning%}
```c
uint64
sys_symlink(void){
  char sym_link[MAXPATH], target_file[MAXPATH];
  struct inode *ip;

  if(argstr(0, target_file, MAXPATH) < 0 || argstr(1, sym_link, MAXPATH) < 0)
    return -1;

  begin_op();
  //创建链接文件
  if((ip = create(sym_link, T_SYMLINK, 0, 0)) == 0){
    end_op();
    return -1;
  }
  // 将目标文件的路径保存到符号链接的inode中
  if(writei(ip, 0, (uint64)target_file, 0, argstr(0, target_file, MAXPATH)) != argstr(0, target_file, MAXPATH)) {
    iunlockput(ip);
    end_op();
    return -1;
  }
  iunlockput(ip);
  end_op();
  return 0;  
}
```
```c
uint64
sys_unlink(void)
{
  struct inode *ip, *dp;
  struct dirent de;
  char name[DIRSIZ], path[MAXPATH];
  uint off;

  if(argstr(0, path, MAXPATH) < 0)
    return -1;

  begin_op();
  if((dp = nameiparent(path, name)) == 0){
    end_op();
    return -1;
  }

  ilock(dp);

  // Cannot unlink "." or "..".
  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
    goto bad;

  if((ip = dirlookup(dp, name, &off)) == 0)
    goto bad;
  ilock(ip);

  if(ip->nlink < 1)
    panic("unlink: nlink < 1");
  if(ip->type == T_DIR && !isdirempty(ip)){
    iunlockput(ip);
    goto bad;
  }

  memset(&de, 0, sizeof(de));
  if(writei(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
    panic("unlink: writei");
  if(ip->type == T_DIR){
    dp->nlink--;
    iupdate(dp);
  }
  iunlockput(dp);

  ip->nlink--;
  iupdate(ip);
  iunlockput(ip);

  end_op();

  return 0;

bad:
  iunlockput(dp);
  end_op();
  return -1;
}
```
**④`sys_open`**
>**概述**：在`kernel/fcntl.h`中补全`O_NOFOLLOW`的定义，并且**根据要求**修改`sys_open`逻辑
{%list%}
如果打开的链接，其链接的文件也是符号链接，则必须递归地跟踪它，直到到达非链接文件
{%endlist%}
{%right%}
链接形成循环，则必须返回错误代码，可以通过设置最大链接深度近似达到这一点
{%endright%}
{%warning%}
传递给open的标志是使用按位OR运算符组合的，因此新标志不应与任何现有标志重叠
{%endwarning%}
>只有在`O_NOFOLLOW`设置的情况下，才考虑对符号链接进行**递归跟踪**
```c
#define O_RDONLY  0x000
#define O_WRONLY  0x001
#define O_RDWR    0x002
#define O_CREATE  0x200
#define O_TRUNC   0x400
#define O_NOFOLLOW 0x004
```
```c
uint64
sys_open(void)
{
  char path[MAXPATH];
  int fd, omode;
  struct file *f;
  struct inode *ip;
  int n;

  argint(1, &omode);
  if((n = argstr(0, path, MAXPATH)) < 0)
    return -1;

  begin_op();

  if(omode & O_CREATE){
    ip = create(path, T_FILE, 0, 0);
    if(ip == 0){
      end_op();
      return -1;
    }
  } else {
    if((ip = namei(path)) == 0){
      end_op();
      return -1;
    }
    ilock(ip);
    if(ip->type == T_DIR && omode != O_RDONLY){
      iunlockput(ip);
      end_op();
      return -1;
    }
  }

  if(ip->type == T_SYMLINK && !(omode & O_NOFOLLOW)){
    int depth = 0;
    //只要当前文件还是符号链接且没有超过递归深度，就往下读取
    while(ip->type == T_SYMLINK){
      if(++depth == 10){
        iunlockput(ip);
        end_op();
        return -1;
      }
      //读取链接文件存放的目标文件路径
      if(readi(ip,0,(uint64)path,0,MAXPATH) < 0){
        iunlockput(ip);
        end_op();
        return -1;
      }
      //注意这里要解锁，因为需要修改ip
      iunlockput(ip);
      //将ip设置为读取到的文件路径的inode
      if((ip = namei(path))==0){
        end_op();
        return -1;
      }
      //上锁
      ilock(ip);
    }
  }

  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
    iunlockput(ip);
    end_op();
    return -1;
  }

  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
    if(f)
      fileclose(f);
    iunlockput(ip);
    end_op();
    return -1;
  }

  if(ip->type == T_DEVICE){
    f->type = FD_DEVICE;
    f->major = ip->major;
  } else {
    f->type = FD_INODE;
    f->off = 0;
  }
  f->ip = ip;
  f->readable = !(omode & O_WRONLY);
  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);

  if((omode & O_TRUNC) && ip->type == T_FILE){
    itrunc(ip);
  }

  iunlock(ip);
  end_op();

  return fd;
}
```


















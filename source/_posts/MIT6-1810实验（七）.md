---
title: MIT6.1810实验（七）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 中断
---
# MIT6.1810实验（七）
## MIT6.1810 Lab7
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：实现一个**网卡驱动**
{%list%}
做之前记得切换到对应分支git checkout net
{%endlist%}
**②实验描述**
>**背景**：`Xv6`和**当前主机**位于`QEMU`模拟的**局域网**中，`Xv6`使用模拟的`E1000`向**主机**发送数据包
{%list%}
Lab在kernel/e1000_dev.h中标识了E1000寄存器和标识位的相关定义
{%endlist%}
>`E1000`详细信息可见其[软件开发手册](https://pdos.csail.mit.edu/6.S081/2021/readings/8254x_GBe_SDM.pdf)
{%right%}
Lab在kernel/net.c和kernel/net.h中实现了一个包含IP、UDP和ARP协议的简单网络栈
{%endright%}
>**数据包**对应数据结构代码如下，并且可以使用`tcpdump -XXnr packets.pcap`查看**数据包记录**
```c
struct mbuf {
  struct mbuf  *next; // the next mbuf in the chain
  char         *head; // the current start position of the buffer
  unsigned int len;   // the length of the buffer
  char         buf[MBUF_SIZE]; // the backing store
};
```
>**实验目标**：在`kernel/e1000.c`下补全函数`e1000_transmit()`和`e1000_recv()`，使驱动程序可以**收发数据包**

>**测试**：打开**两个终端**，一边运行`make server`，一边运行`make qemu`并在Xv6中运行`nettests`
{%list%}
nettests会尝试向make server创造出来的host主机发送一个UDP数据包
{%endlist%}
**③实验结果**
>**测试准备**：**主目录**添加`time.txt`，随后`make qemu`，退出`make grade`即可
{%list%}
time.txt填写实验花费的时间
{%endlist%}
![测试结果](/image/MIT.6.1810_Lab7.png)

#### 1.2Xv6中断
**①引言**
>**`PLIC`**：用于**管理设备中断**的一个硬件，`PLIC`会保存**中断信息**，并通知一个`CPU`**处理中断**
{%list%}
CPU核处理完中断之后，CPU会通知PLIC，PLIC将不再保存中断的信息
{%endlist%}
{%right%}
内核可以对PLIC进行编程，从而设置中断的优先级
{%endright%}
>**`UART`**：将传输数据在**串行通信**与**并行通信**之间加以转换
{%list%}
数据先由设备传递给设备端的UART，随后设备端UART传递给CPU端UART，最后CPU端UART传递给CPU
{%endlist%}
>`polling`：除了依赖**中断**，CPU可以一直读取外设的**控制寄存器**，来检查**是否有数据**
{%list%}
polling需要一直占用CPU，但是可以节省进出中断的代价，高性能如网卡常使用polling与设备交互
{%endlist%}
{%right%}
可以polling和Interrupt之间动态切换达到最好的效果
{%endright%}
**②中断设置流程**
>`start.c`：将所有的中断都设置在`Supervisor mode`，然后设置`SIE`**寄存器**来接收中断，并**初始化定时器**
{%list%}
SIE寄存器每一位控制对应类型中断的打开与否，如设备中断、软中断和定时器中断
{%endlist%}
```c
// entry.S jumps here in machine mode on stack0.
void
start()
{
  // set M Previous Privilege mode to Supervisor, for mret.
  unsigned long x = r_mstatus();
  x &= ~MSTATUS_MPP_MASK;
  x |= MSTATUS_MPP_S;
  w_mstatus(x);

  // set M Exception Program Counter to main, for mret.
  // requires gcc -mcmodel=medany
  w_mepc((uint64)main);

  // disable paging for now.
  w_satp(0);

  // delegate all interrupts and exceptions to supervisor mode.
  w_medeleg(0xffff);
  w_mideleg(0xffff);
  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);

  // configure Physical Memory Protection to give supervisor mode
  // access to all of physical memory.
  w_pmpaddr0(0x3fffffffffffffull);
  w_pmpcfg0(0xf);

  // ask for clock interrupts.
  timerinit();

  // keep each CPU's hartid in its tp register, for cpuid().
  int id = r_mhartid();
  w_tp(id);

  // switch to supervisor mode and jump to main().
  asm volatile("mret");
}
```
>`main()`：Xv6第一个初始化的**外设**为`console`
```c
// start() jumps here in supervisor mode on all CPUs.
void
main()
{
  if(cpuid() == 0){
    consoleinit();
    printfinit();
    printf("\n");
    printf("xv6 kernel is booting\n");
    printf("\n");
    kinit();         // physical page allocator
    kvminit();       // create kernel page table
    kvminithart();   // turn on paging
    procinit();      // process table
    trapinit();      // trap vectors
    trapinithart();  // install kernel trap vector
    plicinit();      // set up interrupt controller
    plicinithart();  // ask PLIC for device interrupts
    binit();         // buffer cache
    iinit();         // inode table
    fileinit();      // file table
    virtio_disk_init(); // emulated hard disk
    userinit();      // first user process
    __sync_synchronize();
    started = 1;
  } else {
    while(started == 0)
      ;
    __sync_synchronize();
    printf("hart %d starting\n", cpuid());
    kvminithart();    // turn on paging
    trapinithart();   // install kernel trap vector
    plicinithart();   // ask PLIC for device interrupts
  }

  scheduler();        
}
```
>`consoleinit()`：初始化**对应的锁**，调用`uartinit()`，并设置对应的**读写处理函数**
```c
void
consoleinit(void)
{
  initlock(&cons.lock, "cons");

  uartinit();

  // connect read and write system calls
  // to consoleread and consolewrite.
  devsw[CONSOLE].read = consoleread;
  devsw[CONSOLE].write = consolewrite;
}
```
>`uartinit()`：配置好对应的`UART`芯片，如其**字符长度**，并初始化**对应的锁**
```c
void
uartinit(void)
{
  // disable interrupts.
  WriteReg(IER, 0x00);

  // special mode to set baud rate.
  WriteReg(LCR, LCR_BAUD_LATCH);

  // LSB for baud rate of 38.4K.
  WriteReg(0, 0x03);

  // MSB for baud rate of 38.4K.
  WriteReg(1, 0x00);

  // leave set-baud mode,
  // and set word length to 8 bits, no parity.
  WriteReg(LCR, LCR_EIGHT_BITS);

  // reset and enable FIFOs.
  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);

  // enable transmit and receive interrupts.
  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);

  initlock(&uart_tx_lock, "uart");
}
```
>`plicinit()`：`main`函数初始化完`console`之后，还需要初始化`PLIC`，才能**接受中断**，并设置其**管理的中断**
{%list%}
plicinit()由0号CPU调用，其余CPU调用plicinithart()进行PLIC的设置
{%endlist%}
{%right%}
最后main函数会调用scheduler()，并在其中打开中断
{%endright%}
```c
void
plicinit(void)
{
  // set desired IRQ priorities non-zero (otherwise disabled).
  *(uint32*)(PLIC + UART0_IRQ*4) = 1;
  *(uint32*)(PLIC + VIRTIO0_IRQ*4) = 1;
}
```
```c
void
plicinithart(void)
{
  int hart = cpuid();
  
  // set enable bits for this hart's S-mode
  // for the uart and virtio disk.
  *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ);

  // set this hart's S-mode priority threshold to 0.
  *(uint32*)PLIC_SPRIORITY(hart) = 0;
}
```
**③设备驱动**
>**概述**：内核**管理设备**的代码，大部分可分为`top`和`bottom`两部分，以下以`UART`驱动为例
{%list%}
top部分通常与用户的进程交互，并进行数据的读写，bottom部分通常用于处理设备中断
{%endlist%}
>`shell`：其中调用的`fprintf`会调用`write`系统调用，该系统调用会走到`sysfile.c`文件的`sys_write`函数
{%list%}
详细代码可见user/sh.c
{%endlist%}
>`sys_write()`：**获取参数**并对参数进行**检查**，然后又调用了`filewrite`函数
```c
uint64
sys_write(void)
{
  struct file *f;
  int n;
  uint64 p;
  
  argaddr(1, &p);
  argint(2, &n);
  if(argfd(0, 0, &f) < 0)
    return -1;

  return filewrite(f, p, n);
}
```
>`filewrite()`：判断**文件描述符的类型**，对于**设备类型**，会执行**特定的设备**相应的`write`函数
{%list%}
shell将信息打印到屏幕上，对应的设备是console，会调用console.c中的consolewrite函数
{%endlist%}
{%right%}
初始化console设备时，设置了相应的映射
{%endright%}
```c
// Write to file f.
// addr is a user virtual address.
int
filewrite(struct file *f, uint64 addr, int n)
{
  int r, ret = 0;

  if(f->writable == 0)
    return -1;

  if(f->type == FD_PIPE){
    ret = pipewrite(f->pipe, addr, n);
  } else if(f->type == FD_DEVICE){
    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].write)
      return -1;
    ret = devsw[f->major].write(1, addr, n);
  } else if(f->type == FD_INODE){
    // write a few blocks at a time to avoid exceeding
    // the maximum log transaction size, including
    // i-node, indirect block, allocation blocks,
    // and 2 blocks of slop for non-aligned writes.
    // this really belongs lower down, since writei()
    // might be writing a device like the console.
    int max = ((MAXOPBLOCKS-1-1-2) / 2) * BSIZE;
    int i = 0;
    while(i < n){
      int n1 = n - i;
      if(n1 > max)
        n1 = max;

      begin_op();
      ilock(f->ip);
      if ((r = writei(f->ip, 1, addr + i, f->off, n1)) > 0)
        f->off += r;
      iunlock(f->ip);
      end_op();

      if(r != n1){
        // error from writei
        break;
      }
      i += r;
    }
    ret = (i == n ? n : -1);
  } else {
    panic("filewrite");
  }

  return ret;
}
```
>`consolewrite()`：先通过`either_copyin`**拷入字符**，之后调用`uartputc`函数
{%list%}
uartputc位于uart.c中
{%endlist%}
{%right%}
可以认为consolewrite是一种UART驱动的top部分
{%endright%}
```c
//
// user write()s to the console go here.
//
int
consolewrite(int user_src, uint64 src, int n)
{
  int i;

  for(i = 0; i < n; i++){
    char c;
    if(either_copyin(&c, user_src, src+i, 1) == -1)
      break;
    uartputc(c);
  }

  return i;
}
```
>`uartputc()`：判断**缓冲区是否已满**，如果已满，则调用`sleep`让出CPU，反之则**写入字符**并调用`uartstart`
{%list%}
UART驱动的缓冲区为一个环形队列，读写指针相同表示缓冲区为空，写指针比读指针大1表示buffer已满
{%endlist%}
{%warning%}
一个buffer只针对一个UART设备，而这个buffer会被所有的CPU核共享，使用时需要添加锁
{%endwarning%}
```c
// the transmit output buffer.
struct spinlock uart_tx_lock;
#define UART_TX_BUF_SIZE 32
char uart_tx_buf[UART_TX_BUF_SIZE];
uint64 uart_tx_w; // write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]
uint64 uart_tx_r; // read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]

void
uartputc(int c)
{
  acquire(&uart_tx_lock);

  if(panicked){
    for(;;)
      ;
  }
  while(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE){
    // buffer is full.
    // wait for uartstart() to open up space in the buffer.
    sleep(&uart_tx_r, &uart_tx_lock);
  }
  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;
  uart_tx_w += 1;
  uartstart();
  release(&uart_tx_lock);
}
```
>`uartstart()`：检查设备**是否空闲**，空闲则从`buffer`中读出数据并写入`console`设备的`THR`寄存器
{%list%}
当数据被送到设备后，会返回，并层层返回到用户程序shell
{%endlist%}
{%right%}
同时，UART设备会将数据送出，并且在某个时间，CPU会收到UART触发的中断
{%endright%}
```c
void
uartstart()
{
  while(1){
    if(uart_tx_w == uart_tx_r){
      // transmit buffer is empty.
      return;
    }
    
    if((ReadReg(LSR) & LSR_TX_IDLE) == 0){
      // the UART transmit holding register is full,
      // so we cannot give it another byte.
      // it will interrupt when it's ready for a new byte.
      return;
    }
    
    int c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];
    uart_tx_r += 1;
    
    // maybe uartputc() is waiting for space in the buffer.
    wakeup(&uart_tx_r);
    
    WriteReg(THR, c);
  }
}
```
>`PILC`：**设备**通过`PILC`将中断传递给**CPU**，若CPU可以接受**设备中断**，则跳转到**中断代码**
{%list%}
CPU接受设备中断后，会清除SIE寄存器对应的位防止同类中断打扰，记录当前mode并转换为Supervisor mode
{%endlist%}
{%right%}
CPU将当前当前PC寄存器的值到SEPC寄存器中，并将PC寄存器设置为STVEC寄存器的值从而跳转到中断代码
{%endright%}
>`STVEC`寄存器保存`trap`处理程序的**地址**，这里是**用户态**，所以跳转到`usertrap`，并跳转到`devintr`分支
```c
 else if((which_dev = devintr()) != 0){
    // ok
 }
```
>`devintr()`：判断该中断是否来自于**外设**，是则调用`plic_claim()`获取**中断号**，并调用对应**中断函数**
{%list%}
如果是UART中断，那么会调用位于uart.c文件的uartintr函数
{%endlist%}
```c
// check if it's an external interrupt or software interrupt,
// and handle it.
// returns 2 if timer interrupt,
// 1 if other device,
// 0 if not recognized.
int
devintr()
{
  uint64 scause = r_scause();

  if((scause & 0x8000000000000000L) &&
     (scause & 0xff) == 9){
    // this is a supervisor external interrupt, via PLIC.

    // irq indicates which device interrupted.
    int irq = plic_claim();

    if(irq == UART0_IRQ){
      uartintr();
    } else if(irq == VIRTIO0_IRQ){
      virtio_disk_intr();
    } else if(irq){
      printf("unexpected interrupt irq=%d\n", irq);
    }

    // the PLIC allows each device to raise at most one
    // interrupt at a time; tell the PLIC the device is
    // now allowed to interrupt again.
    if(irq)
      plic_complete(irq);

    return 1;
  } else if(scause == 0x8000000000000001L){
    // software interrupt from a machine-mode timer interrupt,
    // forwarded by timervec in kernelvec.S.

    if(cpuid() == 0){
      clockintr();
    }
    
    // acknowledge the software interrupt by clearing
    // the SSIP bit in sip.
    w_sip(r_sip() & ~2);

    return 2;
  } else {
    return 0;
  }
}
```
```c
// ask the PLIC what interrupt we should serve.
int
plic_claim(void)
{
  int hart = cpuid();
  int irq = *(uint32*)PLIC_SCLAIM(hart);
  return irq;
}
```
>`uartintr()`：读取**进程传递的字符**，并将其**打印在屏幕**上，最后调用`uartstart()`处理**下一个字符**
```c
// read one input character from the UART.
// return -1 if none is waiting.
int
uartgetc(void)
{
  if(ReadReg(LSR) & 0x01){
    // input data is ready.
    return ReadReg(RHR);
  } else {
    return -1;
  }
}

// handle a uart interrupt, raised because input has
// arrived, or the uart is ready for more output, or
// both. called from devintr().
void
uartintr(void)
{
  // read and process incoming characters.
  while(1){
    int c = uartgetc();
    if(c == -1)
      break;
    consoleintr(c);
  }

  // send buffered characters.
  acquire(&uart_tx_lock);
  uartstart();
  release(&uart_tx_lock);
}
```
### 2.具体实现
#### 2.1前置知识
**①接收环**
>**概述**：接收数据包时，其**到达速度**快于**驱动程序处理速度**，使用一个**环形队列**作为缓冲
{%list%}
缓冲区本质上是一个内存描述符数组，描述符结构代码如下，其中addr为保存数据包的中转内存地址
{%endlist%}
{%right%}
每当E1000接收到一个数据包时，会将数据包DMA到接收环中的下一个位置描述符对应的中转内存中
{%endright%}
{%warning%}
接收环为一环形队列，对应指针Head到Tail，[Head,Tail]为待填充数据，这之外是已填充待读取数据
{%endwarning%}
>**填充数据**时，`Head`指针**后移**，**读取数据**时，从`Tail+1`位置读取，并将`Tail`**后移**

>`E1000_RDH/E1000_RDT`**寄存器**分别保存了`Head/Tail`指针距`Base`位置的偏移量

>`e1000_init()`中，`E1000_RDH`被设置为`0`，`E1000_RDT`被设置为`RX_RING_SIZE-1`，表示**接收环已满**
```c
//接受队列
#define RX_RING_SIZE 16
static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));
```
```c
// [E1000 3.2.3]
struct rx_desc
{
  uint64 addr;       /* Address of the descriptor's data buffer */
  uint16 length;     /* Length of data DMAed into data buffer */
  uint16 csum;       /* Packet checksum */
  uint8 status;      /* Descriptor status */
  uint8 errors;      /* Descriptor Errors */
  uint16 special;
};
```
```c
regs[E1000_RDH] = 0;
regs[E1000_RDT] = RX_RING_SIZE - 1;
regs[E1000_RDLEN] = sizeof(rx_ring);
```

**②发送环**
>**概述**：**驱动**将待发送数据包相关信息存放在**发送环**中，等待`E1000`进行发送
{%list%}
大部分和接收环一致，[Head,Tail)之间是待发送数据，其余是待填充数据
{%endlist%}
>**写入**数据包时，从`Tail`位置读取，并将`Tail`**后移**，**读取**数据包时，从`Head`读取，并将`Head`**后移**

>`E1000_TDH/E1000_TDT`**寄存器**分别保存了`Head/Tail`指针距`Base`位置的偏移量

>`e1000_init()`中，`E1000_TDH`被设置为`0`，`E1000_TDT`被设置为`0`，表示**发送环为空**
```c
#define TX_RING_SIZE 16
static struct tx_desc tx_ring[TX_RING_SIZE] __attribute__((aligned(16)))
```
```c
// [E1000 3.3.3]
struct tx_desc
{
  uint64 addr;
  uint16 length;
  uint8 cso;
  uint8 cmd;
  uint8 status;
  uint8 css;
  uint16 special;
};
```
```c
regs[E1000_TDLEN] = sizeof(tx_ring);
regs[E1000_TDH] = regs[E1000_TDT] = 0;
```
**③中转内存**
>**概述**：`rx_mbufs/tx_mbufs`为`mbuf`指针数组，即接**接受/发送数据包**时对应的**内存中转区域**
{%list%}
在e1000_init()中，中转内存和接收环/发送环进行了相应的映射，两者的大小和对应下标是一致的
{%endlist%}
{%right%}
使用mbufalloc()为E1000分配用于DMA的mbuf数据包缓冲区
{%endright%}
```c
memset(rx_ring, 0, sizeof(rx_ring));
for (i = 0; i < RX_RING_SIZE; i++) {
  rx_mbufs[i] = mbufalloc(0);
  if (!rx_mbufs[i])
    panic("e1000");
  rx_ring[i].addr = (uint64) rx_mbufs[i]->head;
}
```
```c
// [E1000 14.5] Transmit initialization
memset(tx_ring, 0, sizeof(tx_ring));
for (i = 0; i < TX_RING_SIZE; i++) {
  tx_ring[i].status = E1000_TXD_STAT_DD;
  tx_mbufs[i] = 0;
}
regs[E1000_TDBAL] = (uint64) tx_ring;
if(sizeof(tx_ring) % 128 != 0)
  panic("e1000");
```
#### 2.2函数实现
**①`e1000_recv`**
>**概述**：扫描**接收环**，将每个**旧数据包**传输到**网络栈**，随后**为新数据包分配内存**并与**描述符**建立映射
{%list%}
不需要锁，因为该函数由E1000中断触发，CPU接受该中断后会忽略设备中断，没有竞争问题
{%endlist%}
```c
static void
e1000_recv(void)
{
  //
  // Your code here.
  //
  // the mbuf contains an ethernet frame; program it into
  // the TX descriptor ring so that the e1000 sends it. Stash
  // a pointer so that it can be freed after sending.
  //

  while(1){

    //E1000_RDT+最开始指向接收环已填充区域的第一个描述符
    int index = (regs[E1000_RDT]+1)%RX_RING_SIZE;
    //检查对应位置描述符是否有数据包准备好，即旧数据包
    //如果该位置没有数据包，则表示数据包被传递完
    if(!(rx_ring[index].status & E1000_RXD_STAT_DD))
    return;
    //更新旧数据包存放队列对应位置数据包长度信息
    rx_mbufs[index]->len = rx_ring[index].length;
    //将旧数据包传递给网络栈
    net_rx(rx_mbufs[index]);
    //为新数据包mbuf结构分配地址
    rx_mbufs[index] = mbufalloc(0);
    //建立数据包存放队列和接收环的映射
    rx_ring[index].addr = (uint64)rx_mbufs[index]->head;
    //抹除数据包传入状态
    //因为此时旧数据包被抹除，新数据包还未传入
    rx_ring[index].status = 0;
    //递增Tail指针，开始处理下一个位置
    regs[E1000_RDT] = index;
  }
  
  return;
}
```
**②`e1000_transmit`**
>**概述**：将数据包写入**发送环**，并建立数据包和**中转内存**的映射，最后更新`Head`指针
{%list%}
该函数由内核调用，需要加锁对数据进行保护，并避免中断切入导致的死锁
{%endlist%}
```c
int
e1000_transmit(struct mbuf *m)
{
  //
  // Your code here.
  //
  // Check for packets that have arrived from the e1000
  // Create and deliver an mbuf for each packet (using net_rx()).
  //

  //获取e1000网卡的锁，避免其他内核线程
  acquire(&e1000_lock);
  //由发送环介绍可知，写入数据包从Tail开始
  int index = regs[E1000_TDT];
  //若发送环对应位置没有数据包，则直接返回
  //记得释放锁
  if(!(tx_ring[index].status & E1000_TXD_STAT_DD)){
    release(&e1000_lock);
    return -1;
  }
  //如果对应位置有数据包，则释放对应位置的数据包结构
  if(tx_mbufs[index])
  mbuffree(tx_mbufs[index]);
  //使用新的数据包填充该位置，并设置对应状态
  tx_ring[index].length = (uint16)m->len;
  tx_ring[index].addr = (uint64)m->head;
  tx_ring[index].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;
  //建立发送环和中转内存的映射
  tx_mbufs[index] = m;
  //更新Head指针位置
  regs[E1000_TDT] = (index + 1) % TX_RING_SIZE;
  release(&e1000_lock);
  return 0;  
}
```

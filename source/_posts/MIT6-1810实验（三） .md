---
title: MIT6.1810实验（三）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 页表
---
# MIT6.1810实验（三）
## MIT6.1810 Lab3
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：Lab3的主要工作围绕**Xv6的虚拟内存和页表**进行
{%list%}
做之前记得切换到对应分支git checkout pgtbl
{%endlist%}
**②系统调用提速**
>**概述**：给进程的**地址空间**划分出一片区域，其中为一个`struct usyscall`结构体，用于保存**该进程的PID**
{%list%}
struct usyscall定义在kernel/memlayout.h中，lab提供了测试函数ugetpid()，定义在user/ulib.c
{%endlist%}
{%right%}
部分操作系统的用户空间和内核空间之间使用一块只读区域进行数据共享，从而消除了和内核交互的开销
{%endright%}
```c
#define USYSCALL (TRAPFRAME - PGSIZE)
struct usyscall {
  int pid;  // Process ID
};
```
```c
#ifdef LAB_PGTBL
int
ugetpid(void)
{
  struct usyscall *u = (struct usyscall *)USYSCALL;
  return u->pid;
}
#endif
```
**③页表打印**
>**概述**：定义函数`vmprint()`，接受**页表指针**，即`pagetable_t`类型，将页表**有效信息**打印出来
{%list%}
页表有效信息格式如下，打印一级页表并递归地打印其下级页表，每个页表项由编号、PTE和物理地址组成
{%endlist%}
>用` ..`来表示这个`PTE`的**深度**
{%right%}
PTE2PA可以将物理地址PA从PTE中读取出来
{%endright%}
```
page table 0x0000000087f6e000
 ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
 .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
 .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
 ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
 .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
 .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000
 .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
```
**④内存访问查询**
>**概述**：实现名为`pgaccess`的**系统调用**，查看**哪些内存页被访问**了，将结果保存在变量`bitmask`中
{%list%}
当内存页被访问，其PTE的A位会被设置为高位；bitmask的每一位从右向左和每个检查过的内存页一一对应
{%endlist%}
**⑤实验结果**
>**测试准备**：**主目录**添加`time.txt`和`answers-pgtbl.txt`，随后`make qemu`，退出`make grade`即可
{%list%}
两个txt前者填写花费的时间数，后者填写对于这个lab的疑问
{%endlist%}
![测试结果](/image/MIT.6.1810_Lab3.png)
#### 1.2Xv6虚拟内存
**①页表**
>**概述**：Xv6的**每个进程**都有自己的页表，其中**虚拟地址**为`39`位，可分为`9:9:9:12`
{%list%}
可见Xv6的页表为三级页表，其中每一级页表有2^9个页表项，每一页大小为2^12比特，即4KB
{%endlist%}
>每个**页表项**称为`PTE`，详细信息如下图所示
{%right%}
Xv6进程一级页表的地址存放在寄存器satp中
{%endright%}
>**Xv6**`kernel/vm.c`中的`walk`函数用于将**虚拟地址转化为物理地址**
```c
// Return the address of the PTE in page table pagetable
// that corresponds to virtual address va.  If alloc!=0,
// create any required page-table pages.
//
// The risc-v Sv39 scheme has three levels of page-table
// pages. A page-table page contains 512 64-bit PTEs.
// A 64-bit virtual address is split into five fields:
//   39..63 -- must be zero.
//   30..38 -- 9 bits of level-2 index.
//   21..29 -- 9 bits of level-1 index.
//   12..20 -- 9 bits of level-0 index.
//    0..11 -- 12 bits of byte offset within the page.
pte_t *
walk(pagetable_t pagetable, uint64 va, int alloc) 
  //pagetable表示一级页表的地址，va为虚拟内存地址，alloc表示是否创建条目
{
  if(va >= MAXVA) //虚拟内存地址越界，报错
    panic("walk");

  for(int level = 2; level > 0; level--) { //分三级地址
    pte_t *pte = &pagetable[PX(level, va)]; //使用位运算获取L2/L1/L0，计算索引位置
    if(*pte & PTE_V) {
      pagetable = (pagetable_t)PTE2PA(*pte); //若条目有效，将页表指针指向下级页表
    } else {
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) //若无效，且alloc有设置，创建相关条目
        return 0;
      memset(pagetable, 0, PGSIZE);
      *pte = PA2PTE(pagetable) | PTE_V;
    }
  }
  return &pagetable[PX(0, va)]; //最后返回三级页表中映射的物理地址
}
```
![Xv6页表](/image/Xv6_pgtbl-3-level.png)
**②内核地址空间**
>**概述**：`0-0x80000000`用于模拟**I/O设备**，`0x80000000-0x86400000`存放**内核数据**，这些部分都是**直接映射**的
{%list%}
还有一些其余空间为trampoline页和内核栈页，依次位于内核地址空间的顶端，这些部分不是直接映射
{%endlist%}
{%right%}
每个内核栈页上方都有一守护页，其PTE标志是无效的，当内核栈溢出时会引发异常，从而防止内核栈溢出
{%endright%}
>**内核页表**：`main()`函数调用`kvminit()`**初始化内核页表**，如下，该函数仅仅只是调用了`kvmmake()`
```c
// Initialize the one kernel_pagetable
void
kvminit(void)
{
  kernel_pagetable = kvmmake();
}
```
>`kvmmake()`：创建了内核页表`kpgtb`，并通过`kvmmap()`设置了**一系列对应的映射**
```c
// Make a direct-map page table for the kernel.
pagetable_t
kvmmake(void)
{
  pagetable_t kpgtbl;

  kpgtbl = (pagetable_t) kalloc();
  memset(kpgtbl, 0, PGSIZE);

  // uart registers
  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

  // virtio mmio disk interface
  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);

  // PLIC
  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);

  // map kernel text executable and read-only.
  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);

  // map kernel data and the physical RAM we'll make use of.
  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);

  // map the trampoline for trap entry/exit to
  // the highest virtual address in the kernel.
  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);

  // map kernel stacks
  proc_mapstacks(kpgtbl);
  
  return kpgtbl;
}
```
>`kvmmap()`：主要工作通过`mappages()`完成，即**页表设置的最底层**
{%list%}
各个参数分别为内核页表kpgtbl、虚拟地址va、物理地址pa、映射大小sz和标志位perm
{%endlist%}
```c
// add a mapping to the kernel page table.
// only used when booting.
// does not flush TLB or enable paging.
void
kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
{
  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
    panic("kvmmap");
}
```
```c
// Create PTEs for virtual addresses starting at va that refer to
// physical addresses starting at pa. va and size might not
// be page-aligned. Returns 0 on success, -1 if walk() couldn't
// allocate a needed page-table page.
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
{
  uint64 a, last;
  pte_t *pte;

  if(size == 0)
    panic("mappages: size");
  
  a = PGROUNDDOWN(va);
  last = PGROUNDDOWN(va + size - 1);
  for(;;){
    if((pte = walk(pagetable, a, 1)) == 0)
      return -1;
    if(*pte & PTE_V)
      panic("mappages: remap");
    *pte = PA2PTE(pa) | perm | PTE_V;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
```
>`kvminithart()`：**内核页表**生成结束后，`main()`函数调用`kvminithart()`使用内核页表
{%list%}
该函数该将根页表页的物理地址写入satp寄存器 
{%endlist%}
```c
// Switch h/w page table register to the kernel's page table,
// and enable paging.
void
kvminithart()
{
  w_satp(MAKE_SATP(kernel_pagetable));
  sfence_vma();
}
```
**③用户地址空间**
>**概述**：**每个进程**都有自己**独立的地址空间**，主要有**数据段**、**代码段**、**堆栈段**、**trapframe段**和**trampoline段**
{%list%}
trapframe段用于保存所有用户寄存器数据
{%endlist%}
{%right%}
栈段只有一页大小，其下同样有个保护页guard page，栈溢出时会因为映射无效产生一个页错误异常
{%endright%}
{%warning%}
每个进程地址空间最大可增长到`MAXVA`，即为`256GB`
{%endwarning%}
>**空间分配**：每当一个**新进程被创建**时，如`fork()/userinit()`，都会调用`allocproc()`分配用户地址空间
{%list%}
该函数遍历进程列表，找到状态为UNUSED的进程，为进程分配资源，如proc_pagetable()创建页表
{%endlist%}
```c
// Look in the process table for an UNUSED proc.
// If found, initialize state required to run in the kernel,
// and return with p->lock held.
// If there are no free procs, or a memory allocation fails, return 0.
static struct proc*
allocproc(void)
{
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state == UNUSED) {
      goto found;
    } else {
      release(&p->lock);
    }
  }
  return 0;

found:
  p->pid = allocpid();
  p->state = USED;

  // Allocate a trapframe page.
  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  // An empty user page table.
  p->pagetable = proc_pagetable(p);
  if(p->pagetable == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  // Set up new context to start executing at forkret,
  // which returns to user space.
  memset(&p->context, 0, sizeof(p->context));
  p->context.ra = (uint64)forkret;
  p->context.sp = p->kstack + PGSIZE;

  return p;
}
```
>`proc_pagetable()`：调用`uvmcreate()`创建**空页表**，随后调用`mappages()`进行映射
```c
// Create a user page table for a given process,
// with no user memory, but with trampoline pages.
pagetable_t
proc_pagetable(struct proc *p)
{
  pagetable_t pagetable;

  // An empty page table.
  pagetable = uvmcreate();
  if(pagetable == 0)
    return 0;

  // map the trampoline code (for system call return)
  // at the highest user virtual address.
  // only the supervisor uses it, on the way
  // to/from user space, so not PTE_U.
  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
              (uint64)trampoline, PTE_R | PTE_X) < 0){
    uvmfree(pagetable, 0);
    return 0;
  }

  // map the trapframe just below TRAMPOLINE, for trampoline.S.
  if(mappages(pagetable, TRAPFRAME, PGSIZE,
              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
  }

  return pagetable;
}
```
### 2.具体实现
#### 2.1系统调用提速
**①进程内存分配修改**
>**概述**：修改`proc`结构体，添加`usyscall`结构，随后修改`allocproc()`进行对应结构的**内存分配**
{%list%}
proc结构体定义在kernel/proc.h中，allocproc()定义在kernel/proc.c中
{%endlist%}
{%wrong%}
注意分配struct usyscall必须在创建页表之前完成
{%endwrong%}
```c
// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  struct usyscall *usyspage;   // 添加的对应usyscall结构
  char name[16];               // Process name (debugging)
};
```
```c
// Look in the process table for an UNUSED proc.
// If found, initialize state required to run in the kernel,
// and return with p->lock held.
// If there are no free procs, or a memory allocation fails, return 0.
static struct proc*
allocproc(void)
{
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state == UNUSED) {
      goto found;
    } else {
      release(&p->lock);
    }
  }
  return 0;

found:
  p->pid = allocpid();
  p->state = USED;

  // Allocate a trapframe page.
  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  //给进程分配struct usyscall，并初始化该结构
  if((p->usyspage = (struct usyscall*)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  p->usyspage->pid = p->pid;

  // An empty user page table.
  p->pagetable = proc_pagetable(p);
  if(p->pagetable == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }
  
  // Set up new context to start executing at forkret,
  // which returns to user space.
  memset(&p->context, 0, sizeof(p->context));
  p->context.ra = (uint64)forkret;
  p->context.sp = p->kstack + PGSIZE;

  return p;
}
```
**②添加映射**
>**概述**：修改`proc_pagetable()`，将分配的`struct usyscall`映射到**用户地址空间**的`USYSCALL`位置
{%list%}
proc_pagetable()定义在kernel/proc.c中
{%endlist%}
```c
// Create a user page table for a given process, with no user memory,
// but with trampoline and trapframe pages.
pagetable_t
proc_pagetable(struct proc *p)
{
  pagetable_t pagetable;

  // An empty page table.
  pagetable = uvmcreate();
  if(pagetable == 0)
    return 0;

  // map the trampoline code (for system call return)
  // at the highest user virtual address.
  // only the supervisor uses it, on the way
  // to/from user space, so not PTE_U.
  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
              (uint64)trampoline, PTE_R | PTE_X) < 0){
    uvmfree(pagetable, 0);
    return 0;
  }

  // map the trapframe page just below the trampoline page, for
  // trampoline.S.
  if(mappages(pagetable, TRAPFRAME, PGSIZE,
              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
  }
  //添加usyspage的映射
  if(mappages(pagetable,USYSCALL,PGSIZE,
              (uint64)(p->usyspage), PTE_R | PTE_U) < 0){
    uvmunmap(pagetable, USYSCALL, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
              }

  return pagetable;
}
```
**③释放进程空间**
>**概述**：在`freeproc()`中添加释放`usyspage`的代码，在`proc_freepagetable()`添加**释放映射**的代码
{%list%}
freeproc()和proc_freepagetable()均定义在kernel/proc.c中
{%endlist%}
```c
// free a proc structure and the data hanging from it,
// including user pages.
// p->lock must be held.
static void
freeproc(struct proc *p)
{
  if(p->trapframe)
    kfree((void*)p->trapframe);
  p->trapframe = 0;
  if(p->pagetable)
    proc_freepagetable(p->pagetable, p->sz);
  //释放usyspage
  if(p->usyspage)
    kfree((void*)p->usyspage);
  p->usyspage = 0;
  p->pagetable = 0;
  p->sz = 0;
  p->pid = 0;
  p->parent = 0;
  p->name[0] = 0;
  p->chan = 0;
  p->killed = 0;
  p->xstate = 0;
  p->state = UNUSED;
}
```
```c
// Free a process's page table, and free the
// physical memory it refers to.
void
proc_freepagetable(pagetable_t pagetable, uint64 sz)
{
  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
  uvmunmap(pagetable, TRAPFRAME, 1, 0);
  uvmunmap(pagetable, USYSCALL, 1, 0);
  uvmfree(pagetable, sz);
}
```
#### 2.2页表打印
**①核心功能函数**
>**概述**：**遍历页表项**检查其`PTE`是否**有效**，是则打印该项，如果其有**下级页表**，则**递归调用该函数**打印其页表项
{%list%}
PTE的V位为高位则该页表项有效，PTE的R、W和X位为低位则说明其指向下级页表
{%endlist%}
```c
// Recursively free page-table pages.
// All leaf mappings must already have been removed.
void
freewalk(pagetable_t pagetable)
{
  // there are 2^9 = 512 PTEs in a page table.
  for(int i = 0; i < 512; i++){
    pte_t pte = pagetable[i];
    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
      // this PTE points to a lower-level page table.
      uint64 child = PTE2PA(pte);
      freewalk((pagetable_t)child);
      pagetable[i] = 0;
    } else if(pte & PTE_V){
      panic("freewalk: leaf");
    }
  }
  kfree((void*)pagetable);
}

void pagetable_print(pagetable_t pagetable,int depth){
  for(int i = 0;i < 512;++i){
    pte_t pte = pagetable[i];
    if(pte & PTE_V){
      for(int j = 0;j < depth;j++){
        printf(" ..");
      }
      printf("%d: pte %p pa %p\n", i, pte, PTE2PA(pte));

      //如果其下还有低级页表，则通过递归打印出来
      if((pte & (PTE_R|PTE_W|PTE_X)) == 0){
        // start with new child PTE addr
        pagetable_t child = (pagetable_t)PTE2PA(pte);
        pagetable_print(child, depth + 1);
      }
    }
  }
}

void vmprint(pagetable_t pagetable) {
  printf("page table %p\n", pagetable);
  pagetable_print(pagetable, 1);
}
```
**②其他设置**
>**概述**：在`defs.h`中添加`vmprint()`的声明，并在`kernel/exec.c`的`exec()`函数中插入对应代码
{%list%}
插入位置为return argc;前
{%endlist%}
```c
// vm.c
void            kvminit(void);
void            kvminithart(void);
void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
int             mappages(pagetable_t, uint64, uint64, uint64, int);
pagetable_t     uvmcreate(void);
void            uvminit(pagetable_t, uchar *, uint);
uint64          uvmalloc(pagetable_t, uint64, uint64);
uint64          uvmdealloc(pagetable_t, uint64, uint64);
int             uvmcopy(pagetable_t, pagetable_t, uint64);
void            uvmfree(pagetable_t, uint64);
void            uvmunmap(pagetable_t, uint64, uint64, int);
void            uvmclear(pagetable_t, uint64);
uint64          walkaddr(pagetable_t, uint64);
int             copyout(pagetable_t, uint64, char *, uint64);
int             copyin(pagetable_t, char *, uint64, uint64);
int             copyinstr(pagetable_t, char *, uint64, uint64);
void            vmprint(pagetable_t pagetable);
```
```c
if(p->pid==1) vmprint(p->pagetable);

return argc; // this ends up in a0, the first argument to main(argc, argv)
```

#### 2.3内存访问查询
**①添加定义**
>**概述**：在`kernel/riscv.h`下添加`PTE_A`定义
```c
#define PTE_V (1L << 0) // valid
#define PTE_R (1L << 1)
#define PTE_W (1L << 2)
#define PTE_X (1L << 3)
#define PTE_U (1L << 4) // user can access
#define PTE_A (1L << 6) 
```
**②系统调用实现**
>**概述**：添加系统调用的**大部分步骤**Lab已帮忙处理好，只需在`kernel/sysproc.c`下实现`sys_pgaccess()`即可
{%list%}
该函数接收参数分别为内存页地址、需要查询的内存页数量以及一个用户空间地址，用于返回结果
{%endlist%}
```c
#ifdef LAB_PGTBL
int
sys_pgaccess(void)
{
  // lab pgtbl: your code here.
  uint64 va;
  int page_nums;
  uint64 out_addr;

  //获取对应参数
  argaddr(0,&va);
  argint(1,&page_nums);
  argaddr(2,&out_addr);

  //检查参数是否合理
  if(page_nums < 0 || page_nums > 64){
    return -1;
  }

  //创建bitmask，并读取该进程的proc结构
  uint64 bitmask = 0;
  pte_t *pte;
  struct proc *p = myproc();

  for(int i = 0;i < page_nums;++i){
    //检查是否越界
    if(va >= MAXVA){
      return -1;
    }
    //获取pte
    pte = walk(p->pagetable,va,0);
    if(!pte)
    return -1;

    //检查pte
    //如果符合要求，设置对应bitmask位并清除对应标志
    if(*pte & PTE_A){
      bitmask |= (1<<i);
      *pte ^= PTE_A;
    }

    va += PGSIZE;
  }
  
  //传递bitmask到用户空间
  if(copyout(p->pagetable, out_addr, (char *)&bitmask, sizeof(bitmask)) < 0){
    return -1;
  }
  return 0;
}
#endif
```
**③其他步骤**
>**概述**：在`kernel/defs.h`中添加`walk()`函数的声明
```c
// vm.c
void            kvminit(void);
void            kvminithart(void);
void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
int             mappages(pagetable_t, uint64, uint64, uint64, int);
pagetable_t     uvmcreate(void);
void            uvmfirst(pagetable_t, uchar *, uint);
uint64          uvmalloc(pagetable_t, uint64, uint64, int);
uint64          uvmdealloc(pagetable_t, uint64, uint64);
int             uvmcopy(pagetable_t, pagetable_t, uint64);
void            uvmfree(pagetable_t, uint64);
void            uvmunmap(pagetable_t, uint64, uint64, int);
void            uvmclear(pagetable_t, uint64);
pte_t *         walk(pagetable_t, uint64, int);
uint64          walkaddr(pagetable_t, uint64);
int             copyout(pagetable_t, uint64, char *, uint64);
int             copyin(pagetable_t, char *, uint64, uint64);
int             copyinstr(pagetable_t, char *, uint64, uint64);
void            vmprint(pagetable_t pagetable);
pte_t*          walk(pagetable_t pagetable, uint64 va, int alloc);
```
---
title: 操作系统（二）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机基础
  - 操作系统
  - 《操作系统导论》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/2.webp
date:
summary: 操作系统概述
---
# 操作系统（二）
## 操作系统概述
### 1.进程同步
#### 1.1信号量
{%list%}
进程之间需要合作，需要通过信号量来相互通信，从而合理推进进程
{%endlist%}
**①代码实现**
{%list%}
信号量是内核中的全局变量
{%endlist%}
```
struct sqmaphore
{
  int value; //记录资源个数
  PCB *queue; //记录等待在该信号量上的进程
}
//进程通过函数p申请使用资源，如果资源不足，则沉睡
p(sqmaphore s)
{
  s.value--;
  if(s.value < 0)
  {
    sleep(s.queue);
  }
}
//进程通过v生产资源，如果资源不足，则唤醒
v(sqmaphore s)
{
  s.value++;
  if(s.value <= 0)
  {
    wake(s.queue);
  }
}
```
**②实例**
>有两个**进程**，分别为**生产者**和**消费者**，**生产者**向缓存区**写入字符**，**消费者**从缓存区**读出字符**
{%list%}
不同的进程，对同一个信号量的使用是不相同的，对于生产者，只有缓存区有空位才能工作，对于消费者只有缓存区有数据才能工作
{%endlist%}
{%right%}
其中mutex为互斥信号量，防止生产者和消费者同时对缓存区进行操作
{%endright%}
```
//定义缓存区
int buffer [BUFFER_SIZE];

//定义信号量
sqmaphore full = 0;
sqmaphore empty = BUFFER_SIZE;
sqmaphore mutex = 1;
```
```
//生产者程序
Producer(*item,in)
{
  P(empty);
  p(mutex); //互斥信号量

  将item写入到in对应位置;

  v(mutex);
  v(full);  
}
```
```
//消费者程序
Consumer(*item,out)
{
  P(full);
  p(mutex); //互斥信号量

  将out对应位置数据读出;

  v(mutex);
  v(empty);  
}
```
#### 1.2临界区
**①引言**
{%warning%}
信号量由多个进程共用，但是进程调度可能导致一个进程还没有修改好信号量，就切到另一个相关进程
{%endwarning%}
{%right%}
当一个进程修改但没有修改完信号量时，禁止其他进程修改信号量，即将信号量操作放入临界区中
{%endright%}
```
P1.register = empty;
P1.register = P1.register - 1;
//发生进程调度，切到P2进程
P2.register = empty;
P2.register = P2.register - 1;
////发生进程调度，切到P1进程
empty = P1.register
```
**②基本原则**
>**互斥进入**：只有**一个进程**可以访问

>**有空让进**：当临界区**空闲**时，尽快使得**一个进程**进入

>**优先等待**：进程从**发出进入请求**到**允许进入**的时间不能过长
```
剩余区

进入区
临界区
退出区

剩余区
```
**③实现**
>**面包店算法**：当进程**想进入临界区**，会获得一个**序号**，**序号最小**的可以**进入临界区**，**退出时**序号变为`0`
{%list%}
过于复杂，效率较低
{%endlist%}
>**阻止调度**：进入临界区时，**禁止中断（`cli()`）**，直到**退出临界区才允许中断（`sti()`）**
{%list%}
只适用于单CPU，因为cli和sti只能禁止当前CPU的中断，其他CPU可能还会进入临界区
{%endlist%}
>**硬件原子指令**：**临界区**和**互斥信号量**使用非常相似，只要将**互斥信号量的修改**变为**原子操作**即可，即**锁信号量**
```
boolean TestAndSet(boolean &x)
{
  boolean rv = x;
  x = true;
  return rv;
}

剩余区
while(TestAndSet(&lock));
临界区
lock = false;
剩余区
```
#### 1.3死锁
**①概述**
{%warning%}
多个进程互相等待对方持有资源时，谁都无法执行，这就是死锁
{%endwarning%}
>如下，**生产者**使得`mutex`从`1`变为`0`，倘若其在`p(empty)`处**阻塞**，进程**切换到消费者**，**消费者直接阻塞**，无法清空缓冲区，从而导致**生产者和消费者一起一直阻塞**
```
//生产者程序
Producer(*item,in)
{
  P(mutex);
  p(empty); 

  将item写入到in对应位置;

  v(mutex);
  v(full);  
}
```
```
//消费者程序
Consumer(*item,out)
{
  P(mutex);
  p(full); 

  将out对应位置数据读出;

  v(mutex);
  v(empty);  
}
```
**②出现条件**
>**互斥使用**：资源只能被**一个进程占有**

>**不可抢占**：只有对应进程**自动放弃对应资源**，才能被**其他进程**使用

>**请求和保持**：进程需要**先占用一个资源**，然后根据这个资源**申请下一个资源**

>**循环等待**：资源分配中出现**一个环路**

**③处理方法**
>**预防**：检测每个**资源请求**，如果**造成死锁就自动拒绝**
{%list%}
银行家算法：根据每个进程占有的资源、需要的资源和当前空余的资源决定进程执行序列
{%endlist%}
>**恢复**：**死锁出现时**，使一些进程**回滚**，**让出资源**

>**忽略**：**忽略死锁**，在**运行一会就关机**的机器上常用

### 2.内存管理
#### 2.1重定位
**①引言**
>**逻辑地址**：**用户程序中直接给出**的地址，如`call 40`中的`40`
**物理地址**：**存储单元的编号**，是**真实且唯一**的
{%list%}
需要通过逻辑地址找到对应的物理地址，即重定位
{%endlist%}
**②重定位时机**
>**编译时**：程序只能放在**内存固定位置**

>**载入时**:程序一旦**载入内存就不能动了**

>**运行时**：**动态**记录**逻辑地址**和**物理地址**的关系
{%right%}
一般采用运行时重定位，因为进程在内存中位置是动态变化的，只有卫星等一烧录就不改变的采用编译时重定位
{%endright%}
#### 2.2内存分割
**①程序分段**
>程序由**多个段**组成，**每个段**有各自的**特点和用途**
{%list%}
程序段只读，数据段可写，栈段向下增长等
{%endlist%}
**②内存分区**
>将程序**各个段**放入**内存分区**中，**分区大小根据段大小调整**
{%list%}
程序内的逻辑地址由段号和段内偏移组成，每个段号和某块内存区域相对应（记录在进程的LDT表中）
{%endlist%}
{%warning%}
因为不可能每次一个程序段的大小刚好和空闲区域大小相当，内存分区会产生内存碎片，导致内存使用率低
{%endwarning%}
>不能**整理内存**将**内存碎片合并**，因为**得不偿失**

![内存分区](/image/OS_2.png)
**③内存分页**
>将**程序**分为多个**固定大小的部分**，并将**内存**分为多个**固定大小的页**
{%list%}
每个进程也有一个固定的页表，其中记录了两者的对应关系，即用页地址取代段地址
{%endlist%}
{%right%}
内存分页能减少内存的浪费，顶多浪费1页
{%endright%}
{%warning%}
为了减少内存的浪费，页的大小尽量得小，但是会造成页表过大
{%endwarning%}
>**页表**需要**连续记录整个内存**，这样**便于查找（O(1)）**，**不连续记录**则需要使用**查找算法**，得不偿失

**④多级页表和快表**
>**多级页表**：类似于**多级目录**
{%right%}
多级页表可以只连续记录使用了那段内存空间，不用记录整个内存空间，可以有效减少页表大小
{%endright%}
{%warning%}
但是多级页表增加了访问的次数，速度会慢一些
{%endwarning%}
>**快表（`TLB`）**：一个**寄存器**，存放**经常使用的页**，可以有效**减少访问时间**
{%right%}
快表可以通过硬件设置，直接找到对应的页，速度非常快，且由于程序内存访问具有局部性，TLB命中率高
{%endright%}
![多级页表](/image/OS_3.png)
**⑤段页结合**
{%list%}
程序员希望使用段，物理内存希望使用页，为了同时满足上层和硬件，将段页结合使用
{%endlist%}
>如`call 300`，`300`为**逻辑地址**，根据**LDT表**找到对应**虚拟地址**`00045300`，再根据**页表**找到对应**物理地址**`0007300`

![段页结合](/image/OS_4.png)

#### 2.3内存交换
{%right%}
换入换出可以实现大内存，假设虚拟内存有4G，但是实际物理内存只有1G，将访问的部分映射到物理内存即可
{%endright%}
**①内存换入**
>当**MMU**无法根据**用户请求的虚拟地址**找到对应**物理地址**，产生**缺页中断**，调用对应**中断处理程序**，申请**空闲页**，将**磁盘数据读入**，做好**映射关系**，随后**继续执行**

**②内存换出**
>选择**一页**换出到**磁盘**
{%list%}
内存换出类似于进程调度，但是内存换出的频率更高，颗粒度更小
{%endlist%}
>**clock算法**：**每一页**都有一个**标志位**，**每次访问**一个页时，**硬件自动设置该位**，为`1`置`0`，并**继续扫描**，为`0`**淘汰**该页
{%list%}
为LUR算法粗略实现，即淘汰最近最少使用的页，因为LUR的精细实现代价太大，得不偿失
{%endlist%}
{%right%}
如果缺页情况很少，到最后很可能大部分页标志位为1，退化为FIFO，所以需要再来一个更快的扫描指针定时清除R位
{%endright%}

### 3.文件系统
#### 3.1文件树
{%list%}
对于用户来说，文件的位置就是它的路径，对于操作系统来说就是区块号，需要将两者相互转换
{%endlist%}
**①磁盘分区**
>**引导区**：存放**引导程序**

>**超级块**：记录磁盘**整体信息**，如**各个区的起始位置**

>**I节点位图**：记录**Inode指针区**的**统计信息**，如有哪些**空闲空间**

>**盘块位图**：记录**数据区**的**统计信息**，如有哪些**空闲空间**
{%list%}
inode为linux中记录文件信息（如区块号）的结构
{%endlist%}
![磁盘分区](/image/OS_5.png)
**②路径到inode**
>如`/home/my`，首先从**Inode指针区第一个位置**找到**根目录**的`inode`指针，从而找到**根目录**的`inode`**结构**

>**根目录**的`inode`**结构**中存放了**各个目录项**的**名字字符串**与其在**Inode指针区的位置**

>**匹配名字字符串**即可找到`home`**目录**的`inode`**结构**，类似的**一层一层寻找下去**

**③inode到区块号**
>**每个文件**对应的**inode结构**中有一个**索引表**，记录了文件**各个部分对应的区块号**

#### 3.2磁盘定位
**①原理**
>**柱面（C）**：描述是**磁头相对磁盘位置**

>**磁头（H）**：描述是使用**哪一个磁头读**

>**扇区（S）**：磁盘的**访问单位**，长度为**512字节**
{%list%}
磁头移动到对应磁道，旋转磁盘找到对应的扇区，即根据CHS定位磁盘
{%endlist%}
{%right%}
为了提高计算机读取磁盘的效率，增大读写单位（每次读写扇区的个数），本质上是用空间换时间
{%endright%}
![磁盘](/image/OS_6.png)
**②区块号到CHS**
>由**磁盘驱动程序**将**区块号**转化为**CHS**
{%list%}
为了提升磁盘读写的效率（读取一个区块时，经量少切换磁头），区块在磁盘上是连续且有直接计算关系的：Block = CxHxS+HxS+S
{%endlist%}
![区块到CHS](/image/OS_7.png)

#### 3.3磁盘调度
{%list%}
当多个区块需要被访问时，一时间只有一个能被访问
{%endlist%}
**①磁盘访问时间**
>由**写入控制器时间**、**寻道时间**、**旋转时间**和**传输时间**组成
{%list%}
其中主要部分是寻道时间和旋转时间，即找到对应扇区的时间
{%endlist%}
**②调度算法**
>**电梯算法**：选择**区块号和当前磁头位置距离最小**的区块申请
{%list%}
单向选择，只有当一个方向的区块全部选择完，再反方向申请
{%endlist%}

### 4.设备驱动
#### 4.1引言
**①概述**
>计算机**使用外设的本质**就是**修改外设控制卡的寄存器**，外设工作完毕后，通过**中断**向计算机**传递信息**

**②文件视图**
>**设备**在**操作系统中**视为一种**特殊的文件**，也是通过类似于`open()`，`read()`等**文件操作函数**操作







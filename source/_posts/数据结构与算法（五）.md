---
title: 数据结构与算法（五）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 数据结构与算法
  - 计算机基础
  - 《hello 算法》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/10.webp
date:
summary: 堆
---
### 5.堆
**2.1定义**：特殊的**队列**，取出元素的顺序是按照元素的**优先级**（关键字）
>用**数组**表示的**完全二叉树**
任意节点的优先级是**其子树所有节点**的最大/小值，即**根节点到任意节点路径**是**有序**的
**2.2结构代码**
```
typedef struct HeapStruct *MaxHeap
struct HeapStruct
{
  ElementType *Elements; /*存储堆的数组
  int Size; /*堆的当前元素个数
  int Capacity; /*最大容量
};
```
**2.3操作集（最大堆）**
**①创建堆**
```
MaxHeap Create(int MaxSize)
{
  MaxHeap H = malloc(sizeof(struct HeapStruct));
  H->Elements = malloc((MaxSize+1)*sizeof(ElementType));
  H->Size = 0;
  H->Capacity = MaxSize;
  /*定义哨兵，便于查找
  H->Elements[0] = MaxData;
  return H;
}
```
>其中定义了**哨兵**
**②堆的插入**
```
void Insert(MaxHeap H,ElementType item)
{
  int i;
  if(IsFull(H))
  {
    printf("最大堆已满")；
    return;
  }
  i = ++H->Size;
  /*保证最大堆特性的比较
  for( ;H->Elements[i/2] < item; i/=2)
    H->Elements[i] = H->Elements[i/2];
  H->Elements[i] = item;
}
```
>为了保证最大堆的特性，需要保证**新插入节点要比父节点小**，所以如果他比父节点要大，就**交换**其和父节点位置，直到其小于对应的父节点
在这个过程中，哨兵的存在可以防止其到0的位置（超出堆的范围，因为堆的下标不能是0）
**③堆的删除**
```
ElementType DeleteMax(MaxHeap H)
{
  /*从堆中取出最大元素，并删除一个节点
  int Parent,Child;
  ElementType MaxItem,temp;
  if(IsEmpty(H))
  {
    printf("最大堆已为空")；
    return;
  }
  /*取出根节点最大值
  MaxItem = H->Elements[1];
  /*用最大堆中最后一个元素从根节点开始向上过滤下层节点
  temp = H->Elements[H->Size--]; /先取出末尾元素，然后Size减1
  for(Parent = 1;Parent*2 <= H->Size; Parent = Child) 
  {
    Child = Parent * 2；
    if((Child!=H->Size)&&(H->Elements[Child] < H->ElementType[Child+1]))
      Child++; /*找到其左儿子和右儿子的较大者并指向它
    if(temp>= H->Element[Child])
    break; /*找到对应插入位置了，即比其儿子节点都大
    else
      H->Elements[Parent] = H->Elements[Child]; /*移动到下一层，将较大的儿子移上去
  }
  H->Elements[Parent] = H->Elements[Child];
  return MaxItem;
}
```
>总体思想：将最后一个位置的节点**内存**删除，将其值**先插入到根节点**中（因为根节点的值已经被取出），然后慢慢向下迭代，交换位置
`Parent*2 <= H->Size`的作用是判断该父节点有没有左儿子，如果没有左儿子就更加没有右儿子
`Child!=H->Size`的作用是判断其有没有右儿子，因为如果左儿子刚好是堆的边界，则没有右儿子
**④堆的建立**
>总体思想：先将各个元素按照**输入顺序**存入，形成**完全二叉树**，利用**分而治之**的思想，将整个堆分为**根节点和左子堆和右子堆**，以此类推，最后分到最后就是父节点和左右儿子节点的比较

### 3.哈夫曼树
**3.1定义**：最优二叉树，即每个**叶子结点**到根节点的带权路径长度之和最小
**3.2构造**
**①总体思想**：将所有节点按照大小排序（可以用堆的方法），每次把权值最小的两棵二叉树合并，比如说1、2、3、4、5，合并一次变为3（1、2）、3、4、5，然后变为6（3（1、2）、3）、4、5，以此类推
**②代码实现**
![哈夫曼树的构造](/image/sjjg_14.png)
**3.3哈夫曼编码**:为了使得出现频率高的字符编码短些，出现频率低的字符编码长些，可以将哈夫曼树的节点路径看作为1和0，左节点为0，右节点为1，**编码长度就是路径长度**，按照字符出现频率构造哈夫曼树即可
![哈夫曼编码](/image/sjjg_13.png)

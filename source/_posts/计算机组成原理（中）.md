---
title: 计算机组成原理（中）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机组成原理
  - 《计算机组成原理》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/39.webp
date:
summary: 输入输出
---
# 计算机组成原理（中）
## 计算机组成原理基础
### 1.I/O系统
#### 1.1组成
**①软件部分**
>**I/O指令**：**CPU指令集**的一部分，格式为`操作码:命令码:设备码`
{%list%}
操作码指明该指令是I/O指令，命令码指明操作，设备码指定I/O设备或者其端口的地址
{%endlist%}

>**通道指令**：**通道自身**的指令，用于控制**通道的工作**
{%list%}
通道是一种小型的DMA处理机，实现I/O设备和主机直接进行信息传输
{%endlist%}
**②硬件部分**
>**I/O设备**：由**设备控制器**和**其他部分**组成

>**接口**：**I/O设备**通过**设备控制器**和**接口**相连，从而和**主机总线**连接
{%list%}
如果设备使用通道，设备通过设备控制器和子通道连接
{%endlist%}

**③接口组成**
>**设备选择电路**：**一个接口**可能连接**多个设备**，**一个设备**也有**多个端口**，需要通过**设备地址/端口号**进行选择
{%list%}
I/O设备可能被看作内存的一部分进行统一编址，也可能单独设置一个地址空间，后者需要专门的I/O指令
{%endlist%}
>**数据缓冲寄存器**：用于作为**数据缓冲区**，平衡**处理器**和**外设**之间的**速度差异**

>**命令寄存器和译码器**：用于**存储**以及**解释I/O指令**

>**状态标记**：用于告知**控制逻辑电路**外设和处理器状态，如是否**准备完成**，是否**空闲**、是否**允许中断**等

>**控制逻辑电路**：接口中的**控制单元**
{%list%}
除此之外，接口还需要协调外设和处理器，如进行数据串—并格式转换，并记录数据传输信息，如
{%endlist%}
![接口组成](/image/JZ_12.png)

**④程序查询方式**
{%list%}
一种CPU和外设通信的方式，其余还有程序中断方式和DMA方式
{%endlist%}
>**CPU**发出**I/O指令**后，根据**设备优先级**依次检查设备，若该设备**准备好**，则进行**对应操作**，否则一直**轮询**
{%warning%}
I/O处理过程中，CPU一直被占用，效率很低
{%endwarning%}

#### 1.2程序中断方式
**①工作原理**
>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，向CPU发送**中断信号**，CPU执行完**当前指令**后，如果**可以处理该中断**，转去执行**中断处理程序**
{%list%}
CPU可能会屏蔽中断，以及由于设备是有优先级的，对应中断也有优先级，低优先级中断无法打断高优先级中断
{%endlist%}
{%right%}
CPU如果想要响应外部中断，则需要开启允许中断触发器，每条指令结束时查询是否有中断请求
{%endright%}
**②中断服务程序**
>**保存现场**：保存**中断时的返回地址**，并保存**CPU各个寄存器内容**
{%list%}
前者通过硬件完成，也称为中断隐指令，后者通过压栈完成
{%endlist%}
>**中断服务**：根据**I/O指令**做出**对应操作**

>**恢复现场**：跳转到**返回地址**，并恢复**寄存器内容**

**③单重/多重中断**
>**单重中断**：**不允许**中断**现行的中断服务程序**
{%list%}
执行中断服务程序之前关中断，直到恢复现场后才开中断
{%endlist%}

>**多重中断**：**允许级别更高的中断源**中断**现行的中断服务程序**
{%list%}
保护现场之后就开中断
{%endlist%}
#### 1.3DMA方式
**①工作原理**

>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，**DMA控制器**发出**DMA请求**，占用**总线**和**内存**，进行**I/O设备**和**内存**的**数据交换**
{%list%}
MA方式中，主存和I/O设备之间有一条直接的数据通道，不需要通过CPU寄存器进行数据交互
{%endlist%}
{%right%}
DMA工作期间，CPU虽然不能使用总线以及访问内存，但是可以进行其他工作，如执行缓存中的指令
{%endright%}

**②占用方式**
>**直接占用**：当**发出DMA请求**时，使得CPU**放弃总线和主存控制权**，直到**DMA**工作**全部完成**
{%warning%}
若DMA工作时间过长，会影响CPU工作，因为CPU还要去主存取出指令和数据
{%endwarning%}
>**交替访问**：CPU**工作周期**中，有**一段时间**专门提供给**DMA**
{%warning%}
不够灵活
{%endwarning%}
>**周期挪用**：当**发出DMA请求**时，若CPU**正在访问**主存，则**DMA等待**，若**CPU没有访问主存**，DMA挪**用一个或者固定几个存取周期**，两者**同时请求**，**DMA优先**
{%right%}
DMA分批次传送数据，若数据没有被传输完，则再发送DMA请求，直到数据传输完成
{%endright%}

**③传送过程**
>**预处理**：将一定的**控制信息**存入**DMA接口的寄存器**中，随后**启动设备**
{%list%}
控制信息主要有传输方向、设备地址、主存地址和传送字数
{%endlist%}
>**数据传送**：**CPU**继续**执行主程序**，由**DMA**完成**数据输送**，**传输完成**后，向CPU发出**中断请求**告知
{%list%}
每次传输完数据后，还需要修改控制信息，以便于下一次的传输
{%endlist%}

>**后处理**：执行**中断服务程序**，以**检查**这次传输过程**是否出现错误**

**④DMA接口分类**
{%list%}
同样，一个DMA接口可能连接多个设备，有请求线和响应线，连接方式类似于总线的链式请求和独立请求
{%endlist%}
{%right%}
设备的传输速度越快，优先级较高
{%endright%}
>**选择型**：各个寄存器**只有一套**，只能给**一个设备**使用，直到**数据全部传输结束**，才**释放接口**

>**多路型**：各个寄存器有**多套**，每一套也称为**子通道**，每次有一个**新的设备的I/O请求**，就给其**分配一个空闲子通道**，供其进行**为数据传输进行准备**
{%list%}
两者都只能是一个设备传输数据，但是多路型可以在多个设备间交替传输，即使一个设备的任务还没有完成
{%endlist%}
### 2.数字
#### 2.1表示形式
无符号数：没有符号位，只有数值位
源码表示法
有符号数：机器数的最高位为符号位，0表示正数，1表示负数，0的符号位可能是1也可能是0
小数点约定在特定位置，如符号位的后面或者数值位的后面
原码表示法：带符号的绝对值表示
整数01101 11101
+0.1101 -0.1101
小数0.1101 1.1101这里的0和1分别表示符号位
正数和负数的加法实际上是两个正数的减法，如果使用原码作加法运算，还需要区分加减
找到一个与负数等价的正数代替负数，将减法变为加法
补码
时钟的顺时针和逆时针调整，6点调整3点，可以顺时针调整9格（+9），也可以逆时针调整3格（-3）+9为-3以12为模的补数，一个负数加上模为其补数
减一个数字相当于加上它的补数
正数的补码是他本身
负数的补码为其加上2^n，n为数值位+1，符号位不变，数值位每位取反并加1，补码变源码同样
受到长度限制
1.0001的补码是1.1111
0的原码有不同形式，补码形式是相同的
1.0000
0.0000
0.0000

反码
正数的反码为原码
负数的反码为符号位不变，数值位每位取反
0的反码是不同的 0.0000 1.1111
 
对于8位的数字补码可以表示-128-127（11111111-01111111） 源码和反码只能表示-127-127（11111111-01111111）

y连同符号位，每位取反，获得-y补码

移码：无论正数还是负数，都加上2^n-1，即符号位加一，x的绝对值小于2^n-1
移码和补码就是符号位相反
只有整数形式的定义
补码表示很难判断两个数的大小
如+21的补码为0,10101 -21的补码为1,10101，直接判断会判断后者大于前者

定点表示
小数点只能放在特定位置，一种是放在符号位后面，表示其只能表示小数
一种是放在数值位后面，则都是整数
定点表示需要手动调节小数点位置，且数值表示范围较小
浮点表示 
N=Sxr^j S为尾数 r为尾数的基值（通常取2） j为阶码
尾数规定为可正可负的定点小数，其中数值最高位是1，如果尾数的基值为4，则尾数的最高两位不能同时为0，以此类推
j规定为定点整数
数符：阶符:阶码：尾数
最小负数 最大负数 最小正数 最大正数
当处于最大负数和最小正数之间，当作0处理，其余则发生上溢错误
尾数的基值不同，浮点数规格化不同，
通过同时调整尾数和阶码，使得真值不发生变化
浮点表示的数字，其补码反码等，各个部位按照定点数的规则进行变化

浮点数尾数是0，则其为机器0
等于小于它所能表示的最小值，按照机器0处理
阶码=-16（假设阶码为16位）
移码全0
IEEE754标准

---
title: 计算机组成原理（中）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机组成原理
  - 《计算机组成原理》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/39.webp
date:
summary: 输入输出
---
# 计算机组成原理（中）
## 计算机组成原理基础
### 1.I/O系统
#### 1.1组成
**①软件部分**
>**I/O指令**：**CPU指令集**的一部分，格式为`操作码:命令码:设备码`
{%list%}
操作码指明该指令是I/O指令，命令码指明操作，设备码指定I/O设备或者其端口的地址
{%endlist%}

>**通道指令**：**通道自身**的指令，用于控制**通道的工作**
{%list%}
通道是一种小型的DMA处理机，实现I/O设备和主机直接进行信息传输
{%endlist%}
**②硬件部分**
>**I/O设备**：由**设备控制器**和**其他部分**组成

>**接口**：**I/O设备**通过**设备控制器**和**接口**相连，从而和**主机总线**连接
{%list%}
如果设备使用通道，设备通过设备控制器和子通道连接
{%endlist%}

**③接口组成**
>**设备选择电路**：**一个接口**可能连接**多个设备**，**一个设备**也有**多个端口**，需要通过**设备地址/端口号**进行选择
{%list%}
I/O设备可能被看作内存的一部分进行统一编址，也可能单独设置一个地址空间，后者需要专门的I/O指令
{%endlist%}
>**数据缓冲寄存器**：用于作为**数据缓冲区**，平衡**处理器**和**外设**之间的**速度差异**

>**命令寄存器和译码器**：用于**存储**以及**解释I/O指令**

>**状态标记**：用于告知**控制逻辑电路**外设和处理器状态，如是否**准备完成**，是否**空闲**、是否**允许中断**等

>**控制逻辑电路**：接口中的**控制单元**
{%list%}
除此之外，接口还需要协调外设和处理器，如进行数据串—并格式转换，并记录数据传输信息，如
{%endlist%}
![接口组成](/image/JZ_12.png)

**④程序查询方式**
{%list%}
一种CPU和外设通信的方式，其余还有程序中断方式和DMA方式
{%endlist%}
>**CPU**发出**I/O指令**后，根据**设备优先级**依次检查设备，若该设备**准备好**，则进行**对应操作**，否则一直**轮询**
{%warning%}
I/O处理过程中，CPU一直被占用，效率很低
{%endwarning%}

#### 1.2程序中断方式
**①工作原理**
>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，向CPU发送**中断信号**，CPU执行完**当前指令**后，如果**可以处理该中断**，转去执行**中断处理程序**
{%list%}
CPU可能会屏蔽中断，以及由于设备是有优先级的，对应中断也有优先级，低优先级中断无法打断高优先级中断
{%endlist%}
{%right%}
CPU如果想要响应外部中断，则需要开启允许中断触发器，每条指令结束时查询是否有中断请求
{%endright%}
**②中断服务程序**
>**保存现场**：保存**中断时的返回地址**，并保存**CPU各个寄存器内容**
{%list%}
前者通过硬件完成，也称为中断隐指令，后者通过压栈完成
{%endlist%}
>**中断服务**：根据**I/O指令**做出**对应操作**

>**恢复现场**：跳转到**返回地址**，并恢复**寄存器内容**

**③单重/多重中断**
>**单重中断**：**不允许**中断**现行的中断服务程序**
{%list%}
执行中断服务程序之前关中断，直到恢复现场后才开中断
{%endlist%}

>**多重中断**：**允许级别更高的中断源**中断**现行的中断服务程序**
{%list%}
保护现场之后就开中断
{%endlist%}
#### 1.3DMA方式
**①工作原理**

>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，**DMA控制器**发出**DMA请求**，占用**总线**和**内存**，进行**I/O设备**和**内存**的**数据交换**
{%list%}
MA方式中，主存和I/O设备之间有一条直接的数据通道，不需要通过CPU寄存器进行数据交互
{%endlist%}
{%right%}
DMA工作期间，CPU虽然不能使用总线以及访问内存，但是可以进行其他工作，如执行缓存中的指令
{%endright%}

**②占用方式**
>**直接占用**：当**发出DMA请求**时，使得CPU**放弃总线和主存控制权**，直到**DMA**工作**全部完成**
{%warning%}
若DMA工作时间过长，会影响CPU工作，因为CPU还要去主存取出指令和数据
{%endwarning%}
>**交替访问**：CPU**工作周期**中，有**一段时间**专门提供给**DMA**
{%warning%}
不够灵活
{%endwarning%}
>**周期挪用**：当**发出DMA请求**时，若CPU**正在访问**主存，则**DMA等待**，若**CPU没有访问主存**，DMA挪**用一个或者固定几个存取周期**，两者**同时请求**，**DMA优先**
{%right%}
DMA分批次传送数据，若数据没有被传输完，则再发送DMA请求，直到数据传输完成
{%endright%}

**③传送过程**
>**预处理**：将一定的**控制信息**存入**DMA接口的寄存器**中，随后**启动设备**
{%list%}
控制信息主要有传输方向、设备地址、主存地址和传送字数
{%endlist%}
>**数据传送**：**CPU**继续**执行主程序**，由**DMA**完成**数据输送**，**传输完成**后，向CPU发出**中断请求**告知
{%list%}
每次传输完数据后，还需要修改控制信息，以便于下一次的传输
{%endlist%}

>**后处理**：执行**中断服务程序**，以**检查**这次传输过程**是否出现错误**

**④DMA接口分类**
{%list%}
同样，一个DMA接口可能连接多个设备，有请求线和响应线，连接方式类似于总线的链式请求和独立请求
{%endlist%}
{%right%}
设备的传输速度越快，优先级较高
{%endright%}
>**选择型**：各个寄存器**只有一套**，只能给**一个设备**使用，直到**数据全部传输结束**，才**释放接口**

>**多路型**：各个寄存器有**多套**，每一套也称为**子通道**，每次有一个**新的设备的I/O请求**，就给其**分配一个空闲子通道**，供其进行**为数据传输进行准备**
{%list%}
两者都只能是一个设备传输数据，但是多路型可以在多个设备间交替传输，即使一个设备的任务还没有完成
{%endlist%}
### 2.计算机数字
#### 2.1表示形式
**①引言**
>称**真实世界**的数字为**真值**，如`+0.1101111B`，**存储在机器中**的**01序列**为**机器数**，如`01101111B`
{%list%}
数字中的小数点规定在特定位置，并不显示出现在机器数中
{%endlist%}
{%right%}
本质上就是用有限个数值表示对应范围，机器数的位数越多，范围/精度越大
{%endright%}
>**进制**：**计算机**采用**二进制**保存数据，同时辅以**其他进制**，如**八进制**、**十进制**、**十六进制**等
{%list%}
两个稳定态的物理实现简单，且二进制便于计算以及逻辑运算
{%endlist%}
{%right%}
同样的信息，二进制表示较长，可以将其转化为八进制以及十六进制减少其长度
{%endright%}
**②有符号/无符号数**
>**有符号数**：**最高位**为**符号位**，**其余位**用于**表示数值大小**，即`符号位:数值位`，**范围**为`-2^n-1`至`2^(n-1)-1`
{%list%}
符号位为0表示正，符号位为1表示负
{%endlist%}
>**无符号数**：**所有位**都用于**表示数值**，**范围**为`0`至`2^n-1`
{%warning%}
同一二进制序列，被解释为有符号数和无符号数差别是很大的
{%endwarning%}
>若**有符号负数**被解释为**无符号数**，相当于**真值加**`2^n`，若若**无符号数**被解释为**有符号数**，相当于**真值减**`2^n`

**③定点/浮点数**
>**定点数**：**小数点**规定在**特定位置**，常见的有在**符号位后**或者在**数值位后**
{%list%}
小数点在符号位后，则只能表示整数，小数点在数值位后，则只能表示绝对值小于等于1的小数
{%endlist%}
{%warning%}
机器数位相同的情况下，定点数能表示的范围太小
{%endwarning%}
>**浮点数**：根据`IEEE 754`标准，**机器位**分为`数符位:阶码位J:尾数位S`，**数值大小**为`Sx2^J`
{%list%}
阶码位为定点整数，尾数位为定点小数，浮点数的表示范围为最小负数—最大负数和最小正数—最大正数
{%endlist%}
>当**阶码**为`0`，**尾数**为`0`时，浮点数表示`+/-0`，当**阶码**为**全一**，**尾数**为`0`时，表示`+/-∞`
{%right%}
为了充分利用数值位，规定尾数形式为1.xxx，其中小数点前的1省略不写，在计算时自动加上即可
{%endright%}
{%warning%}
当输入数据是一个不可表示数时，转化为最邻近的可表示数
{%endwarning%}


**④编码方案**
{%list%}
主要讨论8位有符号定点数，假设小数点在数值位后，浮点数将其中各个部分按照定点数规则变换即可
{%endlist%}
>**原码**：**符号位**表示其**正负**，**数值位**表示**其绝对值**，如`01101111B`为`+1101111B`
{%warning%}
使用原码进行加减运算，无法统一，不利于硬件实现，如一个正数加上一个负数，还需要考虑符号位转化为减法
{%endwarning%}
{%list%}
使用原码表示浮点数尾数
{%endlist%}

>**补码**：对于**正数**，补码为其**原码**，对于**负数**，保持原码**符号位不变**，**数值位依次取反随后加1**，`y`的**补码**连同**符号位**，每位取反，即可获得`-y`的**补码**
{%list%}
补数：一个数加上模数即为补数，加一个数的补数减去模数，相当于减去该数，此处模数位2^n
{%endlist%}
>如将时钟**6点**调整到**3点**，可以**顺时针拨动9格**，也可以**逆时针拨动3格**
{%right%}
计算机会自动帮机器数减去模数，所以使用补码可以很简单的统一正负数的加减法，用补码表示有符号整数
{%endright%}
{%warning%}
使用补码无法通过机器直接判断两个数的大小
{%endwarning%}
>如`+21`的**补码**为`00010101` `-21`的**补码**为`10010101`，判断大小会判断**后者大于前者**

>**移码**：无论是**正数还是负数**，移码为**补码**的**符号位取反**
{%list%}
移码的就是给其加上2^n-1，只有整数形式的定义
{%endlist%}
{%right%}
移码便于比较大小，常用于表示浮点数阶码
{%endright%}
>**反码**：对于**正数**，反码为**原码**，对于**负数**保持原码**符号位不变**，**数值位依次取反**

**⑤机器零**
>可分为`+0`和`-0`，两者**补码**和**移码**相同，**源码**和**反码**不同
{%list%}
所以8位机器数的补码表示范围为-128-127，源码和反码只能表示-127-127
{%endlist%}
>对于**浮点数**，当其**尾数**为`0`、**阶码为最小负值**或者处于**最大负数**和**最小正数**之间，都可**判断**其为`0`

#### 2.2定点运算
**①移位运算**
>**概述**：**数据位**相对于**小数点**进行**左/右移**，**绝对值**进行**扩大/缩小**，对于**二进制**，移动**一位**，数值变化**2倍**
{%list%}
移位运算可分为算数移位和逻辑移位，前者面对有符号数，后者面对无符号数
{%endlist%}
{%right%}
移位操作还可以将移出部分记录到寄存器中
{%endright%}
{%warning%}
注意移位操作移动的是数值位，不会影响符号位
{%endwarning%}
>**算数移位**：对于**正数**，**任何情况**都填`0`，对于**负数**，**原码**填`0`，**反码**填`1`，**补码左移**填`0`，**右移**填`1`
{%warning%}
移动时，右移丢1会导致精度丢失，可能向上或者向下进位，左移丢1可能会导致结果错误，实际上就是溢出
{%endwarning%}
>**逻辑移位**：**所有的位**都会参加移位，**左移右移**均填`0`
{%right%}
通常采用对无符号数进行逻辑移位，移植性更强
{%endright%}
**②加减法运算**
>**概述**：通过**补码**进行**运算**，`A+B`的**补码**等于`A`的**补码**加上`B`的**补码**，`A-B`的**补码**等于`A`的**补码**加上`-B`的**补码**
{%list%}
符号位一起相加，符号位产生的进位自然丢掉
{%endlist%}
{%right%}
将正负数的加减法都统一为补码的加法
{%endright%}
{%warning%}
进行加减操作时，需要考虑结果是否超出存储单元长度，即发生了溢出
{%endwarning%}
>**溢出**：当参加操作的两个数**符号相同**，其**结果符号**与**原操作数符号不同**，则发生**溢出**
{%list%}
因为只有两个正数/负数相加才可能发生溢出
{%endlist%}
{%right%}
若数值位最高位发生的进位与符号位产生的进位结果不相同（异或结果为1），则发生了溢出
{%endright%}
**③乘法运算**
>**概述**：将**乘数数值位拆分**为多个**乘法因子**相加，**与乘法因子相乘**相当于进行**移位操作**，最后将**各个结果相加**即可
{%list%}
结果的符号位有乘数和被乘数的符号位异或得到
{%endlist%}
{%right%}
第i个乘法因子即第i位为原值，其余位为0，如11拆为10+01
{%endright%}
{%warning%}
被乘数和乘数的位应该相同，结果保存到长度为其两倍的寄存器中
{%endwarning%}
**④除法运算**
>**概述**：比较**被除数**和**除数**的**绝对值**，根据两者大小做出**不同的操作**，随后**除数右移**，循环操作

>若**被除数大于除数**，被除数**减少除数**，**末位**添`0`，**商**上`1`

>若**被除数大于除数**，被除数**不变**，**末位**添`0`，**商**上`1`
{%list%}
除法进行过程中，除数和被除数的长度不断增加，对于N位除法，需要使用2N位的加法器
{%endlist%}
>当**商的位数**等于其**存储器长度**时，**被除数减去除数**的值为**余数**
{%list%}
结果的符号位有除数和被除数的符号位异或得到
{%endlist%}
{%warning%}
对于小数除法，除数应该大于被除数，对于整数除法，除数应该小于被除数，否则会发生溢出
{%endwarning%}
{%wrong%}
除数不能为0
{%endwrong%}





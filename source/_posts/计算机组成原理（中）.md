---
title: 计算机组成原理（中）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机组成原理
  - 《计算机组成原理》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/39.webp
date:
summary: 输入输出
---
# 计算机组成原理（中）
## 计算机组成原理基础
### 1.I/O系统
#### 1.1组成
**①软件部分**
>**I/O指令**：**CPU指令集**的一部分，格式为`操作码:命令码:设备码`
{%list%}
操作码指明该指令是I/O指令，命令码指明操作，设备码指定I/O设备或者其端口的地址
{%endlist%}

>**通道指令**：**通道自身**的指令，用于控制**通道的工作**
{%list%}
通道是一种小型的DMA处理机，实现I/O设备和主机直接进行信息传输
{%endlist%}
**②硬件部分**
>**I/O设备**：由**设备控制器**和**其他部分**组成

>**接口**：**I/O设备**通过**设备控制器**和**接口**相连，从而和**主机总线**连接
{%list%}
如果设备使用通道，设备通过设备控制器和子通道连接
{%endlist%}

**③接口组成**
>**设备选择电路**：**一个接口**可能连接**多个设备**，**一个设备**也有**多个端口**，需要通过**设备地址/端口号**进行选择
{%list%}
I/O设备可能被看作内存的一部分进行统一编址，也可能单独设置一个地址空间，后者需要专门的I/O指令
{%endlist%}
>**数据缓冲寄存器**：用于作为**数据缓冲区**，平衡**处理器**和**外设**之间的**速度差异**

>**命令寄存器和译码器**：用于**存储**以及**解释I/O指令**

>**状态标记**：用于告知**控制逻辑电路**外设和处理器状态，如是否**准备完成**，是否**空闲**、是否**允许中断**等

>**控制逻辑电路**：接口中的**控制单元**
{%list%}
除此之外，接口还需要协调外设和处理器，如进行数据串—并格式转换，并记录数据传输信息，如
{%endlist%}
![接口组成](/image/JZ_12.png)

**④程序查询方式**
{%list%}
一种CPU和外设通信的方式，其余还有程序中断方式和DMA方式
{%endlist%}
>**CPU**发出**I/O指令**后，根据**设备优先级**依次检查设备，若该设备**准备好**，则进行**对应操作**，否则一直**轮询**
{%warning%}
I/O处理过程中，CPU一直被占用，效率很低
{%endwarning%}

#### 1.2程序中断方式
**①工作原理**
>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，向CPU发送**中断信号**，CPU执行完**当前指令**后，如果**可以处理该中断**，转去执行**中断处理程序**
{%list%}
CPU可能会屏蔽中断，以及由于设备是有优先级的，对应中断也有优先级，低优先级中断无法打断高优先级中断
{%endlist%}
{%right%}
CPU如果想要响应外部中断，则需要开启允许中断触发器，每条指令结束时查询是否有中断请求
{%endright%}
**②中断服务程序**
>**保存现场**：保存**中断时的返回地址**，并保存**CPU各个寄存器内容**
{%list%}
前者通过硬件完成，也称为中断隐指令，后者通过压栈完成
{%endlist%}
>**中断服务**：根据**I/O指令**做出**对应操作**

>**恢复现场**：跳转到**返回地址**，并恢复**寄存器内容**

**③单重/多重中断**
>**单重中断**：**不允许**中断**现行的中断服务程序**
{%list%}
执行中断服务程序之前关中断，直到恢复现场后才开中断
{%endlist%}

>**多重中断**：**允许级别更高的中断源**中断**现行的中断服务程序**
{%list%}
保护现场之后就开中断
{%endlist%}
#### 1.3DMA方式
**①工作原理**

>CPU发出**I/O指令**后，**启动外设**后继续**执行主程序**，外设**开始准备**

>**I/O设备准备好后**，**DMA控制器**发出**DMA请求**，占用**总线**和**内存**，进行**I/O设备**和**内存**的**数据交换**
{%list%}
MA方式中，主存和I/O设备之间有一条直接的数据通道，不需要通过CPU寄存器进行数据交互
{%endlist%}
{%right%}
DMA工作期间，CPU虽然不能使用总线以及访问内存，但是可以进行其他工作，如执行缓存中的指令
{%endright%}

**②占用方式**
>**直接占用**：当**发出DMA请求**时，使得CPU**放弃总线和主存控制权**，直到**DMA**工作**全部完成**
{%warning%}
若DMA工作时间过长，会影响CPU工作，因为CPU还要去主存取出指令和数据
{%endwarning%}
>**交替访问**：CPU**工作周期**中，有**一段时间**专门提供给**DMA**
{%warning%}
不够灵活
{%endwarning%}
>**周期挪用**：当**发出DMA请求**时，若CPU**正在访问**主存，则**DMA等待**，若**CPU没有访问主存**，DMA挪**用一个或者固定几个存取周期**，两者**同时请求**，**DMA优先**
{%right%}
DMA分批次传送数据，若数据没有被传输完，则再发送DMA请求，直到数据传输完成
{%endright%}

**③传送过程**
>**预处理**：将一定的**控制信息**存入**DMA接口的寄存器**中，随后**启动设备**
{%list%}
控制信息主要有传输方向、设备地址、主存地址和传送字数
{%endlist%}
>**数据传送**：**CPU**继续**执行主程序**，由**DMA**完成**数据输送**，**传输完成**后，向CPU发出**中断请求**告知
{%list%}
每次传输完数据后，还需要修改控制信息，以便于下一次的传输
{%endlist%}

>**后处理**：执行**中断服务程序**，以**检查**这次传输过程**是否出现错误**

**④DMA接口分类**
{%list%}
同样，一个DMA接口可能连接多个设备，有请求线和响应线，连接方式类似于总线的链式请求和独立请求
{%endlist%}
{%right%}
设备的传输速度越快，优先级较高
{%endright%}
>**选择型**：各个寄存器**只有一套**，只能给**一个设备**使用，直到**数据全部传输结束**，才**释放接口**

>**多路型**：各个寄存器有**多套**，每一套也称为**子通道**，每次有一个**新的设备的I/O请求**，就给其**分配一个空闲子通道**，供其进行**为数据传输进行准备**
{%list%}
两者都只能是一个设备传输数据，但是多路型可以在多个设备间交替传输，即使一个设备的任务还没有完成
{%endlist%}
### 2.计算机数字
#### 2.1表示形式
**①引言**
>称**真实世界**的数字为**真值**，如`+0.1101111B`，**存储在机器中**的数字为**机器数**，如`01101111B`
{%list%}
数字中的小数点规定在特定位置，并不显示出现在机器数中
{%endlist%}
{%right%}
本质上就是用有限个数表示对应范围，机器数的位数越多，范围/精度越大
{%endright%}
**②有符号/无符号数**
>**无符号数**：机器数的**所有位**都用于**表示数值**

>**有符号数**：机器数的**最高位**为**符号位**，`0`表示**正**，`1`表示**负**，**其余位**用于**表示数值**，即`符号位:数值位`
{%list%}
0的符号位可以是1也可以是0
{%endlist%}

**③定点/浮点数**
>**定点数**：**小数点**规定在**特定位置**，常见的有在**符号位后**或者在**数值位后**
{%list%}
小数点在符号位后，则只能表示整数，小数点在数值位后，则只能表示绝对值小于等于1的小数
{%endlist%}
{%warning%}
机器数位相同的情况下，定点数能表示的范围太小
{%endwarning%}
>**浮点数**：**机器位**分为`数符位:阶符位R:阶码位J:尾数位S`，**数值大小**为`SxR^J`，常见的**阶符**为`2、4...`
{%list%}
阶码位为定点整数，尾数位为定点小数，为了充分利用机器数各个位，若阶符为2^i，尾数数值位的前i位不能都为0
{%endlist%}
{%right%}
通过同时调整尾数和阶码，使得真值不发生变化
{%endright%}
{%warning%}
浮点数的表示范围为最小负数——最大负数和最小正数——最大正数
{%endwarning%}
>处于**最大负数**和**最小正数**之间的数被视为`0`，**其余**超出范围则视为**溢出错误**

**④表示方法**
{%list%}
主要讨论有符号定点数，假设小数点在数值位后，浮点数将其中各个部分按照定点数规则变换即可
{%endlist%}
>**原码**：**符号位**表示其**正负**，**数值位**表示**其绝对值**，如`01101111B`为`+1101111B`
{%warning%}
正数和负数的加法实际上是一个减法，如果仅仅使用原码，还需要通过符号位辨别加减法
{%endwarning%}
>**补码**：对于**正数**，补码为其**原码**，对于**负数**，保持原码**符号位不变**，**数值位依次取反随后加1**，`y`的**补码**连同**符号位**，每位取反，即可获得`-y`的**补码**
{%list%}
补数：一个数加上模数即为补数，加一个数的补数减去模数，相当于减去该数
{%endlist%}
>如将时钟**6点**调整到**3点**，可以**顺时针拨动9格**，也可以**逆时针拨动3格**
{%right%}
计算机会自动帮机器数减去模数，所以使用补码可以很简单的统一正负数的加减法
{%endright%}
{%warning%}
使用补码很难判断两个数的大小
{%endwarning%}
>如`+21`的**补码**为`00010101` `-21`的**补码**为`10010101`，判断大小会判断**后者大于前者**

>**移码**：无论是**正数还是负数**，移码为**补码**的**符号位取反**
{%list%}
移码的就是给其加上模数，只有整数形式的定义
{%endlist%}
>**反码**：对于**正数**，反码为**原码**，对于**负数**保持原码**符号位不变**，**数值位依次取反**

**⑤机器零**
>可分为`+0`和`-0`，两者**补码**和**移码**相同，**源码**和**反码**不同
{%list%}
所以8位机器数的补码表示范围为-128-127，源码和反码只能表示-127-127
{%endlist%}
>对于**浮点数**，当其**尾数**为`0`、**阶码为最小负值**或者处于**最大负数**和**最小正数**之间，都可**判断**其为`0`






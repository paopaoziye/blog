---
title: MIT6.1810（二）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 手搓操作系统
---
# 项目实战
## MIT6.1810（一）
### 1.环境配置
#### 1.1工具链安装
{%list%}
以Ubuntu20.04.1为例
{%endlist%}
>在**命令行**输入**以下代码**
```shell
sudo apt-get update  //更新软件包来源
sudo apt-get upgrade //更新所有能更新的软件
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```
>`git`：**版本控制**工具，并且可以将**Lab文件夹**保存到**github**

>`build-essential`：编译`c/c++`所需要的**所有工具**的**软件包**，如`gdb`、`gcc`和`make`等

>`gdb-multiarch`：为`gdb`的**多架构版本**，支持**多种CPU架构**

>`qemu`：一个支持**跨平台虚拟化**的虚拟机，如在**x86架构**平台上虚拟出一个**ARM架构**平台

>`gcc-riscv64-linux-gnu`:是**基于GCC**的**跨平台编译工具**，可以在**某架构**如X86，平台上将**C/C++代码**编译成**RISC-V指令集**的**汇编码**、**机器码**，并做出相应的**程序分析**

>`binutils-riscv64-linux-gnu`：针对**RISC-V架构**的**GNU Binutils工具集**的特定变体

#### 1.2课程源码编译
>在**命令行**输入**以下代码**，`ctrl-a x`，即**先同时**按住`ctrl`和`a`,**随后**按下`x`即可**退出**
{%list%}
第一次需要输入以下三行代码，以后只需要在对应目录下输入make qemu即可
{%endlist%}
```shell
git clone git://g.csail.mit.edu/xv6-labs-2023
cd xv6-labs-2023
make qemu
```
### 2.XV6操作系统
#### 2.1引言
**①简介**
>**概述**：以**ANSI C**重新编写的**Unix第六版**，基于`Sv39 RISC-V`运行
{%list%}
RISC-V有三种CPU可以执行指令的模式，机器模式、用户模式和管理模式，特权级不同
{%endlist%}

**②启动概述**
>**通电**时，**初始化**自己并运行存储在**ROM**的**引导加载程序**,将**xv6内核**加载到**内存**中，随后执行`entry.s`
{%list%}
XV6内核起始位置为0x80000000，之前的内存用于存放I/O设备
{%endlist%}
>`entry.s`设置了一个**栈区**，这样xv6就可以**运行C代码**，即`start.c`

>`start.c`执行一些仅在**机器模式**下允许的配置，并开启**时钟中断**，随后切换到**管理模式**并跳转到`main.c`
{%right%}
start.c设置了一些寄存器，如将main函数的地址写入寄存器mepc，随后使用mret“返回”到main并进入管理模式
{%endright%}
>`main.c`先进行**初始化**，随后执行`userinit()`调用`initcode.s`，`initcode.s`通过`exec()`调用`init.c`启动`shell`

#### 2.2内存管理
**①页表**
>**概述**：**一级结构**的原理**如下图**所示，可见总共有`2^44`页，**每一页的大小**为`2^12`位
{%list%}
由硬件实现，实际上xv6采用的是三级结构，即27位的页表索引分为三个9位的页表索引，可以用于节省空间
{%endlist%}
>如果采用**一级结构**，需要`2^27`条**页表项**，而**三级结构**，只需要`3*2^9`条**页表项**
{%right%}
每个CPU都有一个satp寄存器指向根页表页的物理地址以及指向的页表转换后续指令生成的所有地址
{%endright%}
{%warning%}
易知虚拟地址大小为2^39位，而物理地址大小位2^56位，其中多余的物理地址用于存放I/O 设备和 DRAM 芯片
{%endwarning%}
>**标志位**：每个**页表项**都有其**标志位**，告诉**分页硬件**允许**如何使用**关联的虚拟地址
{%list%}
如是否存在和允许读写等，详细可查看riscv.h头文件
{%endlist%}

**②地址空间**
>**进程地址空间**：**每个进程**都有一个**单独的页表**，从**虚拟地址零**开始增长到**MAXVA（256G）**

>**内核地址空间**：可以将**内核**看作为一个**特殊的进程**，XV6有一个**单独描述内核地址空间**的页表
{%list%}
kernel/memlayout.h中声明了描述内核分布的常量，其中0x80000000:0x86400000为内核代码
{%endlist%}
{%right%}
XV6内核地址空间大部分采用的是直接映射，可以简化内核代码，省去虚拟地址的转化
{%endright%}
**③源码概述**
>`main()`调用`kvminit()`,`kvminit()`调用`kvmmake()`创建**内核页表**，此时**还没有分页**，使用**物理地址**

>
pagetable_t为指向根页表页的指针，可以是一个内核页表，也可以是一个进程页表

为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在 Translation Look-aside Buffer 
为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在 Translation Look-aside Buffer (TLB) 中。

RISC-V上的指针有64位宽；硬件在页表中查找虚拟地址时只使用低39位；xv6只使用这39位中的38位
每个进程有一个单独的页表，映射其地址空间，进程最大地址空间受到限制，MAXVA，kernel/riscv.h:348

xv6为trampoline（用于在用户和内核之间切换）和映射进程切换到内核的trapframe分别保留了一个页面，正如我们将在第4章中解释的那样。

proc结构保存了每个进程的状态，页表、内核栈区和运行状态

进程都有一个或者多个线程，用于执行进程的指令，线程的大部分状态保存在线程的栈中

每个进程有一个用户栈和内核栈，进程执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核（由于系统调用或中断）时，内核代码在进程的内核堆栈上执行；当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，只是不处于活动状态。进程的线程在主动使用它的用户栈和内核栈之间交替

RISC-V的ecall指令允许应用程序从指定点陷入内核，提升硬件特权级别，并将程序计数器（PC）更改为内核定义的入口点，入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈，并通过调用sret指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。进程的线程可以在内核中“阻塞”等待I/O，并在I/O完成后恢复到中断的位置。

用户和内核指令使用的是虚拟地址，RISC-V页表硬件通过将每个虚拟地址映射到物理地址来为这两种地址建立联系
### 3.操作系统接口
#### 3.1进程
**①创建**
>`int fork()`：创建一个**内存内容**与其**完全相同**的**子进程**，即**指令**、**数据**和**堆栈**
{%list%}
在父进程中，返回值为子进程的PID，在子进程中，返回值为0
{%endlist%}
{%right%}
创建的是进程，子进程被创建后不久就执行了，通常使用fork的返回值以及if语句区别父子进程
{%endright%}
{%warning%}
子进程运行时有自己独立的内存空间的，父子进程相互不影响
{%endwarning%}
**②销毁**
>`void exit(int status)`：**销毁**当前进程并**释放资源**，`status`表示进程**结束状态**
{%list%}
主动结束进程，当status为0时，表示正常结束，1表示发生错误并结束
{%endlist%}
{%right%}
主动结束进程并给出提示信息，即是正常结束还是非正常结束
{%endright%}
**③等待**
>`int wait(int *)`：进程**立刻阻塞**，若其有**子进程主动退出或者被杀死**，返回**子进程PID**，如果**没有子进程**，返回`-1`，反之则**一直等待**
{%list%}
传入参数为一返回地址，用于接受子进程退出状态，如果不关心该信息，传入一个0地址（int*）0
{%endlist%}
{%right%}
对于父子进程共享的信息，可以先让父进程wait，让子进程先访问
{%endright%}
**④调用**
>`void exec(char* filename，char* argv)`：在**进程内部**执行一个**可执行文件**
{%list%}
filename用于提供文件路径，对应文件必须有特定的格式，argv用于提供字符串参数数组，第一个参数为程序名
{%endlist%}

#### 3.2I/O操作
**①文件描述符**
>**概述**：本质上是一个**小整型**，一个**可以读写**的由**内核管理**的对象，将**文件**、**目录**和**设备**等抽象为**字节流**
{%list%}
各个进程的文件描述符是相互隔离的，每个进程都至少有一个标准输入0，标准输出1和标准错误2
{%endlist%}
**②读取与写入**
>`int read(int fd,char* buf,int n)`：从`fd`处**最多读取n字节**，并复**制到缓冲区**`buf`中，返回**读取的字节数**
{%list%}
每个文件描述符都会记录其字节流所在位置信息，且随着读写等操作向前/后推移
{%endlist%}
{%warning%}
读取字节数为0表示到达文件末尾
{%endwarning%}
>`write(fd，buf，n)`：将**缓冲区**`buf`中的**n个字节**写入`fd`处，返回**写入的字节数**
{%warning%}
若写入字节小于n，则表示发生了错误
{%endwarning%}
**③打开与关闭**
>`close(int fd)`：**释放**文件描述符，使其可以被**重新分配**

>`int open(char* filename,MACRO)`：为文件**分配文件描述符**，并指定**字节流特性**
{%list%}
新分配的文件描述符号，总是当前进程最小的
{%endlist%}
{%right%}
常用的宏有O_RDONLY只读、O_WRONLY	只写、O_RDWR可读可写
{%endright%}
>还有`O_CREAT`若文件**不存在**则**创建该文件**、`O_TRUNC`将文件**截断为零长度**

>`int dup(int fd)`:接受一个**文件描述符**，返回一个**新文件描述符**，**一同**指向**对应文件**
{%list%}
父进程和子进程，以及dup得到的文件描述符和原文件描述符的字节流位置偏移一开始是一样的
{%endlist%}
**④管道**
>**概述**：本质上是**一对文件描述符**，指向**全局的内核缓冲区**，用于在**两个进程**之间**传递数据**
{%right%}
两个文件描述符分别传递给两个进程，一个用于一个进程写数据，另一个用于另一个进程读书据
{%endright%}
>`void pipe(int* p)`：创建一个**管道**，`p`为一个**长度为2**的**文件描述符数组**，`pipe`会**在其中记录**管道所需的**读写文件描述符**
{%list%}
若一直没有写入数据，管道的读取操作会进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭
{%endlist%}
{%warning%}
及时关闭指向管道写入端的文件描述符，因为对于管道来说所有的写入端都被关闭才是结束，否则会一直等待
{%endwarning%}
>如下例，**子进程**必须在**调用wc之前**关闭**管道写入端的文件描述符**
{%right%}
对于cat|echo，shell对|的左端和右端，均调用fork和runcmd，并创建一个管道连接两者传递信息即可
{%endright%}
>还可通过**临时文件**在**进程间**传递信息，但管道会**自动清理自己**，且允许**两程序并行**，且管道的**阻塞式读写**更高效
```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
//创建管道所需要的文件描述符
pipe(p);
//创建子进程，这样父子进程都有指向同一个管道的文件描述符了
if (fork() == 0) {
    //子进程关闭标准读取，并将其指向管道的读取端
    close(0);
    dup(p[0]);
    //关闭所有指向管道的文件描述符
    close(p[0]);
    close(p[1]);
    //exec调用wc，wc从标准读取，也就是管道读取端读入数据
    exec("/bin/wc", argv);
} else {
    //关闭管道读取端
    close(p[0]);
    //将"hello world\n"写入管道
    write(p[1], "hello world\n", 12);
    //关闭管道写入端
    close(p[1]);
}
```
#### 3.3文件系统
**①引言**
>**绝对路径**：以`/`开头，从**根目录**开始**层层向下**寻找对应文件

>**相对路径**：不以`/`开头，相对于**调用进程的当前工作目录**进行计算

>**inode**：**文件**在操作系统中的**抽象**，保存了文件的**元数据**、**长度**、**磁盘位置**等**描述信息**
{%list%}
一个inode文件可以对应多个链接（名字）
{%endlist%}
**②修改路径**
>`void chdir(char* path)`：修改**当前工作目录**，可以传入**相对路径**也可以传入**绝对路径**

**③创建**
>`void mkdir(char* path)`：创建**目录**
{%list%}
可以通过open创建文件，fd = open("/dir/file", O_CREATE | O_WRONLY);
{%endlist%}
>`mknod(char* path,int device_number1,int device_number2)`：创建一个**设备文件**
{%list%}
后两个参数分别为设备的主设备号和次设备号，唯一地标识了一个内核设备
{%endlist%}
**④链接**
>`link(char* file1,char* file2)`：给**链接**`file1`创建一个**新的链接**`file2`，两者指向**同一个inode**文件
{%list%}
从file1读取或写入与从file2读取或写入是相同的操作
{%endlist%}

>`unlink(char* file1)`：从**文件系统**中删除一个**链接**
{%list%}
当文件的链接数为零且没有文件描述符引用时，文件的inode和包含其内容的磁盘空间会被释放
{%endlist%}
{%right%}
可以利用unlink创建临时文件
{%endright%}
```c
fd = open("/tmp/xyz", O_CREATE | O_RDWR);
unlink("/tmp/xyz");
```


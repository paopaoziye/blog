---
title: python学习笔记（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 编程语言
  - python
categories: 编程语言
keywords: 文章关键词
updated: ''
date:
img: /medias/featureimages/4.webp
summary: python启蒙
---
# python学习笔记（一）
## python启蒙
### 1.基本元素
#### 1.1对象
**①定义**
>即**被存储的数据**，如`1`、`"cat"`、`1.23456e2`等
{%list%}
类似于C语言中的字面值，当一个对象被声明后，会给其分配对应的地址和内存，且数据类型不能更改
{%endlist%}
**②基本数据类型**
>**整型**、**浮点型**、**字符串**、**布尔类型**、**复数类型**
{%list%}
可以使用type()检查数据类型
{%endlist%}
**③分类**
>**不可变类型**：对象**一旦创建**，内容就**不能被更改**，只能被**覆盖**，**基本数据类型**都是**不可变类型**

>**可变类型**：对象的**值可以被更改**，如**列表**、**集合**和**字典**等
{%right%}
在将可变数据类型传递给函数时，又不希望函数改变其值，可以在函数内部拷贝一份对应的值
{%endright%}
**④数据类型转换**
>**自动类型转换**：**不同类型**数据**混合运算**，**精度低**的类型将自动转化为**精度高**的类型**避免数据丢失**
{%list%}
自动转换类型功能有限，如整型不能自动转化为字符串类型，需要使用强制类型转换
{%endlist%}
>**强制类型转换**：使用`str()`、`int()`、`float()`将对象**强制转换**为**对应类型**
#### 1.2变量
**①定义**
>本质是**对象**的一个**引用**，**本身**也占用**一定的内存**，用于存储**对象的地址**，通过**赋值符**`=`为**变量**指定**对象**
{%list%}
python变量对应的内存是变化的，是上次赋值时新对象所在的内存，而C语言变量名所代表的地址是不变的
{%endlist%}
{%right%}
没有变量指向的对象会被回收，即python的垃圾回收机制
{%endright%}
{%warning%}
变量的本质是引用，如果两个变量指向是同一个可变类型对象，改变其中一个，另一个也随之改变
{%endwarning%}
![变量的本质](/image/python_7.png)
**②取名规则**
>只能是**一个词**，且只包含**字母、数字和下划线**，**不能以数字开头**
{%right%}
一个好的变量名包含了数据对应的信息，常见的命名格式有my_cat和MyCat
{%endright%}
{%warning%}
注意和关键词冲突
{%endwarning%}

#### 1.3操作符
**①数字操作符**
>**加**`+`、**减**`-`、**乘**`*`、**除**`/`、**取模**`%`、**整除**`//`、**指数**`**`
{%list%}
C的除法结果由其操作数类型决定，而python的除法结果由其操作符决定
{%endlist%}
{%right%}
+可以用于拼接字符串，比如'a'+'b'结果是'ab'，*可以用于字符串复制，比如'a'*5结果时'aaaaa'
{%endright%}
**②比较操作符**
>**等于**`==`、**不等于**`!=`、**小于**`<`、**大于**`>`、**小于等于**`<=`、**大于等于**`>=`
{%list%}
>、<、≥、≤只能用于整型和浮点型
{%endlist%}
{%warning%}
整型和浮点型之间是可以使用==正常比较的，但是整型、浮点型和字符串使用==只能得到False
{%endwarning%}
**③布尔操作符**
>**与**`and`、**或**`or`、**非**`not`
{%list%}
not优先级最高，随后是and，最后是or
{%endlist%}

#### 1.4格式
**①注释**
>**单行注释**：以`#`**开头**，以**换行符**结尾

>**多行注释**：用**三个单引号/双引号**包围

**②代码块**
>根据**缩进**划分**代码块**，**相同缩进**的**连续代码**为一**代码块**
{%list%}
代码块内部可以嵌套代码块，嵌套代码块的缩进更多
{%endlist%}
{%right%}
通常以四个空格为一个缩进，不要使用tab
{%endright%}
**③语句**
>**语句**使用**换行符**结尾，**语句关键词语句**使用**冒号**结尾

#### 1.5控制流
**①if条件语句**
```
if(expression): 
  statement
elif(expression):
  statement
else:
  statement
```
{%right%}
一旦一个语句的条件为Ture，后面的语句会被忽略，所以要注意语句的顺序，或者说清晰化条件的范围，使其之间没有交集
{%endright%}

**②while循环语句**
```
while(expression):
  statement
```
**③for循环语句**
```
for 控制变量 in range(): 
  statement
```
{%list%}
缺省情况下，控制变量被初始化为0
{%endlist%}
{%right%}
在Python中，下划线_通常用作一个无用的变量名称，常用做控制变量的名称
{%endright%}
**④range函数**
>`range(a)`：`0`至`a-1`，**步长为1**

>`range(a,b)`：`a`至`b-1`，**步长为1**

>`range(a,b,i)`：`a`至`b-1`,**步长为i**
{%list%}
可以将循环中的range()换为一个列表，在每次迭代中，让变量依次设置为列表中的值
{%endlist%}

**⑤循环控制语句**
>**break**：遇到`break`语句，马上**退出循环**
>**continue**：遇到`continue`语句，马上**跳回到循环开始处**

#### 1.6字符串
**①定义**
>以**单引号**、**双引号**、**三个单引号**或**三个双引号**开始和结束，是**不可变类型**
{%list%}
三重引号之间的所有引号、制表符或换行，都被认为是字符串的一部分
{%endlist%}
{%right%}
可以看作是单个文本字符的元组（空格也算）
{%endright%}
>`name = 'cat'`相当于`name = ('c','a','t')`

**②原始字符串**
>在字符串**开始的引号之前**加上`r`，**完全忽略**所有的**转义字符**，打印出字符串中**所有**的**倒斜杠**

**③print和input**
>**print()**：将括号内的**字符串**显示在**屏幕**上，输出**其他类型变量**时，需要使用`str()`将其**转换为字符串类型**
{%right%}
采用占位符语法灵活配置字符串
{%endright%}

>**input()**：等待用户**输入文本**，并按下**回车键**，将其转化为一个**字符串**

**④占位符语法**
>`print('%d + %d = %d' % (a, b, a + b))`：其中`%d`是**整数**的**占位符**，**字符串后`%`后面**跟的**变量值**会**替换掉占位符**
{%warning%}
带该种占位符的字符串中要表示百分号必须写成%%
{%endwarning%}

>`print('{0} * {1} = {2}'.format(a, b, a * b))`：其中`{0}`、`{1}`和`{2}`都是**占位符**，其中**数字**为**format方法**的**索引**，**占位符**最后会被**替换**为**对应的变量**
{%right%}
还可以利用语法糖简化写法，即print(f'{a} * {b} = {a * b}')
{%endright%}

### 2.函数
#### 2.1引言
**①格式**
>`None`是`NoneType`**数据类型**的**唯一值**，代表**没有值**，相当于**C语言**中的`void`
```
def 函数名(形参n):
  statement
  return expression #可以是变量，也可以是表达式

```
{%list%}
某些函数有可选的关键字参数，在函数调用时可以指定，相当于修改函数的默认设置
{%endlist%}
{%right%}
如果需要传递多个同一位置的关键字参数，可以采用 | 管道命令将这些参数连接
{%endright%}
**②可变参数**
>使用`args`**关键字**实现
{%right%}
函数的参数可以有默认值，也支持使用可变参数（类型、个数均可变），所以Python并不需要支持函数的重载
{%endright%}
```
# 在参数名前面的*表示args是一个可变参数
def add(*args):
    total = 0
    for val in args:
        total += val
    return total


# 在调用add函数时可以传入0个或多个参数
print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
print(add(1, 3, 5, 7, 9))
```
#### 2.2作用域
**①分类**
>**局部作用域**：在**被调用函数内赋值**的变量，局部作用域在**函数被调用**时创建，在**函数返回时**销毁
{%warning%}
如果在函数内没有对其进进行赋值，则为全局变量
{%endwarning%}
>**全局作用域**：在**所有函数之外**赋值的变量，属于**全局作用域**，全局作用域在**程序开始时**创建，在**程序终止时**销毁

>**嵌套作用域**：当一个**函数内部**有**另一个函数**时，**前者**的变量属于**后者**的**嵌套作用域**

>**内置作用域**：**Python内置**的那些**标识符**

**②联系**
>**内置作用域**→**全局作用域**→**嵌套作用域**→**局部作用域**，**从左往右**依次**内推**
{%list%}
内部的作用域可以访问外部作用域中的变量，但是外部作用域不能访问内部作用域的变量
{%endlist%}
{%warning%}
局部作用域不能访问其他局部作用域的变量
{%endwarning%}
{%right%}
如果在不同的作用域中，你可以用相同的名字命名不同的变量
{%endright%}
**③关键词修饰**
>`global`：**修饰变量**使其变为**全局变量**

>`nonlocal`：**修饰变量**使其变为**嵌套作用域变量**
{%warning%}
全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收
{%endwarning%}
#### 2.3模块
**①定义**
>模块类似于C++中的**命名空间**，可以**防止命名冲突**，同时也**封装了代码**

**②使用**
>**导入模块**：`import 模块名,模块名n`
{%list%}
import 模块 as 新名字可以对模块进行重命名
{%endlist%}
>**调用模块中函数/方法**：`模块名.函数名/方法名`

**③测试**
{%list%}
模块内部有一个测试函数，直接运行该模块文件即可运行测试函数
{%endlist%}
>`__name__`为python中的一个**内置变量**，当程序**直接被执行**时，其`__name__`的值为`'__main__'`，而**作为模块导入**时，其`__name__ `值为**自己的模块名**
```
def c2f(cel):
    fah = cel * 1.8 + 32
    return fah
def f2c(fah):
    cel = (fah - 32) / 1.8
    return cel
def test():
    print("测试数据：0 摄氏度 = %.2f 华氏度" % c2f(0))
    print("测试数据：0 华氏度 = %.2f 摄氏度" % f2c(0))
if __name__ == '__main__':
test()
```
#### 2.4异常处理
{%list%}
本质上是试图捕捉函数内部某些语句的错误
{%endlist%}
>**try语句**：将可**能出错的语句**放在`try`之后，当这些语句**出错**后，会立马**跳转到**`except`语句
```
try:
  statement
```
>**except语句**：后面常接一些**错误提醒**的`print`语句
```
except 错误名:
  print()
```
>**finally语句**：`finally`块的代码**不论程序正常还是异常**都会执行
{%list%}
该语句不是必须的，通常用于执行一些必要的清理操作，如关闭文件、释放资源、关闭数据库连接等
{%endlist%}

### 3.容器
#### 3.1列表
**①定义**
>`列表名 = [表项1,...,表项n]`
{%list%}
表项的数据类型可以不是一致的，也可以是列表，元素一致时，类似于C语言的数组
{%endlist%}
**②访问**
>`列表名[i]`：访问列表中**第`i-1`个表项**，当`i`前面有**负号**时，代表**倒数**第`i`个
{%list%}
不同于C语言，python中有对应的下标检查
{%endlist%}
{%right%}
当列表某个表项是列表时，如果想要访问其中元素，需要再次使用下标，即列表名[i][j]
{%endright%}
>`列表名[i:j:n]`：访问列表的**一部分**，**结果**还是**一个列表**，也称为**切片**，其中`[i:j:n]`表示**第i个下标**到**第j个下标**,**步长为n**
{%list%}
缺省i表示列表开始处，缺省j表示列表结束处，缺省n步长为1
{%endlist%}
{%right%}
当n为负数时，表示从第j个下标到第i个下标，即反向切片
{%endright%}
**③常用操作**
>`+`：**连接**两个列表，`spam1+spam2`

>`*`：**复制**列表，`spam*5`

>`del`：**删除**列表项，如`del spam[2]`
{%list%}
表中被删除值后面的所有值，都将向前移动一个下标
{%endlist%}

>`in`：**判断**元素**是否在列表中**，`if(var in spam)`

>**常用方法**：**查找**`index()`、**添加**`append()`、**插入**`insert()`、**删除**`remove()`、**排序**`sort()`

#### 3.2元组和集合
**①元组**
>**列表**的**不可变数据类型**版本，**创建时**时用**圆括号()**
{%right%}
元组在创建时间和占用的空间上面都优于列表
{%endright%}
{%warning%}
若元组中只有一个值，在该值的后面跟上一个逗号，否则就是一个值，而不是包含一个值的元组
{%endwarning%}
**②集合**
>`set1 = {1, 2, 3, 3, 3, 2}`，是**无序**的可变数据类型
{%list%}
不允许有重复元素，而且可以进行交集、并集、差集等运算
{%endlist%}
{%right%}
列表、元组和集合之间可以通过list()、tuple()和set()相互转化
{%endright%}

#### 3.3字典
**①定义**
>`字典名 = {键1:值1,...,键n:值n};`
{%list%}
通过键查询对应值，且键可以是任意数据类型，但是不能重复
{%endlist%}
{%right%}
字典是无序的，只要键值对完全相同，两个字典就是完全相同的
{%endright%}
**②基本操作**
>`字典名[键名]`：访问**键对应的值**

>`字典名[键名]=值`：**添加/修改**键值对

>`del 字典名[键名]`：**删除**键值对

>`键名 in 字典名`：判断键**是否存在**
{%list%}
字典中的get方法可以同时获得值并检测键是否存在
{%endlist%}
**③常用方法**
>`keys()`:返回`dict_keys`，类似**键的列表**

>`values()`：返回`dict_values`，类似**值的列表**

>`items()`：返回`dict_items`，类似**键-值对的列表**
{%list%}
为字典的方法
{%endlist%}
{%right%}
这些返回值不能改变，常用于for循环判定条件中如for v in spam.values()用于遍历字典
{%endright%}

>`get()`：它有**两个参数**，**第一个**参数为**键**，以及如果**该键不存在**时，返回的**第二个参数**

>`setdefault()`:为字典中**某个键设置一个默认值**
```
#计算一个字符串中每个字符出现的次数
message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
count = {}
#for循环语句，即将character依次设置为message列表中的值
for character in message:
  count.setdefault(character, 0)
  count[character] = count[character] + 1
print(count)
```



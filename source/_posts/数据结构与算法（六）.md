---
title: 数据结构与算法（五）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机基础
  - 数据结构与算法
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/10.webp
date:
summary: 排序算法
---
# 数据结构与算法（五）
## 排序算法
{%right%}
默认按照从小到大排序
{%endright%}
### 1.冒泡排序
**1.1思路**：从头比较相邻的两个元素，如果两个元素满足设定的大小关系，则不变，反之则调换位置，这样可以把最小/大的元素放在末尾，随机再对n-1个元素再次使用冒泡排序，总共重复n-1次
**1.2代码实现**
![冒泡排序](/image/sjjg_39.png)
>其中`flag`的作用就是判断是否已经排序好

### 2.插入排序
**2.1思路**：类似于打扑克理牌的过程，一开始我们手里有一张牌，即`A[0]`，随后从A[1]开始往手里加牌，和**手里的牌的最后一位**（即`A[P-1]`）开始向前比较，如果比新牌大，则交换新牌和他的位置，直到找到新牌的位置（即前一张牌小于新牌）
**2.2代码实现**
![插入排序](/image/sjjg_40.png)
>注意中间变量的作用

### 3.希尔排序（改进的插入排序）
**3.1逆序对**
![逆序对](/image/sjjg_41.png)
![改进思路](/image/sjjg_42.png)
**3.2思路**
![基本思路](/image/sjjg_43.png)
![不足](/image/sjjg_44.png)
![改进](/image/sjjg_45.png)

### 4.选择排序
**4.1思路**：首先找到全部元素中的最小元素，放在最前面，然后再找到剩余元素的最小元素，放在第二位，以此类推
**4.2代码实现**
![选择排序](/image/sjjg_46.png)

### 5.堆排序（改进的选择排序）
**5.1思路**：选择排序的瓶颈主要是如何**快速找到最小元**，所以可以采用最小堆来找到最小元素
**5.2代码实现**
![堆排序](/image/sjjg_47.png)
![改进的堆排序](/image/sjjg_48.png)
>改进的堆排序将数组调整为最大堆，然后将根节点和最后元素交换，然后将最大元素排除在外，重复以上步骤

### 6.归并排序
**6.1思路**：主要采用的是**分而治之**的思想，将整个序列一直二分，直到将其分为最小单元即只有两个单元，然后将其转化为有序子列并成为新的最小单元，以此类推，直到整个序列都被排序
>两个**有序子列**的合并：已知两个有序子列，以及一个足够容纳两个子列的空容器，首先比较两个子序列的第一个位置上的元素，选择较小的那个放进容器，然后被选择的子序列的位置向后挪一位，以此类推完成排序
![有序子列的归并](/image/sjjg_49.png)
![有序子列的归并代码实现](/image/sjjg_50.png)
**6.2代码实现**
**①递归实现**
![递归实现](/image/sjjg_51.png)
![统一接口](/image/sjjg_52.png)
![注意事项](/image/sjjg_53.png)
**②非递归实现**
![非递归实现](/image/sjjg_54.png)
![统一接口](/image/sjjg_55.png)

### 7.快速排序
{%right%}
小规模数据采用简单排序（如插入排序），大规模数据采用快速排序
{%endright%}
**7.1思路**：挑选一个主元，将序列分为大于该主元和小于该主元的两部分，然后在对这两部分实施上述类似的操作
>快速排序可以保证在划分子集后，主元所在位置都是它**最终的正确位置**

**7.2代码实现**
**①主元的选取**
![主元的选取](/image/sjjg_56.png)
>这样选取主元之后，`Right`和`Left`元素都不用考虑了

**②子集划分**：如下图，选取后的主元为6，考虑中间的元素（理由见上），最左端和最右端都有一个指针，当左端（右端）指针指向元素小于（大于）主元时，向右（左）移动指针，**反之则停下，当两边指针都停下时交换对应元素**，随后继续迭代，当左端指针大于右端时，交换主元和左端指针位置，完成子集划分
![子集划分——开始](/image/sjjg_57.png)
![子集划分——结束](/image/sjjg_58.png)
**③算法主体**
![快速排序](/image/sjjg_59.png)
### 8.基于表排序的物理排序
{%right%}
之前的算法都需要频繁地交换元素，对于元素较大的序列效率较差，可以先进行表排序，减少交换元素的次数
{%endright%}
**8.1表排序**：不直接排序元素本身，而是排序其指针（位置），需要一个新的数组存储**排序后的位置**
![表排序](/image/sjjg_60.png)
**8.2物理排序**：进行完表排序后，发现其排列组成了若干个独立的环，如下图所示，`table[0]`→`A[3]`→`table[3]`→`A[1]`→`table[1]`→`A[5]`→`table[5]`→`A[0]`→`table[0]`形成了一个独立的环，分别调整这些环，将环的一项拆除（将对应的数据存到临时变量中），并根据其`table[]`的值将对应数据放入其中，**并将其`table[i]`改为对应的`i`**，表示这个数据的位置是调整过的，直到空位`table[]`对应位置满足`table[i]==i`，表示环结束，将存在临时变量中的数据存到对应空位中。
![物理排序](/image/sjjg_61.png)
### 9.基数排序
**9.1桶排序**：建立一个**指针数组**，每个指针对应一个**链表**，每个链表代表一种情况，将符合该情况的数据插入该链表即可，排序完后依次从每个桶中提取数据即可
![桶排序](/image/sjjg_62.png)
**9.2基数排序**：实际上就是多次的桶排序，如下例，一个三位数如果将每一个数都看作为一种情况，则需要1000个桶，不划算，可以每次只看三位数的某一位，假设从个位数看到百位数，则只需要十个桶，看三次即可，第一次将个位数符合情况的插入到各个桶中，**根据第一次桶排序的顺序**，观察其十位数，插入到对应的桶中，以此类推，观察完所有特征即可
![基数排序](/image/sjjg_63.png)
**9.3多关键字排序**
**①主位优先**
![主位优先](/image/sjjg_64.png)
**②次位优先**
![次位优先](/image/sjjg_65.png)

>注意题中需要的顺序，如果主位优先中第二步也采用桶排序，则获得的顺序是13组，而不是4组，要注意如果只使用桶排序，**关键字的顺序**是非常重要的

### 10.小结
![小结](/image/sjjg_66.png)
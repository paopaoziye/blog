---
title: 数据结构与算法（四）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 数据结构与算法
  - 计算机基础
  - 《hello 算法》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/10.webp
date:
summary: 树形结构
---
# 数据结构与算法（四）
## 树形结构
### 1.二叉树
#### 1.1树
**①定义**
>每个树都有一个**根节点**，**其余节点**可分为**互不相交的子树**，且只有**一个父节点**和**若干个子节点**，**没有子节点**的节点称为**叶节点**
{%list%}
树明显是基于递归定义的，所以有关树的很多算法都用到了递归思想
{%endlist%}

**②儿子-兄弟表示法**
>**每个节点**存储**两个指针**，**左指针**指向**最左的儿子节点**，**右指针**指向**相邻兄弟节点**
{%right%}
所有的树都可以转化为二叉树，所以树的主要研究对象为二叉树
{%endright%}
![儿子-兄弟表示法](/image/SF_3.png)

#### 1.2二叉树
**①定义**
> 由**根节点**和同为**二叉树**的**左子树**和**右子树**组成，即**每个节点**最多只能有**两个子节点**，称为**左节点**和**右节点**

**②特殊二叉树**
>**完美二叉树**：当二叉树有**n层**时，有**2^n-1个节点**，**叶子节点**只能出现在**最下面一层**

>**完全二叉树**：对二叉树中节点**从上至下**，**从左往右**进行**编号**，**编号为i**的节点与**满二叉树**中**编号为i**的节点**位置相同**
{%list%}
即从某一叶节点缺失所有右边的兄弟节点，左边的兄弟节点不缺失
{%endlist%}
![特殊二叉树](/image/SF_4.png)

#### 1.3二叉树的存储结构
**①顺序存储结构**
>将二叉树转化为**广义的完全二叉树**，**从上至下**，**从左往右**进行**编号**，节点的**编号**就是其在**数组的索引**
{%list%}
不存在的节点表示为空
{%endlist%}
**②链表存储**
>**节点结构**分别有**指向左子节点的指针**和**指向右子节点的指针**，**整个二叉树**只需要知道其**根节点指针**即可

### 2.二叉树的遍历
#### 2.1先序遍历
**1.1定义与递归表示**
![先序遍历](/image/sjjg_4.png)
**1.2非递归实现**
```
void InOrderTraversal(BinTree BT)
{
  BinTree T = BT;
  Stack S = CreateStack(MaxSize); /*创建并初始化栈S
  while(T|| !IsEmpty(S))
  {
    /*一直向左并将沿途节点压入栈
    wihle(T)
    {
      printf("%5d",T->Data); /*第一次碰到该节点，打印节点
      Push(S,T);
      T = T->left
    }
    if(!IsEmpty(S))
    {
      T = Pop(S); /*将没有左节点的节点弹出
      T = T->Right; /*遍历其右子树
    }
  }
}
```
### 2.中序遍历
**2.1定义与递归表示**
![中序遍历](/image/sjjg_5.png)
**2.2非递归实现**
```
void InOrderTraversal(BinTree BT)
{
  BinTree T = BT;
  Stack S = CreateStack(MaxSize); /*创建并初始化栈S
  while(T|| !IsEmpty(S))
  {
    /*一直向左并将沿途节点压入栈
    wihle(T)
    {
      Push(S,T);
      T = T->left
    }
    if(!IsEmpty(S))
    {
      T = Pop(S); /*将没有左节点的节点弹出
      printf("%5d",T->Data); /*第二次碰到该节点，打印节点
      T = T->Right; /*遍历其右子树
    }
  }
}
```
### 3.后序遍历
**3.1定义与递归表示**
![后序遍历](/image/sjjg_6.png)

<font color=red >**3.2非递归实现**</font>

### 4.三种遍历的关系
**4.1本质**
![三种遍历的联系与区别](/image/sjjg_7.png)
>对于一个节点，有三次访问的时刻，即第一次访问（没有访问其子节点），从左子树返回访问和从右子树返回访问，三种遍历方式就是在第一、二、三次访问时输出

**4.2根据两中遍历结果推断树的结构**：先根据先序遍历/后续遍历判断出**根节点**，然后在根据根节点和中序遍历判断出**左子树**和**右子树**，再同上判断左右子树即可
>只有知道中序遍历和前/后序遍历才能推断出结果

### 5.层序遍历
![层序遍历](/image/sjjg_8.png)

## 三、特殊二叉树
### 1.二叉搜索树
**1.1定义**
>非空左子树的**所有键值**小于其根节点
非空右子树的**所有键值**大于其根节点
左右子树都是二叉搜索树
**1.2二叉搜索树的查找**
**①递归实现**
```
Position Find(ElementType x,BinTree BST)
{
  /*没找到，递归退出条件
  if(!Bst)
    return NULL;
  /*递归查找
  if(x>Bst->Data)
    return Find(x,BST->Right);
  else if(x<Bst->Data)
    return Find(x,BST->Left);
  /*成功找到，递归退出条件
  else
    return BST;
}
```
**②非递归实现**
```
Position Find(ElementType x,BinTree BST)
{
  while(BST)
  {
    if(x > BST->Data)
      BST = BST->Right;
    else if(x < BST->Data)
      BST = BST->Left;
    else
      return BST;
  }
  return NULL;
}
``` 
**1.3二叉搜索树的插入**
**①递归实现**
```
BinTree Insert(ElementType x,BinTree BST)
{
  /*递归退出条件，找到对应插入位置，即一个空位置
  if(!BST)
  {
    BST = malloc(sizeof(struct TreeNode));
    BST->Data = x;
    BST->Left = BST->Right =NULL;
  }
  else
  {
    if(x < BST->Data)
      BST->Left = Insert(x,BST->Left); 
    else if(x > BST->Data)
      BST->Right = Insert(x,BST->Right);
  }
  return BST;
}
```
**②非递归实现**
```
BinTree Insert(ElementType x,BinTree BST)
{
  while(BST)
  {
    if(x > BST->Data)
    {
      if(!BST->Right)
      {
      BST->Right = malloc(sizeof(struct TreeNode));
      BST->Right->Data = x;
      BST->Right->Right = BST->Right->Left = NULL;
      return BST->Right
      }
      else
      BST = BST->Right
    }
    else if(x < BST->Data)
    {
      if(!BST->Left)
      {
      BST->Left = malloc(sizeof(struct TreeNode));
      BST->Left->Data = x;
      BST->Left->Right = BST->Left->Left = NULL;
      return BST->Right
      }
      else
      BST = BST->Left;
    }
    else 
    return BST;
  }
  BST = malloc(sizeof(struct TreeNode));
  BST->Data = x;
  BST->Left = Bst->Right = NULL;
  return BST;
}
```
**1.4二叉搜索树的删除**
**①思路**：节点分为三类，即叶节点、有一个孩子的节点和有两个孩子的节点
>叶节点：直接删除即可
有一个孩子的节点：将孩子节点接到其父节点即可
有两个孩子的节点：将其**右子树最小元素**或者**左子树最大元素**代替之，可以转化为上述两种情况

**②代码实现**
```
BinTree Delete(ElementType x,BinTree BST)
{
  Position Tmp;
  if(!BST)
    print("未找到该元素")；
  else if(x < BST->Data)
    BST->Left = Delete(x,BST->Left);
  else if(x > BST->Data)
    BST->Right = Delete(x,BST->Right);
  else
    /*当有两个孩子
    if(BST->Left && BST->Right)
    {
      /*找到其右子树最小元素替代之
      Tmp = FindMin(BST->Right);
      BST->Data = Tmp->Data;
      /*删除其右子树最小元素
      BST->Right = Delete(BST->Data,BST->Right);
    }
    /*有一个或者没有孩子
    else
    {
      Tmp = BST
      if(!BST->Left)
        BST = BST->Right
      else if(!BST->Right)
        BST = BST->Left;
      free(Tmp)
    }
  return BST;
}
```
**1.5平衡二叉树**
**①定义**：空树或者**任意节点**左右子树**高度差**绝对值不超过1
>平衡二叉树的优点：给定节点数n的最大高度为O(log2n)

**②平衡二叉树的调整**：当插入节点时可能会破坏搜索二叉树的平衡性
![RR旋转](/image/sjjg_9.png)
![LL旋转](/image/sjjg_10.png)
![LR旋转](/image/sjjg_11.png)
![RL旋转](/image/sjjg_12.png)
>注意多余出来部分要根据二叉搜索树的定义调整

### 2.堆
**2.1定义**：特殊的**队列**，取出元素的顺序是按照元素的**优先级**（关键字）
>用**数组**表示的**完全二叉树**
任意节点的优先级是**其子树所有节点**的最大/小值，即**根节点到任意节点路径**是**有序**的
**2.2结构代码**
```
typedef struct HeapStruct *MaxHeap
struct HeapStruct
{
  ElementType *Elements; /*存储堆的数组
  int Size; /*堆的当前元素个数
  int Capacity; /*最大容量
};
```
**2.3操作集（最大堆）**
**①创建堆**
```
MaxHeap Create(int MaxSize)
{
  MaxHeap H = malloc(sizeof(struct HeapStruct));
  H->Elements = malloc((MaxSize+1)*sizeof(ElementType));
  H->Size = 0;
  H->Capacity = MaxSize;
  /*定义哨兵，便于查找
  H->Elements[0] = MaxData;
  return H;
}
```
>其中定义了**哨兵**
**②堆的插入**
```
void Insert(MaxHeap H,ElementType item)
{
  int i;
  if(IsFull(H))
  {
    printf("最大堆已满")；
    return;
  }
  i = ++H->Size;
  /*保证最大堆特性的比较
  for( ;H->Elements[i/2] < item; i/=2)
    H->Elements[i] = H->Elements[i/2];
  H->Elements[i] = item;
}
```
>为了保证最大堆的特性，需要保证**新插入节点要比父节点小**，所以如果他比父节点要大，就**交换**其和父节点位置，直到其小于对应的父节点
在这个过程中，哨兵的存在可以防止其到0的位置（超出堆的范围，因为堆的下标不能是0）
**③堆的删除**
```
ElementType DeleteMax(MaxHeap H)
{
  /*从堆中取出最大元素，并删除一个节点
  int Parent,Child;
  ElementType MaxItem,temp;
  if(IsEmpty(H))
  {
    printf("最大堆已为空")；
    return;
  }
  /*取出根节点最大值
  MaxItem = H->Elements[1];
  /*用最大堆中最后一个元素从根节点开始向上过滤下层节点
  temp = H->Elements[H->Size--]; /先取出末尾元素，然后Size减1
  for(Parent = 1;Parent*2 <= H->Size; Parent = Child) 
  {
    Child = Parent * 2；
    if((Child!=H->Size)&&(H->Elements[Child] < H->ElementType[Child+1]))
      Child++; /*找到其左儿子和右儿子的较大者并指向它
    if(temp>= H->Element[Child])
    break; /*找到对应插入位置了，即比其儿子节点都大
    else
      H->Elements[Parent] = H->Elements[Child]; /*移动到下一层，将较大的儿子移上去
  }
  H->Elements[Parent] = H->Elements[Child];
  return MaxItem;
}
```
>总体思想：将最后一个位置的节点**内存**删除，将其值**先插入到根节点**中（因为根节点的值已经被取出），然后慢慢向下迭代，交换位置
`Parent*2 <= H->Size`的作用是判断该父节点有没有左儿子，如果没有左儿子就更加没有右儿子
`Child!=H->Size`的作用是判断其有没有右儿子，因为如果左儿子刚好是堆的边界，则没有右儿子
**④堆的建立**
>总体思想：先将各个元素按照**输入顺序**存入，形成**完全二叉树**，利用**分而治之**的思想，将整个堆分为**根节点和左子堆和右子堆**，以此类推，最后分到最后就是父节点和左右儿子节点的比较

### 3.哈夫曼树
**3.1定义**：最优二叉树，即每个**叶子结点**到根节点的带权路径长度之和最小
**3.2构造**
**①总体思想**：将所有节点按照大小排序（可以用堆的方法），每次把权值最小的两棵二叉树合并，比如说1、2、3、4、5，合并一次变为3（1、2）、3、4、5，然后变为6（3（1、2）、3）、4、5，以此类推
**②代码实现**
![哈夫曼树的构造](/image/sjjg_14.png)
**3.3哈夫曼编码**:为了使得出现频率高的字符编码短些，出现频率低的字符编码长些，可以将哈夫曼树的节点路径看作为1和0，左节点为0，右节点为1，**编码长度就是路径长度**，按照字符出现频率构造哈夫曼树即可
![哈夫曼编码](/image/sjjg_13.png)


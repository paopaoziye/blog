---
title: 数据结构与算法（四）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 数据结构与算法
  - 计算机基础
  - 《hello 算法》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/10.webp
date:
summary: 树形结构
---
# 数据结构与算法（四）
## 树形结构
### 1.二叉树
#### 1.1树
**①定义**
>每个树都有一个**根节点**，**其余节点**可分为**互不相交的子树**，且只有**一个父节点**和**若干个子节点**，**没有子节点**的节点称为**叶节点**
{%list%}
树明显是基于递归定义的，所以有关树的很多算法都用到了递归思想
{%endlist%}

**②儿子兄弟表示法**
>**每个节点**存储**两个指针**，**左指针**指向**最左的儿子节点**，**右指针**指向**相邻兄弟节点**
{%right%}
所有的树都可以通过儿子兄弟表示法转化为二叉树，所以树的主要研究对象为二叉树
{%endright%}
![儿子-兄弟表示法](/image/SF_3.png)

#### 1.2二叉树
**①定义**
> 由**根节点**和同为**二叉树**的**左子树**和**右子树**组成，即**每个节点**最多只能有**两个子节点**，称为**左节点**和**右节点**

**②特殊二叉树**
>**完美二叉树**：当二叉树有**n层**时，有**2^n-1个节点**，**叶子节点**只能出现在**最下面一层**

>**完全二叉树**：对二叉树中节点**从上至下**，**从左往右**进行**编号**，**编号为i**的节点与**满二叉树**中**编号为i**的节点**位置相同**
{%list%}
完全二叉树即从某一叶节点缺失所有右边的兄弟节点，左边的兄弟节点不缺失的完美二叉树
{%endlist%}
![特殊二叉树](/image/SF_4.png)

#### 1.3二叉树的存储结构
**①链表**
{%list%}
二叉树通常使用链表存储
{%endlist%}
>**节点结构**分别有**指向左子节点的指针**和**指向右子节点的指针**，**整个二叉树**只需要知道其**根节点指针**即可
**②数组**
>将二叉树转化为**广义的完全二叉树**，**从上至下**，**从左往右**进行**编号**，节点的**编号**就是其在**数组的索引**
{%list%}
不存在的节点表示为空
{%endlist%}
{%right%}
若一节点为i，则其左子节点为2i+1，右子节点为2i+2，访问速度较快
{%endright%}
{%warning%}
数组需要连续内存空间，不适合存储数据量过大的树，且若二叉树和完全二叉树相差较大时，会造成巨大的空间浪费
{%endwarning%}
![二叉树的数组表示](/image/SF_7.png)

### 2.二叉树的遍历
#### 2.1层序遍历
**①定义**
>**向下逐层**遍历二叉树，**每一层**按照**从左到右**的顺序**访问节点**
{%list%}
层序遍历本质上是广度优先遍历，体现了一种“一圈一圈向外扩展”的逐层遍历方式
{%endlist%}
{%right%}
层序遍历的逐层推进和队列的先进先出本质上一样的
{%endright%}
![层序遍历](/image/SF_5.png)
**②非递归实现**
```
int *levelOrder(TreeNode *root, int *size) {
    /* 辅助队列 */
    int front, rear;
    int index, *arr;
    TreeNode *node;
    TreeNode **queue;

    /*动态申请队列，队列保存的是节点指针，所以最终表现形态为节点指针的指针*/
    queue = (TreeNode **)malloc(sizeof(TreeNode *) * MAX_SIZE);
    // 队列伪指针
    front = 0, rear = 0;
    // 加入根节点
    queue[rear++] = root;
    // 初始化一个列表，用于保存遍历序列
    /* 辅助数组 */
    arr = (int *)malloc(sizeof(int) * MAX_SIZE);
    // 数组指针
    index = 0;
    /*利用队列实现层序遍历*/
    while (front < rear) {
        // 队列出队
        node = queue[front++];
        // 保存节点值
        arr[index++] = node->val;
        if (node->left != NULL) {
            // 左子节点入队
            queue[rear++] = node->left;
        }
        if (node->right != NULL) {
            // 右子节点入队
            queue[rear++] = node->right;
        }
    }
    // 更新数组长度的值
    *size = index;
    arr = realloc(arr, sizeof(int) * (*size));

    // 释放辅助数组空间
    free(queue);
    return arr;
}
```
#### 2.2前序、中序和后续遍历
**①定义**
>**前序遍历**：先访问**根节点**，**前序遍历**其**左子树**，再**前序遍历**其**右子树**

>**中序遍历**：**中序遍历**其**左子树**，访问**根节点**，再**中序遍历**其**右子树**

>**后序遍历**：**后序遍历**其**左子树**，**后续遍历**其**右子树**，访问其**根节点**
{%list%}
这三种遍历本质上是深度优先遍历，体现了一种“先走到尽头，再回溯继续”的遍历方式
{%endlist%}
{%right%}
对于一个节点，有三次访问的时刻，即第一次访问（没有访问其子节点），从左子树返回访问和从右子树返回访问，三种遍历方式就是分别再三次访问时输出
{%endright%}
![前序、中序和后续遍历](/image/SF_6.png)
**②三种遍历的递归实现**
```
/* 前序遍历 */
void preOrder(TreeNode *root, int *size) {
    if (root == NULL)
        return;
    // 访问优先级：根节点 -> 左子树 -> 右子树
    arr[(*size)++] = root->val;
    preOrder(root->left, size);
    preOrder(root->right, size);
}

/* 中序遍历 */
void inOrder(TreeNode *root, int *size) {
    if (root == NULL)
        return;
    // 访问优先级：左子树 -> 根节点 -> 右子树
    inOrder(root->left, size);
    arr[(*size)++] = root->val;
    inOrder(root->right, size);
}

/* 后序遍历 */
void postOrder(TreeNode *root, int *size) {
    if (root == NULL)
        return;
    // 访问优先级：左子树 -> 右子树 -> 根节点
    postOrder(root->left, size);
    postOrder(root->right, size);
    arr[(*size)++] = root->val;
}
```
### 3.二叉搜索树
#### 3.1定义
>**左子树**中**所有节点**的值`<`**根节点**的值`<`**右子树**中**所有节点**的值，且其**左右子树**都是**二叉搜索树**
{%warning%}
二叉搜索树不允许存在重复节点
{%endwarning%}
{%right%}
由定义可知，二叉搜索树的中序遍历序列是升序的，所以从二叉搜索树中获取有序数据时间复杂度仅仅为O(n)
{%endright%}
#### 3.2查找
**①递归实现**
```
Position Find(ElementType x,BinTree BST)
{
  /*没找到，递归退出条件
  if(!Bst)
    return NULL;
  /*递归查找
  if(x>Bst->Data)
    return Find(x,BST->Right);
  else if(x<Bst->Data)
    return Find(x,BST->Left);
  /*成功找到，递归退出条件
  else
    return BST;
}
```
**②非递归实现**
```
Position Find(ElementType x,BinTree BST)
{
  while(BST)
  {
    if(x > BST->Data)
      BST = BST->Right;
    else if(x < BST->Data)
      BST = BST->Left;
    else
      return BST;
  }
  return NULL;
}
``` 
#### 3.3插入
**①递归实现**
```
BinTree Insert(ElementType x,BinTree BST)
{
  /*递归退出条件，找到对应插入位置，即一个空位置
  if(!BST)
  {
    BST = malloc(sizeof(struct TreeNode));
    BST->Data = x;
    BST->Left = BST->Right =NULL;
  }
  else
  {
    if(x < BST->Data)
      BST->Left = Insert(x,BST->Left); 
    else if(x > BST->Data)
      BST->Right = Insert(x,BST->Right);
  }
  return BST;
}
```
**②非递归实现**
```
BinTree Insert(ElementType x,BinTree BST)
{
  while(BST)
  {
    if(x > BST->Data)
    {
      if(!BST->Right)
      {
      BST->Right = malloc(sizeof(struct TreeNode));
      BST->Right->Data = x;
      BST->Right->Right = BST->Right->Left = NULL;
      return BST->Right
      }
      else
      BST = BST->Right
    }
    else if(x < BST->Data)
    {
      if(!BST->Left)
      {
      BST->Left = malloc(sizeof(struct TreeNode));
      BST->Left->Data = x;
      BST->Left->Right = BST->Left->Left = NULL;
      return BST->Right
      }
      else
      BST = BST->Left;
    }
    else 
    return BST;
  }
  BST = malloc(sizeof(struct TreeNode));
  BST->Data = x;
  BST->Left = Bst->Right = NULL;
  return BST;
}
```
#### 3.4删除
**①思路**
{%list%}
需要保证删除节点后的二叉树依旧是搜索二叉树，所以对于不同的节点，删除操作是不同的
{%endlist%}
>**叶节点**：**直接删除**即可

>**节点的度为1**：将**待删除节点**替换为**子节点**

>**节点的度为2**：将其**右子树最小元素**或者**左子树最大元素**代替之

**②代码实现**
```
BinTree Delete(ElementType x,BinTree BST)
{
  Position Tmp;
  if(!BST)
    print("未找到该元素")；
  else if(x < BST->Data)
    BST->Left = Delete(x,BST->Left);
  else if(x > BST->Data)
    BST->Right = Delete(x,BST->Right);
  else
    /*当有两个孩子
    if(BST->Left && BST->Right)
    {
      /*找到其右子树最小元素替代之
      Tmp = FindMin(BST->Right);
      BST->Data = Tmp->Data;
      /*删除其右子树最小元素
      BST->Right = Delete(BST->Data,BST->Right);
    }
    /*有一个或者没有孩子
    else
    {
      Tmp = BST
      if(!BST->Left)
        BST = BST->Right
      else if(!BST->Right)
        BST = BST->Left;
      free(Tmp)
    }
  return BST;
}
```

### 4.AVL树
#### 4.1引言
**①树的退化**
{%warning%}
多次插入和删除，可能导致树退化为链表，很多操作将从O(logn)变为O(n)
{%endwarning%}
![树的退化](/image/SF_8.png)

**②定义**
>**平衡二叉树**：**空树**或者**任意节点**左右子树**高度差**绝对值**不超过1**
{%list%}
AVL树既是平衡二叉树，又是二叉搜索树
{%endlist%}
{%right%}
树越平衡，同等个数节点的高度就越小，操作的时间复杂度就越小，所以AVL树的数据操作性能很优秀
{%endright%}

#### 4.2AVL树旋转
{%right%}
将搜索二叉树变为AVL树
{%endright%}
**①RR旋转**
![RR旋转](/image/sjjg_9.png)
**②LL旋转**
![LL旋转](/image/sjjg_10.png)
**③LR旋转**
![LR旋转](/image/sjjg_11.png)
**④RL旋转**
![RL旋转](/image/sjjg_12.png)

#### 4.3AVL树的实现

### 5.堆
**2.1定义**：特殊的**队列**，取出元素的顺序是按照元素的**优先级**（关键字）
>用**数组**表示的**完全二叉树**
任意节点的优先级是**其子树所有节点**的最大/小值，即**根节点到任意节点路径**是**有序**的
**2.2结构代码**
```
typedef struct HeapStruct *MaxHeap
struct HeapStruct
{
  ElementType *Elements; /*存储堆的数组
  int Size; /*堆的当前元素个数
  int Capacity; /*最大容量
};
```
**2.3操作集（最大堆）**
**①创建堆**
```
MaxHeap Create(int MaxSize)
{
  MaxHeap H = malloc(sizeof(struct HeapStruct));
  H->Elements = malloc((MaxSize+1)*sizeof(ElementType));
  H->Size = 0;
  H->Capacity = MaxSize;
  /*定义哨兵，便于查找
  H->Elements[0] = MaxData;
  return H;
}
```
>其中定义了**哨兵**
**②堆的插入**
```
void Insert(MaxHeap H,ElementType item)
{
  int i;
  if(IsFull(H))
  {
    printf("最大堆已满")；
    return;
  }
  i = ++H->Size;
  /*保证最大堆特性的比较
  for( ;H->Elements[i/2] < item; i/=2)
    H->Elements[i] = H->Elements[i/2];
  H->Elements[i] = item;
}
```
>为了保证最大堆的特性，需要保证**新插入节点要比父节点小**，所以如果他比父节点要大，就**交换**其和父节点位置，直到其小于对应的父节点
在这个过程中，哨兵的存在可以防止其到0的位置（超出堆的范围，因为堆的下标不能是0）
**③堆的删除**
```
ElementType DeleteMax(MaxHeap H)
{
  /*从堆中取出最大元素，并删除一个节点
  int Parent,Child;
  ElementType MaxItem,temp;
  if(IsEmpty(H))
  {
    printf("最大堆已为空")；
    return;
  }
  /*取出根节点最大值
  MaxItem = H->Elements[1];
  /*用最大堆中最后一个元素从根节点开始向上过滤下层节点
  temp = H->Elements[H->Size--]; /先取出末尾元素，然后Size减1
  for(Parent = 1;Parent*2 <= H->Size; Parent = Child) 
  {
    Child = Parent * 2；
    if((Child!=H->Size)&&(H->Elements[Child] < H->ElementType[Child+1]))
      Child++; /*找到其左儿子和右儿子的较大者并指向它
    if(temp>= H->Element[Child])
    break; /*找到对应插入位置了，即比其儿子节点都大
    else
      H->Elements[Parent] = H->Elements[Child]; /*移动到下一层，将较大的儿子移上去
  }
  H->Elements[Parent] = H->Elements[Child];
  return MaxItem;
}
```
>总体思想：将最后一个位置的节点**内存**删除，将其值**先插入到根节点**中（因为根节点的值已经被取出），然后慢慢向下迭代，交换位置
`Parent*2 <= H->Size`的作用是判断该父节点有没有左儿子，如果没有左儿子就更加没有右儿子
`Child!=H->Size`的作用是判断其有没有右儿子，因为如果左儿子刚好是堆的边界，则没有右儿子
**④堆的建立**
>总体思想：先将各个元素按照**输入顺序**存入，形成**完全二叉树**，利用**分而治之**的思想，将整个堆分为**根节点和左子堆和右子堆**，以此类推，最后分到最后就是父节点和左右儿子节点的比较

### 3.哈夫曼树
**3.1定义**：最优二叉树，即每个**叶子结点**到根节点的带权路径长度之和最小
**3.2构造**
**①总体思想**：将所有节点按照大小排序（可以用堆的方法），每次把权值最小的两棵二叉树合并，比如说1、2、3、4、5，合并一次变为3（1、2）、3、4、5，然后变为6（3（1、2）、3）、4、5，以此类推
**②代码实现**
![哈夫曼树的构造](/image/sjjg_14.png)
**3.3哈夫曼编码**:为了使得出现频率高的字符编码短些，出现频率低的字符编码长些，可以将哈夫曼树的节点路径看作为1和0，左节点为0，右节点为1，**编码长度就是路径长度**，按照字符出现频率构造哈夫曼树即可
![哈夫曼编码](/image/sjjg_13.png)


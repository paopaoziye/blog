---
title: 计算机组成原理（上）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机组成原理
  - 《计算机组成原理》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/39.webp
date:
summary: 计算机基本组成、总线、存储器
---
# 计算机组成原理（上）
## 计算机组成原理启蒙
### 1.计算机基本组成
#### 1.1冯诺依曼结构
**①特点**
>计算机由**运算器**、**控制器**、**存储器**、**输入设备**、**输出设备**五大部分组成

>**指令**和**数据**以**同等地位**存储，用**二进制**表示，其中**指令**由**操作码**和**地址码**组成
{%right%}
程序是指令的集合，也存储在存储器中
{%endright%}
>以**运算器**为中心
{%list%}
以运算器为中心导致运算器成为瓶颈，故再次基础上对其进行改进，以存储器为核心
{%endlist%}
**②以存储器为核心**
![以存储器为核心的冯诺依曼结构](/image/JZ_1.png)

#### 1.2主要部件
**①存储器**
>**存储体**：由多个**存储单元**构成，存放**二进制代码**

>**MAR**：存储器**地址寄存器**，反映存储**单元个数**

>**MDR**：存储器**数据寄存器**，反映存储器**字长**
{%right%}
MAR相当于存储器的地址线，MDR相当于存储器的数据线
{%endright%}

**②运算器**
>**ALU**：**算数逻辑单元**，进行**主要运算**的单元

>**相关寄存器**：`ACC`、`MQ`、`X`寄存器，不同的**指令**，这些寄存器的**用途不同**
{%right%}
使用运算器前，需要将各个数据放入对应的寄存器中，运算完成后，结果也存放在对应寄存器中
{%endright%}
{%warning%}
不同的CPU运算器都是不同的，尤其是寄存器的个数及其用途
{%endwarning%}

**③控制器**
{%list%}
解释指令，并保证指令的按序执行
{%endlist%}
>**PC**：存放当前**欲执行指令的地址**，即**取指**

>**IR**：存放当前**欲执行的指令**，即**分析指令**

>**CU**：取得指令的**操作码**和**地址码**，并发出**控制信号**以**执行指令**

![结构](/image/JZ_2.png)

#### 1.3一条指令的完成过程
{%list%}
以取数指令为例
{%endlist%}
>**PC**将**指令地址**送入**MAR**

>**MAR**从存储体中**取出取数指令**放入**MDR**

>**MDR**将**指令**送入**IR**

>**IR**将指令的**操作码**送入**CU**，**地址码**送入**MAR**

>在**CU**的控制下，从**存储体**中取出**对应数据**放入**MDR**，随后送入**ACC**

>**PC+1**等待**下一条指令**


#### 1.4机器主要指标
>**机器字长**：CPU**一次**能处理**数据的位数**
{%list%}
通常情况，机器字长和寄存器长度是相同的
{%endlist%}
>**运算速度**：**主频**、**核数**、**CPI**和**MIPS**等
{%list%}
CPI为执行一条指令所需的时钟周期数，MIPS为每秒能执行多少条指令
{%endlist%}
>**存储容量**：可以表示为**字节数**或者**存储单元个数x存储字长**
****
### 2.系统总线
#### 2.1引言
**①定义**
>连接**各个部件**的**信息传输线**，是各个部件**共享的传输介质**
{%warning%}
一根总线在同一时间只能被一组设备使用
{%endwarning%}

**②总线的分类**
>**片内总线**：**芯片内部**的总线

>**系统总线**：**计算机各部件之间**的总线
{%list%}
还可细分位数据总线、地址总线和控制总线
{%endlist%}

>**通信总线**：**计算机系统之间**或者计算机系统**与其他系统**的通信
{%list%}
通信总线还可细分位串行通信总线和并行通信总线
{%endlist%}

**③总线性能指标**
{%list%}
总线标准：一种对总线各种性能指标的规定，如USB和PCI等
{%endlist%}
>**总线宽度**：数据线的**根数**

>**标准传输率**：**每秒**传输的**最大字节数**

>**时钟同步/异步**：是否有**同步时钟**

>**总线复用**：**地址线**与**数据线**是否复用，总线复用能**有效减少芯片的管脚数**

>**信号线数**、**总线控制方式**等

#### 2.2总线结构
{%warning%}
单总线、双总线结构存在总线争用严重、无法进行设备分级等问题，故不作主要介绍
{%endwarning%}
**①三总线结构**
>**DMA总线**连接**高速设备**，**系统总线**连接**低速设备**
{%warning%}
无法平衡主存和CPU的处理速度差异
{%endwarning%}
![四总线结构](/image/JZ_3.png)
**②四总线结构**
>**高速总线**连接**高速设备**，**扩展总线**连接**低速设备**
{%right%}
cache用于平衡主存和CPU的处理速度差异
{%endright%}
![四总线结构](/image/JZ_5.png)

**③PCI总线结构**
>其中**设备能接的地方**也能接`PCI桥`，从而实现**设备分级**，经过**越多的桥**，**速度越慢**

![PCI总线结构](/image/JZ_6.png)

#### 2.3总线占用控制
**①设备分类**
>**主设备**：可以主**动申请总线资源**并对总线进行**控制权**

>**从设备**：只能**响应主设备**发来的**总线命令**，不能**主动**申请**总线资源**

**②链式查询方式**
>**BR线**：设备通过这条线发出**总线占用请求**

>**BS线**：如果**总线被占用**，则会**收到对应信号**

>**BG线**：总线**授权**线，按照**设备的优先级**依次连接
{%list%}
总线空闲时，多个设备提出总线占用请求，通过BG线依次查询部件，先给优先级高的部件提供总线，并设置总线忙
{%endlist%}
{%warning%}
对电路故障敏感，且靠后的设备很难申请到总线，速度较慢，通常用于简单的系统中
{%endwarning%}

![链式查询方式](/image/JZ_7.png)

**②计数器定时查询**
>**总线控制部件**中有一个**计数器**，值为`n`，当接收到**总线请求**后，通过**设备地址线**从**第n个部件开始**查找**找到发出总线请求**的部件
{%list%}
和链式类似，但是链式的值只能是0，定时器可以人为或者通过程序设置优先级
{%endlist%}
![计数器定时查询](/image/JZ_8.png)

**③独立请求方式**
>**每个部件**都有对应的**BR线**和**BS线**，**总线控制部件**中有一个**排队器**设置**设备的优先级**

![独立请求方式](/image/JZ_9.png)

#### 2.4总线通信控制
**①总线传输周期**
>**申请分配阶段**：主模块**申请总线**

>**寻址阶段**：**主模块**给出**地址**和**命令**，通过地址**找到从设备**并**传递命令**

>**传数阶段**：主从模块**交换数据**

>**结束阶段**：主从模块**撤销相关信息**

**②同步通信**
>**统一时标**控制**通信过程**，需要在**对应的传输周期节点**必须完成**对应的操作**
{%warning%}
对于速度不一样的模块，选择速度最慢的模块对时标进行设计，即速度快的模块需要等速度慢的模块
{%endwarning%}
**③异步通信**
>**不互锁**：主设备**发出请求**，**一定时间后**撤销，从设备**接收到请求后应答**，**一段时间后**撤销

>**半互锁**：主设备**发出请求**后，只有**接收到应答信号**才撤销请求信号，从设备**接收到请求后应答**，**一段时间后**撤销

>**全互锁**：主设备**发出请求**后，只有**接收到应答信号**才撤销请求信号，从设备**接收到请求后应答**，只有**知道主设备撤销请求后**再撤销应答信号

**④半同步通信**
>类似于**同步通信**，但是如果**某个时间点**主/从设备**没有准备好**，则会插入**一个个等待周期**，直到其**准备好继续**

**⑤分离式通信**
{%list%}
一个总线传输周期会有不使用总线的小周期，比如从设备准备数据
{%endlist%}
{%right%}
为了提高总线使用效率，将总线周期分为两个子周期，在不使用总线时先释放总线，随后需要使用再申请
{%endright%}
>**第一个子周期**：**主模块申请占用总线**，使用完后**放弃总线的使用权**

>**第二个子周期**：当主/从模块**准备好数据**，**从模块在申请占用总线**，将**各种信息**送至**总线**上
***

### 3.存储器
#### 3.1引言
**①分类**
>**按照存储介质分类**：**半导体存储器**、**磁表面存储器**、**磁芯存储器**、**光盘存储器**
{%warning%}
其中半导体存储器是易失的，即如果不加电，信息会丢失
{%endwarning%}
>**按存取方式分类**：**随机存储器**、**顺序存取存储器**、**直接存取存储器**
{%list%}
其中随机存储器存取时间与物理地址无关，顺序存取存储器和直接存取存储器则有关
{%endlist%}
>**按照作用分类**：**主存储器**、**高速缓存**、**闪存**、**辅助存储器**
{%list%}
主存储器还可分为RAM和ROM其中RAM可读可写，ROM只读
{%endlist%}
{%right%}
辅助存储器通常用于存放数据和文档，并不直接和CPU交换数据
{%endright%}
**②层次结构**
>**主存辅存结构**：解决**容量问题**，若**程序过大**，则会将**执行部分**放入**主存**，**其余部分**放入**辅存**

>**主存缓存结构**：解决**CPU和主存速度差异问题**，**缓存**中存放**CPU经常使用**的的**主存信息**
{%right%}
将不同层次的存储器结合到一起，使其整体形成一个容量大、速度快、价格合适的存储器
{%endright%}
![层次](/image/JZ_10.png)
![结构](/image/JZ_11.png)

#### 3.2主存
**①基本构成**
>**CPU和主存**通过**地址总线**、**数据总线**、**控制总线**和**片选线**连接
{%list%}
片选先表示该存储器芯片是否被选择
{%endlist%}
{%warning%}
不同存储器的存储单元存储方式可能不同
{%endwarning%}
{%right%}
各种介质的存储器抽象结构都是类似的，只是其实现细节不一样
{%endright%}
>**大端大尾**：**高位字节的地址**为字地址，**高位字节**存储**字的低位**

>**小端小尾**：**低位字节的地址**为字地址。**低位字节**存储**字的低位**

![主存基本构成](/image/JZ_4.png)

**②译码驱动方式**
{%list%}
译码驱动就是根据地址线找到对应的地址单元
{%endlist%}
>**线选法**：只有一个**地址译码器**，将**存储矩阵**看作为**一个个线性的数组**，每次通过**译码结果**选择**其中一行**
{%warning%}
当地址线很多时，如20根，译码器需要1M根线，导致无法高度集成
{%endwarning%}
>**重合法**：有**行地址译码器**和**列地址译码器**，根据**两者译码结果**打开对应**行列的开关**，选取**对应坐标的存储单元**
{%right%}
20地址线，平均分为两份，每份需要1K根线，总共只要2k条，所以主要使用重合法进行译码驱动
{%endright%}
{%list%}
一个列选信号可能对应多列，从而一次性取出多位数据
{%endlist%}
>假设有**16列**，将其分为**4组**，**列选信号**`0`表示选择**每一组的第0列**，从而**一次选取4列**

**③主要技术指标**
>**存储容量**：存放**二进制代码**的**总位数**

>**存取时间**：存储器的**访问时间**

>**存储周期**：**连续两次独立**的存储器操作所需的**最小间隔时间**

>**存储器带宽**：**单位时间存储读取的长度（位/秒）**

**④随机存取存储器RAM**
>**静态RAM**：使用**双稳态触发器**存放`0/1`

>**动态RAM**：使用**电容**存放`0/1`
{%warning%}
电容很容易漏电，需要定时对电容进行充电，也就是刷新
{%endwarning%}
{%list%}
刷新方式可分为集中刷新、分散刷新和异步刷新
{%endlist%}
>**集中刷新**：**每隔一段时间**对**所有单元**进行刷新
{%warning%}
刷新期间无法对芯片进行读写，也被称为死区，一次性刷新所有单元导致死区时间较长
{%endwarning%}
>**分散刷新**：**每个读写周期**后，对**一个存储单元**进行刷新，使**读写周期变长**

>**异步刷新**：**每隔一段时间**刷新**一行**
{%right%}
合理安排刷新时间，如安排在指令译码阶段，则不会出现死区
{%endright%}
**⑤只读存储器ROM**
>**ROM**的主要供**读取**，通常**不可修改**或者**修改起来很麻烦**，通常用来保存**系统程序**以及**系统配置信息**

>可分为**MROM**、**PROM**、**ERPOM**、**EEPROM**和**闪存**
{%list%}
MROM不能修改，PROM可以被修改一次，EPROM可紫外线擦写多次，EEPROM电可擦写多次
{%endlist%}

#### 3.3主存和CPU的连接
**①扩展**
{%right%}
扩展的本质就是合理安排各个芯片的数据线、地址线和片选线
{%endright%}
>**位扩展**：增加**存储字长**，如使用**2片1Kx4位**的存储芯片组成**一个1Kx8位**的存储器
{%list%}
1KX4位芯片有10根地址线和4根数据线，1KX8位芯片有10根地址线和8根数据线
{%endlist%}
{%right%}
将两个1Kx4位芯片的数据线分别连接到八根数据线上，地址线同连在10根地址线上，并将两者的片选线并联即可
{%endright%}
>**字扩展**：增加**存储容量**，如使用**2片1Kx4位**的存储芯片组成**一个2Kx4位**的存储器
{%list%}
1KX4位芯片有10根地址线和4根数据线，2KX4位芯片有11根地址线和4根数据线
{%endlist%}
{%right%}
将两个1Kx4位芯片的数据线同连到4根数据线上，地址线同连在10根地址线上，并将多余地址线作为两芯片的片选线
{%endright%}

>**字位同时扩展**：使用**4片1Kx4位**的存储芯片组成**一个2Kx8位**的存储器
{%list%}
先进行位扩展，再进行字扩展即可
{%endlist%}

**②校验**
{%warning%}
存储器可能被周围环境干扰，导致其存储单元的数值发生变化，从而产生误码
{%endwarning%}
>**合法代码集**：不在该**集合中**的**码元**是**误码**

>如`{000,111}`使用`000`表示`0`，`111`表示`1`，当出现`100`，会被自动纠正位`000`
{%list%}
由于1位错误发生概率最大，所以出现误码时，认为其出现1位错误
{%endlist%}
{%warning%}
该合法代码集合无法检测出两位错误并纠正，这也是合法代码集的局限性
{%endwarning%}
{%right%}
合法代码集的纠错能力与其冗余度有关，冗余度越高，纠错能力越强，如{00000,11111}可以检测出两位错误并纠正
{%endright%}
>**汉明码**：采用**偶校验**、**分组校验**，能**检测并纠错1位**
{%list%}
偶校验即本来代码的1个数为偶数个，若发生一位误码，则校验位变为1，使其变为偶数个，奇校验类似
{%endlist%}
>假设代码有**x位**，其**二进制表示**有**y位**，则将其**分为y组**，如`0000000`有**7位**，则将其分为**3组**

>**索引二进制形式第i位为1**的为**第i组**，并将**索引第i位为1，其他位为0**的那一位作为**所在组**的**校验位**，第`1、3、5、7`位分为**一组**，第`2、3、6、7`位分为**一组**，第`4、5、6、7`位分为**一组**，其中第`1、2、4`位作为**校验位**

>如果**没有差错**，**校验位**应该**均为0**，若**出现差错**，则将**校验位从小到大进行排序**，组成的**二进制数对应索引位**出现**错误**，若**校验位**分别为`001`，则**第一位出错**
{%list%}
001表示第一组出错，但是其余两组没错，则就是第一位错，因为只有1在第一组而不再其余两组中
{%endlist%}

**③主存结构**
{%list%}
CPU需要从内存中读取/写入指令和数据才能进行工作，所以需要提升CPU和内存的交互速度
{%endlist%}
{%right%}
可以一次性从内存中读取多个存储单元以提升两者交互速度
{%endright%}
>**单体多字**：一次性**线性选择**多个存储单元
{%warning%}
不够灵活，如果如果只需要读取/存储一个或者零星分布的存储单元，将比较麻烦
{%endwarning%}

>**高位交叉**：将**存储地址**分为`存储体号:体内地址`，每次先根据**存储体号**选择**存储体**，再根据**体内地址**选择**存储单元**
{%warning%}
由于程序是连续存储的，执行程序时会一直访问局部单元（即低位变化），导致一个存储体特别繁忙
{%endwarning%}

>**低位交叉**：将**存储地址**分为`体内地址:存储体号`，其余**和高位交叉一致**
{%right%}
这样就可以将程序分布在多个存储体中，执行程序时，多个存储体可以并行工作
{%endright%}

#### 3.4高速缓存Cache
**①引言**
>由于**局部性原理**，将程序**近期使用的指令和数据**放入**Cache**中以**提升访问速度**，**Cache**的**访问速度块**，但是**容量小**
{%list%}
局部性原理：当前正在使用的指令和数据不久后很有可能在此使用，其相邻的指令和数据也很有可能被调用
{%endlist%}
{%right%}
可以通过对Cache进行分级或者将其分为指令Cache和数据Cache进一步提升效率
{%endright%}
**②工作原理**
>**Cache地址**可分为`缓存块号:块内地址`，**主存地址**可分为`主存块号:块内地址`

>**Cache**每个块有一个**标记**，保存了`缓存块号`和`主存块号`的**映射关系**

>**读数据**时，先查看**访问地址的**`主存块号`是否**在Cache中**，如果在则**直接读取**，如果**不在**，则将其**存入Cache**中
{%list%}
如果Cache没有空闲空间，则采用替换算法取出不用的块再将其存入，常见的替换算法有FIFO和LUR
{%endlist%}

>**写数据**时，可以将数据**同时**写入**缓存块**和**对应主存块**，也可以**先更新缓存块**，当缓存块被**替换**时，再**更新主存块**
{%warning%}
第一种方法可能导致对同一个主存块的频繁访问
{%endwarning%}


**③地址映射**
>**直接映射**：将主存**分区**，该区的**主存块**只能映射到Cache的**某个固定缓存块**
{%list%}
访问速度较快，但是容易产生冲突
{%endlist%}
>**全相联映射**：主存块可以放在**任意缓存块位置**
{%list%}
不会发生冲突，但是每次访问需要遍历缓存块，访问速度较慢
{%endlist%}
>**组相联映射**：主存**分区**，Cache**分组**，主存储器**某个区的存储单元**只能存储到Cache的**固定组的任意位置**
{%list%}
直接映射和全相联映射的结合，中和了两者的优点和缺点
{%endlist%}


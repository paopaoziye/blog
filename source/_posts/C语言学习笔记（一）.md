---
title: C语言学习笔记（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - C语言
  - 《C和指针》        
categories: 编程语言
keywords: 文章关键词
updated: ''
date:
img: /medias/featureimages/0.webp
summary: C语言基础
---
# C语言学习笔记（一）
## C语言启蒙
### 1.引言
#### 1.1C语言程序组成简介
**①空白**
>**换行**、`tab`和**空格键**，使得程序更加**美观**

**②注释**
>**单行注释**：以`//`开始、以**换行符**结束

>**多行注释**：以`/*`开始，以`*/`结束
{%wrong%}
多行注释不能嵌套，第一个/*到第一个*/之间都视为注释
{%endwrong%}
>**预处理注释**：用于注释**包含注释**的代码块
```
#if 0
  statement
#endif
```
**③预处理命令**
>`#include <xx.h>`：将**对应文件内容**逐字写到**对应位置**

>`#define [变量] [值]`：将**宏变量**替换为**对应值**
{%right%}
define还可定义宏，暂不介绍
{%endright%}
**④函数原型**
>告诉**编译器**调用函数的**特征**
{%right%}
如果一些函数声明经常需要使用，可以将他们的函数声明写到一个头文件中，再调用#include宏将该头文件写入
{%endright%}

**⑤main函数**
>程序执行的**起点**和**终点**
```
int main (void)
{
  statement;
  return 0;
}
```
#### 1.2C程序内存分布
>**代码段**：存放**程序执行代码**的内存区域，也包括一些**只读的常量**，在**程序运行前**就已经确定

>**初始化数据段**：存放**已初始化的全局变量**，在进程运行时**静态分配**

>**未初始化数据段**：存放程序中**未初始化的全局变量**和**静态变量**，默认为`0`，在进程运行时**静态分配**

>**栈**：存放**自动变量**以及**函数调用时所需的信息**，按内存地址**由高到低**扩张，最大长度**编译时确定**
{%list%}
每次函数调用，都会创建一个新的栈帧存放函数返回地址、寄存器的值
{%endlist%}
>**堆**：可**自由申请**的空间，按内存地址**由低到高**方向扩张，其长度由**系统内存/虚拟内存上限**决定，通常在堆中进行**动态存储分配**
{%list%}
进程的每个线程都会有自己的栈，但是堆空间是共用的。
{%endlist%}
{%warning%}
自动变量因为其地址只有在其创建时确定，故其缺省情况下的初始值是垃圾
{%endwarning%}
![C程序内存分布](/image/C_2.png)

#### 1.3 基本数据类型
**①整型**
>**字符**`char`、**短整型**`short int`、**整型**`int`、**长整型**`long int`
{%list%}
char本质上是一个小整型，占一个字节，int位数由编译器决定，通常是这种机器最为高效的位数
{%endlist%}
{%warning%}
仅规定了长整型≥整型≥短整型，且short int至少占16位，long int至少占32位，他们能表示的范围是不同的
{%endwarning%}
{%right%}
在C11的标准中追加stdint.h避免了位数的不确定性，如：int32_t长度为4个字节的，int8_t就是一个字节
{%endright%}

**②浮点类型**
>**单精度浮点数**`float`、**双精度浮点数**`double`、**扩展精度浮点数**`long double`
{%list%}
ANSI C没有规定浮点类型的长度，long double≥doubl≥float
{%endlist%}
{%warning%}
只有某些机器支持扩展精度，通常采用double
{%endwarning%}
**③有符号数和无符号数**
{%list%}
仅对整型具有意义
{%endlist%}
>对于`int`、`short int`、`long int`来说，**缺省情况**下为**有符号数**

>对于`char`来说，分为`char`、`singed char`和`unsigned char`，其中`char`的带符号与否**取决于编译器**
{%right%}
为了提高程序的可移植性，需要将char限制0~127内，且只对显式声明为有符号数和无符号数的char进行数值运算
{%endright%}
**④枚举类型**
>**格式**：`enum 枚举类型名{枚举1,枚举2,枚举3…} ；`
{%list%}
如果不对枚举进行赋值，则枚举从0开始，依次增大1，如果对某些枚举复制，则没有被赋值的枚举比前者大1
{%endlist%}
{%right%}
本质上还是int，相当于被命名的int集合
{%endright%}
**⑤字面值**
>**没有赋予给变量**的数据，有**整型字面值**、**字符型字面值**、**字符串字面值**和**浮点数字面值**
{%list%}
缺省情况下，整型字面值能表示该字面量的最短的类型，字符型字面量为int，浮点数字面值为double
{%endlist%}
{%warning%}
字面量的内存地址不确定，且不能改变
{%endwarning%}
***

### 2.变量
#### 2.1声明与定义
**①格式**：`说明符 声明表达式列表`
>**说明符**：用于指明变量的**基本类型**、**存储类型**和**作用域**，可以有一个，也可以有多个
**声明表达式**：命名变量、赋值

**②声明和定义**
>**声明**：用于向程序表明变量的**类型和名字**
**定义**：用于为变量**分配存储空间**，还可为变量**指定初始值**
{%list%}
对于int a;，如果a是全局变量的话就是声明，是局部变量的话就是定义
{%endlist%}
>可以利用`extern`修饰**局部变量**表明是变量的**声明**，该关键词含义是此变量/函数是**在别处定义**的，要在此处引用

{%right%}
在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明（extern）
{%endright%}
{%warning%}
变量可以声明多次，而只能定义一次
{%endwarning%}
{%wrong%}
在声明变量时不要赋值，否则就是定义了
{%endwrong%}
**③实例**
```
include <stdio.h>
int a;
int a;
int main()
{
	return 0;
}
```
>该程序正常工作
```
include <stdio.h>

int main()
{
	int a;
    int a;
	return 0;
}
```
>该程序由于**重复定义**错误

**④声明/定义的解释**
{%right%}
变量的声明可以理解为，变量通过声明表达式的运算得到说明符，如int a[]可以理解为变量a通过下标运算得到一个整数，则a就是一个数组，本质上是一个指向整型的指针
{%endright%}

#### 3.2typedef
**①格式**：只要在**变量声明**前面加上`typedef`，就成了**类型定义**，对应变量名即称为新的类型名
>如`typedef int (*function_t) (int param);`，在这里`function_t`则称为了对应的函数指针的类型名

**②与define的区别**：`define`只是简单的替换，如下，`a`被定义为一个指针，而`b`被定义为一个字符
```
#define char* ptr_to_char
ptr_to_char a,b;
```
{%wrong%}
在进行句法分析的时候，typedef和存储类型指示符是等价的，故该关键词不能和static等存储类型指示符一起用
{%endwrong%}

#### 3.3const常量
>使得变量被**初始化后不得被更改**

**①修饰对象**
>`const`修饰指针时，需要注意`const`修饰的是**指针**还是**指针指向的值**
```
int const *a：指针指向的值不能被修改
int * const a：指针无法被修改
```
**②`const`与`define`**
>`const`只能用于允许使用变量的地方，比如数组的大小就最好使用`define`
{%right%}
函数中被const修饰的形参获得对应的实参的值后无法被改变，当你不希望函数改变该值时，可以使用const修饰该形参
{%endright%}

#### 3.4作用域
>变量只能在一定的区域中才能被访问，即变量**能被访问的区域**

**①代码块作用域**
>代码块中变量的作用域**于代码块开头开始，到代码块结尾结束**

>**嵌套**的代码块中，**同名**内层变量会**覆盖**外层变量，包括全局变量
**非嵌套**的代码块，每个代码块的变量无法被另一个代码块访问，**代码块之间变量隔离**
{%list%}
在ANSI C中，函数形参的作用域在函数最外层代码块内（动态变量）
{%endlist%}

**②文件作用域**
>在**代码块外**声明的变量都具有文件作用域（`extern`属性），从他们**声明之处到所处源文件结尾**都可以访问
{%list%}
使用include包含到该文件的变量属于文件作用域
{%endlist%}
**③原型作用域**
>只适用于**函数原型（不是函数定义）**中声明的参数名，只存在那个括号内

**④函数作用域**
>只适用于语句标签，一个函数中所有**语句标签必须唯一**

#### 3.5链接属性（如果使用extern修饰局部变量的效果是什么？？？）
>变量的链接属性决定如何处理在**不同文件中的同名变量**

**①`none`**
>只能在其**所在代码块中**被访问。

**②`internal`**
>**同一个源文件**中的所有同名变量都是同一个实体，可以在**该源文件**中被访问

**③`external`**
>**所有源文件**的所有同名变量是**同一个实体**，可以被所有源文件访问

{%list%}
在缺省情况下，在代码块外的链接属性为external，其余none
{%endlist%}
{%right%}
拥有extern属性的变量在单个源文件中，从头到尾都可以访问，在有多个源文件时，其他源文件也可以访问
{%endright%}
{%warning%}
注意拥有extern属性的变量只是可以被其他文件访问，若要在其他源文件中使用，需要在使用的源文件中添加对应变量的声明（需要加上extern关键词）
{%endwarning%}
{%wrong%}
在多个文件中定义同名的全局变量会导致链接错误，因此建议在一个文件中定义一个全局变量，并通过extern关键字在其他文件中进行引用（可以声明在头文件中）
{%endwrong%}



#### 3.6存储类型（静态变量和全局变量的区别？？？？）

**①静态内存**
>在**代码块之外**声明的变量被称为**静态变量**，无法改变其存储类型，在**程序运行之前**创建，在程序的**整个执行期间**始终存在
{%list%}
全局变量总是静态变量
{%endlist%}
**②堆栈**
>在**代码块内**声明的变量被称为**动态变量**，存储在**堆栈**中，当**程序执行流到达该代码块时，才被创建，执行流离开该代码块时，该变量被销毁**，当该代码块重复执行时（比如循环），**内存位置不固定**

**③硬件寄存器**
>称为**寄存器变量**，**访问效率更高**，可以把**高频使用**的变量声明为寄存器变量，寄存器变量的**生命周期和动态变量**相同
{%warning%}
寄存器变量是一种请求，编译器可能忽略该请求，同时，当寄存器数量不足是，寄存器变量也可能转变为自动变量，且只要声明为寄存器变量，就不能对其取址
{%endwarning%}

#### 3.7相关属性修改
**①`static`**
>对**缺省属性**为`extern`属性的的变量，`static`将改变其**链接属性**，变为`internal`
对**缺省属性**为`none`属性的的变量，`static`将改变其**存储类型**，由动态变量变为**静态变量**
{%list%}
用static将动态变量转化为静态变量，其作用域不会改变，原先的值也不会改变
{%endlist%}
{%warning%}
static不能修饰形参
{%endwarning%}

**②`extern`**
可以给标识符赋予`external`链接属性（只需要在声明处添加即可），则**所有源文件都能访问该变量**
{%warning%}
如果标识符在第一次声明中已经指定了链接属性，那么extern在后面的第二次或以后的声明中，不会更改第一次声明所指定的链接属性
{%endwarning%}

**③`register`**
>将**动态变量**转化为**寄存器变量**



### 4.语句
#### 4.1空语句
>本身**只包含一个分号**，用于**不需要操作但是语法要求出现一条完整语句**的场合

#### 4.2表达式语句
>每个表达式语句都有其**对应返回值**，但是没有其他操作的情况下，该返回值**不被保存**

#### 4.3代码块
>被一对花括号囊括的多条语句，在语法上相当于**一条语句**

#### 4.4条件语句
```
if （expression）
	{
	statement;
	}
else if (expression)
	{
	statement;
	}
else 
	{
	statement；
	}
  ```
>出现`if`嵌套时，`else`从句属于**最靠近**他的**不完整**的`if`从句

#### 4.5循环语句
**①`while`循环**
```
while （expression）
	{
	statement;
	}
```

**②f`or`循环**
```
for （初始化语句; 条件语句;调整语句）
	{
	statement;
	}
```
>**初始化语句在循环一开始执行，条件语句在每一次循环开始之前执行，调整语句在每一次循环后执行**

**③`do while`循环**
```
do{
	statement;
	}while(expression);
```
>`while`语句相比，`do while`语句会先执行语句然后再判断条件是否成立

**④`switch`循环**
```
switch（expression）
	{
    case expression_n：
	  statement；
      break；
    default：
      statement；
      break；
	}
```

{%list%}
expression的结果必须是整数，C语言中没有布尔类型，非零值为真，零值为假，缺省情况下，真值为1，假值为0
{%endlist%}
{%right%}
在循环中可以使用break语句，用于永久终止循环，使用continue语句终止当前的循环
{%endright%}
{%warning%}
若循环是嵌套的，则break和continue语句，只能终止其所在的循环
{%endwarning%}
{%wrong%}
当执行到匹配到case语句后，执行流会一直往下直到switch语句结束(包括default子句)，所以要在每个case语句下添加break及时退出，同时这也是一种特性，可以加以利用
{%endwrong%}

#### 4.6跳转语句
```
biaoqian:
goto biaoqian;
```
>标签就是**标识符后面加一个冒号**
可以通过goto语句**跳出嵌套循环**
{%wrong%}
非必要不使用goto语句
{%endwrong%}

### 5.操作符
#### 5.1基本操作符
**①算术操作符**
>`+`、`-`、`*`、`/`、`%`（取余）
{%warning%}
/操作符只有当两个操作数都为整型时，才做整型运算，%只能接受两个整型
{%endwarning%}
**②关系操作符**
>`>`、`<`、`>=`、`<=`、`!=`、`==`

**③逻辑操作符**
>`&&`（与）、`||`（或）、`^`（异）、`！`（否）
{%list%}
短路求值，通过第一个操作数能判断结果就不会判断后面的操作数，且要求操作数均为整数
{%endlist%}
**④赋值操作符**
>**基本赋值操作符**：`=`
**复合赋值符**：比如`+=`，`a += （expression）`代表` a = a+（expression）`
{%list%}
赋值表达式语句的返回值是左操作数的新值，所以可以连等a=b=10
{%endlist%}
{%right%}
当a比较复杂或者其中有需要编译器实时计算的项，采用复合赋值符可以提高效率
{%endright%}

**⑤逗号操作符**
>`expression1,expression2,...,expressionN`,`expression`都会被求值，但是整个表达式的值是**最后一个表达式**的值

**⑥条件操作符**
>`expression1 ？ expression2 ： expression3`：如果`expression1`值为真，则该表达式结果为`expression2`，反之为`expression3`

**⑦单目操作符**
>`&`（取址）、`*`（引用）、`sizeof()`（判断类型长度）、`~`（求补，位取相反）、`++/--`（递增/递减）
{%list%}
++/--为前缀时，先递加/减，再进行相关操作，为后缀时，先进行相关操作，再递加/减
{%endlist%}
{%wrong%}
强制类型转换的优先级非常高
{%endwrong%}

#### 5.2位操作符
**①移位操作符**
>**左移`<<`**：最左边的几位被丢弃，右边多出来的几位**由0补齐**
**右移`>>`**：可以选择两种移位方案，一种是**逻辑移位**，用**0**补充，一种是**算数移位**，补充的**取决于符号数**，对于**无符号数**，采用的都是**逻辑移位**，对于**有符号数**，采用逻辑移位还是算数移位**取决于编译器**，可能会影响程序的移植性
{%warning%}
两边的操作数都必须是整型，需要移动的位数必须正数，且不能超过被操作数的位数
{%endwarning%}
**②逻辑位操作符**
>对操作数的**各个位**执行逻辑运算（`&`与，`|`或，异或`^`）
`value = value | 1 << bit_number;`即将`bit_number`对应位置转换为1
{%list%}
位操作符优先级比移位操作符高
{%endlist%}

#### 5.3左值和右值
>左值相当于一个**容器**，可以储存结果的地方，一个内存位置，右值则是一个**可以被储存的数据**
变量`a`可以表示一个容器，也可以表示一个数据，`a+1`只能是一个数据
{%warning%}
左值是一个确切知道地址的容器
{%endwarning%}

#### 5.4类型转换
**①隐式类型转换**
>在C中的整型算数运算总是以**缺省整型类型精度**进行的，所以操作数是**字符型**和**短整型**时，在使用之前会先被**转化为普通整型**再进行运算，如果要将结果存储到字符型和短整型中，则会将结果进行截短。

**②算数转换**
>当多操作数进行运算时，且操作数属于不同的类型，则会**将精度低的数据类型转化为精度高的数据类型进行运算**

**③强制类型转换**
>`(类型) [操作数/表达式]`
{%warning%}
在16位机器上，第三个算式可能会产生溢出，可以在运算前将 a、b中的一个或者两个转化为long即可
{%endwarning%}
```
int a = 5000；
int b = 25；
long c = a*b；
```
{%warning%}
强制类型转换可能会导致精度的损失，因为位数不同
{%endwarning%}
#### 5.4优先级和结合性
**①优先级**
>标识运算符在表达式中的**运算顺序**

**②结合性**
>当一个运算对象两侧运算符的**优先级别相同时**, 运算对象与运算符的结合顺序
>比如`*a++`，其中`*`和`++`为同一优先级，结合性为右到左，先进行`a++`，再进行`*(a++)`
{%warning%}
表达式的求值顺序不一定完全按照优先级和结合性求值，如c + --c，我们并不知道c是否是在执行了--c后再与其相加，结果取决于编译器，面对有副作用的操作符需要小心
{%endwarning%}

### 6.字符串

**6.1定义**：一串以`'/0'`结尾的字符 
>`'/0'`的位模式全为0，也叫**NUL字节**，是字符串的**终止符**
{%list%}
NUL字节不是字符串的一部分，字符串长度不包括终止符的长度
{%endlist%}

**6.2基本操作**
{%list%}
需要包含string.h头文件
{%endlist%}
**①**`strlen()`：**测量字符串长度**，即字符串包含的**字符个数**
>该函数返回的长度的数据类型为`size_t`，是一个**无符号数**
{%warning%}
两个无符号数a、b相互比较时，应该使用a>b，而不是a-b>0，因为无符号数运算结果为无符号数，无符号数永远大于0
{%endwarning%}
{%wrong%}
大部分字符串相关函数都是根据终止符判断字符串长度，所以使用者要确保操作后字符串不会溢出，否则会缺少终止符
{%endwrong%}
**②**`strcpy()`：**复制字符串**，但是如果复制的字符串长度**超出了容器的限度**，则会**覆盖其后面的内存空间**
{%wrong%}
大部分字符串函数不允许两个数组参数重叠，否则函数的返回值是未定义的
{%endwrong%}
**③**`strcat()`：**连接字符串**，将一个字符串添加到另一个字符串后面
**④**`strcmp()`：**字符串比较**，进行的是**字典比较**
>**字典比较**：对两个字符串的逐个字符从头进行比较，只要比较出一个字符大小即可判断结果，`'/0'`小于任何字符
**⑤长度受限的字符串函数**：为了**防止目标数组溢出**，定义了对应函数的长度受限版本，接受一个长度参数，用于限制操作的字符个数，如`strncpy()`
{%wrong%}
但是这些函数可能导致目标数组**不是以“/0”结尾**，可能会**导致程序崩溃**
{%endwrong%}
{%right%}
可以在函数调用完后将字符数组的最后一个元素改为NUL
{%endright%}


**6.3字符串查找**
**①字符查找**
>`strchr()`：返回对应字符**第一次**出现的位置
`strrchr()`：返回对应字符**最后一次**出现的位置
`strpbrk()`：返回**一组字符中任意一个字符**第一次出现的位置

**②字串查找**
>`strstr()`：返回**子串**第一次出现的起始位置
`strtok()`：删除字符串中的所有**标记字符**，其第二个参数是一个字符串，也就是**标记字符的集合**
`strspn()`：检索字符串str1（第一个参数）中**第一个不在字符串str2（第二个参数）中出现的字符下标**
`strcspn()`:检索字符串str1（第一个参数）中**第一个出现在字符串str2（第二个参数）中出现的字符下标**


**6.4字符操作**
{%list%}
需要包含ctype.h头文件
{%endlist%}
**①字符分类**：根据对应分类函数定义，判断该字符是否为该类型
>`isspace()`：是否为空白字符
`isdigit()`：是否为数字
{%list%}
还有很多类似函数，可自行查询
{%endlist%}
**②字符转换**：转换字符的大小写
>`tolower()`：转换为小写形式
`toupper()`：转化为大写形式
{%right%}
直接测试或者操纵字符可能会影响程序的移植性，比如if(ch>='A' && ch<='Z')判断ch是否为大写字母，在使用EBCDIC字符集上的机器上将失败，但是使用isupper(ch)则无限制
{%endright%}










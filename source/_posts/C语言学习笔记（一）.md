---
title: C语言学习笔记（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - C语言
  - 《C和指针》        
categories: 编程语言
keywords: 文章关键词
updated: ''
date:
img: /medias/featureimages/0.webp
summary: C语言基础
---
# C语言学习笔记（一）
## C语言启蒙
### 1.引言
#### 1.1C语言程序组成简介
**①空白**
>**换行**、`tab`和**空格键**，使得程序更加**美观**

**②注释**
>**单行注释**：以`//`开始、以**换行符**结束

>**多行注释**：以`/*`开始，以`*/`结束
{%wrong%}
多行注释不能嵌套，第一个/*到第一个*/之间都视为注释
{%endwrong%}
>**预处理注释**：用于注释**包含注释**的代码块
```
#if 0
  statement
#endif
```
**③预处理命令**
>`#include <xx.h>`：将**对应文件内容**逐字写到**对应位置**

>`#define [变量] [值]`：将**宏变量**替换为**对应值**
{%right%}
define还可定义宏，暂不介绍
{%endright%}
**④函数原型**
>告诉**编译器**调用函数的**特征**
{%right%}
如果一些函数声明经常需要使用，可以将他们的函数声明写到一个头文件中，再调用#include宏将该头文件写入
{%endright%}

**⑤main函数**
>程序执行的**起点**和**终点**
```
int main (void)
{
  statement;
  return 0;
}
```
#### 1.2C程序内存分布
>**代码段**：存放**程序执行代码**的内存区域，也包括一些**只读的常量**，在**程序运行前**就已经确定

>**初始化数据段**：存放**已初始化的全局变量**，在进程运行时**静态分配**

>**未初始化数据段**：存放程序中**未初始化的全局变量**和**静态变量**，默认为`0`，在进程运行时**静态分配**

>**栈**：存放**自动变量**以及**函数调用时所需的信息**，按内存地址**由高到低**扩张，最大长度**编译时确定**
{%list%}
每次函数调用，都会创建一个新的栈帧存放函数返回地址、寄存器的值
{%endlist%}
>**堆**：可**自由申请**的空间，按内存地址**由低到高**方向扩张，其长度由**系统内存/虚拟内存上限**决定，通常在堆中进行**动态存储分配**
{%list%}
进程的每个线程都会有自己的栈，但是堆空间是共用的。
{%endlist%}
{%warning%}
自动变量因为其地址只有在其创建时确定，故其缺省情况下的初始值是垃圾
{%endwarning%}
![C程序内存分布](/image/C_2.png)

#### 1.3 基本数据类型
**①整型**
>**字符**`char`、**短整型**`short int`、**整型**`int`、**长整型**`long int`
{%list%}
char本质上是一个小整型，占一个字节，int位数由编译器决定，通常是这种机器最为高效的位数
{%endlist%}
{%warning%}
仅规定了长整型≥整型≥短整型，且short int至少占16位，long int至少占32位，他们能表示的范围是不同的
{%endwarning%}
{%right%}
在C11的标准中追加stdint.h避免了位数的不确定性，如：int32_t长度为4个字节的，int8_t就是一个字节
{%endright%}

**②浮点类型**
>**单精度浮点数**`float`、**双精度浮点数**`double`、**扩展精度浮点数**`long double`
{%list%}
ANSI C没有规定浮点类型的长度，long double≥doubl≥float
{%endlist%}
{%warning%}
只有某些机器支持扩展精度，通常采用double
{%endwarning%}
**③有符号数和无符号数**
{%list%}
仅对整型具有意义
{%endlist%}
>对于`int`、`short int`、`long int`来说，**缺省情况**下为**有符号数**

>对于`char`来说，分为`char`、`singed char`和`unsigned char`，其中`char`的带符号与否**取决于编译器**
{%right%}
为了提高程序的可移植性，需要将char限制0~127内，且只对显式声明为有符号数和无符号数的char进行数值运算
{%endright%}
**④枚举类型**
>**格式**：`enum 枚举类型名{枚举1,枚举2,枚举3…} ；`
{%list%}
如果不对枚举进行赋值，则枚举从0开始，依次增大1，如果对某些枚举复制，则没有被赋值的枚举比前者大1
{%endlist%}
{%right%}
本质上还是int，相当于被命名的int集合
{%endright%}
**⑤字面值**
>**没有赋予给变量**的数据，有**整型字面值**、**字符型字面值**、**字符串字面值**和**浮点数字面值**
{%list%}
缺省情况下，整型字面值能表示该字面量的最短的类型，字符型字面量为int，浮点数字面值为double
{%endlist%}
{%warning%}
字面量的内存地址不确定，且不能改变
{%endwarning%}
***

### 2.变量
#### 2.1声明与定义
**①格式**
>`说明符 声明表达式列表`
{%list%}
说明符用于指明变量的基本类型、存储类型和作用域；声明表达式用于命名变量并对其赋值
{%endlist%}
{%right%}
变量的声明可以理解为，变量通过声明表达式的运算得到说明符
{%endright%}
>如`int a[]`可以理解为**变量`a`**通过**下标运算**得到一个**整数**，则`a`就是一个**数组**

**②定义**
>**声明**：**表明**变量的**类型和名字**
{%list%}
若一源文件中只有变量的声明，则会去别的地方寻找该变量的定义
{%endlist%}
>**定义**：为变量**分配存储空间**，还可为变量**指定初始值**
{%list%}
对于int a;，如果a是全局变量的话就是声明，是局部变量的话就是定义，可以使用extern修饰表示声明
{%endlist%}
{%right%}
在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明（extern）
{%endright%}
{%warning%}
只要对变量赋值，就一定是定义变量，即使有extern修饰
{%endwarning%}
{%wrong%}
变量可以声明多次，而只能定义一次
{%endwrong%}
**③typedef**
{%list%}
只要在变量声明前面加上typedef，就成了类型定义，对应变量名即称为新的类型名
{%endlist%}
>如`typedef int (*function_t) (int param);`，在这里`function_t`则成为了**对应的函数指针的类型名**
{%warning%}
与define不同，define只是简单的替换
{%endwarning%}
>如下，`a`被**定义**为一个**字符指针**，而`b`被**定义**为一个**字符**
```
#define char* ptr_to_char
ptr_to_char a,b;
```
{%wrong%}
在进行句法分析的时候，typedef和存储类型指示符是等价的，故该关键词不能和static等存储类型指示符一起用
{%endwrong%}


#### 2.2作用域
>**代码块作用域**：**代码块中**变量的作用域，**于代码块开头开始，到代码块结尾结束**
{%list%}
非嵌套的代码块，每个代码块的变量无法被另一个代码块访问，代码块之间变量隔离
{%endlist%}
{%right%}
在ANSI C中，函数形参的作用域在函数最外层代码块内（动态变量）
{%endright%}
{%warning%}
嵌套的代码块中，同名变量会覆盖外层变量，包括全局变量
{%endwarning%}

>**文件作用域**：在**代码块外**声明的变量都具有**文件作用域**，从他们**声明之处到所处源文件结尾**都可以访问
{%list%}
使用include包含到该文件的变量属于文件作用域
{%endlist%}
{%right%}
也称为extern属性，缺省情况下相当于有extern修饰
{%endright%}

>**原型作用域**：只适用于**函数原型（不是函数定义）**中声明的参数名，只存在**那个括号**内

>**函数作用域**：只适用于语句标签，一个函数中所有**语句标签必须唯一**

#### 2.2链接属性（如果使用extern修饰局部变量的效果是什么？？？）
{%list%}
变量的链接属性决定如何处理在不同文件中的同名变量
{%endlist%}
>**`none`**：只能在其**所在代码块中**被访问。

>**`internal`**：**同一个源文件**中的所有同名变量都是同一个实体，可以在**该源文件**中被访问

>**`external`**：**所有源文件**的所有同名变量是**同一个实体**，可以**被所有源文件访问**

{%list%}
在缺省情况下，在代码块外的链接属性为external，其余none
{%endlist%}
{%right%}
拥有extern属性的变量在单个源文件中，从头到尾都可以访问，在有多个源文件时，其他源文件也可以访问
{%endright%}
{%warning%}
external属性变量只是能被其他源文件访问，若要使用，还需要在该文件中声明该变量
{%endwarning%}
{%wrong%}
在多个文件中定义同名的全局变量会导致链接错误
{%endwrong%}

#### 2.3存储类型（静态变量和全局变量的区别？？？？）
>**静态变量**：在**代码块之外**声明的变量
{%list%}
在程序运行之前创建，在程序的整个执行期间始终存在
{%endlist%}
{%warning%}
无法改变静态变量的存储类型
{%endwarning%}

>**动态变量**：在**代码块内**声明的变量
{%list%}
存储在堆栈中，当程序执行流到达该代码块时，才被创建，执行流离开该代码块时，该变量被销毁
{%endlist%}
{%warning%}
当该代码块重复执行时（比如循环）内存位置不固定
{%endwarning%}

>**寄存器变量**：使用`register`可以将**动态变量**转化为**寄存器变量**，**访问效率更高**
{%list%}
寄存器变量是一种请求，编译器可能忽略该请求，同时，当寄存器数量不足时，寄存器变量会为自动变量
{%endlist%}
{%right%}
可以把高频使用的变量声明为寄存器变量，寄存器变量的生命周期和动态变量相同
{%endright%}
{%warning%}
只要声明为寄存器变量，就不能对其取址
{%endwarning%}

#### 2.4修饰符
**①`static`**
>对**缺省属性**为`extern`属性的的变量，`static`将改变其**链接属性**，变为`internal`

>对**缺省属性**为`none`属性的的变量，`static`将改变其**存储类型**，由动态变量变为**静态变量**
{%list%}
用static将动态变量转化为静态变量，其作用域不会改变，原先的值也不会改变
{%endlist%}
{%warning%}
static不能修饰形参
{%endwarning%}

**②`extern`**
>可以给**变量**赋予`external`链接属性（只需要在声明处添加即可），则**所有源文件都能访问该变量**
{%warning%}
若变量已经有链接属性，则extern修饰符无效
{%endwarning%}

**③`const`**
>使得变量被**初始化后不得被更改**
{%list%}
const只能用于允许使用变量的地方，不允许使用变量的地方比如数组的大小，可以使用define
{%endlist%}
{%right%}
函数中被const修饰的形参获得对应的实参的值后无法被改变，当你不希望函数改变该值时，可以使用const修饰该形参
{%endright%}
{%warning%}
要注意const修饰的变量是什么，尤其是修饰指针时
{%endwarning%}
```
int const *a：指针指向的值不能被修改
int * const a：指针无法被修改
```

### 3.语句
#### 3.1基本语句
>**空语句**：本身**只包含一个分号**，用于**不需要操作但是语法要求出现一条完整语句**的场合

>**表达式语句**：由**变量**和**操作符**构成，如`1+1`
{%list%}
每个表达式语句都有其返回值，但是没有其他操作的情况下，该返回值不被保存
{%endlist%}

>**代码块**：被**一对花括号**囊括的**语句**，在语法上相当于**一条语句**

#### 3.2条件语句
{%list%}
出现if嵌套时，else从句属于最靠近他的不完整的if从句
{%endlist%}
```
if （expression）
	{
	statement;
	}
else if (expression)
	{
	statement;
	}
else 
	{
	statement；
	}
  ```


#### 3.3循环语句
**①`while`循环**
{%list%}
expression的结果必须是整数，C语言中没有布尔类型，非零值为真，零值为假，缺省情况下，真值为1，假值为0
{%endlist%}
```
while （expression）
	{
	statement;
	}
```

**②`for`循环**
{%list%}
初始化语句在循环一开始执行，条件语句在每一次循环开始之前执行，调整语句在每一次循环后执行
{%endlist%}
```
for （初始化语句; 条件语句;调整语句）
	{
	statement;
	}
```


**③`do while`循环**
{%list%}
与while语句相比，do while语句会先执行语句然后再判断条件是否成立
{%endlist%}
```
do{
	statement;
	}while(expression);
```

**④`switch`循环**
{%list%}
当执行到匹配到case语句后，执行流会一直往下直到switch语句结束，包括default子句
{%endlist%}
{%warning%}
在每个case语句下添加break及时退出
{%endwarning%}
{%right%}
在循环中可以使用break语句，用于永久终止循环，使用continue语句终止当前的循环
{%endright%}
```
switch（expression）
	{
    case expression_n：
	  statement；
      break；
    default：
      statement；
      break；
	}
```

#### 3.4跳转语句
>当执行到**跳转语句**时，会**跳转**到**标号**处
{%list%}
标签就是标识符后面加一个冒号
{%endlist%}
{%warning%}
非必要不使用goto语句
{%endwarning%}
{%right%}
可以通过goto语句跳出嵌套循环
{%endright%}
```
biaoqian:
goto biaoqian;
```

### 4.操作符
#### 4.1基本操作符
**①算术操作符**
>**加**`+`、**减**`-`、**乘**`*`、**除**`/`、**取余**`%`
{%list%}
/操作符只有当两个操作数都为整型时，才做整型运算，%只能接受两个整型
{%endlist%}
**②关系操作符**
>**大于**`>`、**小于**`<`、**大于等于**`>=`、**小于等于**`<=`、**不等于**`!=`、**等于**`==`
{%warning%}
注意==和赋值符号=的区别
{%endwarning%}
**③逻辑操作符**
>**与**`&&`、**或**`||`、**异或**`^`、**非**`！`
{%list%}
短路求值：通过第一个操作数能判断结果就不会判断后面的操作数，且要求操作数均为整数
{%endlist%}
**④赋值操作符**
>**基本赋值操作符**：`=`，**赋值表达式语句**的**返回值**是**左操作数的新值**，所以可以**连等**`a=b=10`
{%list%}
在复制操作符左边的标识符称为左值，右边的称为右值
{%endlist%}
{%right%}
左值相当于一个容器，可以储存结果的地方，一个内存位置，右值则是一个可以被储存的数据
{%endright%}
>**变量**`a`可以表示一个**容器**，也可以表示一个**数据**，`a+1`只能是一个**数据**
{%warning%}
左值是一个确切知道地址的容器
{%endwarning%}
>**复合赋值符**：比如`+=`，`a += （expression）`代表` a = a+（expression）`
{%right%}
当a比较复杂或者其中有需要编译器实时计算的项，采用复合赋值符可以提高效率
{%endright%}

**⑤逗号操作符**
>`expression1,expression2,...,expressionN`,`expression`都会被求值，但是**整个表达式的值**是**最后一个表达式**的值

**⑥条件操作符**
>`expression1 ？ expression2 ： expression3`：如果`expression1`值为**真**，则该**表达式结果**为`expression2`，反之为`expression3`

**⑦单目操作符**
>**取址**`&`、**引用**`*`、**判断类型长度**`sizeof()`、**求补码**`~`、**递增/减**`++/--`
{%list%}
++/--为前缀时，先递加/减，再进行相关操作，为后缀时，先进行相关操作，再递加/减
{%endlist%}
{%wrong%}
强制类型转换的优先级非常高
{%endwrong%}

#### 4.2位操作符
**①移位操作符**
>**左移`<<`**：**左边**的几位被**丢弃**，**右边**多出来的几位**由0补齐**

>**右移`>>`**：有**两种**移位方案，一种是**逻辑移位**，用**0**补充，一种是**算数移位**，使用**符号位（最高位）**补全
{%list%}
对于无符号数，采用的都是逻辑移位，对于有符号数，则取决于编译器，这可能会影响程序的移植性
{%endlist%}
{%warning%}
两边的操作数都必须是整型，需要移动的位数必须正数，且不能超过被操作数的位数
{%endwarning%}

**②逻辑位操作符**
>对操作数的**各个位**执行**逻辑运算**，**与**`&`、**或**`|`、**异或**`^`
{%list%}
位操作符优先级比移位操作符高
{%endlist%}
{%right%}
value = value | 1 << bit_number;即将bit_number对应位置转换为1
{%endright%}

#### 4.3类型转换
**①隐式类型转换**
>当**操作数**为**字符型**和**短整型**时，使用之前会先被**转化为普通整型**再进行运算，结果是**普通整型**，若将**结果**存储到**字符型**和短**整型**中，则会**截短**

{%list%}
在C中的整型算数运算总是以缺省整型类型精度进行的
{%endlist%}
**②算数转换**
>当**多操作数**进行**运算**时，且操作数属于**不同的类型**，则会**将精度低的数据类型转化为精度高的数据类型进行运算**
{%list%}
防止数据丢失
{%endlist%}
**③强制类型转换**
>`(类型) [操作数/表达式]`
{%warning%}
在16位机器上，第三个算式可能会产生溢出，可以在运算前将 a、b中的一个或者两个转化为long即可
{%endwarning%}
```
int a = 5000；
int b = 25；
long c = a*b；
```
{%warning%}
强制类型转换可能会导致精度的损失，因为位数不同
{%endwarning%}
#### 4.4优先级和结合性
**①优先级**
>标识**运算符**在表达式中的**运算顺序**

**②结合性**
>当一个**运算对象两侧**运算符的**优先级别相同时**, **运算对象**与**运算符**的**结合顺序**

>如`*a++`，其中`*`和`++`为**同一优先级**，结合性为**从右到左**，先进行`a++`，再进行`*(a++)`
{%warning%}
表达式的求值顺序不一定完全按照优先级和结合性，面对有副作用的操作符需要小心
{%endwarning%}
>如`c + --c`，`c`**是否**在执行了`--c`后再**与其相加**,结果**取决于编译器**










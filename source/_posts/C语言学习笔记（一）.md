---
title: C语言学习笔记（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - C语言
  - 《C和指针》        
categories: 编程语言
keywords: 文章关键词
updated: ''
date:
img: /medias/featureimages/0.webp
summary: C语言基础
---
# C语言学习笔记（一）
## C语言启蒙
### 1.引言
#### 1.1程序框架
**①预处理命令**
>`#include <xx.h>`：将**对应文件内容**逐字写到**对应位置**，**常用的库**有`stdio.h`和`stdlib.h`
{%right%}
如果一些函数声明/全局变量需要经常使用，可以将其写到一个头文件中，再将该头文件写入
{%endright%}
>`#define [变量] [值]`：将**宏变量**替换为**对应值**
{%list%}
define还可定义宏，类似于函数，暂不介绍
{%endlist%}
**②main函数**
>**概述**：程序执行的**起点**和**终点**，包含**一系列执行语句**
{%list%}
程序无误时返回0，否则返回其他非0值，用于指明错误类型，由系统定义，在errno头文件中
{%endlist%}
{%right%}
Unix系统中，可以采用echo $?查看程序返回状态
{%endright%}
```c
#include<stdio.h>
#include<stdlib.h>

int main (void)
{
  statement;
  return 0;
}
```
**③注释**
>**单行注释**：以`//`开始、以**换行符**结束

>**多行注释**：以`/*`开始，以`*/`结束
{%right%}
对于多行注释内的每一行，以*开头指示其也为注释，是一种良好的编程风格
{%endright%}
{%wrong%}
多行注释不能嵌套，第一个/*到第一个*/之间都视为注释，所以后期注释代码段通常采用单行注释或者预处理注释
{%endwrong%}
>**预处理注释**：用于注释**包含注释**的代码块
```c
#if 0
  statement
#endif
```

#### 1.2C程序内存分布
**①代码段**
>**概述**：存放**程序执行代码**的内存区域，也包括一些**只读的常量**，在**程序运行前**就已经确定

**②数据段**
>**初始化数据段**：存放**已初始化的全局变量**，在进程运行时**静态分配**

>**未初始化数据段**：存放程序中**未初始化的全局变量**和**静态变量**，默认为`0`，在进程运行时**静态分配**

**③堆栈**
>**栈**：存放**自动变量**以及**函数调用时所需的信息**，按内存地址**由高到低**扩张，最大长度**编译时确定**
{%list%}
每次函数调用，都会创建一个新的栈帧存放函数返回地址、寄存器等的值
{%endlist%}
{%right%}
栈的分配由编译器完成，所以栈的分配和释放操作快于堆
{%endright%}
>**堆**：按内存地址**由低到高**方向扩张，其长度由**系统内存/虚拟内存上限**决定，通常在堆中进行**动态存储分配**
{%list%}
进程的每个线程都会有自己的栈，但是堆空间是共用的。
{%endlist%}
{%warning%}
自动变量因为其地址只有在其创建时确定，故其缺省情况下的初始值是垃圾
{%endwarning%}
![C程序内存分布](/image/C_2.png)

#### 1.3 基本内置类型
**①引言**
>**整型**：**字符**`char`、**短整型**`short`、**整型**`int`、**长整型**`long`

>**浮点类型**：**单精度浮点数**`float`、**双精度浮点数**`double`、**扩展精度浮点数**`long double`
{%list%}
字节为计算机最小寻址单元，通常为8比特；字为计算机的最小存储单元，通常为4字节或8字节
{%endlist%}
{%right%}
内置数据类型的尺寸在不同机器上有所差异，只规定了其最小值和大小关系
{%endright%}
**②分类**
>**字符**：大小和**机器字节**相同，通常是**8位**
{%list%}
还有一些字符类型用于扩展字符集，如char_32t位Unicode字符集服务
{%endlist%}
>**整型**：`int`位数由**编译器决定**，通常是这种机器**最为高效的位数**，规定长度上**长整型≥整型≥短整型**
{%list%}
int、short至少为16位，long至少为32位，在C11的标准中追加stdint.h避免了位数的不确定性
{%endlist%}
>如`int32_t`长度为**4个字节**，`int8_t`就是**一个字节**
{%right%}
C语言还定义了枚举类型，本质上是一种命名的int类型
{%endright%}
>**格式**：`enum 枚举类型名{枚举1,枚举2,枚举3…} ；`
{%list%}
如果不对枚举进行赋值，则枚举从0开始，依次增大1，如果对某些枚举赋值，则没有被赋值的枚举比前者大1
{%endlist%}
>**浮点类型**：通常`float`长度为一个字，`double`长度为两个字，`long double`长度为3-4个字
{%list%}
规定长度上long double≥doubl≥float
{%endlist%}
{%right%}
只有某些机器支持扩展精度，通常采用double进行浮点数表示
{%endright%}
**③有符号数和无符号数**
{%list%}
仅对整型具有意义
{%endlist%}
>对于`int`、`short int`、`long int`来说，**缺省情况**下为**有符号数**

>对于`char`来说，分为`char`、`singed char`和`unsigned char`，其中`char`的带符号与否**取决于编译器**
{%list%}
为了提高程序的可移植性，需要将char限制为正，且只对显式声明为有符号数和无符号数的char进行数值运算
{%endlist%}
{%warning%}
有符号数与无符号数进行运算，有符号数会被转化为无符号数，且结果也为无符号数
{%endwarning%}
>若有符号数为**正数**，则转换后**大小不变**，若为**负数**，则相当于**加上2^n**
{%right%}
无符号数a、b相互比较时，应该使用a>b，而不是a-b>0，因为运算结果为无符号数，无符号数永远大于0
{%endright%}
**④字面值**
>**定义**：**没有赋予给变量**的数据，有**整型字面值**、**字符型字面值**、**字符串字面值**和**浮点数字面值**
{%warning%}
字面值的地址有编译器分配，且不能改变
{%endwarning%}
{%right%}
字面值类型可以用前缀或者后缀修改字面值的数据类型
{%endright%}
>**整型字面值**：若其为**十进制**，则为**带符号数**，若其为**八/十六进制**，则可能为**有符号数和无符号数**
{%list%}
缺省情况下，整型字面值为可以容纳其数值的最小尺寸数据类型，如十进制字面值从int和long中选取
{%endlist%}
{%right%}
严格来说，整型字面值均为正值，-42表示给42整型字面值加上负号
{%endright%}
{%warning%}
short类型没有对应的字面值
{%endwarning%}
>**浮点数字面值**：**缺省**类型为`double`，可采用**科学计数法**，如`3.14e0`

>**字符/字符串型字面值**：**前者**用`''`包围，**类型**为`char`，**后者**用`""`包围，本质上是`char`**数组**
{%list%}
字面值的类型可以通过对其添加前缀/后缀进行修改，详细见《C++ primer》p37
{%endlist%}
**⑤类型转换**
>**整型提升**：表达式中，**比`int`类型小的整型值**首先会被提升为**较大的整数类型**
{%list%}
如char、unsigned char和short等，一般会被提升为int，如果int不能容纳，则转换为unsigned int等
{%endlist%}
>**算数转换**：当**多操作数**进行**运算**时，且操作数属于**不同的类型**，会将**所有对象**转化为**其中最宽的类型**
{%list%}
如int对象和double对象进行运算，int会被转化为double类型再进行运算，以防精度丢失
{%endlist%}
>**赋值转换**：**赋值语句**的**右侧运算对象**会转化为**左侧运算对象类型**

>**强制类型转换**：`(类型) [操作数/表达式]`，可能会导致**精度丢失**
{%warning%}
在16位机器上，第三个算式可能会产生溢出，可以在运算前将 a、b中的一个或者两个转化为long即可
{%endwarning%}
```
int a = 5000；
int b = 25；
long c = a*b；
```

***

### 2.变量
#### 2.1引言
**①声明与定义**
>**声明**：**表明**变量的**类型和名字**
{%list%}
若一源文件中只有变量的声明，则会去别的地方寻找该变量的定义
{%endlist%}
>**定义**：为变量**分配存储空间**，还可为变量**指定初始值**
{%list%}
使用extern修饰且不显示初始化变量即声明而非定义该变量，其余情况下均为定义
{%endlist%}
{%warning%}
变量可以声明多次，而只能定义一次
{%endwarning%}


**②格式**
>`[说明符] [声明符]`：**说明符**用于指明变量的**数据类型**、**存储类型**和**作用域**，**说明符**用于**命名变量**并对其**赋值**
{%list%}
一个变量的数据类型决定了对应比特流的解释方式以及其能参与的运算
{%endlist%}
{%right%}
变量的声明可以理解为，变量通过声明表达式的运算得到说明符
{%endright%}
>如`int a[]`可以理解为**变量`a`**通过**下标运算**得到一个**整数**，则`a`就是一个**数组**

**③typedef**
{%list%}
只要在变量声明前面加上typedef，就成了类型定义，对应变量名即称为新的类型名
{%endlist%}
>如`typedef int (*function_t) (int param);`，在这里`function_t`则成为了**对应的函数指针的类型名**
{%warning%}
与define不同，define只是简单的替换，可能会导致歧义
{%endwarning%}
>如下，`a`被**定义**为一个**字符指针**，而`b`被**定义**为一个**字符**
```c
#define char* ptr_to_char
ptr_to_char a,b;
```
{%wrong%}
在进行句法分析的时候，typedef和存储类型指示符是等价的，故该关键词不能和static等存储类型指示符一起用
{%endwrong%}

#### 2.2属性
**①作用域**
>**代码块作用域**：**代码块中**变量的作用域，**于代码块开头开始，到代码块结尾结束**
{%list%}
非嵌套的代码块，每个代码块的变量无法被另一个代码块访问，代码块之间变量隔离
{%endlist%}
{%right%}
在ANSI C中，函数形参的作用域在函数最外层代码块内（动态变量）
{%endright%}
{%warning%}
嵌套的代码块中，同名变量会覆盖外层变量，包括全局变量
{%endwarning%}

>**文件作用域**：在**代码块外**声明的变量都具有**文件作用域**，从他们**声明之处到所处源文件结尾**都可以访问
{%list%}
使用include包含到该文件的变量属于文件作用域
{%endlist%}
{%right%}
也称为extern属性，缺省情况下相当于有extern修饰
{%endright%}

>**原型作用域**：只适用于**函数原型（不是函数定义）**中声明的参数名，只存在**那个括号**内

>**函数作用域**：只适用于**语句标签**，一个函数中所有**语句标签必须唯一**

**②链接属性**
{%list%}
变量的链接属性决定如何处理在不同文件中的同名变量
{%endlist%}
>**`none`**：只能在其**所在代码块中**被访问

>**`internal`**：**同一个源文件**中的所有同名变量都是同一个实体，可以在**该源文件**中被访问

>**`external`**：**所有源文件**的所有同名变量是**同一个实体**，可以**被所有源文件访问**

{%list%}
在缺省情况下，在代码块外的链接属性为external，其余none
{%endlist%}
{%right%}
拥有extern属性的变量在单个源文件中，从头到尾都可以访问，在有多个源文件时，其他源文件也可以访问
{%endright%}
{%warning%}
external属性变量只是能被其他源文件访问，若要使用，还需要在该文件中声明该变量
{%endwarning%}
{%wrong%}
在多个文件中定义同名的全局变量会导致链接错误
{%endwrong%}

**③存储类型**
>**静态变量**：在**代码块之外**声明的变量
{%list%}
在程序运行之前创建，在程序的整个执行期间始终存在
{%endlist%}
{%warning%}
无法改变静态变量的存储类型
{%endwarning%}

>**动态变量**：在**代码块内**声明的变量
{%list%}
存储在堆栈中，当程序执行流到达该代码块时，才被创建，执行流离开该代码块时，该变量被销毁
{%endlist%}
{%warning%}
当该代码块重复执行时（比如循环）内存位置不固定
{%endwarning%}

>**寄存器变量**：使用`register`可以将**动态变量**转化为**寄存器变量**，**访问效率更高**
{%list%}
寄存器变量是一种请求，编译器可能忽略该请求，同时，当寄存器数量不足时，寄存器变量会为自动变量
{%endlist%}
{%right%}
可以把高频使用的变量声明为寄存器变量，寄存器变量的生命周期和动态变量相同
{%endright%}
{%warning%}
只要声明为寄存器变量，就不能对其取址
{%endwarning%}

#### 2.3修饰符
**①`static`**
>**代码块外变量**：改变其**链接属性**，变为`internal`

>**代码块内变量**：改变其**存储类型**，由**动态变量**变为**静态变量**
{%list%}
用static将动态变量转化为静态变量，其作用域不会改变，原先的值也不会改变
{%endlist%}
{%warning%}
static不能修饰形参
{%endwarning%}

**②`extern`**
>**概述**：给**变量**赋予`external`链接属性，**所有源文件都能访问该变量**
{%list%}
全局变量自带extern修饰
{%endlist%}
{%warning%}
若变量已经有链接属性，则extern修饰符无效
{%endwarning%}
{%wrong%}
在函数体内部初始化一个extern修饰的变量将引发错误
{%endwrong%}
**③`const`**
>**概述**：`const`修饰的变量**必须被初始化**且之后**不能更改**，编译器会将`const`对象替换为**对应的值**
{%list%}
缺省情况下const对象只在对应文件内可见，想在一个文件中定义且在其他文件中使用该变量，需要使用extern修饰
{%endlist%}
```c
//file_1.cc中定义并初始化一个const常量
extern const int buf_size = size_of_buf();
//file_1.h头文件
extern const int buf_size;
```
{%right%}
函数中被const修饰的形参获得对应的实参的值后无法被改变，不希望函数改变该值时，可以使用const修饰该形参
{%endright%}
{%warning%}
const只能用于允许使用变量的地方，不允许使用变量的地方比如数组的大小，可以使用define
{%endwarning%}

### 3.语句
#### 3.1表达式语句
**①定义**
>**概述**：由**运算对象**和**操作符**构成，如`1+1`
{%list%}
每个表达式语句都有其返回值，但是没有其他操作的情况下，该返回值不被保存
{%endlist%}
>**空语句**：本身**只包含一个分号**，用于**不需要操作**但是**语法要求**出现**一条完整语句**的场合
{%warning%}
空语句不需要的时候不要使用，尤其是在控制流中
{%endwarning%}
>**代码块**：被**一对花括号**囊括的**语句**，在语法上相当于**一条语句**

**②基本操作符**
>**算术操作符**：**加**`+`、**减**`-`、**乘**`*`、**除**`/`、**取余**`%`
{%list%}
/操作符只有当两个操作数都为整型时，才做整型运算，%只能接受两个整型
{%endlist%}

>**关系操作符**：**大于**`>`、**小于**`<`、**大于等于**`>=`、**小于等于**`<=`、**不等于**`!=`、**等于**`==`
{%warning%}
注意==和赋值符号=的区别
{%endwarning%}

>**逻辑操作符**：**与**`&&`、**或**`||`、**异或**`^`、**非**`！`
{%list%}
短路求值：通过第一个操作数能判断结果就不会判断后面的操作数，且要求操作数均为整数
{%endlist%}

>**赋值操作符**：**基本赋值操作符**`=`以及各种**复合赋值符**如`+=`，`a += （expression）`代表` a = a+（expression）`
{%list%}
在赋值操作符左边的标识符称为左值，右边的称为右值
{%endlist%}
{%right%}
左值相当于一个容器，可以储存结果的地方，一个内存位置，右值则是一个可以被储存的数据
{%endright%}
>**变量**`a`可以表示一个**容器**，也可以表示一个**数据**，`a+1`只能是一个**数据**
{%warning%}
左值是一个确切知道地址的容器
{%endwarning%}

>**逗号操作符**：`expr1,expr2,...,exprN`,`expr`都会被求值，但是**整个表达式的值**是**最后一个表达式**的值

>**条件操作符**：`expr1 ? expr2 : expr3`：如果`expr1`值为**真**，则该**表达式结果**为`expr2`，反之为`expr3`

>**单目操作符**：**取址**`&`、**引用**`*`、**判断类型长度**`sizeof()`、**求补码**`~`、**递增/减**`++/--`
{%list%}
++/--为前缀时，先递加/减，再进行相关操作，为后缀时，先进行相关操作，再递加/减
{%endlist%}
{%right%}
++/--优先选择其前置形式，因为后置形式还需要将原始值保留以返回
{%endright%}
{%warning%}
sizeof()返回的是以字节为单位的无符号整型size_t，sizeof(*p)，p不必是一个有效指针，因为不会对其进行解引用
{%endwarning%}
**③位操作符**
>**左移`<<`**：**左边**的几位被**丢弃**，**右边**多出来的几位**由0补齐**

>**右移`>>`**：有**两种**移位方案，一种是**逻辑移位**，用**0**补充，一种是**算数移位**，使用**符号位（最高位）**补全
{%list%}
对于无符号数，采用的都是逻辑移位，对于有符号数，则取决于编译器，这可能会影响程序的移植性
{%endlist%}
{%warning%}
两边的操作数都必须是整型，需要移动的位数必须正数，且不能超过被操作数的位数
{%endwarning%}

>**逻辑位操作符**：对操作数的**各个位**执行**逻辑运算**，**与**`&`、**或**`|`、**异或**`^`
{%list%}
位操作符优先级比移位操作符高
{%endlist%}
{%right%}
value = value | 1 << bit_number;即将bit_number对应位置转换为1
{%endright%}
**④操作符属性**
>**优先级**：标识**运算符**在表达式中的**运算顺序**
{%right%}
可以使用小括号无视优先级改变运算顺序
{%endright%}
>**结合性**：当一个**运算对象两侧**运算符的**优先级别相同时**, **运算对象**与**运算符**的**结合顺序**

>如`*a++`，其中`*`和`++`为**同一优先级**，结合性为**从右到左**，先进行`a++`，再进行`*(a++)`

>**求值顺序**：**优先级**和**结合性**只规定了**运算对象**的**组合方式**，并没有**规定其求值顺序**
{%list%}
只有&&、||、,和:?运算符规定了求值顺序，其余运算符的求值顺序由编译器决定
{%endlist%}
{%warning%}
对于一些有副作用的运算符，由于求值顺序的不同可能会导致结果是不确定的
{%endwarning%}
>如`c = c + --c`，`c`**是否**在执行了`--c`后再**与其相加**,结果**取决于编译器**

#### 3.2条件语句
**①if语句**
{%list%}
出现if嵌套时，else从句属于最靠近他的不完整的if从句
{%endlist%}
{%right%}
如果想要else忽略其最近的不完整if从句，使用代码块将对应if语句包裹起来即可
{%endright%}
{%warning%}
可以在if的expression中定义变量，但是其只在if结构内的语句中可见，其余语句如for语句，也有类似的特性
{%endwarning%}
```c
if (expression){
	statement;
	}
else if (expression){
	statement;
	}
else {
	statement；
	}
```
**②`switch`循环**
{%list%}
当执行到匹配到case语句后，执行流会一直往下直到switch语句结束，包括default子句
{%endlist%}
{%right%}
switch类似于有条件的goto语句，在每个case语句下添加break及时退出，break可以直接退出switch语句
{%endright%}
{%warning%}
switch语句的expression只能是整型常量表达式
{%endwarning%}
```cpp
switch (expression)
	{
    case expression_n：
	  statement；
      break；
    default：
      statement；
      break；
	}
```
**③跳转语句**
>`goto [标签]`：当执行到**跳转语句**时，会**跳转**到**标号**处
{%list%}
标签就是标识符后面加一个冒号，且与其他实体的名字不会相互干扰
{%endlist%}
{%right%}
可以通过goto语句跳出嵌套循环
{%endright%}
{%warning%}
非必要不使用goto语句，且不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置，switch语句类似
{%endwarning%}
```c
goto end;//错误，跳过了a的定义
int a = 1;
end:
a = 2;
```
#### 3.3循环语句
**①`while`循环**
{%list%}
定义在while条件部分和循环体内的变量，每次迭代都要被创建并销毁
{%endlist%}
{%right%}
在循环语句中，可以使用break语句永久终止循环，使用continue语句终止当前的循环
{%endright%}
```c
while (expression){
	statement;
	}
```
**②`do while`循环**
{%list%}
与while语句相比，do while语句会先执行语句然后再判断条件是否成立
{%endlist%}
{%warning%}
注意最后需要加上一个分号
{%endwarning%}
```c
do{
	statement;
	}while(expression);
```
**③`for`循环**
{%list%}
初始化语句在循环一开始执行，条件语句在每一次循环开始之前执行，调整语句在每一次循环后执行
{%endlist%}
```c
for （初始化语句; 条件语句;调整语句）{
	statement;
	}
```











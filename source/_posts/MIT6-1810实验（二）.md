---
title: MIT6.1810实验（二）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 系统调用实现
---
①⑤
# MIT6.1810实验（二）
## MIT6.1810 Lab2
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：Lab2的工作实际上就是要**添加两个系统调用**`trace`和`sysinfo`
{%list%}
做之前记得切换到对应分支git checkout syscall
{%endlist%}
**②`trace`**
>**概述**：接受一个**整数掩码**`mask`作为参数，标识**哪些系统调用**需要被追踪
{%list%}
应当追踪当前的调用进程以及与其相关的所有子进程，每次打印的日志需要包含进程ID、系统调用名和返回值
{%endlist%}
{%right%}
掩码的二进制形式中，从右往左数哪一位是高位，则表示对应的系统调用需要被跟踪
{%endright%}
>如下，掩码`32`二进制形式为`10000`，从右往左**第五位**为`1`，则`read`系统调用被跟踪

```nasm
// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
```
**③`sysinfo`**
>**概述**：接收一个指向`sysinfo`**结构体**的指针，用于收集正在运行的系统的**相关信息**
{%list%}
如下所示，freemem为空闲内存的字节数，nproc为状态不为UNUSED的进程数量
{%endlist%}
{%right%}
本次Lab创建了一个user/sysinfotest.c的UNIX程序以供测试
{%endright%}
```c
struct sysinfo {
  uint64 freemem;   // amount of free memory (bytes)
  uint64 nproc;     // number of process
};
```
**④实验结果**
>**测试准备**：**主目录**添加`time.txt`和`answers-syscall.txt`，随后`make qemu`，退出`make grade`即可
{%list%}
两个txt前者填写花费的时间数，后者填写对于这个lab的疑问
{%endlist%}
![测试结果](/image/MIT.6.1810_Lab2.png)
#### 1.2Xv6系统调用
**①用户态**
>**声明**：`Xv6`系统调用声明在`user/user.h`中，当使用某个系统调用，会跳转到`user/usys.S`**特定位置**处
{%list%}
如下为user/usys.S的fork部分的代码
{%endlist%}
>**进入内核态**：对应代码会将**系统调用编号**写入**a7寄存器**中并调用`ecall`进入**内核态**
{%list%}
系统调用编号实质上是是小整型，详细见kernel/syscall.h
{%endlist%}
{%right%}
usys.S是通过脚本文件user/usys.pl生成的，添加系统调用在该文件中添加对应entry即可
{%endright%}
```nasm
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
```
```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}
	
entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
```
**②中断判断**
>**跳转到中断判断函数**：进入内核态就跳转到`kernel/trampoline.S`的`uservec`处，这个是**设定好的**
{%list%}
uservec处代码将用户寄存器数据保存到陷阱帧中，设置该进程的内核栈等，随后跳转到usertrap()函数
{%endlist%}
```nasm
.globl uservec
uservec:    
	#
        # trap.c sets stvec to point here, so
        # traps from user space start here,
        # in supervisor mode, but with a
        # user page table.
        #
        # sscratch points to where the process's p->trapframe is
        # mapped into user space, at TRAPFRAME.
        #
        
	# swap a0 and sscratch，使用a0寄存器保存陷阱帧地址
        # so that a0 is TRAPFRAME
        csrrw a0, sscratch, a0

        # save the user registers in TRAPFRAME
        sd ra, 40(a0)
        sd sp, 48(a0)
        sd gp, 56(a0)
        sd tp, 64(a0)
        sd t0, 72(a0)
        sd t1, 80(a0)
        sd t2, 88(a0)
        sd s0, 96(a0)
        sd s1, 104(a0)
        sd a1, 120(a0)
        sd a2, 128(a0)
        sd a3, 136(a0)
        sd a4, 144(a0)
        sd a5, 152(a0)
        sd a6, 160(a0)
        sd a7, 168(a0)
        sd s2, 176(a0)
        sd s3, 184(a0)
        sd s4, 192(a0)
        sd s5, 200(a0)
        sd s6, 208(a0)
        sd s7, 216(a0)
        sd s8, 224(a0)
        sd s9, 232(a0)
        sd s10, 240(a0)
        sd s11, 248(a0)
        sd t3, 256(a0)
        sd t4, 264(a0)
        sd t5, 272(a0)
        sd t6, 280(a0)

	# save the user a0 in p->trapframe->a0
        csrr t0, sscratch
        sd t0, 112(a0)

        # restore kernel stack pointer from p->trapframe->kernel_sp
        ld sp, 8(a0)

        # make tp hold the current hartid, from p->trapframe->kernel_hartid
        ld tp, 32(a0)

        # load the address of usertrap(), p->trapframe->kernel_trap
        ld t0, 16(a0)

        # restore kernel page table from p->trapframe->kernel_satp
        ld t1, 0(a0)
        csrw satp, t1
        sfence.vma zero, zero

        # a0 is no longer valid, since the kernel page
        # table does not specially map p->tf.

        # jump to usertrap(), which does not return
        jr t0
```
>**中断判断函数**：即`kernel/trap.c`的`usertrap`函数，用于处理来自**用户态**的**中断、异常或者系统调用**
{%list%}
如果判断执行的是系统调用，则执行响应函数syscall.c中的syscall函数
{%endlist%}
```c
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(p->killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sstatus &c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }

  if(p->killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```
**③系统调用执行**
>**概述**：在`kernel/syscall.c`中，根据**a7寄存器**保存的编号执行对应的**系统调用函数**
{%list%}
对应系统调用函数如sys_fork存储在kernel/sysproc.c中
{%endlist%}
```c
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
};

void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```
>**参数读取**：有些**系统调用**需要从**陷阱帧**中读取**用户传递的参数**，如`wait`，对应**系统调用函数**如下
```c
uint64 sys_wait(void) {
    uint64 p;
    if (argaddr(0, &p) < 0) return -1;
    return wait(p);
}
```
```c
static uint64 argraw(int n) {
    struct proc *p = myproc();
    switch (n) {
        case 0:
            return p->trapframe->a0;
        case 1:
            return p->trapframe->a1;
        case 2:
            return p->trapframe->a2;
        case 3:
            return p->trapframe->a3;
        case 4:
            return p->trapframe->a4;
        case 5:
            return p->trapframe->a5;
    }
    panic("argraw");
    return -1;
}

// Fetch the nth 32-bit system call argument.
int argint(int n, int *ip) {
    *ip = argraw(n);
    return 0;
}

// Retrieve an argument as a pointer.
// Doesn't check for legality, since
// copyin/copyout will do that.
int argaddr(int n, uint64 *ip) {
    *ip = argraw(n);
    return 0;
}

// Fetch the nth word-sized system call argument as a null-terminated string.
// Copies into buf, at most max.
// Returns string length if OK (including nul), -1 if error.
int argstr(int n, char *buf, int max) {
    uint64 addr;
    if (argaddr(n, &addr) < 0) return -1;
    return fetchstr(addr, buf, max);
}
```
>**系统调用核心功能**：以`fork`为例，**系统调用函数**实际上还是需要调用对应**核心函数**完成工作
{%list%}
sys_fork的核心函数在kernel/proc.c中
{%endlist%}
```c
uint64 sys_fork(void) { return fork(); }
```
```c
// Create a new process, copying the parent.
// Sets up child kernel stack to return as if from fork() system call.
int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // Allocate process.
  if((np = allocproc()) == 0){
    return -1;
  }

  // Copy user memory from parent to child.
  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
    freeproc(np);
    release(&np->lock);
    return -1;
  }
  np->sz = p->sz;

  // copy saved user registers.
  *(np->trapframe) = *(p->trapframe);

  // Cause fork to return 0 in the child.
  np->trapframe->a0 = 0;

  // increment reference counts on open file descriptors.
  for(i = 0; i < NOFILE; i++)
    if(p->ofile[i])
      np->ofile[i] = filedup(p->ofile[i]);
  np->cwd = idup(p->cwd);

  safestrcpy(np->name, p->name, sizeof(p->name));

  pid = np->pid;

  release(&np->lock);

  acquire(&wait_lock);
  np->parent = p;
  release(&wait_lock);

  acquire(&np->lock);
  np->state = RUNNABLE;
  release(&np->lock);

  return pid;
}
```
### 2.具体实现
#### 2.1用户态
**①声明**
>**概述**：在`user/user.h`中加入**对应声明**
{%list%}
同时需要添加sysinfo结构体的声明
{%endlist%}
```c
struct stat;
struct sysinfo;

// system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(const char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);
int trace(int);
int sysinfo(struct sysinfo *);
```
**②入口**
>**概述**：在`user/usys.pl`中设置**对应入口**
```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}
	
entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("trace");
entry("sysinfo");
```
**③Makefile修改**
>**概述**：lab本身提供了`trace`和`sysinfotest`程序以便于测试，需要将其加入`makefile`中编译
```makefile
UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\
	$U/_pingpong\
	$U/_primes\
	$U/_find\
	$U/_xargs\
	$U/_trace\
	$U/_sysinfotest\
```

#### 2.2内核态设置
**①添加编号**
>**概述**：在`kernel/syscall.h`中设置**对应编号**
```c
// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_trace  22 
#define SYS_sysinfo 23
```
**②设置映射**
>**概述**：在`kernel/syscall.c`中设置**系统调用的映射**
{%list%}
在kernel/syscall.c中添加对应字符串数组，便于trace打印
{%endlist%}
```c
//系统调用编号与其名字的映射数组
char *syscalls_name[24] = {
    "",      "fork",  "exit",   "wait",   "pipe",  "read",  "kill",   "exec",
    "fstat", "chdir", "dup",    "getpid", "sbrk",  "sleep", "uptime", "open",
    "write", "mknod", "unlink", "link",   "mkdir", "close", "trace","sysinfo"};
// Prototypes for the functions that handle system calls.
extern uint64 sys_fork(void);
extern uint64 sys_exit(void);
extern uint64 sys_wait(void);
extern uint64 sys_pipe(void);
extern uint64 sys_read(void);
extern uint64 sys_kill(void);
extern uint64 sys_exec(void);
extern uint64 sys_fstat(void);
extern uint64 sys_chdir(void);
extern uint64 sys_dup(void);
extern uint64 sys_getpid(void);
extern uint64 sys_sbrk(void);
extern uint64 sys_sleep(void);
extern uint64 sys_uptime(void);
extern uint64 sys_open(void);
extern uint64 sys_write(void);
extern uint64 sys_mknod(void);
extern uint64 sys_unlink(void);
extern uint64 sys_link(void);
extern uint64 sys_mkdir(void);
extern uint64 sys_close(void);
extern uint64 sys_trace(void);
extern uint64 sys_sysinfo(void);
// An array mapping syscall numbers from syscall.h
// to the function that handles the system call.
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_trace]   sys_trace,
[SYS_sysinfo] sys_sysinfo,
};
```
#### 2.3`trace`核心功能
**①`proc`结构修改**
>**概述**：在`kernel/proc.h`中的`proc`结构体中加入变量`mask`，以便传递给**子进程**
{%list%}
后续该进程每次调用任何系统调用时，将其编号和proc结构中的mask进行对比，如果匹配则打印日志
{%endlist%}
```c
// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
  int mask;                    // Tracing mask
};
```
**②具体实现**
>**概述**：在`kernel/sysproc.c`中添加`sys_trace`，并在`kernel/proc.c`中添加对应**核心函数**
{%list%}
可知trace系统调用最主要就是需要修改进程proc结构的mask变量
{%endlist%}
{%right%}
sys_trace中argint用法参照sys_kill即可
{%endright%}
{%warning%}
还需要在kernel/defs.h的proc.c部分中加入对应声明
{%endwarning%}
```c
uint64
sys_kill(void)
{
  int pid;

  argint(0, &pid);
  return kill(pid);
}
uint64
sys_trace(void){
  int mask;

  argint(0,&mask);
  
  return trace(mask);
}
```
```c
int trace(int mask){
  struct proc *p = myproc();
  p->mask = mask;
  return 0;
}
```
```c
// proc.c
int             cpuid(void);
void            exit(int);
int             fork(void);
int             growproc(int);
void            proc_mapstacks(pagetable_t);
pagetable_t     proc_pagetable(struct proc *);
void            proc_freepagetable(pagetable_t, uint64);
int             kill(int);
int             killed(struct proc*);
void            setkilled(struct proc*);
struct cpu*     mycpu(void);
struct cpu*     getmycpu(void);
struct proc*    myproc();
void            procinit(void);
void            scheduler(void) __attribute__((noreturn));
void            sched(void);
void            sleep(void*, struct spinlock*);
void            userinit(void);
int             wait(uint64);
void            wakeup(void*);
void            yield(void);
int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
void            procdump(void);
int             trace(int);
```
**③其他处理**
>**`fork`函数修改**：根据题意，**父进程创建子进程**时需要传递`mask`变量
{%list%}
fork函数定义在kernel/proc.c中
{%endlist%}
```c
// Create a new process, copying the parent.
// Sets up child kernel stack to return as if from fork() system call.
int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // Allocate process.
  if((np = allocproc()) == 0){
    return -1;
  }

  // Copy user memory from parent to child.
  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
    freeproc(np);
    release(&np->lock);
    return -1;
  }
  np->sz = p->sz;

  // copy saved user registers.
  *(np->trapframe) = *(p->trapframe);

  // Cause fork to return 0 in the child.
  np->trapframe->a0 = 0;

  // increment reference counts on open file descriptors.
  for(i = 0; i < NOFILE; i++)
    if(p->ofile[i])
      np->ofile[i] = filedup(p->ofile[i]);
  np->cwd = idup(p->cwd);

  safestrcpy(np->name, p->name, sizeof(p->name));

  pid = np->pid;
  //将mask复制给子进程
  np->mask = p->mask;

  release(&np->lock);

  acquire(&wait_lock);
  np->parent = p;
  release(&wait_lock);

  acquire(&np->lock);
  np->state = RUNNABLE;
  release(&np->lock);

  return pid;
}
```
>**`syscall`函数修改**：根据题意，`syscall`**获得系统调用编号**之后，需要将其与**掩码**对比，并进行**对应打印操作**
{%list%}
syscall函数定义在kernel/syscall.c中
{%endlist%}
```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    // Use num to lookup the system call function for num, call it,
    // and store its return value in p->trapframe->a0
    p->trapframe->a0 = syscalls[num]();
    if(p->mask>>num & 1){
      printf("%d: syscall %s -> %d\n",p->pid, syscalls_name[num], p->trapframe->a0);
    }
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```
#### 2.4`sysinfo`核心功能
**①内存查询**
>**概述**：由`kalloc.c`文件可知，操作系统维护了一个**空闲内存链表**`kmem`，在其中添加**以下函数**即可
{%warning%}
查询内存过程中需要对kmem上锁，防止其他进程修改
{%endwarning%}
```c
struct run {
  struct run *next;
};

struct{
  struct spinlock lock;
  struct run *freelist;
}kmem;
```
```c
uint64
get_free_mem(void){
  struct run *r;
  uint64 count = 0;
  acquire(&kmem.lock); //上锁，以防其他程序对kmem进行修改
  r = kmem.freelist;
  //遍历空闲链表
  while(r){
    count++;
    r = r->next;
  }
  release(&kmem.lock); //解锁
  return count*PGSIZE;
}
```
**②进程查询**
>**概述**：`kernel/proc.c`可见一`proc`数组，即**进程队列**，依次查询即可
{%warning%}
同上，新添加的get_free_mem和used_proc_num也需要在kernel/defs.h中声明
{%endwarning%}
```c
struct proc proc[NPROC];//用于保存进程状态
```
```c
int
used_proc_num(void){

  struct proc *p;
  int count = 0;
  //遍历进程状态数组
  for(p = proc;p < &proc[NPROC];++p){
      acquire(&p->lock); //加锁
      if(p->state != UNUSED){ //查看状态
          count++;
      }
      release(&p->lock); //解锁
  }
  return count;
}
```
```c
// kalloc.c
void*           kalloc(void);
void            kfree(void *);
void            kinit(void);
uint64          get_free_mem(void);
// proc.c
int             cpuid(void);
void            exit(int);
int             fork(void);
int             growproc(int);
void            proc_mapstacks(pagetable_t);
pagetable_t     proc_pagetable(struct proc *);
void            proc_freepagetable(pagetable_t, uint64);
int             kill(int);
int             killed(struct proc*);
void            setkilled(struct proc*);
struct cpu*     mycpu(void);
struct cpu*     getmycpu(void);
struct proc*    myproc();
void            procinit(void);
void            scheduler(void) __attribute__((noreturn));
void            sched(void);
void            sleep(void*, struct spinlock*);
void            userinit(void);
int             wait(uint64);
void            wakeup(void*);
void            yield(void);
int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
void            procdump(void);
int             trace(int);
int             used_proc_num(void);
```
**③具体实现**
>**概述**：采用`argaddr`获取传递的**指针参数**，并使用`copyout`将`sysinfo`结构体复制回**用户空间**
{%right%}
copyout用法可参考sys_fstat() (kernel/sysfile.c)
{%endright%}
```c
uint64
sys_sysinfo(void){
  struct sysinfo info;
  struct proc *p;
  uint64 addr;
  //获取系统调用传递的指针参数
  argaddr(0,&addr);

  p = myproc();
  info.freemem = get_free_mem();
  info.nproc = used_proc_num();

  if(copyout(p->pagetable,addr,(char*)&info,sizeof(info))<0){
    return -1;
  }
  
  return 0;
}
```





---
title: 操作系统（一）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机基础
  - 操作系统
  - 《操作系统导论》
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/2.webp
date:
summary: 操作系统概述
---
# 操作系统（一）
## 操作系统概述
### 1.操作系统的启动
#### 1.1引导扇区的读入
{%list%}
以X86 PC为例（使用16位寄存器）
{%endlist%}
>开机时，PC处于**实模式**，`CS:IP`被**初始化**为`FFFFH:0000H`
{%list%}
CPU的工作模式影响CPU的寻址方式、寄存器大小等
{%endlist%}
>CPU寻址`FFFFH:0000H`，即**ROM BIOS映射区**，并**检查硬件**

>将磁盘**0磁道0扇区**读入`7C00H处`，并设置`CS:IP`为`07c0H:0000H`
{%list%}
0磁道0扇区即操作系统的引导扇区（bootsect.s），一个扇区512个字节
{%endlist%}

#### 1.2`bootsect.s`概述
>将`07C0H:0000`处的引导程序**移动**到`9000H:0000H`处，并跳转到**下一条指令移动后的位置（因为还要继续执行`bootsect.s`）**
{%list%}
将07C0H:0000到9000H:0000H这段地址空间腾出来，给操作系统使用
{%endlist%}
>利用**13号中断**读取`setup.s`**所在扇区**，以及**操作系统所在扇区**（都按顺序放在`bootsect.s`之后），并完成一些**辅助工作（如显示开机画面）**，最后跳转到`setup.s`地址入口

#### 1.3`setup.s`程序概述
>获得相关**硬件信息**，如**扩展内存大小、显卡参数**等，并存放在**某段地址中**，以便之后**操作系统的初始化**
{%list%}
实模式下寻址大小只有1M，所以要扩展内存
{%endlist%}
>将**操作系统**读入到**0地址处**（之前在`setup.s`程序后），并完成一些**准备工作**，并进入**保护模式（32位模式）**，最后跳转到**0地址处**执行**操作系统的第一个模 块**`head.s`
{%list%}
这里的准备工作包括gdt表和idt表的初始化，进入保护模式后CS根据其值查询gdt表获得32位段地址，与32位IP进行相加，获得32位地址
{%endlist%}

#### 1.4`head.s`概述
>完成一些**准备工作**（如**重新建立gdt表**和**idt表**），并进入操作系统的**main函数（通过内嵌汇编）**，进行内存等对象的**初始化并开始工作**
{%list%}
head.s变为32位汇编（GNU as汇编），内嵌汇编
{%endlist%}
***
### 2.系统调用
#### 2.1引言
>**shell实现概述**
`shell`读取**用户输入**并调用`fork()`和`exec()`这两个**系统调用**执行用户输入 
{%list%}
系统调用即由系统提供的函数接口
{%endlist%}
>**POSIX标准**：由**IEEE**制定，每个操作系统**都应该提供**类似功能的**系统调用**（如`fork()`和`open()`） 

#### 2.2内核态和用户态
{%list%}
内核态和用户态本质上是内存的不同部分，拥有不同的权限，由硬件实现
{%endlist%}
>**CPL**：**当前执行指令的特权级**，用**CS的最低两位**来表示
{%list%}
操作系统启动后即进入用户态，CPL被初始化为3，系统调用可以将其变为0
{%endlist%}
>**DPL**：当前指令**访问的目标段的特权级**，放在**GDT表**中
{%list%}
GDT表的每一个表项用于描述一个地址，机器启动时初始化
{%endlist%}
{%right%}
0是内核态，3是用户态，当CPL≤DPL时，可以访问
{%endright%}

#### 2.3陷入内核态概述
{%right%}
通过特定中断进入内核，如Linux是int 80H
{%endright%}
{%list%}
以Linux系统下调用printf函数为例
{%endlist%}
>**用户程序**调用`printf`**库函数**，`printf`**库函数**调用`write`**库函数**

>`write`通过**宏**`_syscall3`调用了`int 80H`**中断**，并根据**宏的参数**将**系统调用号等信息**传递给`int 80H`**中断**
{%list%}
给int 80H传递数据本质上是给对应的寄存器赋值
{%endlist%}
>调用中断后，读取对应的**idt表项**，并获得**对应中断处理函数**`system_call`的**起始地址**
{%right%}
80H中断idt表项的DPL为3，以便用户程序访问，system_call的CPL为0（对应CS为8），当调用system_call函数时，即已经陷入内核
{%endright%}
>`system_call`函数首先**跳转到内核的数据段和代码段**，并根据**系统调用号**在`_sys_call_table`表（**一个函数指针数组**）中查找**对应系统调用处理函数入口**，并调用该函数
***
### 3.进程和线程
#### 3.1基本概念
**①并发**
>CPU是**取指执行**，但是有些指令，如**I/O指令**，执行**非常慢**，且执行过程**不使用CPU**，可以在**等待时执行别的指令**，这就是**并发**
{%list%}
一条I/O指令执行时间为简单指令的10的六次方倍
{%endlist%}

**②进程和线程**
>**进程**：**运行中的程序**，除了**对应的程序**之外，还有**记录其信息（如各个寄存器的值、运行状态等）的结构（PCB）**以及**对应资源**
{%list%}
PCB保留了进程运行时的信息，以便于进程之间的切换，当进程1切换到进程2时，更新并保存进程1的PCB，随后读取进程2的PCB，为进程2运行布置好环境
{%endlist%}
{%right%}
不同的进程解决不同的任务，可以通过管理PCB管理进程
{%endright%}
>**线程**：一个进程可能有**多个指令执行序列**，**每个指令执行序列**就是**线程**，每个线程也有对应的**记录其信息的结构（TCB）**
{%list%}
以一个网页为例，一个线程用于从服务器接收数据，一个线程用于显示文本，一个线程用于处理图片
{%endlist%}
{%right%}
同一个进程的线程共享进程资源，故线程切换的代价较小，又保留了并发的优点
{%endright%}
**③运行状态**
![运行状态](/image/OS_1.png)

#### 3.2线程切换
{%right%}
进程的切换和线程的切换类似，只是多了内存映射的切换而已
{%endright%}
**①引言**
>**函数调用**：C语言中，当**一个函数调用另一个函数**`func(p1,p2,p3)`时，会先**向栈内压入返回地址**、`p1`、`p2`和`p3`，随后**跳转到对应函数的入口**，当函数**结束时**，**将栈内参数弹出**，返回到原来的函数继续执行
{%list%}
函数以}结束，}相当于iret指令
{%endlist%}
{%right%}
线程和进程的切换也类似于函数的调用，需要一个栈保存相关信息
{%endright%}
**②用户级线程**
{%list%}
用户级线程不需要陷入内核，没有用户级进程这一说法，因为进程必须访问计算机资源
{%endlist%}
>**线程栈**：每个线程都有**自己的线程栈**，用于实现**当前线程的函数调用**
{%warning%}
线程之间不能共用栈，因为iret只是简单的弹栈，可能会导致线程1调用的函数返回时返回到线程2中
{%endwarning%}
>**切换概述**：**切换TCB**，并**根据TCB切换线程栈**

>**创建概述**：为线程**申请内存**，创建**TCB和线程栈**，建立**线程栈和TCB的联系**

**③核心级线程**
{%list%}
有些线程需要调用计算机资源，则必须陷入内核
{%endlist%}

>**线程栈**：核心级线程除了**用户态有一个栈（用户栈）**，**内核态还有一个栈（内核栈）**，因为其**在内核态也需要调用函数**

**④核心级线程切换概述**
>当**线程1**接收到中断，**陷入内核**，**从用户栈转移到内核栈**
{%list%}
system_call将相关信息压入内核栈，如用户栈的指针，返回地址和标志寄存器，以及一段包含iret的代码
{%endlist%}
>当**线程1在内核中堵塞**，切换到**线程2的TCB和内核栈**
{%list%}
线程2即陷入内核但是因为某种原因未执行完的线程
{%endlist%}
>**线程2**在内核中完成一些**收尾工作（当然也可能再次阻塞）**，通过**内核栈的iret指令返回用户栈**

**④核心级线程创建概述**
>申请**TCB、内核栈和用户栈**的**内存空间**

>**关联TCB**和**内核栈**以及**用户栈**，**初始化内核栈**和**用户栈**
{%list%}
其中内核栈需要包含用户栈的指针以及初始返回地址
{%endlist%}

#### 3.3子进程
**①`fork()`**
{%list%}
父进程调用该系统调用创建子进程
{%endlist%}
>`fork()`调用`_copy_process`，为子进程**申请内存空间**，**创建并初始化子进程的内核栈和TCB**，**和父进程共用用户栈**，并将其`eax`值设置为`0`
{%list%}
_copy_process的参数是父进程陷入内核时压入内核栈的参数
{%endlist%}
{%right%}
fork()的返回值是eax值，为0表示其是子进程，用于和父进程区分
{%endright%}
**②子进程的运行**
{%list%}
以shell为例，假设执行ls
{%endlist%}
>`shell`**主体代码**如下
```
int main(int argc,char* argv[])
{
  while(1)
  {
    scanf("%s",cmd);
    if(!fork())
    {
      exec(cmd);
    }
    wait(0);
  }
}
```
>`shell`通过**读取用户输入创建对应子进程**，

>通过`fork()`的**返回值判断是子进程还是父进程**

>如果是**子进程**，`exec()`通过中断**进入内核**，修改**子进程的内核栈**，**中断返回后**执行的就是`ls`
{%list%}
主要是将对应pc指向ls代码初始地址，并创建子进程自己的用户栈并修改对应寄存器
{%endlist%}

#### 3.4进程调度
**①调度指标**
>**周转时间**：任务**开始**到任务**结束**

>**响应时间**：从**给出操作**到**发出响应**

>**吞吐量**：**任务时间占比**，因为系统有**内耗**，如**进程切换**也需要时间
{%list%}
进程调度的目标就是使得每个程序的指标都尽可能高，也有矛盾，如要求响应时间则表示进程切换频繁，导致系统内耗增加
{%endlist%}

**②基本调度算法**
>**SJF**：**短作业优先**
{%list%}
可以保证周转，但是无法保证响应时间
{%endlist%}
>**RR**：**按照时间片轮转调度**
{%list%}
可以保证响应时间，但是无法保证周转时间
{%endlist%}
>**优先级算法**：**动态调整优先级**
{%right%}
任务主要可分为I/O约束型（前台）和CPU约束型（后台），一般要求先满足前台的要求
{%endright%}
**③例子**
>**linux0.11**的`schedule()`函数
>找到**任务列表**中，处于**运行状态且时间片大于0的最大**的任务，如果能找到则**调度该任务**
>如果所有处于**运行状态的任务时间片都为0**，则将**所有任务**的时间片变为`（当前时间片/2）+（时间片初值）`
{%list%}
这样保证正在阻塞的程序的时间片会变得更高，使得被阻塞的程序优先级更高
{%endlist%}
{%right%}
假设一个进程的初始时间片为p，且一开始就一直阻塞，他的时间片最长也不会超过2p（p+p/2+p/4...）
{%endright%}
```
woid Schedule(void)
{
  while(1)
  {
    c = -1;
    next = 0;
    i = NR_TASKS;
    p = &task[NR_TASKS];
    while(--i)
    {
      //找到任务列表中，处于运行状态且时间片最大的任务
      if((*p->state == TASK_RUNNING)&&(*p)->COUNTER > c)
      {
        C = (*p)->counter;
        next = i;
      }
      //如果找到则调度该程序
      if(c) break;
    }
    //如果所有处于运行状态的任务时间片都为0，则将所有任务的时间片变为（当前时间片/2）+（时间片初值）
    for(p = &LAST_TASK;p > &FIRST_TASK;--p)
    (*p)->counter = ((*p)->counter>>1)+(*p)->priotity;
  }
  switch_to(next);
}
```

计算机取指执行
系统调用也被称为程序的一个标准库
虚拟化CPU：将单个CPU转化为多个虚拟CPU
虚拟化内存：每个进程都有自己的虚拟地址空间，操作系统将其映射到物理内存上
时分共享技术：让一个进程只运行一个时间片，然后切换到其他进程
进程的重要组成部分：自己的内存即地址空间，寄存器状态
进程创建：将代码和静态数据（初始化变量）加载到进程的地址空间中（从磁盘中读入）只加载需要执行的部分，为程序的运行时栈（存放返局部变量、函数参数和返回地址）和堆（动态分配）分配内存，完成一些初始化任务，跳转到main函数，然后开始执行
每个进程都有对应的进程描述符

程序是一种状态机，执行一条语句就是从一个状态转移到下一个状态
gdb vim
C语言函数调用，每次调用会产生一个新的栈帧，每个栈中含有变量和pc指针等，返回就是弹栈，C程序的状态就是堆栈的状态

递归转化为非递归？汉诺塔

对于二进制程序，状态就是内存、寄存器等的值
计算机系统基础
程序本身只是计算，需要使用系统调用syscall请求操作系统调用硬件资源退出程序等
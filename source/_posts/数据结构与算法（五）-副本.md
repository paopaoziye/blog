---
title: 数据结构与算法（四）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 计算机基础
  - 数据结构与算法
categories: 计算机基础
keywords: 文章关键词
updated: ''
img: /medias/featureimages/10.webp
date:
summary: 图结构
---
# 数据结构与算法（四）
## 图结构
### 1.图
**1.1定义**：由一个非空的有限**顶点**集合V和一个有限**边**集合E组成
**1.2表示**
①邻接矩阵：对角线为0的**对称矩阵**
![邻接矩阵](/image/sjjg_15.png)
![邻接矩阵的数组表示](/image/sjjg_16.png)
②邻接表
![邻接表](/image/sjjg_17.png)

**1.3图的连通性**
①连通：如果两个顶点之间存在一条**无向路径**，则称这两点是连通的
②连通图：图中**任意两点**均连通
③连通分量
![连通分量](/image/sjjg_20.png)

### 2.图的遍历
**2.1深度优先搜索（DFS）**
①思想：选定一个入口，挑选一个没有被访问的与之相连的节点，来到这个节点之后同样挑选一个与之相连的没有被访问的节点，如果没有则原路返回，直到返回到出口
②伪码描述
![DFS](/image/sjjg_18.png)
**2.2广度优先搜索（BFS）**
①思想：选择一个入口，将其压入队列中，弹出入口时，将与入口相连的节点压入队列中，然后弹出队列最前面的节点，并将与其相连的节点压入队列中，直到队列为空
②伪码描述
![BFS](/image/sjjg_19.png)

**2.3两种遍历方法的特点**

### 3.图的建立
**3.1邻接矩阵表示**
①结构代码
顶点结构代码
```
typedef struct GNode *PtrToNode;
struct GNode
{
  int Nv; /*定点数
  int Ne; /*边数
  WeightType G[MaxVertexNum][MaxVertexNum];
};
typedef PtrToNode MGraph;
```
边结构代码
```
typedef struct ENode *PtrToENode;
struct ENode
{
  VerTex V1,V2; /*边连接的顶点
  WeightType Weight; /*权重
}
typedef PtrToENode Edge;
```
②图的初始化（有一定顶点但是边为0）
```
typedef int Vertex; /*用顶点下标表示顶点，为整型
MGraph CreateGraph(int VertexNum)
{
  Vertex V,W;
  MGraph Graph;

  Graph = (MGraph)malloc(sizeof(struct GNode));
  Graph->Nv = VertexNum;
  Graph->Ne = 0;

  for(V = 0;V < Graph->Nv;V++)
    for(W = 0;W < Graph->Nv;W++)
      Graph->G[V][W] = 0;
  return Graph;
}
```
②边的插入
```
void InsertEdge(MGraph Graph,Edge E)
{
  Graph->G[E->V1][E->V2] = E->Weigh; 
  Graph->G[E->V2][E->V1] = E->Weigh; /*如果是有向边，则这条可以省略
}
```
③图的建立
![图的建立](/image/sjjg_21.png)
**3.2邻接表表示**
①结构代码
顶点结构
```
typedef struct GNode *PtrToGNode;
struct GNode
{
  int Nv; /*顶点数
  int Ne; /*边数
  AdjList G; /邻接表
};
```
邻接表结构
```
typedef struct Vnode
{
  PtrToAdjVNode FirstEdge;
  DataType Data; /*顶点数据
}AdjList[MaxVertexNum];
```
>该段代码将元素为`Vnode`结构的数组重命名为`AdjList`

边结构
```
typedef struct AdjVNode *PtrToAdjVNode;
struct AdjVNode
{
  Vertex AdjV; /*邻接点下标
  WeightType Weight; /*边权重
  PtrToAdjVNode Next;
};
②初始化
```
typedef int Vertex; /*定义实质为整形的顶点下标变量
LGraph CreateGraph(int VertexNum)
{
  Vertex V;
  LGraph Graph;

  Graph = (LGraph)malloc(sizeof(struct GNode));
  Graph->Nv = VertexNum;
  Graph->Ne = 0;
  for(V = 0;V < Graph->Nv;V++)
    Graph->G[V].FirstEdge = NULL;
  
  return Graph;
}
③插入边
```
void Insert(LGraph Graph, Edge E)
{
  /*建立新的邻接点
  PtrToAdjVNode NewNode;
  NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
  NewNode->AdjV = E->V2;
  NewNode->Weight = E->Weight;
  /*
  NewNode->Next = Graph->G[E->V1].FirstEdge;
  Graph->G[E->V1].FirstEdge = NewNode;
}
```

### 4.图的最短路径算法
**4.1无权图的单源最短路径算法**
①思路：从起点出发，先找到和他距离为1的**没有访问过**的节点，然后在此基础上寻找距离为2的节点，以此类推，直到找到终点

![思路](/image/sjjg_22.png)
②伪码描述
>其中`dist`数组将没访问的节点与原点的距离设置为一个负数，可以同时起到`Visited`函数作用
`path`记录的是最短路径中，当前节点的上一个节点信息

![伪码描述](/image/sjjg_23.png)
**4.2有权图的单源最短路径算法**
①思路：选定原点`s`，然后访问其**邻接点**，计算其路径长度并存储在`dist[]`中（`dist[]`记录的是原点**经过已收录点**到对应点的距离，初始值都为**正无穷**），选择一个`dist[]`**最小的未收录的点**收录，随后访问收录点的**未收录邻接点**，更新`dist[]`，在更新的过程中，要注意新收录点可能会影响其邻接点的`dist[]`，即**只经过旧收录点的路径不是最短的了**，需要更新`dist[]`和`path[]`，以此类推，直到所有点都被收录。
![Dijkstra](/image/sjjg_24.png)
②伪码描述
![伪码描述](/image/sjjg_25.png)
![时间复杂度](/image/sjjg_26.png)

**4.3多源最短路算法**
①思路
![Floyd](/image/sjjg_27.png)
②伪码描述
![伪码描述](/image/sjjg_28.png)

### 5.最小生成树
**5.1定义**
![最小生成树](/image/sjjg_29.png)
**5.2贪心算法**
![贪心算法](/image/sjjg_30.png)
**5.2prim算法**
①思路：先选择一个起点，选择其**权重最小的邻接点**并收录，随后选择**已收录点**的权重最小的邻接点，但是不能构成回路，以此类推，直到收录所有的点
②伪码描述
![伪码描述](/image/sjjg_31.png)
**5.2Kruskal算法**
①思路：选择其中**未被选择的权值最小的边**（可以是多条）将顶点连接起来，以此类推，但是在过程中不能形成回路，直到收录了V-1条边
②伪码描述
![伪码描述](/image/sjjg_32.png)
>回路的检查：一开始将所有顶点看作为独立集合，新加边就是合并集合，如果新加入的边的两边顶点已经是一个集合的了，则会形成回路

### 6.拓扑排序
**6.1定义**
![拓扑排序](/image/sjjg_33.png)
![例子](/image/sjjg_34.png)
**6.2算法**
①思想：每次输出所有**没有前驱节点**的节点
②伪码描述
![伪码描述](/image/sjjg_35.png)
![算法改进](/image/sjjg_36.png)
### 7.关键路径（项目管理问题）
**7.1定义**
![定义](/image/sjjg_37.png)
**7.2思路**
![思路](/image/sjjg_38.png)
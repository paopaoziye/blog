---
title: Linux内核（四）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - Linux内核
categories: Linux
keywords: 文章关键词
updated: ''
img: /medias/featureimages/29.webp
date:
summary: 内存管理
---
# Linux内核
## Linux内核（二）
### 1.内存管理
#### 1.1引言
**①内存页**
>**概述**：内存管理的**基本单位**，体系结构不同，**页的大小**不同，通常为`4KB`
{%list%}
由struct page结构表示，位于linux/mm_types.h中，其主要成员如下
{%endlist%}
{%warning%}
该结构与物理页相关而不是与虚拟页相关
{%endwarning%}
>`flag`:每一位都表示**页的状态**，如是不是**脏**的，是不是被**锁定在内存**中等，详细见`<linux/page-flags.h>`

>`_count`：存放页的**引用计数**，当页的引用计数**小于等于0**时被回收

>`virtual`：存放页的**虚拟地址**，当其**没有被映射**到内核地址空间时，为`NULL`

**②内存区**
>**概述**：根据**页的用途**将其分为不同的区域，每个区用`struct zone`表示，定义在`<linux/mmzone.h>`中
{%list%}
需要分配一定内存页用于特殊用途，如一些硬件只能在特定的地址执行DMA，如高级内存
{%endlist%}
{%right%}
除了ZONE_NORMAL，其他区都不是必须的，如有些体系结构可以在地址上执行DMA，则可以没有DMA区
{%endright%}
{%warning%}
页的分配不能跨区，优先使用普通内存区
{%endwarning%}
>`ZONE_DMA/ZONE_DMA_32`：用于执行**DMA操作**，后者只能被**32位设备**访问

>`ZONE_NORMAL`：**正常映射**的页，通常**优先分配给其他区域**

>`ZONE_HIGHEM`：包含**高端内存**，及**不能永久映射**到内核地址空间

**③内存分配**
>**概述**：**以页为单位**的内存分配函数定义在`linux/gfp.h`，**以字节为单位**的内存分配函数定义在`linux/slab.h`
{%list%}
gfp_mask变量用于控制内存分配的行为，常用的有GFP_KERNEL、GFP_ATOMIC和GFP_DMA
{%endlist%}
>`GFP_KERNEL`用在**可以睡眠**的场景，`GFP_ATOMIC`用在**不可睡眠**的场景，`GFP_DMA`表明从**DMA内存区**分配
{%right%}
有些硬件设备需要得到物理地址连续的内存，因为没有内存管理单元，仅供软件使用的内存块物理地址可以不连续
{%endright%}
{%warning%}
由于vmalloc()分配的内存虚拟地址连续而物理地址不连续，所以需要建立对应页表项，开销更大
{%endwarning%}
```c
// 分配2^order个连续的物理页，并返回一个指针指向第一个页的结构体
struct page* alloc_pages(gfp_t gfp_mask,unsigned int order);
// 类似于alloc_pages()，但是返回的是第一个物理页的逻辑地址
unsigned long __get_free_pages(gfp_t gfp_mask,unsigned int order);
// 分配一页，全部填充0，并返回其逻辑地址
unsigned long get_zeroed_page(unsigned int gfp_mask);
// 根据传递的物理页结构和逻辑地址，释放2^order个连续的物理页
void __free_pages(stuct page *page,unsigned int order);
void free_pages(unsigned long addr,unsigned int order);
```
```c
// 分配一个大小至少为size的内存块并返回起指针
// 分配的内存物理地址和虚拟地址都是连续的
void* kmalloc(size_t size,gfp_t flags);
void kfree(const void *ptr);
// 类似于kmalloc()
// 但是分配的内存虚拟地址连续但是物理地址不连续
// malloc()底层就是vmalloc()
void* vmalloc(unsigned long size);
void* vfree(const void* addr)
```
**④高端内存**
>**概述**：高端内存页**不能永久映射**到内核地址空间，但是可以创建**永久映射**和**临时映射**
{%list%}
一些体系结构物理寻址范围远大于虚拟寻址范围，所以有些内存不能永远映射到内核空间中
{%endlist%}
{%right%}
linux预留了一组映射作为临时映射，在创建临时映射时，需要传递对应枚举类型描述其用途
{%endright%}
>**枚举类型**定义在`<asm/kmap_types.h>`中
{%warning%}
永久映射的数量是有限的，且创建永久映射可能会阻塞，而创建临时映射不会
{%endwarning%}
```c
// 建立永久映射，并返回逻辑地址
void* kmap(struct page *page)
// 撤销永久映射
void kunmap(struct page *page)
// 建立临时映射
void* kmap_atomic(struct page *page,enum km_type type)
// 撤销临时映射
void kunmap_atomic(void *kvaddr,enum km_type type)
```
**⑤处理器数据**
>**概述**：每个**处理器独有**的数据，需要通过**特定的接口**创建和使用，定义在`linux/percpu.h`中
{%list%}
处理器数据可以静态创建也可以动态创建，详细如下
{%endlist%}
{%right%}
使用内核数据可以不使用锁，但是获取内核数据时会禁止内核抢占
{%endright%}
```c
// 静态创建处理器数据
// 为每个处理器都创建了一个类型为type，名字为name的变量
DEFINE_PER_CPU(type,name);
// 获取处理器变量并禁止内核抢占
get_cpu_var(name);
// 写回处理器变量并重新激活抢占
put_cpu_var(name);
// 获取对应CPU的数据
// 注意这里不会禁止内核抢占，所以需要给对应数据上锁
per_cpu(name,cpu);
```
```c
// 动态创建CPU数据
void *percpu_ptr;
unsigned long *foo;
percpu_ptr = alloc_percpu(unsigned long);
// 获取对应处理器变量的指针拷贝，并禁止内核抢占
foo = get_cpu_var(percpu_ptr);
// 重新激活内核抢占
put_cpu_var(percpu_ptr);

// size为分配的字节数，align为对齐要求
// alloc_percpu()实际上是__alloc_percpu()的封装
// type是需要分配的数据类型，按照单字节对齐，及按照给定类型的自然边界对齐
void* __alloc_percpu(size_t size,size_t align)
void* alloc_percpu(type);
//释放内核数据
void free_percpu(const void*)
```
#### 1.2slab层
**①引言**
>**概述**：某些数据结构的**分配和回收**特别频繁，常采用**空闲链表**省去**分配和释放**的时间
{%list%}
空闲链表包含可供使用的已经分配好的数据结构块，需要时就从空闲链表中抓取，而不需要分配内存
{%endlist%}
{%right%}
为了方便管理，将其层层包装为高速缓存和slab层
{%endright%}
{%warning%}
频繁地分配和回收会导致内存碎片
{%endwarning%}
**②结构**
>**概述**：每种结构对应**一个高速缓存结构**，每个高速缓存结构包含**一个或多个**`slab`，`slab`本质上就是**空闲链表**
{%list%}
高速缓存由kmem_cache结构表示，slab由slab结构描述，详细可见linux/slab.c
{%endlist%}
>`kmem_cache`结构包含三个`slab`链表，分别存放**已满**、**未满**和**未使用**的`slab`

>`slab`结构如下所示，主体为一**空闲链表**
```c
struc slab{
  struct list_head list;//结构链表
  unsigned long    colouroff;//slab着色偏移量
  void             *s_mem;//slab中第一个对象
  unsigned int     inuse;//已经分配的对象数
  kmem_bufctl_t    free;//第一个空闲对象
}
```
**③工作流程**
>**高速缓存**：调用`kmem_cache_create()`创建新的**高速缓存**，调用`kmem_cache_destroy()`释放高速缓存
{%right%}
可以设置其标志控制高速缓存的行为，如要求其下slab中所有对象都按照高速缓存行对齐，使用DMA区等
{%endright%}
{%warning%}
释放高速缓存时，需要保证其下的slab的对象均为空闲
{%endwarning%}
>`slab`：调用`kmem_getpages()`为**特定的高速缓存**创建新的`slab`，调用`kmem_freepages()`释放`slab`
{%list%}
kmem_getpages()本质上还是调用__get_free_page()
{%endlist%}
>**结构对象**：调用`kmem_cache_alloc()`从指定的高速缓存中**分配对象**，调用`kmem_cache_free()`归还对象
{%warning%}
如果没有空闲slab，则kmem_cache_alloc()会调用kmem_getpages()创建一个slab
{%endwarning%}
#### 1.3页高速缓存
①

②

③
### 2.虚拟文件系统
#### 2.1引言
**①定义**
>**概述**：通过**通用文件系统模型**，提供了文件系统共有的**常用接口**和**数据结构**，使得多种文件系统**共存**且**协同工作**
{%list%}
可以通过open()等统一系统调用接口操作不同的文件系统和物理介质，甚至跨越这些文件系统和物理介质
{%endlist%}
>用户空间调用`write()`，`wirte()`调用`sys_write()`，`sys_write()`调用**对应文件系统写方法**写到物理介质
{%right%}
本质上就是提供了一个文件系统的抽象层
{%endright%}
**②抽象**
>**概述**：
{%list%}

{%endlist%}
③



文件系统相关的传统抽象概念
文件、目录项、索引节点和安装点
安装点：文件系统安装的地方，所有的已安装文件系统都做为根文件系统树的枝叶出现在系统中
文件：被看作有序字节串，第一个字节是文件的头，最后一个字节是文件的尾
文件通过目录组织起来，路径的每一个部分都是目录项
索引节点：文件的控制权现、大小、创建时间等元数据被存放在一个单独的数据结构中，该数据结构称为inode
超级块：存放文件系统的控制信息，
保证实现和支持上述概念的文件系统协同工作
目录项代表的是路径中的一个组成部分，目录想不同于目录，目录是另一种形式的文件

每个对象都包含了一个对应的操作对象，这些操作对象描述了内核针对该对象可以使用的方法
操作对象作为一个结构体指针实现，该结构体包含了操作其父对象的函数指针
super_operations
inode_operations
dentry_operations
file_operations

超级块对象，用于存储特定文件系统的信息，通常对应于存放在磁盘特定扇区的文件系统超级块
由super_block结构体表示，定义在linux/fs.h中，管理超级块对象的代码位于fs/super.c中
装载文件系统时，会调用alloc_super()创建并初始化超级块

超级块对象s_op指向超级块的操作函数表，由super_operations结构表示，定义在linux/fs.h中
在C语言中无法直接得到操作函数的父对象，所以必须将父对象以参数形式传递给操作函数
其中一些函数是可选的，文件系统可以将不需要的函数指针设置为NULL

索引节点对象，包含了操作文件或者目录时需要的全部信息，如果文件系统没有定义对应对象，都必须提取这些信息组成索引节点对象
索引节点由inode表示，定义在linux/fs.h中，一个inode可以代表文件系统中的文件，也可以是设备或者管道这样的特殊文件

目录项对象：路径中的每一项都是目录项对象
如访问路径/mydir/myfile，需要将其中的/、mydir和myfile解析为目录项对象
为了避免每次访问该路径名都要进行这种操作，会现在目录想缓存中搜索对应路径名，如果没有找到则遍历文件系统为每个路径分量解析路径
VFS在执行目录操作时根据字符串形式的路径名现场创建目录项对象
目录项对象由dentry结构表示，定义在linux/dcache.h中

被使用、未被使用和负状态
被使用说明目录项对应一个有效的索引节点并且表明该对象存在一个或多个使用者（即d_count为正值）不能被丢弃
未使用说明目录项对应一个有效的索引节点并且表明VFS当前并未使用（即d_count为0）
负状态的目录项没有对应的有效索引节点，如索引节点被删除、路径不再正确
目录项对象释放后可以保存到slab对象缓存中
dentry_operations被定义在linux/dcache.h中

文件对象表示进程已经打开的文件，一个文件可以存在多个对应的文件对象，因为可能有多个进程打开同一文件对象
由file结构表示，file_operations定义在linux/fs.h中

文件对象和目录项对象都没有对应的磁盘数据

file_system_type描述特定文件系统类型linux/fs.h，vfsmount结构体表示一个安装文件系统的实例，即代表一个安装点，linux/mount.h中


#### 进程地址空间
所有进程以虚拟方式共享内存，好像每个进程都可以访问整个系统的所有物理内存，且一个进程的地址空间也可以远大于系统物理内存
相互独立
尽管一个进程可以寻址4GB的虚拟内存,但是并不代表其可以访问所有的虚拟地址，只能访问有效内存区域的内存地址，且有对应权限，可读可写可执行，如果访问了不在有效范围内的内存地址，或者以不正确的方式访问，则会引发段错误
进程由32位或64位的连续地址空间，由体系结构决定
代码段：可执行文件代码的内存映射
数据段：已初始化全局变量的内存映射
BSS段：
堆栈
内存映射文件、共享内存段
链接库的代码段、数据段和BSS段

使用内存描述符表示进程的地址空间，包含了进程地址空间有关的全部信息，由mm_struct结构体表示，定义在linux/sched.h中
mm_users：记录正在使用该地址的进程数目
mm_count：记录是否有进程使用该结构，如果该成员为0，则说明所有正在使用该地址空间的线程都退出，该结构体会被撤销
mmap：描述该地址空间的全部内存区域，链表形式
mm_rb：红黑树形式
存放所有内存区域描述对象的指针
前者用于简单高效地遍历，后者用于搜索指定元素
所有的mm_struct通过自身的mmlist区域链接在一个双向链表中

一个进程的mm域存放着mm_struct的指针
kernel/fork.c
fork通过copy_mm函数复制父进程的进程描述符，调用alloc_mm从对应slab缓存中分配，如果是线程则不需要分配，因为和父进程共享地址空间
kernel/exit.c
exit_mm撤销，当mm_count变为0则会将其归还给对应slab缓存

内核线程进程描述符的mm域为空，因为其没有进程地址空间，
当一个进程被调度时，该进程的mm域指向的地址空间被装载到内存，进程描述符中的active_mm域被更新，使其指向新的地址空间
当一个内核线程被调度时，内核发现其mm域为NULL，就会保留前一个进程的地址空间，使其active_mm指向前一个进程的内存描述符，从而使用其页表等和内核内存相关的信息

虚拟内存区域由vm_area_struct结构体描述，定义在<linux/mm_types.h>中
描述了指定地址空间内连续区间上的一个独立内存范围
每个内存区间作为一个单独的内存对象管理，拥有一致的属性，如访问权限等
vm_mm指向了与之相关的mm_struct，vm_mm对于与之相关的mm_struct是唯一的
VMA标志，定义于linux/mm.h，包含在vm_flags域中，描述了其行为和信息，如是可读可写可共享
vm_ops域指向VMA的操作函数表，由vm_operations_struct结构体表示，定义在linux/mm.h中
共享不可写内存可以节省内存

mmap() do_mmap()创建一个新的地址区间，将一个地址区间加入到进程的地址空间中
定义在linux/mm.h中，如将文件映射到内存中
访问权限prot和行为控制标志flag定义在asm/mman.h中
如果新区域和已经存在的地址区间相邻且具有相同的权限，则会合并为一个区间
否则会从对应slab缓存中分配一个vm_area_struct结构体，并且将其添加到对应mm_struct的红黑树和链表中

用户空间可以调用mmap()
linux/mm.h
do_munmap从指定的进程空间删除指定地址空间

每个进程都有自己的页表，存放在进程描述符pgd域中
定义在<asm/page.h>中
通过页表搜索物理地址比较耗时，为了加快搜索速度，在TLB中缓存了一系列虚拟地址到物理地址的映射，如果命中则直接返回（硬件缓存）

页高速缓存
来自对正规文件、块设备文件和内存映射文件的读写
将磁盘的数据缓存到物理内存中，将对磁盘的访问转化为对内存的访问
内存访问速度更快，局部性原理
页高速缓存由内存中的物理页组成，对应磁盘上的物理块，当内核开始一个读操作，会先访问页高速缓存，如果不在则访问磁盘，读入需要的页并将其添加到页高速缓存中
缓存策略，回写
写操作将写到缓存中，对应的磁盘并不更新，而是将高速缓存页中被写入的页面标记成脏，并将其加入到脏页链表中，然后由一个进程周期将脏页链表中的页写回到磁盘，并清除脏标志

缓存回收算法
维护两个链表活跃链表和非活跃链表，在活跃链表的是不能换出的，在非活跃链表的页是可以换出的，在活跃链表的页面必须在其被访问时就处于非活跃链表中，两个链表都被LUR规则维护
当活跃链表的页过多，则会将其“最久未被访问”的页送入非活跃链表
解决了LUR算法对于仅仅访问一次的窘境

页高速缓存的页可能包含多个不连续的物理磁盘块（X86一个物理页的大小是4KB，一个块的大小是512B）
使用address_space结构体描述
页高速缓存的搜索操作必须要快
定义在<linux/fs.h>中

脏页需要在空闲内存低于一定阈值、脏页在内存中驻留时间超过一个特定的阈值，用户进程调用sync()和fsync()时被回收
内核线程flusher完成，周期性的唤醒
当空闲内存过低还会再多唤醒一个或者多个flusher线程，不同的flusher处理不同的设备队列

字符设备：按照字符流的方式被有序访问，如串口

块设备：随机访问固定大小的数据片的硬件设备，如硬盘
块设备更加复杂，且块设备对执行性能的要求很高
最小可寻址单元为扇区，最常见为512字节
块，文件系统的一种抽象，只能基于块访问文件系统，块是扇区的整数倍大小，且不能大于一页
当一个块被调入内存时，要存储在一个缓冲区中，每个缓冲区和一个块对应
每个缓冲区由结构对象buffer_head描述，定义域<linux/buffer_head.h>中
b_state表示缓冲区的状态，合法的标志存放在bh_state_bits枚举中，定义在linux/buffer_head.h中
b_count标识缓冲区的引用计数
在操作缓冲区头之前，先使用get_bh()增加其引用计数，确保缓冲区头不会被分配出去，操作完后使用put_bh()减少引用计数
b_page：对应的内存物理页
b_data：描述块在对应物理页的偏移

块I/O操作的基本容器，bio结构，定义在linux/bio.h中
表示正在活动的片段I/O操作，一个片段描述了一小块连续的内存缓存区

bi_io_vec指向一个bio_vec结构体数组，描述了一个特定I/O操作需要使用的所有片段
每个bio_vec结构都描述了一个片段：片段所在物理页、块在物理页偏移位置和从给定偏移量开始的块长度

每个IO操作都由一个bio结构体表示

块设备将它们挂起的块I/O请求保存在请求队列中，由reques_queue结构表示，定义在linux/blkdev.h中
包含一个双向请求链表以及相关控制信息

链表的请求由reques表示，定义在文件linux/blkdev.h中每个请求由一个或多个bio组成
磁盘寻址耗时长，所以缩短寻址时间，进行I/O调度
管理设备的请求队列，决定请求的排列顺序以及什么时候派发请求到块设备
合并：将两个或者多个请求合并为一个新请求，如两个请求访问的磁盘扇区相邻
整个请求队列按照扇区增长方向有序排列，保持磁盘头以直线方向移动，类似于电梯

linus电梯
当有新的请求时，先检查其能否和队列中某个请求合并
如果不能则按照扇区方向有序排列的规则进行插入，如果队列中有驻留时间过长的请求，新请求会被添加到尾部
对磁盘某个区域的繁重操作会使得磁盘其他位置上的请求饥饿


写操作，内核有空才执行，和提交它的进程是异步执行的
读操作：程序会发生堵塞直到其提交的读请求被满足，同步执行，会严重影响性能


最后期限I/O调度
每个请求都有一个超时时间，且读请求的超时时间会明显小于写请求
类似于linus电梯以磁盘物理位置为次序维护请求队列
当有新的请求时，会执行类似于linus电梯的合并和插入到请求队列中
但是也会根据其类型将其额外添加到写请求FIFO队列和读请求FIFO队列中
对于普通请求，添加到排序队列中
将排序队列队头元素提交给派发队列，并将FIFO队列中超时的请求提交给派发队列

预测I/O调度程序
最后期限I/O调度优先响应读操作，当写请求较多时，会损害系统全局吞吐量
类似于最后期限I/O调度，但是在请求提交后会等待片刻，这段时间任何对相邻磁盘位置操作的请求都会立刻得到处理，这样可以避免一些寻址操作
等待时间结束后，会返回到原来的位置继续执行剩余请求

完全公正的排队I/O调度
每个提交请求的进程都有自己的队列，每个队列中，刚进入的请求和相邻请求合并并进行插入分类
以时间片轮转调度队列，每次处理n个请求

空操作的I/O调度
除了合并请求之外什么都不做



---
title: MIT6.1810实验（四）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 陷阱处理机制
---
# MIT6.1810实验（四）
## MIT6.1810 Lab4
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：Lab4围绕Xv6的**陷阱处理机制**，并在此基础上实现一个**用户级别的陷阱处理**
{%list%}
做之前记得切换到对应分支git checkout traps
{%endlist%}
**②汇编语言简答**
>**概述**：根据给出的**C和RISC-V汇编**代码文件回答相关问题，并将答案存储在**主目录**下的`answers-traps.txt`中
{%list%}
在主目录下执行make fs.img，编译user/call.c，并生成汇编文件user/call.asm
{%endlist%}
**③栈帧打印**
>**概述**：在`kernel/printf.c`下实现函数`backtrace()`，并在`sys_sleep`中插入**对此函数的调用**
{%list%}
从顶部开始遍历各个栈帧，并将各个栈帧中保存的返回地址打印出来，打印格式如下所示
{%endlist%}
```
backtrace:
0x0000000080002cda
0x0000000080002bb6
0x0000000080002898
```
**④定时器实现**
>**概述**：添加一个新的系统调用`sigalarm`和`sigreturn`
{%list%}
当程序调用sigalarm(n, fn)时，接下来程序每消耗n个ticks的CPU时间后，内核会调用fn
{%endlist%}
{%right%}
当fn成功返回时，程序应当继续不受影响的运行，这部分由系统调用sigreturn负责完成
{%endright%}
{%warning%}
需要将测试代码alarmtest（user/alarmtest.c）添加到Makefile中
{%endwarning%}
```
$ alarmtest
test0 start
........alarm!
test0 passed
test1 start
...alarm!
..alarm!
...alarm!
..alarm!
...alarm!
..alarm!
...alarm!
..alarm!
...alarm!
..alarm!
test1 passed
test2 start
................alarm!
test2 passed
$ usertests
...
ALL TESTS PASSED
$
```
**⑤实验结果**
>**测试准备**：**主目录**添加`time.txt`和`answers-traps.txt`，随后`make qemu`，退出`make grade`即可
{%list%}
两个txt前者填写花费的时间数，后者填写简答题的答案
{%endlist%}
![测试结果](/image/MIT.6.1810_Lab4.png)
#### 1.2Xv6陷阱处理
**①RISC-V汇编**
>`ISA`：`ISA`就是**处理器**能够理解的**指令集**，每条指令都有对应的**二进制编码**，指导处理器工作
{%list%}
RISC-V指令集精简指令集，指令简单且数量较少
{%endlist%}
>**寄存器**：**处理器内部**用来存放数据的一些**小型存储区域**，对**寄存器数据**进行**运算和读取**是**最快**的
{%list%}
寄存器大小一般为64比特，所有数据类型都会被改造成可以放进寄存器的样子
{%endlist%}
>RISC-V寄存器简介如下，更详细信息可见RISC-V的[Calling conventions](https://pdos.csail.mit.edu/6.S081/2021/readings/riscv-calling.pdf)手册
{%right%}
所以汇编代码优先将数据加载到寄存器中，而不是内存中
{%endright%}
![RISC-V寄存器](/image/RISC-V_register.png)
>**栈**：一段**由高地址向低地址增长**的内存空间，**每次函数调用**都会在栈中创建一个**栈帧**
{%list%}
每个栈帧保存了返回地址、指向前一个栈帧的指针、寄存器变量和本地变量等
{%endlist%}
{%right%}
和栈帧相关的寄存器有sp和fp寄存器，分别指向栈的底部和当前栈帧的顶部
{%endright%}
>如下图，可以通过`fp`指针很快地找到**返回地址**和**前一个栈帧的指针**

![栈和栈帧](/image/Xv6_stack.webp)

**②陷阱机制**
>**概述**：每当执行**系统调用**、**出现错误**（如页错误和除0错误）、**响应中断**时，会**从用户态切换到内核态**
{%list%}
由于trap机制使用频繁，所以其简单高效，其中主要涉及到各种寄存器的读写，因为寄存器表明了计算机的状态
{%endlist%}
{%right%}
只有内核态才能读写某些特殊寄存器，并且使用PTE_U标志位为0的PTE
{%endright%}
>**用户寄存器**：RISC-V总共有`32`个**用户应用程序**可以使用的寄存器，如**堆栈寄存器**

>**`pc`寄存器**：保存**当前指令地址**，且该寄存器有一**状态位**，指明当前位于**用户态还是内核态**

>**`SATP`寄存器**：保存了指向`page table`的**物理内存地址**，修改该寄存器完成**内核页表**和**用户页表**的切换

>**`SEPC`寄存器**：在`trap`的**过程中**保存`pc`寄存器的值

>**`STVEC`寄存器**：保存了**内核**处理`trap`的指令的起始地址，即`trampoline page`的第一条指令

>**`SSRATCH`寄存器**：在**进入到用户态之前**，内核会将`trapframe page`的**虚拟地址**保存在这个寄存器中

>**`SSTATUS`寄存器**：一个**控制寄存器**，其中`SPP`和`SPIE`位控制了`sret`指令的行为
{%list%}
SPP为0表示下次sret将返回用户态，SPIE为1表示执行完sret之后会打开中断
{%endlist%}

**③具体流程**
>**`ecall`指令**：**陷入内核**，将`pc`**寄存器**的值保存到`SEPC`**寄存器**中，并跳转到`STVEC`**寄存器**指向的代码
{%list%}
STVEC寄存器指向的代码即trampoline page的代码，首先执行的是uservec汇编函数，位于trampoline.s
{%endlist%}
{%right%}
用户代码不能写trampoline page，因为对应用户页表PTE的PTE_U标志位没有设置，该代码对内核是安全的
{%endright%}
{%warning%}
RISC-V的ecall指令出于灵活性的考虑，工作量较少，其他汇编语言对应指令还会完成其他工作，如切换内核栈
{%endwarning%}
>**`uservec`函数**：保存**用户寄存器**，切换到**内核页表**，并从`trapframe`**读取相关数据**,随后跳转到`usertrap()`
{%list%}
每个进程都有对应的trapframe page，用于保存数据，初始时还有五个内核态相关数据，如内核栈指针
{%endlist%}
{%right%}
trampoline page在用户页表和内核页表中的映射是一致的，所以切换了页表也能正常运行
{%endright%}
```nasm
.globl uservec
uservec:    
	#
        # trap.c sets stvec to point here, so
        # traps from user space start here,
        # in supervisor mode, but with a
        # user page table.

        # save user a0 in sscratch so
        # a0 can be used to get at TRAPFRAME.
        csrw sscratch, a0

        # each process has a separate p->trapframe memory area,
        # but it's mapped to the same virtual address
        # (TRAPFRAME) in every process's user page table.
        li a0, TRAPFRAME
        
        # save the user registers in TRAPFRAME
        sd ra, 40(a0)
        sd sp, 48(a0)
        sd gp, 56(a0)
        sd tp, 64(a0)
        sd t0, 72(a0)
        sd t1, 80(a0)
        sd t2, 88(a0)
        sd s0, 96(a0)
        sd s1, 104(a0)
        sd a1, 120(a0)
        sd a2, 128(a0)
        sd a3, 136(a0)
        sd a4, 144(a0)
        sd a5, 152(a0)
        sd a6, 160(a0)
        sd a7, 168(a0)
        sd s2, 176(a0)
        sd s3, 184(a0)
        sd s4, 192(a0)
        sd s5, 200(a0)
        sd s6, 208(a0)
        sd s7, 216(a0)
        sd s8, 224(a0)
        sd s9, 232(a0)
        sd s10, 240(a0)
        sd s11, 248(a0)
        sd t3, 256(a0)
        sd t4, 264(a0)
        sd t5, 272(a0)
        sd t6, 280(a0)

	# save the user a0 in p->trapframe->a0
        csrr t0, sscratch
        sd t0, 112(a0)

        # initialize kernel stack pointer, from p->trapframe->kernel_sp
        ld sp, 8(a0)

        # make tp hold the current hartid, from p->trapframe->kernel_hartid
        ld tp, 32(a0)

        # load the address of usertrap(), from p->trapframe->kernel_trap
        ld t0, 16(a0)

        # fetch the kernel page table address, from p->trapframe->kernel_satp.
        ld t1, 0(a0)

        # wait for any previous memory operations to complete, so that
        # they use the user page table.
        sfence.vma zero, zero

        # install the kernel page table.
        csrw satp, t1

        # flush now-stale user entries from the TLB.
        sfence.vma zero, zero

        # jump to usertrap(), which does not return
        jr t0
```
>**`usertrap`函数**：修改`STVEC`**寄存器**，保存`pc`**寄存器**并进行**相关操作**，最后跳转到`usertrapret()`
{%list%}
STVEC寄存器一开始指向用户空间处理trap的代码，修改后指向内核空间处理trap的代码
{%endlist%}
{%right%}
有很多原因会触发该函数，不同的原因该函数会做出不同的处理，可以通过检查对应寄存器判断
{%endright%}
{%warning%}
注意系统调用的处理方式中，会将保存在trapframe中的用户态pc指针+4，因为希望返回到ecall的下一条语句
{%endwarning%}
```c
//位于kernel/trap.c中
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(killed(p))
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sepc, scause, and sstatus,
    // so enable only now that we're done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    setkilled(p);
  }

  if(killed(p))
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```
>**`usertrapret`函数**：设置相关寄存器，将**相关数据**保存到`trapframe`中并跳转到`userret()`
{%list%}
修改相关寄存器，即STVEC、SSTATUS和SEPC，做好返回用户态的准备
{%endlist%}
{%right%}
跳转到userret()时还传递了一个参数satp，用于后续设置SATP寄存器
{%endright%}
{%warning%}
在这里会先关闭中断，因为后续将设置STVEC指向trampoline，即用户态的trap处理代码，而目前还处于内核态
{%endwarning%}
```c
//
// return to user space
//
void
usertrapret(void)
{
  struct proc *p = myproc();

  // we're about to switch the destination of traps from
  // kerneltrap() to usertrap(), so turn off interrupts until
  // we're back in user space, where usertrap() is correct.
  intr_off();

  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
  w_stvec(trampoline_uservec);

  // set up trapframe values that uservec will need when
  // the process next traps into the kernel.
  p->trapframe->kernel_satp = r_satp();         // kernel page table
  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
  p->trapframe->kernel_trap = (uint64)usertrap;
  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()

  // set up the registers that trampoline.S's sret will use
  // to get to user space.
  
  // set S Previous Privilege mode to User.
  unsigned long x = r_sstatus();
  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
  x |= SSTATUS_SPIE; // enable interrupts in user mode
  w_sstatus(x);

  // set S Exception Program Counter to the saved user pc.
  w_sepc(p->trapframe->epc);

  // tell trampoline.S the user page table to switch to.
  uint64 satp = MAKE_SATP(p->pagetable);

  // jump to userret in trampoline.S at the top of memory, which 
  // switches to the user page table, restores user registers,
  // and switches to user mode with sret.
  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
  ((void (*)(uint64))trampoline_userret)(satp);
}
```
>**`userret`函数**：切换回**用户页表**，恢复所有**用户寄存器**，最后执行`sret`指令返回用户态
{%list%}
根据SSTATUS的设置，sret指令会切换回用户态，将SEPC寄存器的值拷贝到PC寄存器中并打开中断
{%endlist%}
```nasm
.globl userret
userret:
        # userret(pagetable)
        # called by usertrapret() in trap.c to
        # switch from kernel to user.
        # a0: user page table, for satp.

        # switch to the user page table.
        sfence.vma zero, zero
        csrw satp, a0
        sfence.vma zero, zero

        li a0, TRAPFRAME

        # restore all but a0 from TRAPFRAME
        ld ra, 40(a0)
        ld sp, 48(a0)
        ld gp, 56(a0)
        ld tp, 64(a0)
        ld t0, 72(a0)
        ld t1, 80(a0)
        ld t2, 88(a0)
        ld s0, 96(a0)
        ld s1, 104(a0)
        ld a1, 120(a0)
        ld a2, 128(a0)
        ld a3, 136(a0)
        ld a4, 144(a0)
        ld a5, 152(a0)
        ld a6, 160(a0)
        ld a7, 168(a0)
        ld s2, 176(a0)
        ld s3, 184(a0)
        ld s4, 192(a0)
        ld s5, 200(a0)
        ld s6, 208(a0)
        ld s7, 216(a0)
        ld s8, 224(a0)
        ld s9, 232(a0)
        ld s10, 240(a0)
        ld s11, 248(a0)
        ld t3, 256(a0)
        ld t4, 264(a0)
        ld t5, 272(a0)
        ld t6, 280(a0)

	# restore user a0
        ld a0, 112(a0)
        
        # return to user mode and user pc.
        # usertrapret() set up sstatus and sepc.
        sret
```


### 2.具体实现
#### 2.1 RISC-V汇编语言简答题
**①问题1**
>**概述**：观察`call.asm`下`main()`函数,哪个寄存器用于**函数传递参数**,如在`printf`中，参数`13`在哪个寄存器中

>**回答**：根据**1.2小结**中介绍寄存器的图，`a0~a7`寄存器用于保存**函数参数**，`13`为第三个参数，保存在`a2`中

```nasm
void main(void) {
  1c:	1141                	addi	sp,sp,-16
  1e:	e406                	sd	ra,8(sp)
  20:	e022                	sd	s0,0(sp)
  22:	0800                	addi	s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  26:	45b1                	li	a1,12
  28:	00000517          	auipc	a0,0x0
  2c:	7c850513          	addi	a0,a0,1992 # 7f0 <malloc+0xe8>
  30:	00000097          	auipc	ra,0x0
  34:	61a080e7          	jalr	1562(ra) # 64a <printf>
  exit(0);
  38:	4501                	li	a0,0
  3a:	00000097          	auipc	ra,0x0
  3e:	298080e7          	jalr	664(ra) # 2d2 <exit>

```
**②问题2**
>**概述**：前后对比`call.c`和`call.asm`，请问**主函数**中对`f()`和`g()`调用在哪里

>**回答**：由`call.c`文件可知，主函数在`printf()`的**第二个参数**中调用了`f()`

>而`call.asm`的**0x26**处中直接将`12`传递给了`a1`，所以主函数**没有调用对应函数**，而是进行了**内联优化**
```c
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int g(int x) {
  return x+3;
}

int f(int x) {
  return g(x);
}

void main(void) {
  printf("%d %d\n", f(8)+1, 13);
  exit(0);
}
```
**③问题3**
>**概述**：`printf`函数位于哪个**地址**

>**回答**：在`call.asm`的`0x34`处，跳转到了`print`函数处，即`0x64a`处
```nasm
void
printf(const char *fmt, ...)
{
 64a:	711d                	addi	sp,sp,-96
 64c:	ec06                	sd	ra,24(sp)
 64e:	e822                	sd	s0,16(sp)
 650:	1000                	addi	s0,sp,32
 652:	e40c                	sd	a1,8(s0)
 654:	e810                	sd	a2,16(s0)
 656:	ec14                	sd	a3,24(s0)
 658:	f018                	sd	a4,32(s0)
 65a:	f41c                	sd	a5,40(s0)
 65c:	03043823          	sd	a6,48(s0)
 660:	03143c23          	sd	a7,56(s0)
  va_list ap;

  va_start(ap, fmt);
 664:	00840613          	addi	a2,s0,8
 668:	fec43423          	sd	a2,-24(s0)
  vprintf(1, fmt, ap);
 66c:	85aa                	mv	a1,a0
 66e:	4505                	li	a0,1
 670:	00000097          	auipc	ra,0x0
 674:	dce080e7          	jalr	-562(ra) # 43e <vprintf>
}
 678:	60e2                	ld	ra,24(sp)
 67a:	6442                	ld	s0,16(sp)
 67c:	6125                	addi	sp,sp,96
 67e:	8082                	ret

0000000000000680 <free>:
static Header base;
static Header *freep;
```
**④问题4**
>**概述**：在`jalr`跳转`main`函数的`printf`时，寄存器`ra`中有什么值？

>**回答**：根据RISC-V的`jalr`指令的规则，`ra`的值应该是`pc+4`，即`0x38`

![jalr指令](/image/Xv6_jalr.png)

**⑤问题5**
>**概述**：运行**如下代码**，得到的结果是？RISC-V不是**小端序而是大端序**，需要**如何修改参数**的到一样的结果？
{%list%}
%x表示十六进制，%s表示字符串
{%endlist%}
{%right%}
小端序即将比特的低位放在地址的低位，0x00646c72在内存中从小到大依次为0x72、0x6c、0x64、0x00
{%endright%}

>**回答**：`57616`十六进制形式为`0xE110`，`0x00646c72`字符串形式为`rld`，若为**大端**，`i`应该为`0x726c6400`

```c
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
```
**⑥问题6**
>**概述**：当运行如下代码时，在`y=`后面会打印出什么

>**回答**：根据RISC-V寄存器的规则，打印`a2`**寄存器**的值，这里没有设置`a2`**寄存器**的值，所以是**未知的**

#### 2.2栈帧打印
**①当前栈帧指针获取**
>**概述**：GCC编译器将**当前执行的函数**的栈帧指针`fp`存储在`s0`寄存器中，在 `kernel/printf.c`下加入代码
{%list%}
由上面对栈帧的描述图可知，上一个栈帧的fp保存位置为fp-16
{%endlist%}
{%right%}
可以使用PGROUNDDOWN(fp)和PGROUNDUP(fp)来寻找栈所在页面的顶部和底部地址，见kernel/riscv.h
{%endright%}
{%warning%}
注意内联汇编的空格不要少
{%endwarning%}
{%wrong%}
但按照题目添加在kernel/riscv.h中会报错，添加在kernel/printf.c中可以通过编译
{%endwrong%}
```c
//获取当前函数栈帧指针
static inline uint64
r_fp()
{
  uint64 x;
  asm volatile("mv %0, s0" : "=r" (x) );
  return x;
}
```
```c
#define PGSIZE 4096 // bytes per page
#define PGSHIFT 12  // bits of offset within a page

#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
```
**②`backtrace`函数**
>**概述**：在`kernel/printf.c`中添加`backtrace`函数，并在`kernel/defs.h`添加**对应声明**

```c

void
backtrace(void){
  printf("backtrace:\n");
  uint64 fp = r_fp();
  //fp一开始位于正在执行的
  while(fp != PGROUNDUP(fp)){
    uint64 ra = *(uint64*)(fp-8);
    printf("%p\n", ra);
    fp = *(uint64 *)(fp - 16);
  }
}
```
**③其他工作**
>**概述**：在`kernel/sysproc.c`下的`sys_sleep`函数和`kernel/printf.c`下的 `panic`函数中添加**对应调用**
```c
uint64
sys_sleep(void)
{
  int n;
  uint ticks0;

  argint(0, &n);
  backtrace();
  if(n < 0)
    n = 0;
  acquire(&tickslock);
  ticks0 = ticks;
  while(ticks - ticks0 < n){
    if(killed(myproc())){
      release(&tickslock);
      return -1;
    }
    sleep(&ticks, &tickslock);
  }
  release(&tickslock);
  return 0;
}
```
```c
void
panic(char *s)
{
  pr.locking = 0;
  printf("panic: ");
  printf(s);
  printf("\n");
   backtrace();
  panicked = 1; // freeze uart output from other CPUs
  for(;;)
    ;
}
```
#### 2.3定时器实现
**①添加系统调用**
>**概述**：添加系统调用**声明**、**编号**、**入口**和**对应映射关系**和**系统调用函数**，详细见lab2，以下为系统调用函数
```c
uint64
sys_sigalarm(void){
  int n;
  uint64 fn;
  argint(0,&n);
  argaddr(1,&fn);
  return sigalarm(n, (void(*)())(fn));
}
uint64
sys_sigreturn(void){
  return sigreturn();
}
```
**②完善结构体**
>**概述**：在`kernel/proc.h`中添加对应成员，并在`kernel/proc.c`对`allocproc`和`freeproc`进行对应的处理
{%list%}
在proc结构中添加时间周期间隔、处理函数地址、剩余时间周期数、trapframe备份以及一个锁
{%endlist%}
>在`usertrap`中如果需要跳转到**处理函数**，需要保存当前的`trapframe`，以便后续在`sigreturn`恢复
{%right%}
处理函数不可重入，可以使用一个int充当锁，处理函数正在执行时状态保持为1，执行完毕为0
{%endright%}
>当一个**硬件时钟到期时**已经有一个**时钟处理函数**正在运行，则会推迟到**原处理函数运行完成**后的**下一tick**才触发
{%warning%}
周期ticks时间若为0，则表示定时器处于关闭状态
{%endwarning%}
```c
// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
  int ticks;                   // 时钟的ticks
  int ticks_left;              // 剩余ticks
  void (*alarm_handler)();     // 处理函数地址
  struct trapframe *alarm_backup;// trapframe备份
  int alarm_lock;              // 锁，防止重入
};
```
```c
// Look in the process table for an UNUSED proc.
// If found, initialize state required to run in the kernel,
// and return with p->lock held.
// If there are no free procs, or a memory allocation fails, return 0.
static struct proc*
allocproc(void)
{
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state == UNUSED) {
      goto found;
    } else {
      release(&p->lock);
    }
  }
  return 0;

found:
  p->pid = allocpid();
  p->state = USED;

  //分配trapframe备份
  if((p->alarm_backup = (struct trapframe *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }
  // Allocate a trapframe page.
  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  // An empty user page table.
  p->pagetable = proc_pagetable(p);
  if(p->pagetable == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  // Set up new context to start executing at forkret,
  // which returns to user space.
  memset(&p->context, 0, sizeof(p->context));
  p->context.ra = (uint64)forkret;
  p->context.sp = p->kstack + PGSIZE;

  //初始化其他alarm相关的四个成员
  p->ticks = 0;
  p->ticks_left = 0;
  p->alarm_handler = 0;
  p->alarm_lock = 0;

  return p;
}

// free a proc structure and the data hanging from it,
// including user pages.
// p->lock must be held.
static void
freeproc(struct proc *p)
{
  if(p->trapframe)
    kfree((void*)p->trapframe);
  p->trapframe = 0;
  //释放alarm_backup
  if(p->alarm_backup)
    kfree((void*)p->alarm_backup);
  p->alarm_backup = 0;

  if(p->pagetable)
    proc_freepagetable(p->pagetable, p->sz);
  p->pagetable = 0;
  p->sz = 0;
  p->pid = 0;
  p->parent = 0;
  p->name[0] = 0;
  p->chan = 0;
  p->killed = 0;
  p->xstate = 0;
  p->state = UNUSED;
  //释放其他alarm相关的四个成员
  p->ticks = 0;
  p->ticks_left = 0;
  p->alarm_handler = 0;
  p->alarm_lock = 0;
}
```
**③完善usertrap函数**
>**概述**：修改`kernel/trap.c`下的`usertrap`中的**硬件定时器中断部分**`if(which_dev == 2)`
{%list%}
若当前进程的定时器开启、ticks消耗殆尽且没有冲突，就跳转到对应处理函数
{%endlist%}
{%right%}
保存trapframe结构、设置trapframe中的epc成员，跳转到对应处理函数最后上锁即可
{%endright%}
```c
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(killed(p))
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sepc, scause, and sstatus,
    // so enable only now that we're done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    setkilled(p);
  }

  if(killed(p))
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2){
    if(p->ticks){
      if(--p->ticks_left <= 0){
        if(!p->alarm_lock){
          *p->alarm_backup = *p->trapframe;
          p->trapframe->epc = (uint64)p->alarm_handler;
          p->alarm_lock = 1;
        }
      }
    }
  }
    yield();

  usertrapret();
}
```
**④核心函数实现**
>**概述**：`kernel/trap.c`中实现`sigalarm`和`sigreturn`函数，并在`kernel/defs.h`中声明

```c
int
sigalarm(int alarm_ticks, void (*handler)()){
  //初始化定时器
  struct proc *p = myproc();
  p->ticks = alarm_ticks;
  p->ticks_left = alarm_ticks;
  p->alarm_handler = handler;
  return 0;
}

int
sigreturn(){
  //恢复trapframe，并解锁
  struct proc *p = myproc();
  *p->trapframe = *p->alarm_backup;
  p->alarm_lock = 0;

  return p->alarm_backup->a0;
}

```
```c
// trap.c
extern uint     ticks;
void            trapinit(void);
void            trapinithart(void);
extern struct spinlock tickslock;
void            usertrapret(void);
int             sigalarm(int, void (*)());
int             sigreturn(void);
```
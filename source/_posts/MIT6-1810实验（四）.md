---
title: MIT6.1810实验（四）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 陷阱处理机制
---
①②③④⑤
# MIT6.1810实验（四）
## MIT6.1810 Lab4
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：Lab4围绕Xv6的**陷阱处理机制**，并在此基础上实现一个**用户级别的陷阱处理**
{%list%}
做之前记得切换到对应分支git checkout traps
{%endlist%}
**②汇编语言简答**
>**概述**：根据给出的**C和RISC-V汇编**代码文件回答相关问题，并将答案存储在**主目录**下的`answers-traps.txt`中
{%list%}
在主目录下执行make fs.img，编译user/call.c，并生成汇编文件user/call.asm
{%endlist%}
③

④
#### 1.2Xv6陷阱处理
**①RISC-V汇编**
>`ISA`：`ISA`就是**处理器**能够理解的**指令集**，每条指令都有对应的**二进制编码**，指导处理器工作
{%list%}
RISC-V指令集精简指令集，指令简单且数量较少
{%endlist%}
>**寄存器**：**处理器内部**用来存放数据的一些**小型存储区域**，对**寄存器数据**进行**运算和读取**是**最快**的
{%list%}
寄存器大小一般为64比特，所有数据类型都会被改造成可以放进寄存器的样子
{%endlist%}
>RISC-V寄存器简介如下，更详细信息可见RISC-V的[Calling conventions](https://pdos.csail.mit.edu/6.S081/2021/readings/riscv-calling.pdf)手册
{%right%}
所以汇编代码优先将数据加载到寄存器中，而不是内存中
{%endright%}
![RISC-V寄存器](/image/RISC-V_register.png)
>**栈**：一段**由高地址向低地址增长**的内存空间，**每次函数调用**都会在栈中创建一个**栈帧**
{%list%}
每个栈帧保存了返回地址、指向前一个栈帧的指针、寄存器变量和本地变量等
{%endlist%}
{%right%}
和栈帧相关的寄存器有sp和fp寄存器，分别指向栈的底部和当前栈帧的顶部
{%endright%}
>如下图，可以通过`fp`指针很快地找到**返回地址**和**前一个栈帧的指针**
![栈和栈帧](/image/Xv6_stack.webp)

②

③

④

⑤




global表示你可以在其他文件中调用这个函数。text表明这里的是代码
汇编代码中的text表明这部分是代码，并且位于page table的text区域中

### 2.具体实现
#### 2.1 RISC-V汇编语言简答题
**①问题1**
>**概述**：观察`call.asm`下`main()`函数,哪个寄存器用于**函数传递参数**,如在`printf`中，参数`13`在哪个寄存器中

>**回答**：根据**1.2小结**中介绍寄存器的图，`a0~a7`寄存器用于保存**函数参数**，`13`为第三个参数，保存在`a2`中

②

③

④

⑤





---
title: MIT6.1810实验（四）
seo_title: seo名称
toc: true
indent: true
top: false
comments: true
archive: true
cover: false
mathjax: false
pin: false
top_meta: false
bottom_meta: false
sidebar:
  - toc
tag:
  - 操作系统
  - MIT6.1810
categories: 项目实战
keywords: 文章关键词
updated: ''
img: /medias/featureimages/40.webp
date:
summary: 陷阱处理机制
---
①②③④⑤
# MIT6.1810实验（四）
## MIT6.1810 Lab4
### 1.引言
#### 1.1实验要求
**①引言**
>**概述**：Lab4围绕Xv6的**陷阱处理机制**，并在此基础上实现一个**用户级别的陷阱处理**
{%list%}
做之前记得切换到对应分支git checkout traps
{%endlist%}
**②汇编语言简答**
>**概述**：根据给出的**C和RISC-V汇编**代码文件回答相关问题，并将答案存储在**主目录**下的`answers-traps.txt`中
{%list%}
在主目录下执行make fs.img，编译user/call.c，并生成汇编文件user/call.asm
{%endlist%}
③

④
#### 1.2Xv6陷阱处理
**①RISC-V汇编**
>`ISA`：`ISA`就是**处理器**能够理解的**指令集**，每条指令都有对应的**二进制编码**，指导处理器工作
{%list%}
RISC-V指令集精简指令集，指令简单且数量较少
{%endlist%}
>**寄存器**：**处理器内部**用来存放数据的一些**小型存储区域**，对**寄存器数据**进行**运算和读取**是**最快**的
{%list%}
寄存器大小一般为64比特，所有数据类型都会被改造成可以放进寄存器的样子
{%endlist%}
>RISC-V寄存器简介如下，更详细信息可见RISC-V的[Calling conventions](https://pdos.csail.mit.edu/6.S081/2021/readings/riscv-calling.pdf)手册
{%right%}
所以汇编代码优先将数据加载到寄存器中，而不是内存中
{%endright%}
![RISC-V寄存器](/image/RISC-V_register.png)
>**栈**：一段**由高地址向低地址增长**的内存空间，**每次函数调用**都会在栈中创建一个**栈帧**
{%list%}
每个栈帧保存了返回地址、指向前一个栈帧的指针、寄存器变量和本地变量等
{%endlist%}
{%right%}
和栈帧相关的寄存器有sp和fp寄存器，分别指向栈的底部和当前栈帧的顶部
{%endright%}
>如下图，可以通过`fp`指针很快地找到**返回地址**和**前一个栈帧的指针**

![栈和栈帧](/image/Xv6_stack.webp)

**②陷阱机制**
>**概述**：每当执行**系统调用**、**出现错误**（如页错误和除0错误）、**响应中断**时，会**从用户态切换到内核态**
{%list%}
由于trap机制使用频繁，所以其简单高效，其中主要涉及到各种寄存器的读写，因为寄存器表明了计算机的状态
{%endlist%}
{%right%}
只有内核态才能读写某些特殊寄存器，并且使用PTE_U标志位为0的PTE
{%endright%}
>**用户寄存器**：RISC-V总共有`32`个**用户应用程序**可以使用的寄存器，如**堆栈寄存器**

>**`pc`寄存器**：保存**当前指令地址**，且该寄存器有一**状态位**，指明当前位于**用户态还是内核态**

>**`SATP`寄存器**：保存了指向`page table`的**物理内存地址**，修改该寄存器完成**内核页表**和**用户页表**的切换

>**`SEPC`寄存器**：在`trap`的**过程中**保存`pc`寄存器的值

>**`STVEC`寄存器**：保存了**内核**处理`trap`的指令的起始地址，即`trampoline page`的第一条指令

>**`SSRATCH`寄存器**：在**进入到用户态之前**，内核会将`trapframe page`的**虚拟地址**保存在这个寄存器中

>**`SSTATUS`寄存器**：一个**控制寄存器**，其中`SPP`和`SPIE`位控制了`sret`指令的行为
{%list%}
SPP为0表示下次sret将返回用户态，SPIE为1表示执行完sret之后会打开中断
{%endlist%}


**③具体流程**
>**`ecall`指令**：**陷入内核**，将`pc`**寄存器**的值保存到`SEPC`**寄存器**中，并跳转到`STVEC`**寄存器**指向的代码
{%list%}
STVEC寄存器指向的代码即trampoline page的代码，首先执行的是uservec汇编函数，位于trampoline.s
{%endlist%}
{%right%}
用户代码不能写trampoline page，因为对应用户页表PTE的PTE_U标志位没有设置，该代码对内核是安全的
{%endright%}
{%warning%}
RISC-V的ecall指令出于灵活性的考虑，工作量较少，其他汇编语言对应指令还会完成其他工作，如切换内核栈
{%endwarning%}
>**`uservec`函数**：保存**用户寄存器**，切换到**内核页表**，并从`trapframe`**读取相关数据**,随后跳转到`usertrap()`
{%list%}
每个进程都有对应的trapframe page，用于保存数据，初始时还有五个内核态相关数据，如内核栈指针
{%endlist%}
{%right%}
trampoline page在用户页表和内核页表中的映射是一致的，所以切换了页表也能正常运行
{%endright%}
```nasm
.globl uservec
uservec:    
	#
        # trap.c sets stvec to point here, so
        # traps from user space start here,
        # in supervisor mode, but with a
        # user page table.

        # save user a0 in sscratch so
        # a0 can be used to get at TRAPFRAME.
        csrw sscratch, a0

        # each process has a separate p->trapframe memory area,
        # but it's mapped to the same virtual address
        # (TRAPFRAME) in every process's user page table.
        li a0, TRAPFRAME
        
        # save the user registers in TRAPFRAME
        sd ra, 40(a0)
        sd sp, 48(a0)
        sd gp, 56(a0)
        sd tp, 64(a0)
        sd t0, 72(a0)
        sd t1, 80(a0)
        sd t2, 88(a0)
        sd s0, 96(a0)
        sd s1, 104(a0)
        sd a1, 120(a0)
        sd a2, 128(a0)
        sd a3, 136(a0)
        sd a4, 144(a0)
        sd a5, 152(a0)
        sd a6, 160(a0)
        sd a7, 168(a0)
        sd s2, 176(a0)
        sd s3, 184(a0)
        sd s4, 192(a0)
        sd s5, 200(a0)
        sd s6, 208(a0)
        sd s7, 216(a0)
        sd s8, 224(a0)
        sd s9, 232(a0)
        sd s10, 240(a0)
        sd s11, 248(a0)
        sd t3, 256(a0)
        sd t4, 264(a0)
        sd t5, 272(a0)
        sd t6, 280(a0)

	# save the user a0 in p->trapframe->a0
        csrr t0, sscratch
        sd t0, 112(a0)

        # initialize kernel stack pointer, from p->trapframe->kernel_sp
        ld sp, 8(a0)

        # make tp hold the current hartid, from p->trapframe->kernel_hartid
        ld tp, 32(a0)

        # load the address of usertrap(), from p->trapframe->kernel_trap
        ld t0, 16(a0)

        # fetch the kernel page table address, from p->trapframe->kernel_satp.
        ld t1, 0(a0)

        # wait for any previous memory operations to complete, so that
        # they use the user page table.
        sfence.vma zero, zero

        # install the kernel page table.
        csrw satp, t1

        # flush now-stale user entries from the TLB.
        sfence.vma zero, zero

        # jump to usertrap(), which does not return
        jr t0
```
>**`usertrap`函数**：修改`STVEC`**寄存器**，保存`pc`**寄存器**并进行**相关操作**，最后跳转到`usertrapret()`
{%list%}
STVEC寄存器一开始指向用户空间处理trap的代码，修改后指向内核空间处理trap的代码
{%endlist%}
{%right%}
有很多原因会触发该函数，不同的原因该函数会做出不同的处理，可以通过检查对应寄存器判断
{%endright%}
{%warning%}
注意系统调用的处理方式中，会将保存在trapframe中的用户态pc指针+4，因为希望返回到ecall的下一条语句
{%endwarning%}
```c
//位于kernel/trap.c中
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(killed(p))
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sepc, scause, and sstatus,
    // so enable only now that we're done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    setkilled(p);
  }

  if(killed(p))
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```
>**`usertrapret`函数**：设置相关寄存器，将**相关数据**保存到`trapframe`中并跳转到`userret()`
{%list%}
修改相关寄存器，即STVEC、SSTATUS和SEPC，做好返回用户态的准备
{%endlist%}
{%right%}
跳转到userret()时还传递了一个参数satp，用于后续设置SATP寄存器
{%endright%}
{%warning%}
在这里会先关闭中断，因为后续将设置STVEC指向trampoline，即用户态的trap处理代码，而目前还处于内核态
{%endwarning%}
```c
//
// return to user space
//
void
usertrapret(void)
{
  struct proc *p = myproc();

  // we're about to switch the destination of traps from
  // kerneltrap() to usertrap(), so turn off interrupts until
  // we're back in user space, where usertrap() is correct.
  intr_off();

  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
  w_stvec(trampoline_uservec);

  // set up trapframe values that uservec will need when
  // the process next traps into the kernel.
  p->trapframe->kernel_satp = r_satp();         // kernel page table
  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
  p->trapframe->kernel_trap = (uint64)usertrap;
  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()

  // set up the registers that trampoline.S's sret will use
  // to get to user space.
  
  // set S Previous Privilege mode to User.
  unsigned long x = r_sstatus();
  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
  x |= SSTATUS_SPIE; // enable interrupts in user mode
  w_sstatus(x);

  // set S Exception Program Counter to the saved user pc.
  w_sepc(p->trapframe->epc);

  // tell trampoline.S the user page table to switch to.
  uint64 satp = MAKE_SATP(p->pagetable);

  // jump to userret in trampoline.S at the top of memory, which 
  // switches to the user page table, restores user registers,
  // and switches to user mode with sret.
  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
  ((void (*)(uint64))trampoline_userret)(satp);
}
```
>**`userret`函数**：切换回**用户页表**，恢复所有**用户寄存器**，最后执行`sret`指令返回用户态
{%list%}
根据SSTATUS的设置，sret指令会切换回用户态，将SEPC寄存器的值拷贝到PC寄存器中并打开中断
{%endlist%}
```nasm
.globl userret
userret:
        # userret(pagetable)
        # called by usertrapret() in trap.c to
        # switch from kernel to user.
        # a0: user page table, for satp.

        # switch to the user page table.
        sfence.vma zero, zero
        csrw satp, a0
        sfence.vma zero, zero

        li a0, TRAPFRAME

        # restore all but a0 from TRAPFRAME
        ld ra, 40(a0)
        ld sp, 48(a0)
        ld gp, 56(a0)
        ld tp, 64(a0)
        ld t0, 72(a0)
        ld t1, 80(a0)
        ld t2, 88(a0)
        ld s0, 96(a0)
        ld s1, 104(a0)
        ld a1, 120(a0)
        ld a2, 128(a0)
        ld a3, 136(a0)
        ld a4, 144(a0)
        ld a5, 152(a0)
        ld a6, 160(a0)
        ld a7, 168(a0)
        ld s2, 176(a0)
        ld s3, 184(a0)
        ld s4, 192(a0)
        ld s5, 200(a0)
        ld s6, 208(a0)
        ld s7, 216(a0)
        ld s8, 224(a0)
        ld s9, 232(a0)
        ld s10, 240(a0)
        ld s11, 248(a0)
        ld t3, 256(a0)
        ld t4, 264(a0)
        ld t5, 272(a0)
        ld t6, 280(a0)

	# restore user a0
        ld a0, 112(a0)
        
        # return to user mode and user pc.
        # usertrapret() set up sstatus and sepc.
        sret
```


### 2.具体实现
#### 2.1 RISC-V汇编语言简答题
**①问题1**
>**概述**：观察`call.asm`下`main()`函数,哪个寄存器用于**函数传递参数**,如在`printf`中，参数`13`在哪个寄存器中

>**回答**：根据**1.2小结**中介绍寄存器的图，`a0~a7`寄存器用于保存**函数参数**，`13`为第三个参数，保存在`a2`中

②

③

④

⑤




